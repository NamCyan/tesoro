{"id":24576,"comment_id":0,"comment":"\/\/ if a manifest doesn't have a version, the other attributes won't get written out. lame.","code":"private void addentriestomainmanifest(manifest manifest) { attributes attrs = manifest.getmainattributes(); \/\/ if a manifest doesn't have a version, the other attributes won't get written out. lame. attrs.put(attributes.name.manifest_version, new date().tostring()); for (map.entry<attributes.name, string> entry : this.manifestentries.entryset()) { attrs.put(entry.getkey(), entry.getvalue()); } }","classification":"DEFECT","isFinished":true,"code_context_2":"private void addentriestomainmanifest(manifest manifest) { attributes attrs = manifest.getmainattributes(); \/\/ if a manifest doesn't have a version, the other attributes won't get written out. lame. attrs.put(attributes.name.manifest_version, new date().tostring()); for (map.entry<attributes.name, string> entry : this.manifestentries.entryset()) {","code_context_10":"private void addentriestomainmanifest(manifest manifest) { attributes attrs = manifest.getmainattributes(); \/\/ if a manifest doesn't have a version, the other attributes won't get written out. lame. attrs.put(attributes.name.manifest_version, new date().tostring()); for (map.entry<attributes.name, string> entry : this.manifestentries.entryset()) { attrs.put(entry.getkey(), entry.getvalue()); } }","code_context_20":"private void addentriestomainmanifest(manifest manifest) { attributes attrs = manifest.getmainattributes(); \/\/ if a manifest doesn't have a version, the other attributes won't get written out. lame. attrs.put(attributes.name.manifest_version, new date().tostring()); for (map.entry<attributes.name, string> entry : this.manifestentries.entryset()) { attrs.put(entry.getkey(), entry.getvalue()); } }","repo":"DavidWhitlock\/PortlandStateJava"}
{"id":32849,"comment_id":0,"comment":"\/\/\u9a8c\u8bc1\u624b\u673a\u53f7\u662f\u542611\u4f4d","code":"\/\/\u9a8c\u8bc1\u624b\u673a\u53f7\u662f\u542611\u4f4d private boolean istellenthlegal(string tel) { \/\/todo: replace this with your own logic return tel.length() == 11; }","classification":"NONSATD","isFinished":true,"code_context_2":"private boolean istellenthlegal(string tel) { \/\/todo: replace this with your own logic return tel.length() == 11; }","code_context_10":"private boolean istellenthlegal(string tel) { \/\/todo: replace this with your own logic return tel.length() == 11; }","code_context_20":"private boolean istellenthlegal(string tel) { \/\/todo: replace this with your own logic return tel.length() == 11; }","repo":"Asucanc\/FishMail"}
{"id":32849,"comment_id":1,"comment":"\/\/todo: replace this with your own logic","code":"private boolean istellenthlegal(string tel) { \/\/todo: replace this with your own logic return tel.length() == 11; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"private boolean istellenthlegal(string tel) { \/\/todo: replace this with your own logic return tel.length() == 11; }","code_context_10":"private boolean istellenthlegal(string tel) { \/\/todo: replace this with your own logic return tel.length() == 11; }","code_context_20":"private boolean istellenthlegal(string tel) { \/\/todo: replace this with your own logic return tel.length() == 11; }","repo":"Asucanc\/FishMail"}
{"id":32850,"comment_id":0,"comment":"\/\/\u662f\u5426\u662f\u90ae\u7bb1","code":"\/\/\u662f\u5426\u662f\u90ae\u7bb1 private boolean isemailvalid(string email) { \/\/todo: replace this with your own logic return email.contains(\"@\")&&email.contains(\".\"); }","classification":"NONSATD","isFinished":true,"code_context_2":"private boolean isemailvalid(string email) { \/\/todo: replace this with your own logic return email.contains(\"@\")&&email.contains(\".\"); }","code_context_10":"private boolean isemailvalid(string email) { \/\/todo: replace this with your own logic return email.contains(\"@\")&&email.contains(\".\"); }","code_context_20":"private boolean isemailvalid(string email) { \/\/todo: replace this with your own logic return email.contains(\"@\")&&email.contains(\".\"); }","repo":"Asucanc\/FishMail"}
{"id":32850,"comment_id":1,"comment":"\/\/todo: replace this with your own logic","code":"private boolean isemailvalid(string email) { \/\/todo: replace this with your own logic return email.contains(\"@\")&&email.contains(\".\"); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"private boolean isemailvalid(string email) { \/\/todo: replace this with your own logic return email.contains(\"@\")&&email.contains(\".\"); }","code_context_10":"private boolean isemailvalid(string email) { \/\/todo: replace this with your own logic return email.contains(\"@\")&&email.contains(\".\"); }","code_context_20":"private boolean isemailvalid(string email) { \/\/todo: replace this with your own logic return email.contains(\"@\")&&email.contains(\".\"); }","repo":"Asucanc\/FishMail"}
{"id":85,"comment_id":0,"comment":"\/** * adds a module for placing a voice call. * * <p>the method is a no-op if the number is blocked. *\/","code":"\/** * adds a module for placing a voice call. * * <p>the method is a no-op if the number is blocked. *\/ public historyitemactionmodulesbuilder addmoduleforvoicecall() { if (moduleinfo.getisblocked()) { return this; } \/\/ todo(zachh): support post-dial digits; consider using dialerphonenumber. \/\/ do not set phoneaccounthandle so that regular precall logic will be used. the account used to \/\/ place or receive the call should be ignored for voice calls. callintentbuilder callintentbuilder = new callintentbuilder(moduleinfo.getnormalizednumber(), getcallinitiationtype()) .setallowassisteddial(moduleinfo.getcansupportassisteddialing()); modules.add(intentmodule.newcallmodule(context, callintentbuilder)); return this; }","classification":"NONSATD","isFinished":true,"code_context_2":"public historyitemactionmodulesbuilder addmoduleforvoicecall() { if (moduleinfo.getisblocked()) { return this; } \/\/ todo(zachh): support post-dial digits; consider using dialerphonenumber. \/\/ do not set phoneaccounthandle so that regular precall logic will be used. the account used to \/\/ place or receive the call should be ignored for voice calls. callintentbuilder callintentbuilder = new callintentbuilder(moduleinfo.getnormalizednumber(), getcallinitiationtype()) .setallowassisteddial(moduleinfo.getcansupportassisteddialing()); modules.add(intentmodule.newcallmodule(context, callintentbuilder)); return this; }","code_context_10":"public historyitemactionmodulesbuilder addmoduleforvoicecall() { if (moduleinfo.getisblocked()) { return this; } \/\/ todo(zachh): support post-dial digits; consider using dialerphonenumber. \/\/ do not set phoneaccounthandle so that regular precall logic will be used. the account used to \/\/ place or receive the call should be ignored for voice calls. callintentbuilder callintentbuilder = new callintentbuilder(moduleinfo.getnormalizednumber(), getcallinitiationtype()) .setallowassisteddial(moduleinfo.getcansupportassisteddialing()); modules.add(intentmodule.newcallmodule(context, callintentbuilder)); return this; }","code_context_20":"public historyitemactionmodulesbuilder addmoduleforvoicecall() { if (moduleinfo.getisblocked()) { return this; } \/\/ todo(zachh): support post-dial digits; consider using dialerphonenumber. \/\/ do not set phoneaccounthandle so that regular precall logic will be used. the account used to \/\/ place or receive the call should be ignored for voice calls. callintentbuilder callintentbuilder = new callintentbuilder(moduleinfo.getnormalizednumber(), getcallinitiationtype()) .setallowassisteddial(moduleinfo.getcansupportassisteddialing()); modules.add(intentmodule.newcallmodule(context, callintentbuilder)); return this; }","repo":"DerpGang\/packages_apps_Dialer"}
{"id":85,"comment_id":1,"comment":"\/\/ todo(zachh): support post-dial digits; consider using dialerphonenumber. \/\/ do not set phoneaccounthandle so that regular precall logic will be used. the account used to \/\/ place or receive the call should be ignored for voice calls.","code":"public historyitemactionmodulesbuilder addmoduleforvoicecall() { if (moduleinfo.getisblocked()) { return this; } \/\/ todo(zachh): support post-dial digits; consider using dialerphonenumber. \/\/ do not set phoneaccounthandle so that regular precall logic will be used. the account used to \/\/ place or receive the call should be ignored for voice calls. callintentbuilder callintentbuilder = new callintentbuilder(moduleinfo.getnormalizednumber(), getcallinitiationtype()) .setallowassisteddial(moduleinfo.getcansupportassisteddialing()); modules.add(intentmodule.newcallmodule(context, callintentbuilder)); return this; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"return this; } \/\/ todo(zachh): support post-dial digits; consider using dialerphonenumber. \/\/ do not set phoneaccounthandle so that regular precall logic will be used. the account used to \/\/ place or receive the call should be ignored for voice calls. callintentbuilder callintentbuilder = new callintentbuilder(moduleinfo.getnormalizednumber(), getcallinitiationtype())","code_context_10":"public historyitemactionmodulesbuilder addmoduleforvoicecall() { if (moduleinfo.getisblocked()) { return this; } \/\/ todo(zachh): support post-dial digits; consider using dialerphonenumber. \/\/ do not set phoneaccounthandle so that regular precall logic will be used. the account used to \/\/ place or receive the call should be ignored for voice calls. callintentbuilder callintentbuilder = new callintentbuilder(moduleinfo.getnormalizednumber(), getcallinitiationtype()) .setallowassisteddial(moduleinfo.getcansupportassisteddialing()); modules.add(intentmodule.newcallmodule(context, callintentbuilder)); return this; }","code_context_20":"public historyitemactionmodulesbuilder addmoduleforvoicecall() { if (moduleinfo.getisblocked()) { return this; } \/\/ todo(zachh): support post-dial digits; consider using dialerphonenumber. \/\/ do not set phoneaccounthandle so that regular precall logic will be used. the account used to \/\/ place or receive the call should be ignored for voice calls. callintentbuilder callintentbuilder = new callintentbuilder(moduleinfo.getnormalizednumber(), getcallinitiationtype()) .setallowassisteddial(moduleinfo.getcansupportassisteddialing()); modules.add(intentmodule.newcallmodule(context, callintentbuilder)); return this; }","repo":"DerpGang\/packages_apps_Dialer"}
{"id":16486,"comment_id":0,"comment":"\/\/todo check rewrite in future","code":"public static void main(string[] args) throws ioexception, classnotfoundexception, interruptedexception { if(args.length != 4) { system.out.print(\"args should be 2 : <inputpath> <outpath> <number of centroids> <dimensions> .\") ; system.exit(-1); } int k = integer.valueof(args[2]) ; int dim = integer.valueof(args[3]) ; job init_job = job.getinstance() ; configuration init_conf = init_job.getconfiguration(); init_conf.set(\"kmeans.k\", args[2]); init_conf.set(\"kmeans.dim\", args[3]); init_job.setjarbyclass(kmean.class); init_job.setjobname(\"clustered kmeans\"); init_job.setmapperclass(kmeaninitmapper.class); init_job.setreducerclass(kmeaninitreducer.class); init_job.setoutputkeyclass(intwritable.class); init_job.setoutputvalueclass(text.class); fileinputformat.addinputpath(init_job, new path(args[0])); \/\/todo check rewrite in future fileoutputformat.setoutputpath(init_job, new path(args[1] + \"_m_\" + integer.tostring(0))); init_job.waitforcompletion(true); double[][] old_centroids = new double[k][dim] ; int fi = 1 ; long t1 = system.currenttimemillis() ; while(true) { system.out.print(\"start iteration\") ; job kmean_cluster_jb = job.getinstance() ; configuration conf = kmean_cluster_jb.getconfiguration() ; conf.set(\"kmeans.k\", args[2]); conf.set(\"kmeans.dim\", args[3]); kmean_cluster_jb.setjarbyclass(kmean.class); kmean_cluster_jb.setjobname(\"clustered kmeans\"); kmean_cluster_jb.setmapperclass(kmeaniterationmapper.class); kmean_cluster_jb.setreducerclass(kmeaniterationreducer.class); kmean_cluster_jb.setoutputkeyclass(intwritable.class); kmean_cluster_jb.setoutputvalueclass(text.class); \/\/ todo check rewrite in future string uri = args[1] + \"_m_\" + integer.tostring(fi-1) + \"\/part-r-00000\"; configuration temp_conf = new configuration(); filesystem fs = filesystem.get(uri.create(uri), temp_conf); path input_path = new path(uri); fsdatainputstream input_stream = fs.open(input_path); bufferedreader input_buffer = new bufferedreader(new inputstreamreader(input_stream)); double total_dis = 0 ; double[][] new_centroids = new double[k][dim] ; for(int i = 0 ; i < k ; i++) { string line = input_buffer.readline() ; if(line == null) { for(int j = 0 ; j < dim ; j++) { new_centroids[i][j] = double.valueof(old_centroids[i][j]) ; } continue ; } int key = integer.valueof(line.split(\"\\t\")[0]) ; string[] new_centroid = line.split(\"\\t\")[1].split(\",\") ; for(int j = 0 ; j < dim ; j++) { new_centroids[key][j] = double.valueof(new_centroid[j]) ; total_dis += math.pow(new_centroids[key][j] - old_centroids[key][j], 2) ; } conf.set(\"kmeans.centroid\" + key, line.split(\"\\t\")[1]); } double threshold = math.pow(0.001 ,2) * k * dim ; if(total_dis < threshold) break ; fileinputformat.addinputpath(kmean_cluster_jb, new path(args[0])); \/\/todo check rewrite in future fileoutputformat.setoutputpath(kmean_cluster_jb, new path(args[1] + \"_m_\" + integer.tostring(fi))); kmean_cluster_jb.waitforcompletion(true); old_centroids = new_centroids; fi++ ; } long t2 = system.currenttimemillis() ; system.out.println(\"\\n time token by un-parallel is : \" + (t2-t1) + \"ms\"); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"init_job.setoutputvalueclass(text.class); fileinputformat.addinputpath(init_job, new path(args[0])); \/\/todo check rewrite in future fileoutputformat.setoutputpath(init_job, new path(args[1] + \"_m_\" + integer.tostring(0))); init_job.waitforcompletion(true);","code_context_10":"configuration init_conf = init_job.getconfiguration(); init_conf.set(\"kmeans.k\", args[2]); init_conf.set(\"kmeans.dim\", args[3]); init_job.setjarbyclass(kmean.class); init_job.setjobname(\"clustered kmeans\"); init_job.setmapperclass(kmeaninitmapper.class); init_job.setreducerclass(kmeaninitreducer.class); init_job.setoutputkeyclass(intwritable.class); init_job.setoutputvalueclass(text.class); fileinputformat.addinputpath(init_job, new path(args[0])); \/\/todo check rewrite in future fileoutputformat.setoutputpath(init_job, new path(args[1] + \"_m_\" + integer.tostring(0))); init_job.waitforcompletion(true); double[][] old_centroids = new double[k][dim] ; int fi = 1 ; long t1 = system.currenttimemillis() ; while(true) { system.out.print(\"start iteration\") ; job kmean_cluster_jb = job.getinstance() ; configuration conf = kmean_cluster_jb.getconfiguration() ; conf.set(\"kmeans.k\", args[2]);","code_context_20":"public static void main(string[] args) throws ioexception, classnotfoundexception, interruptedexception { if(args.length != 4) { system.out.print(\"args should be 2 : <inputpath> <outpath> <number of centroids> <dimensions> .\") ; system.exit(-1); } int k = integer.valueof(args[2]) ; int dim = integer.valueof(args[3]) ; job init_job = job.getinstance() ; configuration init_conf = init_job.getconfiguration(); init_conf.set(\"kmeans.k\", args[2]); init_conf.set(\"kmeans.dim\", args[3]); init_job.setjarbyclass(kmean.class); init_job.setjobname(\"clustered kmeans\"); init_job.setmapperclass(kmeaninitmapper.class); init_job.setreducerclass(kmeaninitreducer.class); init_job.setoutputkeyclass(intwritable.class); init_job.setoutputvalueclass(text.class); fileinputformat.addinputpath(init_job, new path(args[0])); \/\/todo check rewrite in future fileoutputformat.setoutputpath(init_job, new path(args[1] + \"_m_\" + integer.tostring(0))); init_job.waitforcompletion(true); double[][] old_centroids = new double[k][dim] ; int fi = 1 ; long t1 = system.currenttimemillis() ; while(true) { system.out.print(\"start iteration\") ; job kmean_cluster_jb = job.getinstance() ; configuration conf = kmean_cluster_jb.getconfiguration() ; conf.set(\"kmeans.k\", args[2]); conf.set(\"kmeans.dim\", args[3]); kmean_cluster_jb.setjarbyclass(kmean.class); kmean_cluster_jb.setjobname(\"clustered kmeans\"); kmean_cluster_jb.setmapperclass(kmeaniterationmapper.class); kmean_cluster_jb.setreducerclass(kmeaniterationreducer.class); kmean_cluster_jb.setoutputkeyclass(intwritable.class); kmean_cluster_jb.setoutputvalueclass(text.class); \/\/ todo check rewrite in future string uri = args[1] + \"_m_\" + integer.tostring(fi-1) + \"\/part-r-00000\"; configuration temp_conf = new configuration();","repo":"AmrHendy\/K-Means"}
{"id":16486,"comment_id":1,"comment":"\/\/ todo check rewrite in future","code":"public static void main(string[] args) throws ioexception, classnotfoundexception, interruptedexception { if(args.length != 4) { system.out.print(\"args should be 2 : <inputpath> <outpath> <number of centroids> <dimensions> .\") ; system.exit(-1); } int k = integer.valueof(args[2]) ; int dim = integer.valueof(args[3]) ; job init_job = job.getinstance() ; configuration init_conf = init_job.getconfiguration(); init_conf.set(\"kmeans.k\", args[2]); init_conf.set(\"kmeans.dim\", args[3]); init_job.setjarbyclass(kmean.class); init_job.setjobname(\"clustered kmeans\"); init_job.setmapperclass(kmeaninitmapper.class); init_job.setreducerclass(kmeaninitreducer.class); init_job.setoutputkeyclass(intwritable.class); init_job.setoutputvalueclass(text.class); fileinputformat.addinputpath(init_job, new path(args[0])); \/\/todo check rewrite in future fileoutputformat.setoutputpath(init_job, new path(args[1] + \"_m_\" + integer.tostring(0))); init_job.waitforcompletion(true); double[][] old_centroids = new double[k][dim] ; int fi = 1 ; long t1 = system.currenttimemillis() ; while(true) { system.out.print(\"start iteration\") ; job kmean_cluster_jb = job.getinstance() ; configuration conf = kmean_cluster_jb.getconfiguration() ; conf.set(\"kmeans.k\", args[2]); conf.set(\"kmeans.dim\", args[3]); kmean_cluster_jb.setjarbyclass(kmean.class); kmean_cluster_jb.setjobname(\"clustered kmeans\"); kmean_cluster_jb.setmapperclass(kmeaniterationmapper.class); kmean_cluster_jb.setreducerclass(kmeaniterationreducer.class); kmean_cluster_jb.setoutputkeyclass(intwritable.class); kmean_cluster_jb.setoutputvalueclass(text.class); \/\/ todo check rewrite in future string uri = args[1] + \"_m_\" + integer.tostring(fi-1) + \"\/part-r-00000\"; configuration temp_conf = new configuration(); filesystem fs = filesystem.get(uri.create(uri), temp_conf); path input_path = new path(uri); fsdatainputstream input_stream = fs.open(input_path); bufferedreader input_buffer = new bufferedreader(new inputstreamreader(input_stream)); double total_dis = 0 ; double[][] new_centroids = new double[k][dim] ; for(int i = 0 ; i < k ; i++) { string line = input_buffer.readline() ; if(line == null) { for(int j = 0 ; j < dim ; j++) { new_centroids[i][j] = double.valueof(old_centroids[i][j]) ; } continue ; } int key = integer.valueof(line.split(\"\\t\")[0]) ; string[] new_centroid = line.split(\"\\t\")[1].split(\",\") ; for(int j = 0 ; j < dim ; j++) { new_centroids[key][j] = double.valueof(new_centroid[j]) ; total_dis += math.pow(new_centroids[key][j] - old_centroids[key][j], 2) ; } conf.set(\"kmeans.centroid\" + key, line.split(\"\\t\")[1]); } double threshold = math.pow(0.001 ,2) * k * dim ; if(total_dis < threshold) break ; fileinputformat.addinputpath(kmean_cluster_jb, new path(args[0])); \/\/todo check rewrite in future fileoutputformat.setoutputpath(kmean_cluster_jb, new path(args[1] + \"_m_\" + integer.tostring(fi))); kmean_cluster_jb.waitforcompletion(true); old_centroids = new_centroids; fi++ ; } long t2 = system.currenttimemillis() ; system.out.println(\"\\n time token by un-parallel is : \" + (t2-t1) + \"ms\"); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"kmean_cluster_jb.setoutputkeyclass(intwritable.class); kmean_cluster_jb.setoutputvalueclass(text.class); \/\/ todo check rewrite in future string uri = args[1] + \"_m_\" + integer.tostring(fi-1) + \"\/part-r-00000\"; configuration temp_conf = new configuration();","code_context_10":"job kmean_cluster_jb = job.getinstance() ; configuration conf = kmean_cluster_jb.getconfiguration() ; conf.set(\"kmeans.k\", args[2]); conf.set(\"kmeans.dim\", args[3]); kmean_cluster_jb.setjarbyclass(kmean.class); kmean_cluster_jb.setjobname(\"clustered kmeans\"); kmean_cluster_jb.setmapperclass(kmeaniterationmapper.class); kmean_cluster_jb.setreducerclass(kmeaniterationreducer.class); kmean_cluster_jb.setoutputkeyclass(intwritable.class); kmean_cluster_jb.setoutputvalueclass(text.class); \/\/ todo check rewrite in future string uri = args[1] + \"_m_\" + integer.tostring(fi-1) + \"\/part-r-00000\"; configuration temp_conf = new configuration(); filesystem fs = filesystem.get(uri.create(uri), temp_conf); path input_path = new path(uri); fsdatainputstream input_stream = fs.open(input_path); bufferedreader input_buffer = new bufferedreader(new inputstreamreader(input_stream)); double total_dis = 0 ; double[][] new_centroids = new double[k][dim] ; for(int i = 0 ; i < k ; i++) { string line = input_buffer.readline() ;","code_context_20":"init_job.setoutputvalueclass(text.class); fileinputformat.addinputpath(init_job, new path(args[0])); \/\/todo check rewrite in future fileoutputformat.setoutputpath(init_job, new path(args[1] + \"_m_\" + integer.tostring(0))); init_job.waitforcompletion(true); double[][] old_centroids = new double[k][dim] ; int fi = 1 ; long t1 = system.currenttimemillis() ; while(true) { system.out.print(\"start iteration\") ; job kmean_cluster_jb = job.getinstance() ; configuration conf = kmean_cluster_jb.getconfiguration() ; conf.set(\"kmeans.k\", args[2]); conf.set(\"kmeans.dim\", args[3]); kmean_cluster_jb.setjarbyclass(kmean.class); kmean_cluster_jb.setjobname(\"clustered kmeans\"); kmean_cluster_jb.setmapperclass(kmeaniterationmapper.class); kmean_cluster_jb.setreducerclass(kmeaniterationreducer.class); kmean_cluster_jb.setoutputkeyclass(intwritable.class); kmean_cluster_jb.setoutputvalueclass(text.class); \/\/ todo check rewrite in future string uri = args[1] + \"_m_\" + integer.tostring(fi-1) + \"\/part-r-00000\"; configuration temp_conf = new configuration(); filesystem fs = filesystem.get(uri.create(uri), temp_conf); path input_path = new path(uri); fsdatainputstream input_stream = fs.open(input_path); bufferedreader input_buffer = new bufferedreader(new inputstreamreader(input_stream)); double total_dis = 0 ; double[][] new_centroids = new double[k][dim] ; for(int i = 0 ; i < k ; i++) { string line = input_buffer.readline() ; if(line == null) { for(int j = 0 ; j < dim ; j++) { new_centroids[i][j] = double.valueof(old_centroids[i][j]) ; } continue ; } int key = integer.valueof(line.split(\"\\t\")[0]) ; string[] new_centroid = line.split(\"\\t\")[1].split(\",\") ; for(int j = 0 ; j < dim ; j++) { new_centroids[key][j] = double.valueof(new_centroid[j]) ;","repo":"AmrHendy\/K-Means"}
{"id":16486,"comment_id":2,"comment":"\/\/todo check rewrite in future","code":"public static void main(string[] args) throws ioexception, classnotfoundexception, interruptedexception { if(args.length != 4) { system.out.print(\"args should be 2 : <inputpath> <outpath> <number of centroids> <dimensions> .\") ; system.exit(-1); } int k = integer.valueof(args[2]) ; int dim = integer.valueof(args[3]) ; job init_job = job.getinstance() ; configuration init_conf = init_job.getconfiguration(); init_conf.set(\"kmeans.k\", args[2]); init_conf.set(\"kmeans.dim\", args[3]); init_job.setjarbyclass(kmean.class); init_job.setjobname(\"clustered kmeans\"); init_job.setmapperclass(kmeaninitmapper.class); init_job.setreducerclass(kmeaninitreducer.class); init_job.setoutputkeyclass(intwritable.class); init_job.setoutputvalueclass(text.class); fileinputformat.addinputpath(init_job, new path(args[0])); \/\/todo check rewrite in future fileoutputformat.setoutputpath(init_job, new path(args[1] + \"_m_\" + integer.tostring(0))); init_job.waitforcompletion(true); double[][] old_centroids = new double[k][dim] ; int fi = 1 ; long t1 = system.currenttimemillis() ; while(true) { system.out.print(\"start iteration\") ; job kmean_cluster_jb = job.getinstance() ; configuration conf = kmean_cluster_jb.getconfiguration() ; conf.set(\"kmeans.k\", args[2]); conf.set(\"kmeans.dim\", args[3]); kmean_cluster_jb.setjarbyclass(kmean.class); kmean_cluster_jb.setjobname(\"clustered kmeans\"); kmean_cluster_jb.setmapperclass(kmeaniterationmapper.class); kmean_cluster_jb.setreducerclass(kmeaniterationreducer.class); kmean_cluster_jb.setoutputkeyclass(intwritable.class); kmean_cluster_jb.setoutputvalueclass(text.class); \/\/ todo check rewrite in future string uri = args[1] + \"_m_\" + integer.tostring(fi-1) + \"\/part-r-00000\"; configuration temp_conf = new configuration(); filesystem fs = filesystem.get(uri.create(uri), temp_conf); path input_path = new path(uri); fsdatainputstream input_stream = fs.open(input_path); bufferedreader input_buffer = new bufferedreader(new inputstreamreader(input_stream)); double total_dis = 0 ; double[][] new_centroids = new double[k][dim] ; for(int i = 0 ; i < k ; i++) { string line = input_buffer.readline() ; if(line == null) { for(int j = 0 ; j < dim ; j++) { new_centroids[i][j] = double.valueof(old_centroids[i][j]) ; } continue ; } int key = integer.valueof(line.split(\"\\t\")[0]) ; string[] new_centroid = line.split(\"\\t\")[1].split(\",\") ; for(int j = 0 ; j < dim ; j++) { new_centroids[key][j] = double.valueof(new_centroid[j]) ; total_dis += math.pow(new_centroids[key][j] - old_centroids[key][j], 2) ; } conf.set(\"kmeans.centroid\" + key, line.split(\"\\t\")[1]); } double threshold = math.pow(0.001 ,2) * k * dim ; if(total_dis < threshold) break ; fileinputformat.addinputpath(kmean_cluster_jb, new path(args[0])); \/\/todo check rewrite in future fileoutputformat.setoutputpath(kmean_cluster_jb, new path(args[1] + \"_m_\" + integer.tostring(fi))); kmean_cluster_jb.waitforcompletion(true); old_centroids = new_centroids; fi++ ; } long t2 = system.currenttimemillis() ; system.out.println(\"\\n time token by un-parallel is : \" + (t2-t1) + \"ms\"); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"init_job.setoutputvalueclass(text.class); fileinputformat.addinputpath(init_job, new path(args[0])); \/\/todo check rewrite in future fileoutputformat.setoutputpath(init_job, new path(args[1] + \"_m_\" + integer.tostring(0))); init_job.waitforcompletion(true);","code_context_10":"configuration init_conf = init_job.getconfiguration(); init_conf.set(\"kmeans.k\", args[2]); init_conf.set(\"kmeans.dim\", args[3]); init_job.setjarbyclass(kmean.class); init_job.setjobname(\"clustered kmeans\"); init_job.setmapperclass(kmeaninitmapper.class); init_job.setreducerclass(kmeaninitreducer.class); init_job.setoutputkeyclass(intwritable.class); init_job.setoutputvalueclass(text.class); fileinputformat.addinputpath(init_job, new path(args[0])); \/\/todo check rewrite in future fileoutputformat.setoutputpath(init_job, new path(args[1] + \"_m_\" + integer.tostring(0))); init_job.waitforcompletion(true); double[][] old_centroids = new double[k][dim] ; int fi = 1 ; long t1 = system.currenttimemillis() ; while(true) { system.out.print(\"start iteration\") ; job kmean_cluster_jb = job.getinstance() ; configuration conf = kmean_cluster_jb.getconfiguration() ; conf.set(\"kmeans.k\", args[2]);","code_context_20":"public static void main(string[] args) throws ioexception, classnotfoundexception, interruptedexception { if(args.length != 4) { system.out.print(\"args should be 2 : <inputpath> <outpath> <number of centroids> <dimensions> .\") ; system.exit(-1); } int k = integer.valueof(args[2]) ; int dim = integer.valueof(args[3]) ; job init_job = job.getinstance() ; configuration init_conf = init_job.getconfiguration(); init_conf.set(\"kmeans.k\", args[2]); init_conf.set(\"kmeans.dim\", args[3]); init_job.setjarbyclass(kmean.class); init_job.setjobname(\"clustered kmeans\"); init_job.setmapperclass(kmeaninitmapper.class); init_job.setreducerclass(kmeaninitreducer.class); init_job.setoutputkeyclass(intwritable.class); init_job.setoutputvalueclass(text.class); fileinputformat.addinputpath(init_job, new path(args[0])); \/\/todo check rewrite in future fileoutputformat.setoutputpath(init_job, new path(args[1] + \"_m_\" + integer.tostring(0))); init_job.waitforcompletion(true); double[][] old_centroids = new double[k][dim] ; int fi = 1 ; long t1 = system.currenttimemillis() ; while(true) { system.out.print(\"start iteration\") ; job kmean_cluster_jb = job.getinstance() ; configuration conf = kmean_cluster_jb.getconfiguration() ; conf.set(\"kmeans.k\", args[2]); conf.set(\"kmeans.dim\", args[3]); kmean_cluster_jb.setjarbyclass(kmean.class); kmean_cluster_jb.setjobname(\"clustered kmeans\"); kmean_cluster_jb.setmapperclass(kmeaniterationmapper.class); kmean_cluster_jb.setreducerclass(kmeaniterationreducer.class); kmean_cluster_jb.setoutputkeyclass(intwritable.class); kmean_cluster_jb.setoutputvalueclass(text.class); \/\/ todo check rewrite in future string uri = args[1] + \"_m_\" + integer.tostring(fi-1) + \"\/part-r-00000\"; configuration temp_conf = new configuration();","repo":"AmrHendy\/K-Means"}
{"id":32941,"comment_id":0,"comment":"\/\/ this can probably work on contentvalues_","code":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n xtcefunctions.gettext( \"xml_dynamic_count_assume1\" ) ); \/\/ noi18n return 1; } } return 1; }","classification":"DESIGN","isFinished":true,"code_context_2":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) {","code_context_10":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; }","code_context_20":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n","repo":"CesarCoelho\/xtcetools"}
{"id":32941,"comment_id":1,"comment":"\/\/ noi18n","code":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n xtcefunctions.gettext( \"xml_dynamic_count_assume1\" ) ); \/\/ noi18n return 1; } } return 1; }","classification":"NONSATD","isFinished":true,"code_context_2":"} if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() );","code_context_10":"for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n","code_context_20":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n","repo":"CesarCoelho\/xtcetools"}
{"id":32941,"comment_id":2,"comment":"\/\/ noi18n","code":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n xtcefunctions.gettext( \"xml_dynamic_count_assume1\" ) ); \/\/ noi18n return 1; } } return 1; }","classification":"NONSATD","isFinished":true,"code_context_2":"} if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() );","code_context_10":"for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n","code_context_20":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n","repo":"CesarCoelho\/xtcetools"}
{"id":32941,"comment_id":3,"comment":"\/\/ noi18n","code":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n xtcefunctions.gettext( \"xml_dynamic_count_assume1\" ) ); \/\/ noi18n return 1; } } return 1; }","classification":"NONSATD","isFinished":true,"code_context_2":"} if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() );","code_context_10":"for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n","code_context_20":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n","repo":"CesarCoelho\/xtcetools"}
{"id":32941,"comment_id":4,"comment":"\/\/ noi18n","code":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n xtcefunctions.gettext( \"xml_dynamic_count_assume1\" ) ); \/\/ noi18n return 1; } } return 1; }","classification":"NONSATD","isFinished":true,"code_context_2":"} if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() );","code_context_10":"for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n","code_context_20":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n","repo":"CesarCoelho\/xtcetools"}
{"id":32941,"comment_id":5,"comment":"\/\/ noi18n","code":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n xtcefunctions.gettext( \"xml_dynamic_count_assume1\" ) ); \/\/ noi18n return 1; } } return 1; }","classification":"NONSATD","isFinished":true,"code_context_2":"} if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() );","code_context_10":"for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n","code_context_20":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n","repo":"CesarCoelho\/xtcetools"}
{"id":32941,"comment_id":6,"comment":"\/\/ noi18n","code":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n xtcefunctions.gettext( \"xml_dynamic_count_assume1\" ) ); \/\/ noi18n return 1; } } return 1; }","classification":"NONSATD","isFinished":true,"code_context_2":"} if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() );","code_context_10":"for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n","code_context_20":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n","repo":"CesarCoelho\/xtcetools"}
{"id":32941,"comment_id":7,"comment":"\/\/ noi18n","code":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n xtcefunctions.gettext( \"xml_dynamic_count_assume1\" ) ); \/\/ noi18n return 1; } } return 1; }","classification":"NONSATD","isFinished":true,"code_context_2":"} if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() );","code_context_10":"for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n","code_context_20":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n","repo":"CesarCoelho\/xtcetools"}
{"id":32941,"comment_id":8,"comment":"\/\/ noi18n","code":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n xtcefunctions.gettext( \"xml_dynamic_count_assume1\" ) ); \/\/ noi18n return 1; } } return 1; }","classification":"NONSATD","isFinished":true,"code_context_2":"} if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() );","code_context_10":"for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n","code_context_20":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n","repo":"CesarCoelho\/xtcetools"}
{"id":32941,"comment_id":9,"comment":"\/\/ noi18n","code":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n xtcefunctions.gettext( \"xml_dynamic_count_assume1\" ) ); \/\/ noi18n return 1; } } return 1; }","classification":"NONSATD","isFinished":true,"code_context_2":"} if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() );","code_context_10":"for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n","code_context_20":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n","repo":"CesarCoelho\/xtcetools"}
{"id":32941,"comment_id":10,"comment":"\/\/ noi18n","code":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n xtcefunctions.gettext( \"xml_dynamic_count_assume1\" ) ); \/\/ noi18n return 1; } } return 1; }","classification":"NONSATD","isFinished":true,"code_context_2":"} if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() );","code_context_10":"for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n","code_context_20":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n","repo":"CesarCoelho\/xtcetools"}
{"id":32941,"comment_id":11,"comment":"\/\/ noi18n","code":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n xtcefunctions.gettext( \"xml_dynamic_count_assume1\" ) ); \/\/ noi18n return 1; } } return 1; }","classification":"NONSATD","isFinished":true,"code_context_2":"} if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() );","code_context_10":"for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n","code_context_20":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { \/\/ this can probably work on contentvalues_ string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { \/\/ noi18n try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \" (\" + \/\/ noi18n xtcefunctions.gettext( \"general_value\" ) + \/\/ noi18n \" '\" + \/\/ noi18n valueobj.getcalibratedvalue() + \"')\" ); \/\/ noi18n return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \/\/ noi18n \" \" + \/\/ noi18n item.getname() + \", \" + \/\/ noi18n","repo":"CesarCoelho\/xtcetools"}
{"id":32983,"comment_id":0,"comment":"\/\/ todo adjust properties","code":"private static void registerfluids(blockregistry blockregistry) { \/\/ todo adjust properties fluid steam = new fluid(\"steam\", new resourcelocation(steamagerevolution.modid, \"fluids\/steam\"), new resourcelocation(steamagerevolution.modid, \"fluids\/steam_flow\")).setgaseous(true) .settemperature(1000).setviscosity(200); if(!(fluidregistry.isfluidregistered(steam))) { \/\/ soft registration fluidregistry.registerfluid(steam); fluidregistry.addbucketforfluid(steam); } blockregistry.register(new blocksarfluid(\"steam\", fluidregistry.getfluid(\"steam\"), material.lava)); fluid sulphur_dioxide = new fluid(\"sulphur_dioxide\", new resourcelocation(steamagerevolution.modid, \"fluids\/sulphur_dioxide\"), new resourcelocation(steamagerevolution.modid, \"fluids\/sulphur_dioxide_flow\")).setviscosity(250) .setgaseous(true).setdensity(-100); fluidregistry.registerfluid(sulphur_dioxide); fluidregistry.addbucketforfluid(sulphur_dioxide); blockregistry.register(new blockdamagingfluid(\"sulphur_dioxide\", fluidregistry.getfluid(\"sulphur_dioxide\"), material.water, sarblocks.damagesourcegas, 2)); fluid sulphuric_acid = new fluid(\"sulphuric_acid\", new resourcelocation(steamagerevolution.modid, \"fluids\/sulphuric_acid\"), new resourcelocation(steamagerevolution.modid, \"fluids\/sulphuric_acid_flow\")).setviscosity(500); fluidregistry.registerfluid(sulphuric_acid); fluidregistry.addbucketforfluid(sulphuric_acid); blockregistry.register(new blockacidfluid(\"sulphuric_acid\", fluidregistry.getfluid(\"sulphuric_acid\"), material.water, sarblocks.damagesourceacid, 4)); \/\/ todo te compat? fluid liquid_glowstone = new fluid(\"liquid_glowstone\", new resourcelocation(steamagerevolution.modid, \"fluids\/liquid_glowstone\"), new resourcelocation(steamagerevolution.modid, \"fluids\/liquid_glowstone_flow\")).setviscosity(2000) .setgaseous(true); fluidregistry.registerfluid(liquid_glowstone); fluidregistry.addbucketforfluid(liquid_glowstone); blockregistry.register(new blockliquidglowstone(\"liquid_glowstone\", fluidregistry.getfluid(\"liquid_glowstone\"), material.lava)); fluid potion = new fluid(\"potion\", new resourcelocation(steamagerevolution.modid, \"fluids\/solution\"), new resourcelocation(steamagerevolution.modid, \"fluids\/solution_flowing\")) { @suppresswarnings(\"deprecation\") @override public string getlocalizedname(fluidstack stack) { return i18n.translatetolocal( potionutils.getpotiontypefromnbt(stack.tag).getnameprefixed(\"potion.effect.\")); } @override public int getcolor(fluidstack stack) { return potionutils.getpotioncolorfromeffectlist(potionutils.geteffectsfromtag(stack.tag)); } }; fluidregistry.registerfluid(potion); fluidregistry.addbucketforfluid(potion); fluidregistry .registerfluid(new fluid(\"slime\", new resourcelocation(steamagerevolution.modid, \"fluids\/solution\"), new resourcelocation(steamagerevolution.modid, \"fluids\/solution\")) { @override public int getcolor() { return color.green.getrgb(); } }); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"private static void registerfluids(blockregistry blockregistry) { \/\/ todo adjust properties fluid steam = new fluid(\"steam\", new resourcelocation(steamagerevolution.modid, \"fluids\/steam\"), new resourcelocation(steamagerevolution.modid, \"fluids\/steam_flow\")).setgaseous(true)","code_context_10":"private static void registerfluids(blockregistry blockregistry) { \/\/ todo adjust properties fluid steam = new fluid(\"steam\", new resourcelocation(steamagerevolution.modid, \"fluids\/steam\"), new resourcelocation(steamagerevolution.modid, \"fluids\/steam_flow\")).setgaseous(true) .settemperature(1000).setviscosity(200); if(!(fluidregistry.isfluidregistered(steam))) { \/\/ soft registration fluidregistry.registerfluid(steam); fluidregistry.addbucketforfluid(steam); } blockregistry.register(new blocksarfluid(\"steam\", fluidregistry.getfluid(\"steam\"), material.lava)); fluid sulphur_dioxide = new fluid(\"sulphur_dioxide\", new resourcelocation(steamagerevolution.modid, \"fluids\/sulphur_dioxide\"),","code_context_20":"private static void registerfluids(blockregistry blockregistry) { \/\/ todo adjust properties fluid steam = new fluid(\"steam\", new resourcelocation(steamagerevolution.modid, \"fluids\/steam\"), new resourcelocation(steamagerevolution.modid, \"fluids\/steam_flow\")).setgaseous(true) .settemperature(1000).setviscosity(200); if(!(fluidregistry.isfluidregistered(steam))) { \/\/ soft registration fluidregistry.registerfluid(steam); fluidregistry.addbucketforfluid(steam); } blockregistry.register(new blocksarfluid(\"steam\", fluidregistry.getfluid(\"steam\"), material.lava)); fluid sulphur_dioxide = new fluid(\"sulphur_dioxide\", new resourcelocation(steamagerevolution.modid, \"fluids\/sulphur_dioxide\"), new resourcelocation(steamagerevolution.modid, \"fluids\/sulphur_dioxide_flow\")).setviscosity(250) .setgaseous(true).setdensity(-100); fluidregistry.registerfluid(sulphur_dioxide); fluidregistry.addbucketforfluid(sulphur_dioxide); blockregistry.register(new blockdamagingfluid(\"sulphur_dioxide\", fluidregistry.getfluid(\"sulphur_dioxide\"), material.water, sarblocks.damagesourcegas, 2)); fluid sulphuric_acid = new fluid(\"sulphuric_acid\", new resourcelocation(steamagerevolution.modid, \"fluids\/sulphuric_acid\"), new resourcelocation(steamagerevolution.modid, \"fluids\/sulphuric_acid_flow\")).setviscosity(500); fluidregistry.registerfluid(sulphuric_acid);","repo":"BrassGoggledCoders\/SteamAgeRevolution"}
{"id":32983,"comment_id":1,"comment":"\/\/ soft registration","code":"private static void registerfluids(blockregistry blockregistry) { \/\/ todo adjust properties fluid steam = new fluid(\"steam\", new resourcelocation(steamagerevolution.modid, \"fluids\/steam\"), new resourcelocation(steamagerevolution.modid, \"fluids\/steam_flow\")).setgaseous(true) .settemperature(1000).setviscosity(200); if(!(fluidregistry.isfluidregistered(steam))) { \/\/ soft registration fluidregistry.registerfluid(steam); fluidregistry.addbucketforfluid(steam); } blockregistry.register(new blocksarfluid(\"steam\", fluidregistry.getfluid(\"steam\"), material.lava)); fluid sulphur_dioxide = new fluid(\"sulphur_dioxide\", new resourcelocation(steamagerevolution.modid, \"fluids\/sulphur_dioxide\"), new resourcelocation(steamagerevolution.modid, \"fluids\/sulphur_dioxide_flow\")).setviscosity(250) .setgaseous(true).setdensity(-100); fluidregistry.registerfluid(sulphur_dioxide); fluidregistry.addbucketforfluid(sulphur_dioxide); blockregistry.register(new blockdamagingfluid(\"sulphur_dioxide\", fluidregistry.getfluid(\"sulphur_dioxide\"), material.water, sarblocks.damagesourcegas, 2)); fluid sulphuric_acid = new fluid(\"sulphuric_acid\", new resourcelocation(steamagerevolution.modid, \"fluids\/sulphuric_acid\"), new resourcelocation(steamagerevolution.modid, \"fluids\/sulphuric_acid_flow\")).setviscosity(500); fluidregistry.registerfluid(sulphuric_acid); fluidregistry.addbucketforfluid(sulphuric_acid); blockregistry.register(new blockacidfluid(\"sulphuric_acid\", fluidregistry.getfluid(\"sulphuric_acid\"), material.water, sarblocks.damagesourceacid, 4)); \/\/ todo te compat? fluid liquid_glowstone = new fluid(\"liquid_glowstone\", new resourcelocation(steamagerevolution.modid, \"fluids\/liquid_glowstone\"), new resourcelocation(steamagerevolution.modid, \"fluids\/liquid_glowstone_flow\")).setviscosity(2000) .setgaseous(true); fluidregistry.registerfluid(liquid_glowstone); fluidregistry.addbucketforfluid(liquid_glowstone); blockregistry.register(new blockliquidglowstone(\"liquid_glowstone\", fluidregistry.getfluid(\"liquid_glowstone\"), material.lava)); fluid potion = new fluid(\"potion\", new resourcelocation(steamagerevolution.modid, \"fluids\/solution\"), new resourcelocation(steamagerevolution.modid, \"fluids\/solution_flowing\")) { @suppresswarnings(\"deprecation\") @override public string getlocalizedname(fluidstack stack) { return i18n.translatetolocal( potionutils.getpotiontypefromnbt(stack.tag).getnameprefixed(\"potion.effect.\")); } @override public int getcolor(fluidstack stack) { return potionutils.getpotioncolorfromeffectlist(potionutils.geteffectsfromtag(stack.tag)); } }; fluidregistry.registerfluid(potion); fluidregistry.addbucketforfluid(potion); fluidregistry .registerfluid(new fluid(\"slime\", new resourcelocation(steamagerevolution.modid, \"fluids\/solution\"), new resourcelocation(steamagerevolution.modid, \"fluids\/solution\")) { @override public int getcolor() { return color.green.getrgb(); } }); }","classification":"NONSATD","isFinished":true,"code_context_2":"new resourcelocation(steamagerevolution.modid, \"fluids\/steam_flow\")).setgaseous(true) .settemperature(1000).setviscosity(200); if(!(fluidregistry.isfluidregistered(steam))) { \/\/ soft registration fluidregistry.registerfluid(steam); fluidregistry.addbucketforfluid(steam);","code_context_10":"private static void registerfluids(blockregistry blockregistry) { \/\/ todo adjust properties fluid steam = new fluid(\"steam\", new resourcelocation(steamagerevolution.modid, \"fluids\/steam\"), new resourcelocation(steamagerevolution.modid, \"fluids\/steam_flow\")).setgaseous(true) .settemperature(1000).setviscosity(200); if(!(fluidregistry.isfluidregistered(steam))) { \/\/ soft registration fluidregistry.registerfluid(steam); fluidregistry.addbucketforfluid(steam); } blockregistry.register(new blocksarfluid(\"steam\", fluidregistry.getfluid(\"steam\"), material.lava)); fluid sulphur_dioxide = new fluid(\"sulphur_dioxide\", new resourcelocation(steamagerevolution.modid, \"fluids\/sulphur_dioxide\"), new resourcelocation(steamagerevolution.modid, \"fluids\/sulphur_dioxide_flow\")).setviscosity(250) .setgaseous(true).setdensity(-100); fluidregistry.registerfluid(sulphur_dioxide); fluidregistry.addbucketforfluid(sulphur_dioxide);","code_context_20":"private static void registerfluids(blockregistry blockregistry) { \/\/ todo adjust properties fluid steam = new fluid(\"steam\", new resourcelocation(steamagerevolution.modid, \"fluids\/steam\"), new resourcelocation(steamagerevolution.modid, \"fluids\/steam_flow\")).setgaseous(true) .settemperature(1000).setviscosity(200); if(!(fluidregistry.isfluidregistered(steam))) { \/\/ soft registration fluidregistry.registerfluid(steam); fluidregistry.addbucketforfluid(steam); } blockregistry.register(new blocksarfluid(\"steam\", fluidregistry.getfluid(\"steam\"), material.lava)); fluid sulphur_dioxide = new fluid(\"sulphur_dioxide\", new resourcelocation(steamagerevolution.modid, \"fluids\/sulphur_dioxide\"), new resourcelocation(steamagerevolution.modid, \"fluids\/sulphur_dioxide_flow\")).setviscosity(250) .setgaseous(true).setdensity(-100); fluidregistry.registerfluid(sulphur_dioxide); fluidregistry.addbucketforfluid(sulphur_dioxide); blockregistry.register(new blockdamagingfluid(\"sulphur_dioxide\", fluidregistry.getfluid(\"sulphur_dioxide\"), material.water, sarblocks.damagesourcegas, 2)); fluid sulphuric_acid = new fluid(\"sulphuric_acid\", new resourcelocation(steamagerevolution.modid, \"fluids\/sulphuric_acid\"), new resourcelocation(steamagerevolution.modid, \"fluids\/sulphuric_acid_flow\")).setviscosity(500); fluidregistry.registerfluid(sulphuric_acid); fluidregistry.addbucketforfluid(sulphuric_acid); blockregistry.register(new blockacidfluid(\"sulphuric_acid\", fluidregistry.getfluid(\"sulphuric_acid\"), material.water, sarblocks.damagesourceacid, 4)); \/\/ todo te compat?","repo":"BrassGoggledCoders\/SteamAgeRevolution"}
{"id":32983,"comment_id":2,"comment":"\/\/ todo te compat?","code":"private static void registerfluids(blockregistry blockregistry) { \/\/ todo adjust properties fluid steam = new fluid(\"steam\", new resourcelocation(steamagerevolution.modid, \"fluids\/steam\"), new resourcelocation(steamagerevolution.modid, \"fluids\/steam_flow\")).setgaseous(true) .settemperature(1000).setviscosity(200); if(!(fluidregistry.isfluidregistered(steam))) { \/\/ soft registration fluidregistry.registerfluid(steam); fluidregistry.addbucketforfluid(steam); } blockregistry.register(new blocksarfluid(\"steam\", fluidregistry.getfluid(\"steam\"), material.lava)); fluid sulphur_dioxide = new fluid(\"sulphur_dioxide\", new resourcelocation(steamagerevolution.modid, \"fluids\/sulphur_dioxide\"), new resourcelocation(steamagerevolution.modid, \"fluids\/sulphur_dioxide_flow\")).setviscosity(250) .setgaseous(true).setdensity(-100); fluidregistry.registerfluid(sulphur_dioxide); fluidregistry.addbucketforfluid(sulphur_dioxide); blockregistry.register(new blockdamagingfluid(\"sulphur_dioxide\", fluidregistry.getfluid(\"sulphur_dioxide\"), material.water, sarblocks.damagesourcegas, 2)); fluid sulphuric_acid = new fluid(\"sulphuric_acid\", new resourcelocation(steamagerevolution.modid, \"fluids\/sulphuric_acid\"), new resourcelocation(steamagerevolution.modid, \"fluids\/sulphuric_acid_flow\")).setviscosity(500); fluidregistry.registerfluid(sulphuric_acid); fluidregistry.addbucketforfluid(sulphuric_acid); blockregistry.register(new blockacidfluid(\"sulphuric_acid\", fluidregistry.getfluid(\"sulphuric_acid\"), material.water, sarblocks.damagesourceacid, 4)); \/\/ todo te compat? fluid liquid_glowstone = new fluid(\"liquid_glowstone\", new resourcelocation(steamagerevolution.modid, \"fluids\/liquid_glowstone\"), new resourcelocation(steamagerevolution.modid, \"fluids\/liquid_glowstone_flow\")).setviscosity(2000) .setgaseous(true); fluidregistry.registerfluid(liquid_glowstone); fluidregistry.addbucketforfluid(liquid_glowstone); blockregistry.register(new blockliquidglowstone(\"liquid_glowstone\", fluidregistry.getfluid(\"liquid_glowstone\"), material.lava)); fluid potion = new fluid(\"potion\", new resourcelocation(steamagerevolution.modid, \"fluids\/solution\"), new resourcelocation(steamagerevolution.modid, \"fluids\/solution_flowing\")) { @suppresswarnings(\"deprecation\") @override public string getlocalizedname(fluidstack stack) { return i18n.translatetolocal( potionutils.getpotiontypefromnbt(stack.tag).getnameprefixed(\"potion.effect.\")); } @override public int getcolor(fluidstack stack) { return potionutils.getpotioncolorfromeffectlist(potionutils.geteffectsfromtag(stack.tag)); } }; fluidregistry.registerfluid(potion); fluidregistry.addbucketforfluid(potion); fluidregistry .registerfluid(new fluid(\"slime\", new resourcelocation(steamagerevolution.modid, \"fluids\/solution\"), new resourcelocation(steamagerevolution.modid, \"fluids\/solution\")) { @override public int getcolor() { return color.green.getrgb(); } }); }","classification":"DESIGN","isFinished":true,"code_context_2":"blockregistry.register(new blockacidfluid(\"sulphuric_acid\", fluidregistry.getfluid(\"sulphuric_acid\"), material.water, sarblocks.damagesourceacid, 4)); \/\/ todo te compat? fluid liquid_glowstone = new fluid(\"liquid_glowstone\", new resourcelocation(steamagerevolution.modid, \"fluids\/liquid_glowstone\"),","code_context_10":"fluidregistry.addbucketforfluid(sulphur_dioxide); blockregistry.register(new blockdamagingfluid(\"sulphur_dioxide\", fluidregistry.getfluid(\"sulphur_dioxide\"), material.water, sarblocks.damagesourcegas, 2)); fluid sulphuric_acid = new fluid(\"sulphuric_acid\", new resourcelocation(steamagerevolution.modid, \"fluids\/sulphuric_acid\"), new resourcelocation(steamagerevolution.modid, \"fluids\/sulphuric_acid_flow\")).setviscosity(500); fluidregistry.registerfluid(sulphuric_acid); fluidregistry.addbucketforfluid(sulphuric_acid); blockregistry.register(new blockacidfluid(\"sulphuric_acid\", fluidregistry.getfluid(\"sulphuric_acid\"), material.water, sarblocks.damagesourceacid, 4)); \/\/ todo te compat? fluid liquid_glowstone = new fluid(\"liquid_glowstone\", new resourcelocation(steamagerevolution.modid, \"fluids\/liquid_glowstone\"), new resourcelocation(steamagerevolution.modid, \"fluids\/liquid_glowstone_flow\")).setviscosity(2000) .setgaseous(true); fluidregistry.registerfluid(liquid_glowstone); fluidregistry.addbucketforfluid(liquid_glowstone); blockregistry.register(new blockliquidglowstone(\"liquid_glowstone\", fluidregistry.getfluid(\"liquid_glowstone\"), material.lava)); fluid potion = new fluid(\"potion\", new resourcelocation(steamagerevolution.modid, \"fluids\/solution\"), new resourcelocation(steamagerevolution.modid, \"fluids\/solution_flowing\")) {","code_context_20":"if(!(fluidregistry.isfluidregistered(steam))) { \/\/ soft registration fluidregistry.registerfluid(steam); fluidregistry.addbucketforfluid(steam); } blockregistry.register(new blocksarfluid(\"steam\", fluidregistry.getfluid(\"steam\"), material.lava)); fluid sulphur_dioxide = new fluid(\"sulphur_dioxide\", new resourcelocation(steamagerevolution.modid, \"fluids\/sulphur_dioxide\"), new resourcelocation(steamagerevolution.modid, \"fluids\/sulphur_dioxide_flow\")).setviscosity(250) .setgaseous(true).setdensity(-100); fluidregistry.registerfluid(sulphur_dioxide); fluidregistry.addbucketforfluid(sulphur_dioxide); blockregistry.register(new blockdamagingfluid(\"sulphur_dioxide\", fluidregistry.getfluid(\"sulphur_dioxide\"), material.water, sarblocks.damagesourcegas, 2)); fluid sulphuric_acid = new fluid(\"sulphuric_acid\", new resourcelocation(steamagerevolution.modid, \"fluids\/sulphuric_acid\"), new resourcelocation(steamagerevolution.modid, \"fluids\/sulphuric_acid_flow\")).setviscosity(500); fluidregistry.registerfluid(sulphuric_acid); fluidregistry.addbucketforfluid(sulphuric_acid); blockregistry.register(new blockacidfluid(\"sulphuric_acid\", fluidregistry.getfluid(\"sulphuric_acid\"), material.water, sarblocks.damagesourceacid, 4)); \/\/ todo te compat? fluid liquid_glowstone = new fluid(\"liquid_glowstone\", new resourcelocation(steamagerevolution.modid, \"fluids\/liquid_glowstone\"), new resourcelocation(steamagerevolution.modid, \"fluids\/liquid_glowstone_flow\")).setviscosity(2000) .setgaseous(true); fluidregistry.registerfluid(liquid_glowstone); fluidregistry.addbucketforfluid(liquid_glowstone); blockregistry.register(new blockliquidglowstone(\"liquid_glowstone\", fluidregistry.getfluid(\"liquid_glowstone\"), material.lava)); fluid potion = new fluid(\"potion\", new resourcelocation(steamagerevolution.modid, \"fluids\/solution\"), new resourcelocation(steamagerevolution.modid, \"fluids\/solution_flowing\")) { @suppresswarnings(\"deprecation\") @override public string getlocalizedname(fluidstack stack) { return i18n.translatetolocal( potionutils.getpotiontypefromnbt(stack.tag).getnameprefixed(\"potion.effect.\")); } @override public int getcolor(fluidstack stack) { return potionutils.getpotioncolorfromeffectlist(potionutils.geteffectsfromtag(stack.tag)); }","repo":"BrassGoggledCoders\/SteamAgeRevolution"}
{"id":33071,"comment_id":0,"comment":"\/** tests matching of built-in operator names. *\/","code":"\/** tests matching of built-in operator names. *\/ @test void testunquotedbuiltinfunctionnames() { \/\/ todo: once oracle is an officially supported dialect, this test \/\/ should be moved to oraclevalidatortest.java. final sql oracle = sql(\"?\") .withunquotedcasing(casing.to_upper) .withcasesensitive(true); \/\/ built-in functions are always case-insensitive. oracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count (*), floor (2.5) from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select \\\"count\\\"(*) from dept\").ok(); }","classification":"NONSATD","isFinished":true,"code_context_2":"@test void testunquotedbuiltinfunctionnames() { \/\/ todo: once oracle is an officially supported dialect, this test \/\/ should be moved to oraclevalidatortest.java. final sql oracle = sql(\"?\") .withunquotedcasing(casing.to_upper) .withcasesensitive(true); \/\/ built-in functions are always case-insensitive. oracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count (*), floor (2.5) from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select \\\"count\\\"(*) from dept\").ok(); }","code_context_10":"@test void testunquotedbuiltinfunctionnames() { \/\/ todo: once oracle is an officially supported dialect, this test \/\/ should be moved to oraclevalidatortest.java. final sql oracle = sql(\"?\") .withunquotedcasing(casing.to_upper) .withcasesensitive(true); \/\/ built-in functions are always case-insensitive. oracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count (*), floor (2.5) from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select \\\"count\\\"(*) from dept\").ok(); }","code_context_20":"@test void testunquotedbuiltinfunctionnames() { \/\/ todo: once oracle is an officially supported dialect, this test \/\/ should be moved to oraclevalidatortest.java. final sql oracle = sql(\"?\") .withunquotedcasing(casing.to_upper) .withcasesensitive(true); \/\/ built-in functions are always case-insensitive. oracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count (*), floor (2.5) from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select \\\"count\\\"(*) from dept\").ok(); }","repo":"AndrewPochapsky\/calcite"}
{"id":33071,"comment_id":1,"comment":"\/\/ todo: once oracle is an officially supported dialect, this test \/\/ should be moved to oraclevalidatortest.java.","code":"@test void testunquotedbuiltinfunctionnames() { \/\/ todo: once oracle is an officially supported dialect, this test \/\/ should be moved to oraclevalidatortest.java. final sql oracle = sql(\"?\") .withunquotedcasing(casing.to_upper) .withcasesensitive(true); \/\/ built-in functions are always case-insensitive. oracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count (*), floor (2.5) from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select \\\"count\\\"(*) from dept\").ok(); }","classification":"TEST","isFinished":true,"code_context_2":"@test void testunquotedbuiltinfunctionnames() { \/\/ todo: once oracle is an officially supported dialect, this test \/\/ should be moved to oraclevalidatortest.java. final sql oracle = sql(\"?\") .withunquotedcasing(casing.to_upper)","code_context_10":"@test void testunquotedbuiltinfunctionnames() { \/\/ todo: once oracle is an officially supported dialect, this test \/\/ should be moved to oraclevalidatortest.java. final sql oracle = sql(\"?\") .withunquotedcasing(casing.to_upper) .withcasesensitive(true); \/\/ built-in functions are always case-insensitive. oracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count (*), floor (2.5) from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok();","code_context_20":"@test void testunquotedbuiltinfunctionnames() { \/\/ todo: once oracle is an officially supported dialect, this test \/\/ should be moved to oraclevalidatortest.java. final sql oracle = sql(\"?\") .withunquotedcasing(casing.to_upper) .withcasesensitive(true); \/\/ built-in functions are always case-insensitive. oracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count (*), floor (2.5) from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select \\\"count\\\"(*) from dept\").ok(); }","repo":"AndrewPochapsky\/calcite"}
{"id":33071,"comment_id":2,"comment":"\/\/ built-in functions are always case-insensitive.","code":"@test void testunquotedbuiltinfunctionnames() { \/\/ todo: once oracle is an officially supported dialect, this test \/\/ should be moved to oraclevalidatortest.java. final sql oracle = sql(\"?\") .withunquotedcasing(casing.to_upper) .withcasesensitive(true); \/\/ built-in functions are always case-insensitive. oracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count (*), floor (2.5) from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select \\\"count\\\"(*) from dept\").ok(); }","classification":"NONSATD","isFinished":true,"code_context_2":".withunquotedcasing(casing.to_upper) .withcasesensitive(true); \/\/ built-in functions are always case-insensitive. oracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok();","code_context_10":"@test void testunquotedbuiltinfunctionnames() { \/\/ todo: once oracle is an officially supported dialect, this test \/\/ should be moved to oraclevalidatortest.java. final sql oracle = sql(\"?\") .withunquotedcasing(casing.to_upper) .withcasesensitive(true); \/\/ built-in functions are always case-insensitive. oracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count (*), floor (2.5) from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select \\\"count\\\"(*) from dept\").ok(); }","code_context_20":"@test void testunquotedbuiltinfunctionnames() { \/\/ todo: once oracle is an officially supported dialect, this test \/\/ should be moved to oraclevalidatortest.java. final sql oracle = sql(\"?\") .withunquotedcasing(casing.to_upper) .withcasesensitive(true); \/\/ built-in functions are always case-insensitive. oracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count (*), floor (2.5) from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select \\\"count\\\"(*) from dept\").ok(); }","repo":"AndrewPochapsky\/calcite"}
{"id":8635,"comment_id":0,"comment":"\/\/todo: collection.tostring() will likely not produce any useful output!","code":"private void tryconnecttoipv6() throws exception { collection<inet6address> possibleinetaddresses = addressutil .getpossibleinetaddressesfor((inet6address) address.getinetaddress()); level level = silent ? level.finest : level.info; \/\/todo: collection.tostring() will likely not produce any useful output! if (logger.isloggable(level)) { logger.log(level, \"trying to connect possible ipv6 addresses: \" + possibleinetaddresses); } boolean connected = false; exception error = null; int configuredtimeoutmillis = ioservice.getsocketconnecttimeoutseconds(endpointmanager.getendpointqualifier()) * millis_per_second; int timeoutmillis = configuredtimeoutmillis > 0 && configuredtimeoutmillis < integer.max_value ? configuredtimeoutmillis : default_ipv6_socket_connect_timeout_seconds * millis_per_second; for (inet6address inetaddress : possibleinetaddresses) { try { trytoconnect(new inetsocketaddress(inetaddress, address.getport()), timeoutmillis); connected = true; break; } catch (exception e) { error = e; } } if (!connected && error != null) { \/\/ could not connect any of addresses throw error; } }","classification":"DEFECT","isFinished":true,"code_context_2":".getpossibleinetaddressesfor((inet6address) address.getinetaddress()); level level = silent ? level.finest : level.info; \/\/todo: collection.tostring() will likely not produce any useful output! if (logger.isloggable(level)) { logger.log(level, \"trying to connect possible ipv6 addresses: \" + possibleinetaddresses);","code_context_10":"private void tryconnecttoipv6() throws exception { collection<inet6address> possibleinetaddresses = addressutil .getpossibleinetaddressesfor((inet6address) address.getinetaddress()); level level = silent ? level.finest : level.info; \/\/todo: collection.tostring() will likely not produce any useful output! if (logger.isloggable(level)) { logger.log(level, \"trying to connect possible ipv6 addresses: \" + possibleinetaddresses); } boolean connected = false; exception error = null; int configuredtimeoutmillis = ioservice.getsocketconnecttimeoutseconds(endpointmanager.getendpointqualifier()) * millis_per_second; int timeoutmillis = configuredtimeoutmillis > 0 && configuredtimeoutmillis < integer.max_value ? configuredtimeoutmillis : default_ipv6_socket_connect_timeout_seconds * millis_per_second; for (inet6address inetaddress : possibleinetaddresses) {","code_context_20":"private void tryconnecttoipv6() throws exception { collection<inet6address> possibleinetaddresses = addressutil .getpossibleinetaddressesfor((inet6address) address.getinetaddress()); level level = silent ? level.finest : level.info; \/\/todo: collection.tostring() will likely not produce any useful output! if (logger.isloggable(level)) { logger.log(level, \"trying to connect possible ipv6 addresses: \" + possibleinetaddresses); } boolean connected = false; exception error = null; int configuredtimeoutmillis = ioservice.getsocketconnecttimeoutseconds(endpointmanager.getendpointqualifier()) * millis_per_second; int timeoutmillis = configuredtimeoutmillis > 0 && configuredtimeoutmillis < integer.max_value ? configuredtimeoutmillis : default_ipv6_socket_connect_timeout_seconds * millis_per_second; for (inet6address inetaddress : possibleinetaddresses) { try { trytoconnect(new inetsocketaddress(inetaddress, address.getport()), timeoutmillis); connected = true; break; } catch (exception e) { error = e; } } if (!connected && error != null) { \/\/ could not connect any of addresses","repo":"HugeOrangeDev\/hazelcast"}
{"id":8635,"comment_id":1,"comment":"\/\/ could not connect any of addresses","code":"private void tryconnecttoipv6() throws exception { collection<inet6address> possibleinetaddresses = addressutil .getpossibleinetaddressesfor((inet6address) address.getinetaddress()); level level = silent ? level.finest : level.info; \/\/todo: collection.tostring() will likely not produce any useful output! if (logger.isloggable(level)) { logger.log(level, \"trying to connect possible ipv6 addresses: \" + possibleinetaddresses); } boolean connected = false; exception error = null; int configuredtimeoutmillis = ioservice.getsocketconnecttimeoutseconds(endpointmanager.getendpointqualifier()) * millis_per_second; int timeoutmillis = configuredtimeoutmillis > 0 && configuredtimeoutmillis < integer.max_value ? configuredtimeoutmillis : default_ipv6_socket_connect_timeout_seconds * millis_per_second; for (inet6address inetaddress : possibleinetaddresses) { try { trytoconnect(new inetsocketaddress(inetaddress, address.getport()), timeoutmillis); connected = true; break; } catch (exception e) { error = e; } } if (!connected && error != null) { \/\/ could not connect any of addresses throw error; } }","classification":"NONSATD","isFinished":true,"code_context_2":"} if (!connected && error != null) { \/\/ could not connect any of addresses throw error; }","code_context_10":"for (inet6address inetaddress : possibleinetaddresses) { try { trytoconnect(new inetsocketaddress(inetaddress, address.getport()), timeoutmillis); connected = true; break; } catch (exception e) { error = e; } } if (!connected && error != null) { \/\/ could not connect any of addresses throw error; } }","code_context_20":"\/\/todo: collection.tostring() will likely not produce any useful output! if (logger.isloggable(level)) { logger.log(level, \"trying to connect possible ipv6 addresses: \" + possibleinetaddresses); } boolean connected = false; exception error = null; int configuredtimeoutmillis = ioservice.getsocketconnecttimeoutseconds(endpointmanager.getendpointqualifier()) * millis_per_second; int timeoutmillis = configuredtimeoutmillis > 0 && configuredtimeoutmillis < integer.max_value ? configuredtimeoutmillis : default_ipv6_socket_connect_timeout_seconds * millis_per_second; for (inet6address inetaddress : possibleinetaddresses) { try { trytoconnect(new inetsocketaddress(inetaddress, address.getport()), timeoutmillis); connected = true; break; } catch (exception e) { error = e; } } if (!connected && error != null) { \/\/ could not connect any of addresses throw error; } }","repo":"HugeOrangeDev\/hazelcast"}
{"id":33242,"comment_id":0,"comment":"\/** * retrieves the packet content. may be recomputed if the packet is invalidated or * if there is memory demand (handled by a soft reference). * <p> * {@link framedpacket#body()} will contain a buffer allocated by this method. *\/","code":"\/** * retrieves the packet content. may be recomputed if the packet is invalidated or * if there is memory demand (handled by a soft reference). * <p> * {@link framedpacket#body()} will contain a buffer allocated by this method. *\/ public @notnull framedpacket retrieve() { if (!packetutils.cached_packet) { \/\/ todo: using a local buffer may be possible return packetutils.allocatetrimmedpacket(packet()); } softreference<framedpacket> ref; framedpacket cache; if (updated == 0 || ((ref = packet) == null || (cache = ref.get()) == null)) { cache = packetutils.allocatetrimmedpacket(packet()); this.packet = new softreference<>(cache); updater.compareandset(this, 0, 1); } return cache; }","classification":"NONSATD","isFinished":true,"code_context_2":"public @notnull framedpacket retrieve() { if (!packetutils.cached_packet) { \/\/ todo: using a local buffer may be possible return packetutils.allocatetrimmedpacket(packet()); } softreference<framedpacket> ref; framedpacket cache; if (updated == 0 || ((ref = packet) == null || (cache = ref.get()) == null)) { cache = packetutils.allocatetrimmedpacket(packet()); this.packet = new softreference<>(cache); updater.compareandset(this, 0, 1); } return cache; }","code_context_10":"public @notnull framedpacket retrieve() { if (!packetutils.cached_packet) { \/\/ todo: using a local buffer may be possible return packetutils.allocatetrimmedpacket(packet()); } softreference<framedpacket> ref; framedpacket cache; if (updated == 0 || ((ref = packet) == null || (cache = ref.get()) == null)) { cache = packetutils.allocatetrimmedpacket(packet()); this.packet = new softreference<>(cache); updater.compareandset(this, 0, 1); } return cache; }","code_context_20":"public @notnull framedpacket retrieve() { if (!packetutils.cached_packet) { \/\/ todo: using a local buffer may be possible return packetutils.allocatetrimmedpacket(packet()); } softreference<framedpacket> ref; framedpacket cache; if (updated == 0 || ((ref = packet) == null || (cache = ref.get()) == null)) { cache = packetutils.allocatetrimmedpacket(packet()); this.packet = new softreference<>(cache); updater.compareandset(this, 0, 1); } return cache; }","repo":"Avinesia-Union\/Minestom"}
{"id":33242,"comment_id":1,"comment":"\/\/ todo: using a local buffer may be possible","code":"public @notnull framedpacket retrieve() { if (!packetutils.cached_packet) { \/\/ todo: using a local buffer may be possible return packetutils.allocatetrimmedpacket(packet()); } softreference<framedpacket> ref; framedpacket cache; if (updated == 0 || ((ref = packet) == null || (cache = ref.get()) == null)) { cache = packetutils.allocatetrimmedpacket(packet()); this.packet = new softreference<>(cache); updater.compareandset(this, 0, 1); } return cache; }","classification":"DESIGN","isFinished":true,"code_context_2":"public @notnull framedpacket retrieve() { if (!packetutils.cached_packet) { \/\/ todo: using a local buffer may be possible return packetutils.allocatetrimmedpacket(packet()); }","code_context_10":"public @notnull framedpacket retrieve() { if (!packetutils.cached_packet) { \/\/ todo: using a local buffer may be possible return packetutils.allocatetrimmedpacket(packet()); } softreference<framedpacket> ref; framedpacket cache; if (updated == 0 || ((ref = packet) == null || (cache = ref.get()) == null)) { cache = packetutils.allocatetrimmedpacket(packet()); this.packet = new softreference<>(cache); updater.compareandset(this, 0, 1);","code_context_20":"public @notnull framedpacket retrieve() { if (!packetutils.cached_packet) { \/\/ todo: using a local buffer may be possible return packetutils.allocatetrimmedpacket(packet()); } softreference<framedpacket> ref; framedpacket cache; if (updated == 0 || ((ref = packet) == null || (cache = ref.get()) == null)) { cache = packetutils.allocatetrimmedpacket(packet()); this.packet = new softreference<>(cache); updater.compareandset(this, 0, 1); } return cache; }","repo":"Avinesia-Union\/Minestom"}
{"id":25149,"comment_id":0,"comment":"\/\/ maybe we could handle java.lang === java.lang.reflect as well ?","code":"@override @jrubymethod(name = \"===\") public rubyboolean op_eqq(threadcontext context, irubyobject obj) { \/\/ maybe we could handle java.lang === java.lang.reflect as well ? return context.runtime.newboolean(obj == this || isinstance(obj)); }","classification":"DESIGN","isFinished":true,"code_context_2":"@jrubymethod(name = \"===\") public rubyboolean op_eqq(threadcontext context, irubyobject obj) { \/\/ maybe we could handle java.lang === java.lang.reflect as well ? return context.runtime.newboolean(obj == this || isinstance(obj)); }","code_context_10":"@override @jrubymethod(name = \"===\") public rubyboolean op_eqq(threadcontext context, irubyobject obj) { \/\/ maybe we could handle java.lang === java.lang.reflect as well ? return context.runtime.newboolean(obj == this || isinstance(obj)); }","code_context_20":"@override @jrubymethod(name = \"===\") public rubyboolean op_eqq(threadcontext context, irubyobject obj) { \/\/ maybe we could handle java.lang === java.lang.reflect as well ? return context.runtime.newboolean(obj == this || isinstance(obj)); }","repo":"DJRickyB\/jruby"}
{"id":25166,"comment_id":0,"comment":"\/\/ todo why is this working with so few steps?","code":"@test public void testcev() { int timesteps = 200;\/\/ todo why is this working with so few steps? int pricesteps = 100; double lowermoneyness = 0.3; \/\/ not working well for itm calls double uppermoneyness = 3.0; double voltol = 5e-3; boolean print = false; \/\/ set to false before pushing tester.testcev(solver, timesteps, pricesteps, lowermoneyness, uppermoneyness, voltol, print); }","classification":"DESIGN","isFinished":true,"code_context_2":"@test public void testcev() { int timesteps = 200;\/\/ todo why is this working with so few steps? int pricesteps = 100; double lowermoneyness = 0.3; \/\/ not working well for itm calls","code_context_10":"@test public void testcev() { int timesteps = 200;\/\/ todo why is this working with so few steps? int pricesteps = 100; double lowermoneyness = 0.3; \/\/ not working well for itm calls double uppermoneyness = 3.0; double voltol = 5e-3; boolean print = false; \/\/ set to false before pushing tester.testcev(solver, timesteps, pricesteps, lowermoneyness, uppermoneyness, voltol, print); }","code_context_20":"@test public void testcev() { int timesteps = 200;\/\/ todo why is this working with so few steps? int pricesteps = 100; double lowermoneyness = 0.3; \/\/ not working well for itm calls double uppermoneyness = 3.0; double voltol = 5e-3; boolean print = false; \/\/ set to false before pushing tester.testcev(solver, timesteps, pricesteps, lowermoneyness, uppermoneyness, voltol, print); }","repo":"Incapture\/OG-Platform"}
{"id":25166,"comment_id":1,"comment":"\/\/ not working well for itm calls","code":"@test public void testcev() { int timesteps = 200;\/\/ todo why is this working with so few steps? int pricesteps = 100; double lowermoneyness = 0.3; \/\/ not working well for itm calls double uppermoneyness = 3.0; double voltol = 5e-3; boolean print = false; \/\/ set to false before pushing tester.testcev(solver, timesteps, pricesteps, lowermoneyness, uppermoneyness, voltol, print); }","classification":"DEFECT","isFinished":true,"code_context_2":"int timesteps = 200;\/\/ todo why is this working with so few steps? int pricesteps = 100; double lowermoneyness = 0.3; \/\/ not working well for itm calls double uppermoneyness = 3.0; double voltol = 5e-3;","code_context_10":"@test public void testcev() { int timesteps = 200;\/\/ todo why is this working with so few steps? int pricesteps = 100; double lowermoneyness = 0.3; \/\/ not working well for itm calls double uppermoneyness = 3.0; double voltol = 5e-3; boolean print = false; \/\/ set to false before pushing tester.testcev(solver, timesteps, pricesteps, lowermoneyness, uppermoneyness, voltol, print); }","code_context_20":"@test public void testcev() { int timesteps = 200;\/\/ todo why is this working with so few steps? int pricesteps = 100; double lowermoneyness = 0.3; \/\/ not working well for itm calls double uppermoneyness = 3.0; double voltol = 5e-3; boolean print = false; \/\/ set to false before pushing tester.testcev(solver, timesteps, pricesteps, lowermoneyness, uppermoneyness, voltol, print); }","repo":"Incapture\/OG-Platform"}
{"id":25166,"comment_id":2,"comment":"\/\/ set to false before pushing","code":"@test public void testcev() { int timesteps = 200;\/\/ todo why is this working with so few steps? int pricesteps = 100; double lowermoneyness = 0.3; \/\/ not working well for itm calls double uppermoneyness = 3.0; double voltol = 5e-3; boolean print = false; \/\/ set to false before pushing tester.testcev(solver, timesteps, pricesteps, lowermoneyness, uppermoneyness, voltol, print); }","classification":"NONSATD","isFinished":true,"code_context_2":"double uppermoneyness = 3.0; double voltol = 5e-3; boolean print = false; \/\/ set to false before pushing tester.testcev(solver, timesteps, pricesteps, lowermoneyness, uppermoneyness, voltol, print); }","code_context_10":"@test public void testcev() { int timesteps = 200;\/\/ todo why is this working with so few steps? int pricesteps = 100; double lowermoneyness = 0.3; \/\/ not working well for itm calls double uppermoneyness = 3.0; double voltol = 5e-3; boolean print = false; \/\/ set to false before pushing tester.testcev(solver, timesteps, pricesteps, lowermoneyness, uppermoneyness, voltol, print); }","code_context_20":"@test public void testcev() { int timesteps = 200;\/\/ todo why is this working with so few steps? int pricesteps = 100; double lowermoneyness = 0.3; \/\/ not working well for itm calls double uppermoneyness = 3.0; double voltol = 5e-3; boolean print = false; \/\/ set to false before pushing tester.testcev(solver, timesteps, pricesteps, lowermoneyness, uppermoneyness, voltol, print); }","repo":"Incapture\/OG-Platform"}
{"id":8849,"comment_id":0,"comment":"\/** * perform's size 2 calculations. *\/","code":"\/** * perform's size 2 calculations. *\/ private static boolean performcalculations2(int srcx, int srcy, routestrategy strategy) { return performcalculationsx(srcx, srcy, 2, strategy); \/\/ todo optimized algorhytm's. }","classification":"NONSATD","isFinished":true,"code_context_2":"private static boolean performcalculations2(int srcx, int srcy, routestrategy strategy) { return performcalculationsx(srcx, srcy, 2, strategy); \/\/ todo optimized algorhytm's. }","code_context_10":"private static boolean performcalculations2(int srcx, int srcy, routestrategy strategy) { return performcalculationsx(srcx, srcy, 2, strategy); \/\/ todo optimized algorhytm's. }","code_context_20":"private static boolean performcalculations2(int srcx, int srcy, routestrategy strategy) { return performcalculationsx(srcx, srcy, 2, strategy); \/\/ todo optimized algorhytm's. }","repo":"CSS-Lletya\/open633"}
{"id":8849,"comment_id":1,"comment":"\/\/ todo optimized algorhytm's.","code":"private static boolean performcalculations2(int srcx, int srcy, routestrategy strategy) { return performcalculationsx(srcx, srcy, 2, strategy); \/\/ todo optimized algorhytm's. }","classification":"DESIGN","isFinished":true,"code_context_2":"private static boolean performcalculations2(int srcx, int srcy, routestrategy strategy) { return performcalculationsx(srcx, srcy, 2, strategy); \/\/ todo optimized algorhytm's. }","code_context_10":"private static boolean performcalculations2(int srcx, int srcy, routestrategy strategy) { return performcalculationsx(srcx, srcy, 2, strategy); \/\/ todo optimized algorhytm's. }","code_context_20":"private static boolean performcalculations2(int srcx, int srcy, routestrategy strategy) { return performcalculationsx(srcx, srcy, 2, strategy); \/\/ todo optimized algorhytm's. }","repo":"CSS-Lletya\/open633"}
{"id":25271,"comment_id":0,"comment":"\/** * add a qualification non diplemantes. *\/","code":"\/** * add a qualification non diplemantes. *\/ public void addqualifnodip() throws ioexception { if (isvalidindcursus(qualifnondiplomante.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux pojoqualif.getcursus().setcomment(pojoqualif.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(pojoqualif.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), pojoqualif.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(pojoqualif.getcursus()); } pojoqualif.addcursus(); collections.sort(pojoqualif.getcursuslist(), new comparatorstring(indcursus.class)); } }","classification":"NONSATD","isFinished":true,"code_context_2":"public void addqualifnodip() throws ioexception { if (isvalidindcursus(qualifnondiplomante.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux pojoqualif.getcursus().setcomment(pojoqualif.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(pojoqualif.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), pojoqualif.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(pojoqualif.getcursus()); } pojoqualif.addcursus(); collections.sort(pojoqualif.getcursuslist(), new comparatorstring(indcursus.class)); } }","code_context_10":"public void addqualifnodip() throws ioexception { if (isvalidindcursus(qualifnondiplomante.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux pojoqualif.getcursus().setcomment(pojoqualif.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(pojoqualif.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), pojoqualif.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(pojoqualif.getcursus()); } pojoqualif.addcursus(); collections.sort(pojoqualif.getcursuslist(), new comparatorstring(indcursus.class)); } }","code_context_20":"public void addqualifnodip() throws ioexception { if (isvalidindcursus(qualifnondiplomante.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux pojoqualif.getcursus().setcomment(pojoqualif.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(pojoqualif.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), pojoqualif.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(pojoqualif.getcursus()); } pojoqualif.addcursus(); collections.sort(pojoqualif.getcursuslist(), new comparatorstring(indcursus.class)); } }","repo":"EsupPortail\/esup-opi"}
{"id":25271,"comment_id":1,"comment":"\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux","code":"public void addqualifnodip() throws ioexception { if (isvalidindcursus(qualifnondiplomante.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux pojoqualif.getcursus().setcomment(pojoqualif.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(pojoqualif.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), pojoqualif.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(pojoqualif.getcursus()); } pojoqualif.addcursus(); collections.sort(pojoqualif.getcursuslist(), new comparatorstring(indcursus.class)); } }","classification":"NONSATD","isFinished":true,"code_context_2":"public void addqualifnodip() throws ioexception { if (isvalidindcursus(qualifnondiplomante.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux pojoqualif.getcursus().setcomment(pojoqualif.getcursus().getcomment()); \/\/todo: fix this !!","code_context_10":"public void addqualifnodip() throws ioexception { if (isvalidindcursus(qualifnondiplomante.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux pojoqualif.getcursus().setcomment(pojoqualif.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(pojoqualif.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), pojoqualif.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(pojoqualif.getcursus()); }","code_context_20":"public void addqualifnodip() throws ioexception { if (isvalidindcursus(qualifnondiplomante.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux pojoqualif.getcursus().setcomment(pojoqualif.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(pojoqualif.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), pojoqualif.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(pojoqualif.getcursus()); } pojoqualif.addcursus(); collections.sort(pojoqualif.getcursuslist(), new comparatorstring(indcursus.class)); } }","repo":"EsupPortail\/esup-opi"}
{"id":25271,"comment_id":2,"comment":"\/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(pojoqualif.getcursus().getcomment()));","code":"public void addqualifnodip() throws ioexception { if (isvalidindcursus(qualifnondiplomante.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux pojoqualif.getcursus().setcomment(pojoqualif.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(pojoqualif.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), pojoqualif.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(pojoqualif.getcursus()); } pojoqualif.addcursus(); collections.sort(pojoqualif.getcursuslist(), new comparatorstring(indcursus.class)); } }","classification":"DEFECT","isFinished":true,"code_context_2":"\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux pojoqualif.getcursus().setcomment(pojoqualif.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(pojoqualif.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base","code_context_10":"public void addqualifnodip() throws ioexception { if (isvalidindcursus(qualifnondiplomante.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux pojoqualif.getcursus().setcomment(pojoqualif.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(pojoqualif.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), pojoqualif.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(pojoqualif.getcursus()); } pojoqualif.addcursus(); collections.sort(pojoqualif.getcursuslist(), new comparatorstring(indcursus.class)); } }","code_context_20":"public void addqualifnodip() throws ioexception { if (isvalidindcursus(qualifnondiplomante.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux pojoqualif.getcursus().setcomment(pojoqualif.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(pojoqualif.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), pojoqualif.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(pojoqualif.getcursus()); } pojoqualif.addcursus(); collections.sort(pojoqualif.getcursuslist(), new comparatorstring(indcursus.class)); } }","repo":"EsupPortail\/esup-opi"}
{"id":25271,"comment_id":3,"comment":"\/\/ajout en base","code":"public void addqualifnodip() throws ioexception { if (isvalidindcursus(qualifnondiplomante.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux pojoqualif.getcursus().setcomment(pojoqualif.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(pojoqualif.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), pojoqualif.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(pojoqualif.getcursus()); } pojoqualif.addcursus(); collections.sort(pojoqualif.getcursuslist(), new comparatorstring(indcursus.class)); } }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ .htmltotext(pojoqualif.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), pojoqualif.getcursus()); \/\/ajout dans l'individu courant","code_context_10":"public void addqualifnodip() throws ioexception { if (isvalidindcursus(qualifnondiplomante.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux pojoqualif.getcursus().setcomment(pojoqualif.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(pojoqualif.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), pojoqualif.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(pojoqualif.getcursus()); } pojoqualif.addcursus(); collections.sort(pojoqualif.getcursuslist(), new comparatorstring(indcursus.class)); } }","code_context_20":"public void addqualifnodip() throws ioexception { if (isvalidindcursus(qualifnondiplomante.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux pojoqualif.getcursus().setcomment(pojoqualif.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(pojoqualif.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), pojoqualif.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(pojoqualif.getcursus()); } pojoqualif.addcursus(); collections.sort(pojoqualif.getcursuslist(), new comparatorstring(indcursus.class)); } }","repo":"EsupPortail\/esup-opi"}
{"id":25271,"comment_id":4,"comment":"\/\/ajout dans l'individu courant","code":"public void addqualifnodip() throws ioexception { if (isvalidindcursus(qualifnondiplomante.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux pojoqualif.getcursus().setcomment(pojoqualif.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(pojoqualif.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), pojoqualif.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(pojoqualif.getcursus()); } pojoqualif.addcursus(); collections.sort(pojoqualif.getcursuslist(), new comparatorstring(indcursus.class)); } }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ajout en base addonecursus(getcurrentind().getindividu(), pojoqualif.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(pojoqualif.getcursus()); }","code_context_10":"public void addqualifnodip() throws ioexception { if (isvalidindcursus(qualifnondiplomante.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux pojoqualif.getcursus().setcomment(pojoqualif.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(pojoqualif.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), pojoqualif.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(pojoqualif.getcursus()); } pojoqualif.addcursus(); collections.sort(pojoqualif.getcursuslist(), new comparatorstring(indcursus.class)); } }","code_context_20":"public void addqualifnodip() throws ioexception { if (isvalidindcursus(qualifnondiplomante.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux pojoqualif.getcursus().setcomment(pojoqualif.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(pojoqualif.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), pojoqualif.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(pojoqualif.getcursus()); } pojoqualif.addcursus(); collections.sort(pojoqualif.getcursuslist(), new comparatorstring(indcursus.class)); } }","repo":"EsupPortail\/esup-opi"}
{"id":25270,"comment_id":0,"comment":"\/** * add a cursuspro. *\/","code":"\/** * add a cursuspro. *\/ public void addcursuspro() throws ioexception { if (isvalidindcursus(cursuspro.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux indcursuspojo.getcursus().setcomment(indcursuspojo.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(indcursuspojo.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), indcursuspojo.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(indcursuspojo.getcursus()); } indcursuspojo.addcursus(); collections.sort(indcursuspojo.getcursuslist(), new comparatorstring(indcursus.class)); } }","classification":"NONSATD","isFinished":true,"code_context_2":"public void addcursuspro() throws ioexception { if (isvalidindcursus(cursuspro.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux indcursuspojo.getcursus().setcomment(indcursuspojo.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(indcursuspojo.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), indcursuspojo.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(indcursuspojo.getcursus()); } indcursuspojo.addcursus(); collections.sort(indcursuspojo.getcursuslist(), new comparatorstring(indcursus.class)); } }","code_context_10":"public void addcursuspro() throws ioexception { if (isvalidindcursus(cursuspro.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux indcursuspojo.getcursus().setcomment(indcursuspojo.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(indcursuspojo.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), indcursuspojo.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(indcursuspojo.getcursus()); } indcursuspojo.addcursus(); collections.sort(indcursuspojo.getcursuslist(), new comparatorstring(indcursus.class)); } }","code_context_20":"public void addcursuspro() throws ioexception { if (isvalidindcursus(cursuspro.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux indcursuspojo.getcursus().setcomment(indcursuspojo.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(indcursuspojo.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), indcursuspojo.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(indcursuspojo.getcursus()); } indcursuspojo.addcursus(); collections.sort(indcursuspojo.getcursuslist(), new comparatorstring(indcursus.class)); } }","repo":"EsupPortail\/esup-opi"}
{"id":25270,"comment_id":1,"comment":"\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux","code":"public void addcursuspro() throws ioexception { if (isvalidindcursus(cursuspro.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux indcursuspojo.getcursus().setcomment(indcursuspojo.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(indcursuspojo.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), indcursuspojo.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(indcursuspojo.getcursus()); } indcursuspojo.addcursus(); collections.sort(indcursuspojo.getcursuslist(), new comparatorstring(indcursus.class)); } }","classification":"NONSATD","isFinished":true,"code_context_2":"public void addcursuspro() throws ioexception { if (isvalidindcursus(cursuspro.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux indcursuspojo.getcursus().setcomment(indcursuspojo.getcursus().getcomment()); \/\/todo: fix this !!","code_context_10":"public void addcursuspro() throws ioexception { if (isvalidindcursus(cursuspro.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux indcursuspojo.getcursus().setcomment(indcursuspojo.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(indcursuspojo.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), indcursuspojo.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(indcursuspojo.getcursus()); }","code_context_20":"public void addcursuspro() throws ioexception { if (isvalidindcursus(cursuspro.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux indcursuspojo.getcursus().setcomment(indcursuspojo.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(indcursuspojo.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), indcursuspojo.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(indcursuspojo.getcursus()); } indcursuspojo.addcursus(); collections.sort(indcursuspojo.getcursuslist(), new comparatorstring(indcursus.class)); } }","repo":"EsupPortail\/esup-opi"}
{"id":25270,"comment_id":2,"comment":"\/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(indcursuspojo.getcursus().getcomment()));","code":"public void addcursuspro() throws ioexception { if (isvalidindcursus(cursuspro.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux indcursuspojo.getcursus().setcomment(indcursuspojo.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(indcursuspojo.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), indcursuspojo.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(indcursuspojo.getcursus()); } indcursuspojo.addcursus(); collections.sort(indcursuspojo.getcursuslist(), new comparatorstring(indcursus.class)); } }","classification":"DEFECT","isFinished":true,"code_context_2":"\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux indcursuspojo.getcursus().setcomment(indcursuspojo.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(indcursuspojo.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base","code_context_10":"public void addcursuspro() throws ioexception { if (isvalidindcursus(cursuspro.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux indcursuspojo.getcursus().setcomment(indcursuspojo.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(indcursuspojo.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), indcursuspojo.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(indcursuspojo.getcursus()); } indcursuspojo.addcursus(); collections.sort(indcursuspojo.getcursuslist(), new comparatorstring(indcursus.class)); } }","code_context_20":"public void addcursuspro() throws ioexception { if (isvalidindcursus(cursuspro.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux indcursuspojo.getcursus().setcomment(indcursuspojo.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(indcursuspojo.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), indcursuspojo.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(indcursuspojo.getcursus()); } indcursuspojo.addcursus(); collections.sort(indcursuspojo.getcursuslist(), new comparatorstring(indcursus.class)); } }","repo":"EsupPortail\/esup-opi"}
{"id":25270,"comment_id":3,"comment":"\/\/ajout en base","code":"public void addcursuspro() throws ioexception { if (isvalidindcursus(cursuspro.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux indcursuspojo.getcursus().setcomment(indcursuspojo.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(indcursuspojo.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), indcursuspojo.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(indcursuspojo.getcursus()); } indcursuspojo.addcursus(); collections.sort(indcursuspojo.getcursuslist(), new comparatorstring(indcursus.class)); } }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ .htmltotext(indcursuspojo.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), indcursuspojo.getcursus()); \/\/ajout dans l'individu courant","code_context_10":"public void addcursuspro() throws ioexception { if (isvalidindcursus(cursuspro.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux indcursuspojo.getcursus().setcomment(indcursuspojo.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(indcursuspojo.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), indcursuspojo.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(indcursuspojo.getcursus()); } indcursuspojo.addcursus(); collections.sort(indcursuspojo.getcursuslist(), new comparatorstring(indcursus.class)); } }","code_context_20":"public void addcursuspro() throws ioexception { if (isvalidindcursus(cursuspro.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux indcursuspojo.getcursus().setcomment(indcursuspojo.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(indcursuspojo.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), indcursuspojo.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(indcursuspojo.getcursus()); } indcursuspojo.addcursus(); collections.sort(indcursuspojo.getcursuslist(), new comparatorstring(indcursus.class)); } }","repo":"EsupPortail\/esup-opi"}
{"id":25270,"comment_id":4,"comment":"\/\/ajout dans l'individu courant","code":"public void addcursuspro() throws ioexception { if (isvalidindcursus(cursuspro.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux indcursuspojo.getcursus().setcomment(indcursuspojo.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(indcursuspojo.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), indcursuspojo.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(indcursuspojo.getcursus()); } indcursuspojo.addcursus(); collections.sort(indcursuspojo.getcursuslist(), new comparatorstring(indcursus.class)); } }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ajout en base addonecursus(getcurrentind().getindividu(), indcursuspojo.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(indcursuspojo.getcursus()); }","code_context_10":"public void addcursuspro() throws ioexception { if (isvalidindcursus(cursuspro.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux indcursuspojo.getcursus().setcomment(indcursuspojo.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(indcursuspojo.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), indcursuspojo.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(indcursuspojo.getcursus()); } indcursuspojo.addcursus(); collections.sort(indcursuspojo.getcursuslist(), new comparatorstring(indcursus.class)); } }","code_context_20":"public void addcursuspro() throws ioexception { if (isvalidindcursus(cursuspro.class, true)) { \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux indcursuspojo.getcursus().setcomment(indcursuspojo.getcursus().getcomment()); \/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(indcursuspojo.getcursus().getcomment())); if (actionenum.getwhataction().equals(actionenum.update_action)) { \/\/ajout en base addonecursus(getcurrentind().getindividu(), indcursuspojo.getcursus()); \/\/ajout dans l'individu courant getcurrentind().getindividu().getcursus().add(indcursuspojo.getcursus()); } indcursuspojo.addcursus(); collections.sort(indcursuspojo.getcursuslist(), new comparatorstring(indcursus.class)); } }","repo":"EsupPortail\/esup-opi"}
{"id":17130,"comment_id":0,"comment":"\/** updates the task *\/","code":"\/** updates the task *\/ @override public void updatetask() { double distancefromtarget = this.host.getdistancesq(host.getattacktarget().posx, host.getattacktarget().boundingbox.miny, host.getattacktarget().posz); boolean canseetarget = true; \/\/this.host.getentitysenses().cansee(this.attacktarget); if (canseetarget) { ++this.targettimelost; } else { this.targettimelost = 0; } if (distancefromtarget <= (double) this.followdistance && this.targettimelost >= 20) { this.host.getnavigator().clearpathentity(); } else { this.host.getnavigator().trymovetoentityliving(host.getattacktarget(), this.entitymovespeed); } this.host.getlookhelper().setlookpositionwithentity(host.getattacktarget(), 30.0f, 30.0f); float f; if (--this.rangedattacktime == 0) { if (distancefromtarget > (double) this.followdistance || !canseetarget) { return; } f = mathhelper.sqrt_double(distancefromtarget) \/ this.attackrange; \/\/ todo replace this.rangedattackentityhost.attackentitywithrangedattack(thost.getattacktarget(), f); this.rangedattacktime = mathhelper.floor_float(f * (float) (this.maxrangedattacktime - this.minrangedattacktime) + (float) this.minrangedattacktime); } else if (this.rangedattacktime < 0) { f = mathhelper.sqrt_double(distancefromtarget) \/ this.attackrange; this.rangedattacktime = mathhelper.floor_float(f * (float) (this.maxrangedattacktime - this.minrangedattacktime) + (float) this.minrangedattacktime); } }","classification":"NONSATD","isFinished":true,"code_context_2":"@override public void updatetask() { double distancefromtarget = this.host.getdistancesq(host.getattacktarget().posx, host.getattacktarget().boundingbox.miny, host.getattacktarget().posz); boolean canseetarget = true; \/\/this.host.getentitysenses().cansee(this.attacktarget); if (canseetarget) { ++this.targettimelost; } else { this.targettimelost = 0; } if (distancefromtarget <= (double) this.followdistance && this.targettimelost >= 20) { this.host.getnavigator().clearpathentity(); } else { this.host.getnavigator().trymovetoentityliving(host.getattacktarget(), this.entitymovespeed); } this.host.getlookhelper().setlookpositionwithentity(host.getattacktarget(), 30.0f, 30.0f); float f; if (--this.rangedattacktime == 0) { if (distancefromtarget > (double) this.followdistance || !canseetarget) { return; } f = mathhelper.sqrt_double(distancefromtarget) \/ this.attackrange; \/\/ todo replace this.rangedattackentityhost.attackentitywithrangedattack(thost.getattacktarget(), f); this.rangedattacktime = mathhelper.floor_float(f * (float) (this.maxrangedattacktime - this.minrangedattacktime) + (float) this.minrangedattacktime); } else if (this.rangedattacktime < 0) { f = mathhelper.sqrt_double(distancefromtarget) \/ this.attackrange; this.rangedattacktime = mathhelper.floor_float(f * (float) (this.maxrangedattacktime - this.minrangedattacktime) + (float) this.minrangedattacktime); } }","code_context_10":"@override public void updatetask() { double distancefromtarget = this.host.getdistancesq(host.getattacktarget().posx, host.getattacktarget().boundingbox.miny, host.getattacktarget().posz); boolean canseetarget = true; \/\/this.host.getentitysenses().cansee(this.attacktarget); if (canseetarget) { ++this.targettimelost; } else { this.targettimelost = 0; } if (distancefromtarget <= (double) this.followdistance && this.targettimelost >= 20) { this.host.getnavigator().clearpathentity(); } else { this.host.getnavigator().trymovetoentityliving(host.getattacktarget(), this.entitymovespeed); } this.host.getlookhelper().setlookpositionwithentity(host.getattacktarget(), 30.0f, 30.0f); float f; if (--this.rangedattacktime == 0) { if (distancefromtarget > (double) this.followdistance || !canseetarget) { return; } f = mathhelper.sqrt_double(distancefromtarget) \/ this.attackrange; \/\/ todo replace this.rangedattackentityhost.attackentitywithrangedattack(thost.getattacktarget(), f); this.rangedattacktime = mathhelper.floor_float(f * (float) (this.maxrangedattacktime - this.minrangedattacktime) + (float) this.minrangedattacktime); } else if (this.rangedattacktime < 0) { f = mathhelper.sqrt_double(distancefromtarget) \/ this.attackrange; this.rangedattacktime = mathhelper.floor_float(f * (float) (this.maxrangedattacktime - this.minrangedattacktime) + (float) this.minrangedattacktime); } }","code_context_20":"@override public void updatetask() { double distancefromtarget = this.host.getdistancesq(host.getattacktarget().posx, host.getattacktarget().boundingbox.miny, host.getattacktarget().posz); boolean canseetarget = true; \/\/this.host.getentitysenses().cansee(this.attacktarget); if (canseetarget) { ++this.targettimelost; } else { this.targettimelost = 0; } if (distancefromtarget <= (double) this.followdistance && this.targettimelost >= 20) { this.host.getnavigator().clearpathentity(); } else { this.host.getnavigator().trymovetoentityliving(host.getattacktarget(), this.entitymovespeed); } this.host.getlookhelper().setlookpositionwithentity(host.getattacktarget(), 30.0f, 30.0f); float f; if (--this.rangedattacktime == 0) { if (distancefromtarget > (double) this.followdistance || !canseetarget) { return; } f = mathhelper.sqrt_double(distancefromtarget) \/ this.attackrange; \/\/ todo replace this.rangedattackentityhost.attackentitywithrangedattack(thost.getattacktarget(), f); this.rangedattacktime = mathhelper.floor_float(f * (float) (this.maxrangedattacktime - this.minrangedattacktime) + (float) this.minrangedattacktime); } else if (this.rangedattacktime < 0) { f = mathhelper.sqrt_double(distancefromtarget) \/ this.attackrange; this.rangedattacktime = mathhelper.floor_float(f * (float) (this.maxrangedattacktime - this.minrangedattacktime) + (float) this.minrangedattacktime); } }","repo":"DarkGuardsman\/Artillects"}
{"id":17130,"comment_id":1,"comment":"\/\/this.host.getentitysenses().cansee(this.attacktarget);","code":"@override public void updatetask() { double distancefromtarget = this.host.getdistancesq(host.getattacktarget().posx, host.getattacktarget().boundingbox.miny, host.getattacktarget().posz); boolean canseetarget = true; \/\/this.host.getentitysenses().cansee(this.attacktarget); if (canseetarget) { ++this.targettimelost; } else { this.targettimelost = 0; } if (distancefromtarget <= (double) this.followdistance && this.targettimelost >= 20) { this.host.getnavigator().clearpathentity(); } else { this.host.getnavigator().trymovetoentityliving(host.getattacktarget(), this.entitymovespeed); } this.host.getlookhelper().setlookpositionwithentity(host.getattacktarget(), 30.0f, 30.0f); float f; if (--this.rangedattacktime == 0) { if (distancefromtarget > (double) this.followdistance || !canseetarget) { return; } f = mathhelper.sqrt_double(distancefromtarget) \/ this.attackrange; \/\/ todo replace this.rangedattackentityhost.attackentitywithrangedattack(thost.getattacktarget(), f); this.rangedattacktime = mathhelper.floor_float(f * (float) (this.maxrangedattacktime - this.minrangedattacktime) + (float) this.minrangedattacktime); } else if (this.rangedattacktime < 0) { f = mathhelper.sqrt_double(distancefromtarget) \/ this.attackrange; this.rangedattacktime = mathhelper.floor_float(f * (float) (this.maxrangedattacktime - this.minrangedattacktime) + (float) this.minrangedattacktime); } }","classification":"NONSATD","isFinished":true,"code_context_2":"{ double distancefromtarget = this.host.getdistancesq(host.getattacktarget().posx, host.getattacktarget().boundingbox.miny, host.getattacktarget().posz); boolean canseetarget = true; \/\/this.host.getentitysenses().cansee(this.attacktarget); if (canseetarget) {","code_context_10":"@override public void updatetask() { double distancefromtarget = this.host.getdistancesq(host.getattacktarget().posx, host.getattacktarget().boundingbox.miny, host.getattacktarget().posz); boolean canseetarget = true; \/\/this.host.getentitysenses().cansee(this.attacktarget); if (canseetarget) { ++this.targettimelost; } else { this.targettimelost = 0; } if (distancefromtarget <= (double) this.followdistance && this.targettimelost >= 20) {","code_context_20":"@override public void updatetask() { double distancefromtarget = this.host.getdistancesq(host.getattacktarget().posx, host.getattacktarget().boundingbox.miny, host.getattacktarget().posz); boolean canseetarget = true; \/\/this.host.getentitysenses().cansee(this.attacktarget); if (canseetarget) { ++this.targettimelost; } else { this.targettimelost = 0; } if (distancefromtarget <= (double) this.followdistance && this.targettimelost >= 20) { this.host.getnavigator().clearpathentity(); } else { this.host.getnavigator().trymovetoentityliving(host.getattacktarget(), this.entitymovespeed); } this.host.getlookhelper().setlookpositionwithentity(host.getattacktarget(), 30.0f, 30.0f); float f; if (--this.rangedattacktime == 0) {","repo":"DarkGuardsman\/Artillects"}
{"id":17130,"comment_id":2,"comment":"\/\/ todo replace this.rangedattackentityhost.attackentitywithrangedattack(thost.getattacktarget(), f);","code":"@override public void updatetask() { double distancefromtarget = this.host.getdistancesq(host.getattacktarget().posx, host.getattacktarget().boundingbox.miny, host.getattacktarget().posz); boolean canseetarget = true; \/\/this.host.getentitysenses().cansee(this.attacktarget); if (canseetarget) { ++this.targettimelost; } else { this.targettimelost = 0; } if (distancefromtarget <= (double) this.followdistance && this.targettimelost >= 20) { this.host.getnavigator().clearpathentity(); } else { this.host.getnavigator().trymovetoentityliving(host.getattacktarget(), this.entitymovespeed); } this.host.getlookhelper().setlookpositionwithentity(host.getattacktarget(), 30.0f, 30.0f); float f; if (--this.rangedattacktime == 0) { if (distancefromtarget > (double) this.followdistance || !canseetarget) { return; } f = mathhelper.sqrt_double(distancefromtarget) \/ this.attackrange; \/\/ todo replace this.rangedattackentityhost.attackentitywithrangedattack(thost.getattacktarget(), f); this.rangedattacktime = mathhelper.floor_float(f * (float) (this.maxrangedattacktime - this.minrangedattacktime) + (float) this.minrangedattacktime); } else if (this.rangedattacktime < 0) { f = mathhelper.sqrt_double(distancefromtarget) \/ this.attackrange; this.rangedattacktime = mathhelper.floor_float(f * (float) (this.maxrangedattacktime - this.minrangedattacktime) + (float) this.minrangedattacktime); } }","classification":"DESIGN","isFinished":true,"code_context_2":"} f = mathhelper.sqrt_double(distancefromtarget) \/ this.attackrange; \/\/ todo replace this.rangedattackentityhost.attackentitywithrangedattack(thost.getattacktarget(), f); this.rangedattacktime = mathhelper.floor_float(f * (float) (this.maxrangedattacktime - this.minrangedattacktime) + (float) this.minrangedattacktime); }","code_context_10":"} this.host.getlookhelper().setlookpositionwithentity(host.getattacktarget(), 30.0f, 30.0f); float f; if (--this.rangedattacktime == 0) { if (distancefromtarget > (double) this.followdistance || !canseetarget) { return; } f = mathhelper.sqrt_double(distancefromtarget) \/ this.attackrange; \/\/ todo replace this.rangedattackentityhost.attackentitywithrangedattack(thost.getattacktarget(), f); this.rangedattacktime = mathhelper.floor_float(f * (float) (this.maxrangedattacktime - this.minrangedattacktime) + (float) this.minrangedattacktime); } else if (this.rangedattacktime < 0) { f = mathhelper.sqrt_double(distancefromtarget) \/ this.attackrange; this.rangedattacktime = mathhelper.floor_float(f * (float) (this.maxrangedattacktime - this.minrangedattacktime) + (float) this.minrangedattacktime); } }","code_context_20":"{ this.targettimelost = 0; } if (distancefromtarget <= (double) this.followdistance && this.targettimelost >= 20) { this.host.getnavigator().clearpathentity(); } else { this.host.getnavigator().trymovetoentityliving(host.getattacktarget(), this.entitymovespeed); } this.host.getlookhelper().setlookpositionwithentity(host.getattacktarget(), 30.0f, 30.0f); float f; if (--this.rangedattacktime == 0) { if (distancefromtarget > (double) this.followdistance || !canseetarget) { return; } f = mathhelper.sqrt_double(distancefromtarget) \/ this.attackrange; \/\/ todo replace this.rangedattackentityhost.attackentitywithrangedattack(thost.getattacktarget(), f); this.rangedattacktime = mathhelper.floor_float(f * (float) (this.maxrangedattacktime - this.minrangedattacktime) + (float) this.minrangedattacktime); } else if (this.rangedattacktime < 0) { f = mathhelper.sqrt_double(distancefromtarget) \/ this.attackrange; this.rangedattacktime = mathhelper.floor_float(f * (float) (this.maxrangedattacktime - this.minrangedattacktime) + (float) this.minrangedattacktime); } }","repo":"DarkGuardsman\/Artillects"}
{"id":17208,"comment_id":0,"comment":"\/\/ todo astutils.getclassfilesforsource(f.tostring()); - attempt to get only relevant classpaths for a given source file? \/\/ todo naively we can multi-thread here (i.e. per file) but simple testing indicated that this slowed us down.","code":"protected void runoperations(string directorypath, usecase usecase) throws ioexception { log.info(system.lineseparator() + \"================================================\" + system.lineseparator() + \" ____ ____________________ ____\" + system.lineseparator() + \" \/ \\\\ \/ __|__ __| _ \\\\ \/ \\\\\" + system.lineseparator() + \" \/ \/\\\\ \\\\ \\\\ \\\\ | | | |\/ \/ \/ \/\\\\ \\\\\" + system.lineseparator() + \" \/ \/__\\\\ \\\\__\\\\ \\\\ | | | |\\\\ \\\\ \/ \/__\\\\ \\\\\" + system.lineseparator() + \" \/__\/ \\\\__\\\\____\/ |__| |__| \\\\__\\\\__\/ \\\\__\\\\\" + system.lineseparator() + \"================================================\"); log.info(\"starting astra run for directory: \" + directorypath); atomiclong currentfileindex = new atomiclong(); atomiclong currentpercentage = new atomiclong(); log.info(\"counting files (this may take a few seconds)\"); instant starttime = instant.now(); list<path> javafilesindirectory; try (stream<path> walk = files.walk(paths.get(directorypath))) { javafilesindirectory = walk .filter(f -> f.tofile().isfile()) .filter(f -> f.getfilename().tostring().endswith(\"java\")) .collect(collectors.tolist()); } log.info(javafilesindirectory.size() + \" .java files in directory to review\"); log.info(\"applying prefilters to files in directory\"); predicate<string> prefilteringpredicate = usecase.getprefilteringpredicate(); list<path> filteredjavafiles = javafilesindirectory.stream() .filter(f -> prefilteringpredicate.test(f.tostring())) .collect(collectors.tolist()); log.info(filteredjavafiles.size() + \" files remain after prefiltering\"); final set<? extends astoperation> operations = usecase.getoperations(); final string[] sources = usecase.getsources(); final string[] classpath = usecase.getclasspath(); for (path f : filteredjavafiles) { \/\/ todo astutils.getclassfilesforsource(f.tostring()); - attempt to get only relevant classpaths for a given source file? \/\/ todo naively we can multi-thread here (i.e. per file) but simple testing indicated that this slowed us down. applyoperationsandsave(new file(f.tostring()), operations, sources, classpath); long newpercentage = currentfileindex.incrementandget() * 100 \/ filteredjavafiles.size(); if (newpercentage != currentpercentage.get()) { currentpercentage.set(newpercentage); logprogress(currentfileindex.get(), currentpercentage.get(), starttime, filteredjavafiles.size()); } } log.info(getprintableduration(duration.between(starttime, instant.now()))); }","classification":"DESIGN","isFinished":true,"code_context_2":"final string[] classpath = usecase.getclasspath(); for (path f : filteredjavafiles) { \/\/ todo astutils.getclassfilesforsource(f.tostring()); - attempt to get only relevant classpaths for a given source file? \/\/ todo naively we can multi-thread here (i.e. per file) but simple testing indicated that this slowed us down. applyoperationsandsave(new file(f.tostring()), operations, sources, classpath); long newpercentage = currentfileindex.incrementandget() * 100 \/ filteredjavafiles.size();","code_context_10":"log.info(\"applying prefilters to files in directory\"); predicate<string> prefilteringpredicate = usecase.getprefilteringpredicate(); list<path> filteredjavafiles = javafilesindirectory.stream() .filter(f -> prefilteringpredicate.test(f.tostring())) .collect(collectors.tolist()); log.info(filteredjavafiles.size() + \" files remain after prefiltering\"); final set<? extends astoperation> operations = usecase.getoperations(); final string[] sources = usecase.getsources(); final string[] classpath = usecase.getclasspath(); for (path f : filteredjavafiles) { \/\/ todo astutils.getclassfilesforsource(f.tostring()); - attempt to get only relevant classpaths for a given source file? \/\/ todo naively we can multi-thread here (i.e. per file) but simple testing indicated that this slowed us down. applyoperationsandsave(new file(f.tostring()), operations, sources, classpath); long newpercentage = currentfileindex.incrementandget() * 100 \/ filteredjavafiles.size(); if (newpercentage != currentpercentage.get()) { currentpercentage.set(newpercentage); logprogress(currentfileindex.get(), currentpercentage.get(), starttime, filteredjavafiles.size()); } } log.info(getprintableduration(duration.between(starttime, instant.now()))); }","code_context_20":"log.info(\"counting files (this may take a few seconds)\"); instant starttime = instant.now(); list<path> javafilesindirectory; try (stream<path> walk = files.walk(paths.get(directorypath))) { javafilesindirectory = walk .filter(f -> f.tofile().isfile()) .filter(f -> f.getfilename().tostring().endswith(\"java\")) .collect(collectors.tolist()); } log.info(javafilesindirectory.size() + \" .java files in directory to review\"); log.info(\"applying prefilters to files in directory\"); predicate<string> prefilteringpredicate = usecase.getprefilteringpredicate(); list<path> filteredjavafiles = javafilesindirectory.stream() .filter(f -> prefilteringpredicate.test(f.tostring())) .collect(collectors.tolist()); log.info(filteredjavafiles.size() + \" files remain after prefiltering\"); final set<? extends astoperation> operations = usecase.getoperations(); final string[] sources = usecase.getsources(); final string[] classpath = usecase.getclasspath(); for (path f : filteredjavafiles) { \/\/ todo astutils.getclassfilesforsource(f.tostring()); - attempt to get only relevant classpaths for a given source file? \/\/ todo naively we can multi-thread here (i.e. per file) but simple testing indicated that this slowed us down. applyoperationsandsave(new file(f.tostring()), operations, sources, classpath); long newpercentage = currentfileindex.incrementandget() * 100 \/ filteredjavafiles.size(); if (newpercentage != currentpercentage.get()) { currentpercentage.set(newpercentage); logprogress(currentfileindex.get(), currentpercentage.get(), starttime, filteredjavafiles.size()); } } log.info(getprintableduration(duration.between(starttime, instant.now()))); }","repo":"Arraying\/astra"}
{"id":25405,"comment_id":0,"comment":"\/\/ todo: some auto handling here?","code":"public static fragmenthostmanager get(view view) { try { return dependency.get(fragmentservice.class).getfragmenthostmanager(view); } catch (classcastexception e) { \/\/ todo: some auto handling here? throw e; } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"return dependency.get(fragmentservice.class).getfragmenthostmanager(view); } catch (classcastexception e) { \/\/ todo: some auto handling here? throw e; }","code_context_10":"public static fragmenthostmanager get(view view) { try { return dependency.get(fragmentservice.class).getfragmenthostmanager(view); } catch (classcastexception e) { \/\/ todo: some auto handling here? throw e; } }","code_context_20":"public static fragmenthostmanager get(view view) { try { return dependency.get(fragmentservice.class).getfragmenthostmanager(view); } catch (classcastexception e) { \/\/ todo: some auto handling here? throw e; } }","repo":"FrankKwok\/Oreo"}
{"id":25463,"comment_id":0,"comment":"\/** * <p>constructs the textual content of the given node and * recursively the textual content of its sub element nodes. * appends the result to the given stringbuilder.<\/p> * * @param node xml node * @param sb stringbuilder that will contain the textual content of the node *\/","code":"\/** * <p>constructs the textual content of the given node and * recursively the textual content of its sub element nodes. * appends the result to the given stringbuilder.<\/p> * * @param node xml node * @param sb stringbuilder that will contain the textual content of the node *\/ public static void gettext(node node, stringbuilder sb) { nodelist children = node.getchildnodes(); for (int i = 0; i < children.getlength(); i++) { node child = children.item(i); if (child.getnodetype() == node.text_node) { sb.append(' '); \/\/ bug: this is a hack sb.append(child.getnodevalue().trim()); } else if (child.getnodetype() == node.element_node) { gettext(child, sb); } } }","classification":"NONSATD","isFinished":true,"code_context_2":"public static void gettext(node node, stringbuilder sb) { nodelist children = node.getchildnodes(); for (int i = 0; i < children.getlength(); i++) { node child = children.item(i); if (child.getnodetype() == node.text_node) { sb.append(' '); \/\/ bug: this is a hack sb.append(child.getnodevalue().trim()); } else if (child.getnodetype() == node.element_node) { gettext(child, sb); } } }","code_context_10":"public static void gettext(node node, stringbuilder sb) { nodelist children = node.getchildnodes(); for (int i = 0; i < children.getlength(); i++) { node child = children.item(i); if (child.getnodetype() == node.text_node) { sb.append(' '); \/\/ bug: this is a hack sb.append(child.getnodevalue().trim()); } else if (child.getnodetype() == node.element_node) { gettext(child, sb); } } }","code_context_20":"public static void gettext(node node, stringbuilder sb) { nodelist children = node.getchildnodes(); for (int i = 0; i < children.getlength(); i++) { node child = children.item(i); if (child.getnodetype() == node.text_node) { sb.append(' '); \/\/ bug: this is a hack sb.append(child.getnodevalue().trim()); } else if (child.getnodetype() == node.element_node) { gettext(child, sb); } } }","repo":"GoVivaceInc\/SpeechPlugin"}
{"id":25463,"comment_id":1,"comment":"\/\/ bug: this is a hack","code":"public static void gettext(node node, stringbuilder sb) { nodelist children = node.getchildnodes(); for (int i = 0; i < children.getlength(); i++) { node child = children.item(i); if (child.getnodetype() == node.text_node) { sb.append(' '); \/\/ bug: this is a hack sb.append(child.getnodevalue().trim()); } else if (child.getnodetype() == node.element_node) { gettext(child, sb); } } }","classification":"DEFECT","isFinished":true,"code_context_2":"node child = children.item(i); if (child.getnodetype() == node.text_node) { sb.append(' '); \/\/ bug: this is a hack sb.append(child.getnodevalue().trim()); } else if (child.getnodetype() == node.element_node) {","code_context_10":"public static void gettext(node node, stringbuilder sb) { nodelist children = node.getchildnodes(); for (int i = 0; i < children.getlength(); i++) { node child = children.item(i); if (child.getnodetype() == node.text_node) { sb.append(' '); \/\/ bug: this is a hack sb.append(child.getnodevalue().trim()); } else if (child.getnodetype() == node.element_node) { gettext(child, sb); } } }","code_context_20":"public static void gettext(node node, stringbuilder sb) { nodelist children = node.getchildnodes(); for (int i = 0; i < children.getlength(); i++) { node child = children.item(i); if (child.getnodetype() == node.text_node) { sb.append(' '); \/\/ bug: this is a hack sb.append(child.getnodevalue().trim()); } else if (child.getnodetype() == node.element_node) { gettext(child, sb); } } }","repo":"GoVivaceInc\/SpeechPlugin"}
{"id":9271,"comment_id":0,"comment":"\/\/ todo: optimize me.","code":"private static string encodecomponent(string s, charset charset) { \/\/ todo: optimize me. try { return urlencoder.encode(s, charset.name()).replace(\"+\", \"%20\"); } catch (unsupportedencodingexception ignored) { throw new unsupportedcharsetexception(charset.name()); } }","classification":"DESIGN","isFinished":true,"code_context_2":"private static string encodecomponent(string s, charset charset) { \/\/ todo: optimize me. try { return urlencoder.encode(s, charset.name()).replace(\"+\", \"%20\");","code_context_10":"private static string encodecomponent(string s, charset charset) { \/\/ todo: optimize me. try { return urlencoder.encode(s, charset.name()).replace(\"+\", \"%20\"); } catch (unsupportedencodingexception ignored) { throw new unsupportedcharsetexception(charset.name()); } }","code_context_20":"private static string encodecomponent(string s, charset charset) { \/\/ todo: optimize me. try { return urlencoder.encode(s, charset.name()).replace(\"+\", \"%20\"); } catch (unsupportedencodingexception ignored) { throw new unsupportedcharsetexception(charset.name()); } }","repo":"AIPaaS\/sky-walking"}
{"id":25701,"comment_id":0,"comment":"\/\/instantiate firebase objects","code":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { view rootview = inflater.inflate(r.layout.queue_list, container, false); \/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator); final list<payment> paymentslist = new arraylist<payment>(); postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); \/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected mchildeventlistener = new childeventlistener() { @override public void onchildadded(datasnapshot datasnapshot, string s) { if (datasnapshot.exists()) { loadingindicator.setvisibility(view.gone); payment payment = datasnapshot.getvalue(payment.class); \/**uncomment this when you've finished*\/ postadapter.add(payment); \/\/here, you could use queuelistview.add() too } } @override public void onchildchanged(datasnapshot datasnapshot, string s) { } @override public void onchildremoved(datasnapshot datasnapshot) { } @override public void onchildmoved(datasnapshot datasnapshot, string s) { } @override public void oncancelled(databaseerror databaseerror) { log.e(tag, \"postcomments:oncancelled\", databaseerror.toexception()); } }; mdepositqueuereference.addchildeventlistener(mchildeventlistener); queuelistview.setonitemclicklistener(new adapterview.onitemclicklistener() { @override public void onitemclick(adapterview<?> parent, view view, int position, long id) { payment payment = paymentslist.get(position); intent intent = new intent(getactivity(), confirmdetailsactivity.class); intent.putextra(\"pushid\", payment.getpushid()); intent.putextra(\"accountname\", payment.getaccountname()); intent.putextra(\"accountnumber\", payment.getaccountnumber()); intent.putextra(\"depositamount\", payment.getdepositamount()); intent.putextra(\"depositorname\", payment.getdepositorname()); intent.putextra(\"depositorphonenumber\", payment.getdepositorphonenumber()); intent.putextra(\"depositoremail\", payment.getdepositoremail()); log.e(tag, \"phone number\" + payment.depositorphonenumber); startactivity(intent); } }); return rootview; }","classification":"NONSATD","isFinished":true,"code_context_2":"bundle savedinstancestate) { view rootview = inflater.inflate(r.layout.queue_list, container, false); \/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object","code_context_10":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { view rootview = inflater.inflate(r.layout.queue_list, container, false); \/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator); final list<payment> paymentslist = new arraylist<payment>(); postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); \/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\"));","code_context_20":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { view rootview = inflater.inflate(r.layout.queue_list, container, false); \/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator); final list<payment> paymentslist = new arraylist<payment>(); postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); \/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected mchildeventlistener = new childeventlistener() { @override public void onchildadded(datasnapshot datasnapshot, string s) { if (datasnapshot.exists()) { loadingindicator.setvisibility(view.gone); payment payment = datasnapshot.getvalue(payment.class); \/**uncomment this when you've finished*\/ postadapter.add(payment); \/\/here, you could use queuelistview.add() too }","repo":"HemlockBane\/cashier-demo"}
{"id":25701,"comment_id":1,"comment":"\/\/instance of firebase object(i.e. database root object)","code":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { view rootview = inflater.inflate(r.layout.queue_list, container, false); \/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator); final list<payment> paymentslist = new arraylist<payment>(); postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); \/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected mchildeventlistener = new childeventlistener() { @override public void onchildadded(datasnapshot datasnapshot, string s) { if (datasnapshot.exists()) { loadingindicator.setvisibility(view.gone); payment payment = datasnapshot.getvalue(payment.class); \/**uncomment this when you've finished*\/ postadapter.add(payment); \/\/here, you could use queuelistview.add() too } } @override public void onchildchanged(datasnapshot datasnapshot, string s) { } @override public void onchildremoved(datasnapshot datasnapshot) { } @override public void onchildmoved(datasnapshot datasnapshot, string s) { } @override public void oncancelled(databaseerror databaseerror) { log.e(tag, \"postcomments:oncancelled\", databaseerror.toexception()); } }; mdepositqueuereference.addchildeventlistener(mchildeventlistener); queuelistview.setonitemclicklistener(new adapterview.onitemclicklistener() { @override public void onitemclick(adapterview<?> parent, view view, int position, long id) { payment payment = paymentslist.get(position); intent intent = new intent(getactivity(), confirmdetailsactivity.class); intent.putextra(\"pushid\", payment.getpushid()); intent.putextra(\"accountname\", payment.getaccountname()); intent.putextra(\"accountnumber\", payment.getaccountnumber()); intent.putextra(\"depositamount\", payment.getdepositamount()); intent.putextra(\"depositorname\", payment.getdepositorname()); intent.putextra(\"depositorphonenumber\", payment.getdepositorphonenumber()); intent.putextra(\"depositoremail\", payment.getdepositoremail()); log.e(tag, \"phone number\" + payment.depositorphonenumber); startactivity(intent); } }); return rootview; }","classification":"NONSATD","isFinished":true,"code_context_2":"view rootview = inflater.inflate(r.layout.queue_list, container, false); \/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables","code_context_10":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { view rootview = inflater.inflate(r.layout.queue_list, container, false); \/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator); final list<payment> paymentslist = new arraylist<payment>(); postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); \/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected","code_context_20":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { view rootview = inflater.inflate(r.layout.queue_list, container, false); \/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator); final list<payment> paymentslist = new arraylist<payment>(); postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); \/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected mchildeventlistener = new childeventlistener() { @override public void onchildadded(datasnapshot datasnapshot, string s) { if (datasnapshot.exists()) { loadingindicator.setvisibility(view.gone); payment payment = datasnapshot.getvalue(payment.class); \/**uncomment this when you've finished*\/ postadapter.add(payment); \/\/here, you could use queuelistview.add() too } }","repo":"HemlockBane\/cashier-demo"}
{"id":25701,"comment_id":2,"comment":"\/\/reference to depositqueue child object in root object","code":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { view rootview = inflater.inflate(r.layout.queue_list, container, false); \/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator); final list<payment> paymentslist = new arraylist<payment>(); postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); \/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected mchildeventlistener = new childeventlistener() { @override public void onchildadded(datasnapshot datasnapshot, string s) { if (datasnapshot.exists()) { loadingindicator.setvisibility(view.gone); payment payment = datasnapshot.getvalue(payment.class); \/**uncomment this when you've finished*\/ postadapter.add(payment); \/\/here, you could use queuelistview.add() too } } @override public void onchildchanged(datasnapshot datasnapshot, string s) { } @override public void onchildremoved(datasnapshot datasnapshot) { } @override public void onchildmoved(datasnapshot datasnapshot, string s) { } @override public void oncancelled(databaseerror databaseerror) { log.e(tag, \"postcomments:oncancelled\", databaseerror.toexception()); } }; mdepositqueuereference.addchildeventlistener(mchildeventlistener); queuelistview.setonitemclicklistener(new adapterview.onitemclicklistener() { @override public void onitemclick(adapterview<?> parent, view view, int position, long id) { payment payment = paymentslist.get(position); intent intent = new intent(getactivity(), confirmdetailsactivity.class); intent.putextra(\"pushid\", payment.getpushid()); intent.putextra(\"accountname\", payment.getaccountname()); intent.putextra(\"accountnumber\", payment.getaccountnumber()); intent.putextra(\"depositamount\", payment.getdepositamount()); intent.putextra(\"depositorname\", payment.getdepositorname()); intent.putextra(\"depositorphonenumber\", payment.getdepositorphonenumber()); intent.putextra(\"depositoremail\", payment.getdepositoremail()); log.e(tag, \"phone number\" + payment.depositorphonenumber); startactivity(intent); } }); return rootview; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables queuelistview = rootview.findviewbyid(r.id.list);","code_context_10":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { view rootview = inflater.inflate(r.layout.queue_list, container, false); \/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator); final list<payment> paymentslist = new arraylist<payment>(); postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); \/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected mchildeventlistener = new childeventlistener() {","code_context_20":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { view rootview = inflater.inflate(r.layout.queue_list, container, false); \/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator); final list<payment> paymentslist = new arraylist<payment>(); postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); \/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected mchildeventlistener = new childeventlistener() { @override public void onchildadded(datasnapshot datasnapshot, string s) { if (datasnapshot.exists()) { loadingindicator.setvisibility(view.gone); payment payment = datasnapshot.getvalue(payment.class); \/**uncomment this when you've finished*\/ postadapter.add(payment); \/\/here, you could use queuelistview.add() too } } @override","repo":"HemlockBane\/cashier-demo"}
{"id":25701,"comment_id":3,"comment":"\/\/instantiate other variables","code":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { view rootview = inflater.inflate(r.layout.queue_list, container, false); \/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator); final list<payment> paymentslist = new arraylist<payment>(); postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); \/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected mchildeventlistener = new childeventlistener() { @override public void onchildadded(datasnapshot datasnapshot, string s) { if (datasnapshot.exists()) { loadingindicator.setvisibility(view.gone); payment payment = datasnapshot.getvalue(payment.class); \/**uncomment this when you've finished*\/ postadapter.add(payment); \/\/here, you could use queuelistview.add() too } } @override public void onchildchanged(datasnapshot datasnapshot, string s) { } @override public void onchildremoved(datasnapshot datasnapshot) { } @override public void onchildmoved(datasnapshot datasnapshot, string s) { } @override public void oncancelled(databaseerror databaseerror) { log.e(tag, \"postcomments:oncancelled\", databaseerror.toexception()); } }; mdepositqueuereference.addchildeventlistener(mchildeventlistener); queuelistview.setonitemclicklistener(new adapterview.onitemclicklistener() { @override public void onitemclick(adapterview<?> parent, view view, int position, long id) { payment payment = paymentslist.get(position); intent intent = new intent(getactivity(), confirmdetailsactivity.class); intent.putextra(\"pushid\", payment.getpushid()); intent.putextra(\"accountname\", payment.getaccountname()); intent.putextra(\"accountnumber\", payment.getaccountnumber()); intent.putextra(\"depositamount\", payment.getdepositamount()); intent.putextra(\"depositorname\", payment.getdepositorname()); intent.putextra(\"depositorphonenumber\", payment.getdepositorphonenumber()); intent.putextra(\"depositoremail\", payment.getdepositoremail()); log.e(tag, \"phone number\" + payment.depositorphonenumber); startactivity(intent); } }); return rootview; }","classification":"NONSATD","isFinished":true,"code_context_2":"mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator);","code_context_10":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { view rootview = inflater.inflate(r.layout.queue_list, container, false); \/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator); final list<payment> paymentslist = new arraylist<payment>(); postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); \/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected mchildeventlistener = new childeventlistener() { @override","code_context_20":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { view rootview = inflater.inflate(r.layout.queue_list, container, false); \/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator); final list<payment> paymentslist = new arraylist<payment>(); postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); \/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected mchildeventlistener = new childeventlistener() { @override public void onchildadded(datasnapshot datasnapshot, string s) { if (datasnapshot.exists()) { loadingindicator.setvisibility(view.gone); payment payment = datasnapshot.getvalue(payment.class); \/**uncomment this when you've finished*\/ postadapter.add(payment); \/\/here, you could use queuelistview.add() too } } @override public void onchildchanged(datasnapshot datasnapshot, string s) {","repo":"HemlockBane\/cashier-demo"}
{"id":25701,"comment_id":4,"comment":"\/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected","code":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { view rootview = inflater.inflate(r.layout.queue_list, container, false); \/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator); final list<payment> paymentslist = new arraylist<payment>(); postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); \/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected mchildeventlistener = new childeventlistener() { @override public void onchildadded(datasnapshot datasnapshot, string s) { if (datasnapshot.exists()) { loadingindicator.setvisibility(view.gone); payment payment = datasnapshot.getvalue(payment.class); \/**uncomment this when you've finished*\/ postadapter.add(payment); \/\/here, you could use queuelistview.add() too } } @override public void onchildchanged(datasnapshot datasnapshot, string s) { } @override public void onchildremoved(datasnapshot datasnapshot) { } @override public void onchildmoved(datasnapshot datasnapshot, string s) { } @override public void oncancelled(databaseerror databaseerror) { log.e(tag, \"postcomments:oncancelled\", databaseerror.toexception()); } }; mdepositqueuereference.addchildeventlistener(mchildeventlistener); queuelistview.setonitemclicklistener(new adapterview.onitemclicklistener() { @override public void onitemclick(adapterview<?> parent, view view, int position, long id) { payment payment = paymentslist.get(position); intent intent = new intent(getactivity(), confirmdetailsactivity.class); intent.putextra(\"pushid\", payment.getpushid()); intent.putextra(\"accountname\", payment.getaccountname()); intent.putextra(\"accountnumber\", payment.getaccountnumber()); intent.putextra(\"depositamount\", payment.getdepositamount()); intent.putextra(\"depositorname\", payment.getdepositorname()); intent.putextra(\"depositorphonenumber\", payment.getdepositorphonenumber()); intent.putextra(\"depositoremail\", payment.getdepositoremail()); log.e(tag, \"phone number\" + payment.depositorphonenumber); startactivity(intent); } }); return rootview; }","classification":"NONSATD","isFinished":true,"code_context_2":"postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); \/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected mchildeventlistener = new childeventlistener() { @override","code_context_10":"view rootview = inflater.inflate(r.layout.queue_list, container, false); \/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator); final list<payment> paymentslist = new arraylist<payment>(); postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); \/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected mchildeventlistener = new childeventlistener() { @override public void onchildadded(datasnapshot datasnapshot, string s) { if (datasnapshot.exists()) { loadingindicator.setvisibility(view.gone); payment payment = datasnapshot.getvalue(payment.class); \/**uncomment this when you've finished*\/ postadapter.add(payment); \/\/here, you could use queuelistview.add() too } }","code_context_20":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { view rootview = inflater.inflate(r.layout.queue_list, container, false); \/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator); final list<payment> paymentslist = new arraylist<payment>(); postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); \/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected mchildeventlistener = new childeventlistener() { @override public void onchildadded(datasnapshot datasnapshot, string s) { if (datasnapshot.exists()) { loadingindicator.setvisibility(view.gone); payment payment = datasnapshot.getvalue(payment.class); \/**uncomment this when you've finished*\/ postadapter.add(payment); \/\/here, you could use queuelistview.add() too } } @override public void onchildchanged(datasnapshot datasnapshot, string s) { } @override public void onchildremoved(datasnapshot datasnapshot) { } @override public void onchildmoved(datasnapshot datasnapshot, string s) { } @override","repo":"HemlockBane\/cashier-demo"}
{"id":25701,"comment_id":5,"comment":"\/**uncomment this when you've finished*\/","code":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { view rootview = inflater.inflate(r.layout.queue_list, container, false); \/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator); final list<payment> paymentslist = new arraylist<payment>(); postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); \/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected mchildeventlistener = new childeventlistener() { @override public void onchildadded(datasnapshot datasnapshot, string s) { if (datasnapshot.exists()) { loadingindicator.setvisibility(view.gone); payment payment = datasnapshot.getvalue(payment.class); \/**uncomment this when you've finished*\/ postadapter.add(payment); \/\/here, you could use queuelistview.add() too } } @override public void onchildchanged(datasnapshot datasnapshot, string s) { } @override public void onchildremoved(datasnapshot datasnapshot) { } @override public void onchildmoved(datasnapshot datasnapshot, string s) { } @override public void oncancelled(databaseerror databaseerror) { log.e(tag, \"postcomments:oncancelled\", databaseerror.toexception()); } }; mdepositqueuereference.addchildeventlistener(mchildeventlistener); queuelistview.setonitemclicklistener(new adapterview.onitemclicklistener() { @override public void onitemclick(adapterview<?> parent, view view, int position, long id) { payment payment = paymentslist.get(position); intent intent = new intent(getactivity(), confirmdetailsactivity.class); intent.putextra(\"pushid\", payment.getpushid()); intent.putextra(\"accountname\", payment.getaccountname()); intent.putextra(\"accountnumber\", payment.getaccountnumber()); intent.putextra(\"depositamount\", payment.getdepositamount()); intent.putextra(\"depositorname\", payment.getdepositorname()); intent.putextra(\"depositorphonenumber\", payment.getdepositorphonenumber()); intent.putextra(\"depositoremail\", payment.getdepositoremail()); log.e(tag, \"phone number\" + payment.depositorphonenumber); startactivity(intent); } }); return rootview; }","classification":"NONSATD","isFinished":true,"code_context_2":"loadingindicator.setvisibility(view.gone); payment payment = datasnapshot.getvalue(payment.class); \/**uncomment this when you've finished*\/ postadapter.add(payment); \/\/here, you could use queuelistview.add() too }","code_context_10":"queuelistview.setadapter(postadapter); \/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected mchildeventlistener = new childeventlistener() { @override public void onchildadded(datasnapshot datasnapshot, string s) { if (datasnapshot.exists()) { loadingindicator.setvisibility(view.gone); payment payment = datasnapshot.getvalue(payment.class); \/**uncomment this when you've finished*\/ postadapter.add(payment); \/\/here, you could use queuelistview.add() too } } @override public void onchildchanged(datasnapshot datasnapshot, string s) { } @override public void onchildremoved(datasnapshot datasnapshot) { } @override","code_context_20":"bundle savedinstancestate) { view rootview = inflater.inflate(r.layout.queue_list, container, false); \/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator); final list<payment> paymentslist = new arraylist<payment>(); postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); \/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected mchildeventlistener = new childeventlistener() { @override public void onchildadded(datasnapshot datasnapshot, string s) { if (datasnapshot.exists()) { loadingindicator.setvisibility(view.gone); payment payment = datasnapshot.getvalue(payment.class); \/**uncomment this when you've finished*\/ postadapter.add(payment); \/\/here, you could use queuelistview.add() too } } @override public void onchildchanged(datasnapshot datasnapshot, string s) { } @override public void onchildremoved(datasnapshot datasnapshot) { } @override public void onchildmoved(datasnapshot datasnapshot, string s) { } @override public void oncancelled(databaseerror databaseerror) { log.e(tag, \"postcomments:oncancelled\", databaseerror.toexception()); } }; mdepositqueuereference.addchildeventlistener(mchildeventlistener); queuelistview.setonitemclicklistener(new adapterview.onitemclicklistener() { @override","repo":"HemlockBane\/cashier-demo"}
{"id":25701,"comment_id":6,"comment":"\/\/here, you could use queuelistview.add() too","code":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { view rootview = inflater.inflate(r.layout.queue_list, container, false); \/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator); final list<payment> paymentslist = new arraylist<payment>(); postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); \/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected mchildeventlistener = new childeventlistener() { @override public void onchildadded(datasnapshot datasnapshot, string s) { if (datasnapshot.exists()) { loadingindicator.setvisibility(view.gone); payment payment = datasnapshot.getvalue(payment.class); \/**uncomment this when you've finished*\/ postadapter.add(payment); \/\/here, you could use queuelistview.add() too } } @override public void onchildchanged(datasnapshot datasnapshot, string s) { } @override public void onchildremoved(datasnapshot datasnapshot) { } @override public void onchildmoved(datasnapshot datasnapshot, string s) { } @override public void oncancelled(databaseerror databaseerror) { log.e(tag, \"postcomments:oncancelled\", databaseerror.toexception()); } }; mdepositqueuereference.addchildeventlistener(mchildeventlistener); queuelistview.setonitemclicklistener(new adapterview.onitemclicklistener() { @override public void onitemclick(adapterview<?> parent, view view, int position, long id) { payment payment = paymentslist.get(position); intent intent = new intent(getactivity(), confirmdetailsactivity.class); intent.putextra(\"pushid\", payment.getpushid()); intent.putextra(\"accountname\", payment.getaccountname()); intent.putextra(\"accountnumber\", payment.getaccountnumber()); intent.putextra(\"depositamount\", payment.getdepositamount()); intent.putextra(\"depositorname\", payment.getdepositorname()); intent.putextra(\"depositorphonenumber\", payment.getdepositorphonenumber()); intent.putextra(\"depositoremail\", payment.getdepositoremail()); log.e(tag, \"phone number\" + payment.depositorphonenumber); startactivity(intent); } }); return rootview; }","classification":"NONSATD","isFinished":true,"code_context_2":"payment payment = datasnapshot.getvalue(payment.class); \/**uncomment this when you've finished*\/ postadapter.add(payment); \/\/here, you could use queuelistview.add() too } }","code_context_10":"\/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected mchildeventlistener = new childeventlistener() { @override public void onchildadded(datasnapshot datasnapshot, string s) { if (datasnapshot.exists()) { loadingindicator.setvisibility(view.gone); payment payment = datasnapshot.getvalue(payment.class); \/**uncomment this when you've finished*\/ postadapter.add(payment); \/\/here, you could use queuelistview.add() too } } @override public void onchildchanged(datasnapshot datasnapshot, string s) { } @override public void onchildremoved(datasnapshot datasnapshot) { } @override public void onchildmoved(datasnapshot datasnapshot, string s) {","code_context_20":"view rootview = inflater.inflate(r.layout.queue_list, container, false); \/\/instantiate firebase objects mdatabase = firebasedatabase.getinstance(); \/\/instance of firebase object(i.e. database root object) mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); \/\/reference to depositqueue child object in root object \/\/instantiate other variables queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator); final list<payment> paymentslist = new arraylist<payment>(); postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); \/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected mchildeventlistener = new childeventlistener() { @override public void onchildadded(datasnapshot datasnapshot, string s) { if (datasnapshot.exists()) { loadingindicator.setvisibility(view.gone); payment payment = datasnapshot.getvalue(payment.class); \/**uncomment this when you've finished*\/ postadapter.add(payment); \/\/here, you could use queuelistview.add() too } } @override public void onchildchanged(datasnapshot datasnapshot, string s) { } @override public void onchildremoved(datasnapshot datasnapshot) { } @override public void onchildmoved(datasnapshot datasnapshot, string s) { } @override public void oncancelled(databaseerror databaseerror) { log.e(tag, \"postcomments:oncancelled\", databaseerror.toexception()); } }; mdepositqueuereference.addchildeventlistener(mchildeventlistener); queuelistview.setonitemclicklistener(new adapterview.onitemclicklistener() { @override public void onitemclick(adapterview<?> parent, view view, int position, long id) {","repo":"HemlockBane\/cashier-demo"}
{"id":25731,"comment_id":0,"comment":"\/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*\/ \/** emit code for the symbol constant class, optionally including non terms, * if they have been requested. * @param out stream to produce output on. * @param emit_non_terms do we emit constants for non terminals? * @param sym_interface should we emit an interface, rather than a class? *\/","code":"\/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*\/ \/** emit code for the symbol constant class, optionally including non terms, * if they have been requested. * @param out stream to produce output on. * @param emit_non_terms do we emit constants for non terminals? * @param sym_interface should we emit an interface, rather than a class? *\/ public static void symbols(printwriter out, boolean emit_non_terms, boolean sym_interface) { terminal term; non_terminal nt; string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); \/* top of file *\/ out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/ out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); } } \/* end of class *\/ out.println(\"}\"); out.println(); symbols_time = system.currenttimemillis() - start_time; }","classification":"NONSATD","isFinished":true,"code_context_2":"public static void symbols(printwriter out, boolean emit_non_terms, boolean sym_interface) { terminal term; non_terminal nt; string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); \/* top of file *\/ out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/ out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); } } \/* end of class *\/ out.println(\"}\"); out.println(); symbols_time = system.currenttimemillis() - start_time; }","code_context_10":"public static void symbols(printwriter out, boolean emit_non_terms, boolean sym_interface) { terminal term; non_terminal nt; string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); \/* top of file *\/ out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/ out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); } } \/* end of class *\/ out.println(\"}\"); out.println(); symbols_time = system.currenttimemillis() - start_time; }","code_context_20":"public static void symbols(printwriter out, boolean emit_non_terms, boolean sym_interface) { terminal term; non_terminal nt; string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); \/* top of file *\/ out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/ out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); } } \/* end of class *\/ out.println(\"}\"); out.println(); symbols_time = system.currenttimemillis() - start_time; }","repo":"AsaiKen\/phpscan"}
{"id":25731,"comment_id":1,"comment":"\/* top of file *\/","code":"public static void symbols(printwriter out, boolean emit_non_terms, boolean sym_interface) { terminal term; non_terminal nt; string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); \/* top of file *\/ out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/ out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); } } \/* end of class *\/ out.println(\"}\"); out.println(); symbols_time = system.currenttimemillis() - start_time; }","classification":"NONSATD","isFinished":true,"code_context_2":"string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); \/* top of file *\/ out.println(); out.println(\"\/\/----------------------------------------------------\");","code_context_10":"public static void symbols(printwriter out, boolean emit_non_terms, boolean sym_interface) { terminal term; non_terminal nt; string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); \/* top of file *\/ out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" +","code_context_20":"public static void symbols(printwriter out, boolean emit_non_terms, boolean sym_interface) { terminal term; non_terminal nt; string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); \/* top of file *\/ out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); }","repo":"AsaiKen\/phpscan"}
{"id":25731,"comment_id":2,"comment":"\/* class header *\/","code":"public static void symbols(printwriter out, boolean emit_non_terms, boolean sym_interface) { terminal term; non_terminal nt; string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); \/* top of file *\/ out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/ out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); } } \/* end of class *\/ out.println(\"}\"); out.println(); symbols_time = system.currenttimemillis() - start_time; }","classification":"NONSATD","isFinished":true,"code_context_2":"out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\");","code_context_10":"non_terminal nt; string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); \/* top of file *\/ out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/","code_context_20":"public static void symbols(printwriter out, boolean emit_non_terms, boolean sym_interface) { terminal term; non_terminal nt; string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); \/* top of file *\/ out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) {","repo":"AsaiKen\/phpscan"}
{"id":25731,"comment_id":3,"comment":"\/* walk over the terminals *\/ \/* later might sort these *\/","code":"\/* walk over the terminals *\/ \/* later might sort these *\/ public static void symbols(printwriter out, boolean emit_non_terms, boolean sym_interface) { terminal term; non_terminal nt; string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); \/* top of file *\/ out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/ out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); } } \/* end of class *\/ out.println(\"}\"); out.println(); symbols_time = system.currenttimemillis() - start_time; }","classification":"NONSATD","isFinished":true,"code_context_2":"symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) {","code_context_10":"out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) {","code_context_20":"public static void symbols(printwriter out, boolean emit_non_terms, boolean sym_interface) { terminal term; non_terminal nt; string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); \/* top of file *\/ out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/","repo":"AsaiKen\/phpscan"}
{"id":25731,"comment_id":4,"comment":"\/* output a constant decl for the terminal *\/","code":"public static void symbols(printwriter out, boolean emit_non_terms, boolean sym_interface) { terminal term; non_terminal nt; string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); \/* top of file *\/ out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/ out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); } } \/* end of class *\/ out.println(\"}\"); out.println(); symbols_time = system.currenttimemillis() - start_time; }","classification":"NONSATD","isFinished":true,"code_context_2":"{ term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\");","code_context_10":"\/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) {","code_context_20":"non_terminal nt; string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); \/* top of file *\/ out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\");","repo":"AsaiKen\/phpscan"}
{"id":25731,"comment_id":5,"comment":"\/* emit names of terminals *\/","code":"public static void symbols(printwriter out, boolean emit_non_terms, boolean sym_interface) { terminal term; non_terminal nt; string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); \/* top of file *\/ out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/ out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); } } \/* end of class *\/ out.println(\"}\"); out.println(); symbols_time = system.currenttimemillis() - start_time; }","classification":"NONSATD","isFinished":true,"code_context_2":"term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) {","code_context_10":"symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); }","code_context_20":"out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement();","repo":"AsaiKen\/phpscan"}
{"id":25731,"comment_id":6,"comment":"\/* do the non terminals if they want them (parser doesn't need them) *\/","code":"public static void symbols(printwriter out, boolean emit_non_terms, boolean sym_interface) { terminal term; non_terminal nt; string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); \/* top of file *\/ out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/ out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); } } \/* end of class *\/ out.println(\"}\"); out.println(); symbols_time = system.currenttimemillis() - start_time; }","classification":"NONSATD","isFinished":true,"code_context_2":"} out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) {","code_context_10":"for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration","code_context_20":"\/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/ out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); } } \/* end of class *\/ out.println(\"}\"); out.println(); symbols_time = system.currenttimemillis() - start_time;","repo":"AsaiKen\/phpscan"}
{"id":25731,"comment_id":7,"comment":"\/* walk over the non terminals *\/ \/* later might sort these *\/","code":"\/* walk over the non terminals *\/ \/* later might sort these *\/ public static void symbols(printwriter out, boolean emit_non_terms, boolean sym_interface) { terminal term; non_terminal nt; string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); \/* top of file *\/ out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/ out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); } } \/* end of class *\/ out.println(\"}\"); out.println(); symbols_time = system.currenttimemillis() - start_time; }","classification":"NONSATD","isFinished":true,"code_context_2":"out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) {","code_context_10":"out.print(\",\"); } out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/ out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); }","code_context_20":"out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/ out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); } } \/* end of class *\/ out.println(\"}\"); out.println(); symbols_time = system.currenttimemillis() - start_time; }","repo":"AsaiKen\/phpscan"}
{"id":25731,"comment_id":8,"comment":"\/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/","code":"public static void symbols(printwriter out, boolean emit_non_terms, boolean sym_interface) { terminal term; non_terminal nt; string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); \/* top of file *\/ out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/ out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); } } \/* end of class *\/ out.println(\"}\"); out.println(); symbols_time = system.currenttimemillis() - start_time; }","classification":"NONSATD","isFinished":true,"code_context_2":"{ nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/ out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\");","code_context_10":"out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/ out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); } } \/* end of class *\/ out.println(\"}\"); out.println(); symbols_time = system.currenttimemillis() - start_time; }","code_context_20":"out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/ out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); } } \/* end of class *\/ out.println(\"}\"); out.println(); symbols_time = system.currenttimemillis() - start_time; }","repo":"AsaiKen\/phpscan"}
{"id":25731,"comment_id":9,"comment":"\/* end of class *\/","code":"public static void symbols(printwriter out, boolean emit_non_terms, boolean sym_interface) { terminal term; non_terminal nt; string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); \/* top of file *\/ out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); \/* class header *\/ out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); \/* walk over the terminals *\/\/* later might sort these *\/ for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); \/* output a constant decl for the terminal *\/ out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } \/* emit names of terminals *\/ out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/ out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); } } \/* end of class *\/ out.println(\"}\"); out.println(); symbols_time = system.currenttimemillis() - start_time; }","classification":"NONSATD","isFinished":true,"code_context_2":"} } \/* end of class *\/ out.println(\"}\"); out.println();","code_context_10":"{ nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/ out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); } } \/* end of class *\/ out.println(\"}\"); out.println(); symbols_time = system.currenttimemillis() - start_time; }","code_context_20":"out.println(); } out.println(\" };\"); \/* do the non terminals if they want them (parser doesn't need them) *\/ if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); \/* walk over the non terminals *\/\/* later might sort these *\/ for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); \/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/ out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); } } \/* end of class *\/ out.println(\"}\"); out.println(); symbols_time = system.currenttimemillis() - start_time; }","repo":"AsaiKen\/phpscan"}
{"id":9378,"comment_id":0,"comment":"\/** * invokes {@link sourcetransferhandler#transferdata(pushsourcestream)} on * {@link #transferhandler} for each of <tt>pkts<\/tt> in order to * consecutively push them out of\/make them available outside this * <tt>pushsourcestream<\/tt>. * * @param pkts the set of <tt>rawpacket<\/tt>s to push out of this * <tt>pushsourcestream<\/tt> *\/","code":"\/** * invokes {@link sourcetransferhandler#transferdata(pushsourcestream)} on * {@link #transferhandler} for each of <tt>pkts<\/tt> in order to * consecutively push them out of\/make them available outside this * <tt>pushsourcestream<\/tt>. * * @param pkts the set of <tt>rawpacket<\/tt>s to push out of this * <tt>pushsourcestream<\/tt> *\/ private void transferdata(rawpacket[] pkts) { for (int i = 0; i < pkts.length; i++) { rawpacket pkt = pkts[i]; pkts[i] = null; if (pkt != null) { if (pkt.isinvalid()) { \/* * return pkt to the pool because it is invalid and, * consequently, will not be made available to reading. *\/ poolrawpacket(pkt); } else { rawpacket oldpkt; synchronized (pktsyncroot) { oldpkt = this.pkt; this.pkt = pkt; } if (oldpkt != null) { \/* * return oldpkt to the pool because it was made * available to reading and it was not read. *\/ poolrawpacket(oldpkt); } if (transferhandler != null && !closed) { try { transferhandler.transferdata(this); } catch (throwable t) { \/\/ xxx we cannot allow transferhandler to kill us. if (t instanceof interruptedexception) { thread.currentthread().interrupt(); } else if (t instanceof threaddeath) { throw (threaddeath) t; } else { logger.warn( \"an rtp packet may have not been fully\" + \" handled.\", t); } } } } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"private void transferdata(rawpacket[] pkts) { for (int i = 0; i < pkts.length; i++) { rawpacket pkt = pkts[i]; pkts[i] = null; if (pkt != null) { if (pkt.isinvalid()) { \/* * return pkt to the pool because it is invalid and, * consequently, will not be made available to reading. *\/ poolrawpacket(pkt); } else { rawpacket oldpkt; synchronized (pktsyncroot) { oldpkt = this.pkt; this.pkt = pkt; } if (oldpkt != null) { \/* * return oldpkt to the pool because it was made * available to reading and it was not read. *\/ poolrawpacket(oldpkt); } if (transferhandler != null && !closed) { try { transferhandler.transferdata(this); } catch (throwable t) { \/\/ xxx we cannot allow transferhandler to kill us. if (t instanceof interruptedexception) { thread.currentthread().interrupt(); } else if (t instanceof threaddeath) { throw (threaddeath) t; } else { logger.warn( \"an rtp packet may have not been fully\" + \" handled.\", t); } } } } } } }","code_context_10":"private void transferdata(rawpacket[] pkts) { for (int i = 0; i < pkts.length; i++) { rawpacket pkt = pkts[i]; pkts[i] = null; if (pkt != null) { if (pkt.isinvalid()) { \/* * return pkt to the pool because it is invalid and, * consequently, will not be made available to reading. *\/ poolrawpacket(pkt); } else { rawpacket oldpkt; synchronized (pktsyncroot) { oldpkt = this.pkt; this.pkt = pkt; } if (oldpkt != null) { \/* * return oldpkt to the pool because it was made * available to reading and it was not read. *\/ poolrawpacket(oldpkt); } if (transferhandler != null && !closed) { try { transferhandler.transferdata(this); } catch (throwable t) { \/\/ xxx we cannot allow transferhandler to kill us. if (t instanceof interruptedexception) { thread.currentthread().interrupt(); } else if (t instanceof threaddeath) { throw (threaddeath) t; } else { logger.warn( \"an rtp packet may have not been fully\" + \" handled.\", t); } } } } } } }","code_context_20":"private void transferdata(rawpacket[] pkts) { for (int i = 0; i < pkts.length; i++) { rawpacket pkt = pkts[i]; pkts[i] = null; if (pkt != null) { if (pkt.isinvalid()) { \/* * return pkt to the pool because it is invalid and, * consequently, will not be made available to reading. *\/ poolrawpacket(pkt); } else { rawpacket oldpkt; synchronized (pktsyncroot) { oldpkt = this.pkt; this.pkt = pkt; } if (oldpkt != null) { \/* * return oldpkt to the pool because it was made * available to reading and it was not read. *\/ poolrawpacket(oldpkt); } if (transferhandler != null && !closed) { try { transferhandler.transferdata(this); } catch (throwable t) { \/\/ xxx we cannot allow transferhandler to kill us. if (t instanceof interruptedexception) { thread.currentthread().interrupt(); } else if (t instanceof threaddeath) { throw (threaddeath) t; } else { logger.warn( \"an rtp packet may have not been fully\" + \" handled.\", t); } } } } } } }","repo":"GNUDimarik\/libjitsi"}
{"id":9378,"comment_id":1,"comment":"\/* * return pkt to the pool because it is invalid and, * consequently, will not be made available to reading. *\/","code":"private void transferdata(rawpacket[] pkts) { for (int i = 0; i < pkts.length; i++) { rawpacket pkt = pkts[i]; pkts[i] = null; if (pkt != null) { if (pkt.isinvalid()) { \/* * return pkt to the pool because it is invalid and, * consequently, will not be made available to reading. *\/ poolrawpacket(pkt); } else { rawpacket oldpkt; synchronized (pktsyncroot) { oldpkt = this.pkt; this.pkt = pkt; } if (oldpkt != null) { \/* * return oldpkt to the pool because it was made * available to reading and it was not read. *\/ poolrawpacket(oldpkt); } if (transferhandler != null && !closed) { try { transferhandler.transferdata(this); } catch (throwable t) { \/\/ xxx we cannot allow transferhandler to kill us. if (t instanceof interruptedexception) { thread.currentthread().interrupt(); } else if (t instanceof threaddeath) { throw (threaddeath) t; } else { logger.warn( \"an rtp packet may have not been fully\" + \" handled.\", t); } } } } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"if (pkt.isinvalid()) { \/* * return pkt to the pool because it is invalid and, * consequently, will not be made available to reading. *\/ poolrawpacket(pkt); }","code_context_10":"private void transferdata(rawpacket[] pkts) { for (int i = 0; i < pkts.length; i++) { rawpacket pkt = pkts[i]; pkts[i] = null; if (pkt != null) { if (pkt.isinvalid()) { \/* * return pkt to the pool because it is invalid and, * consequently, will not be made available to reading. *\/ poolrawpacket(pkt); } else { rawpacket oldpkt; synchronized (pktsyncroot) { oldpkt = this.pkt; this.pkt = pkt; }","code_context_20":"private void transferdata(rawpacket[] pkts) { for (int i = 0; i < pkts.length; i++) { rawpacket pkt = pkts[i]; pkts[i] = null; if (pkt != null) { if (pkt.isinvalid()) { \/* * return pkt to the pool because it is invalid and, * consequently, will not be made available to reading. *\/ poolrawpacket(pkt); } else { rawpacket oldpkt; synchronized (pktsyncroot) { oldpkt = this.pkt; this.pkt = pkt; } if (oldpkt != null) { \/* * return oldpkt to the pool because it was made * available to reading and it was not read. *\/ poolrawpacket(oldpkt); } if (transferhandler != null && !closed) {","repo":"GNUDimarik\/libjitsi"}
{"id":9378,"comment_id":2,"comment":"\/* * return oldpkt to the pool because it was made * available to reading and it was not read. *\/","code":"private void transferdata(rawpacket[] pkts) { for (int i = 0; i < pkts.length; i++) { rawpacket pkt = pkts[i]; pkts[i] = null; if (pkt != null) { if (pkt.isinvalid()) { \/* * return pkt to the pool because it is invalid and, * consequently, will not be made available to reading. *\/ poolrawpacket(pkt); } else { rawpacket oldpkt; synchronized (pktsyncroot) { oldpkt = this.pkt; this.pkt = pkt; } if (oldpkt != null) { \/* * return oldpkt to the pool because it was made * available to reading and it was not read. *\/ poolrawpacket(oldpkt); } if (transferhandler != null && !closed) { try { transferhandler.transferdata(this); } catch (throwable t) { \/\/ xxx we cannot allow transferhandler to kill us. if (t instanceof interruptedexception) { thread.currentthread().interrupt(); } else if (t instanceof threaddeath) { throw (threaddeath) t; } else { logger.warn( \"an rtp packet may have not been fully\" + \" handled.\", t); } } } } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"if (pkt.isinvalid()) { \/* * return pkt to the pool because it is invalid and, * consequently, will not be made available to reading. *\/ poolrawpacket(pkt); }","code_context_10":"private void transferdata(rawpacket[] pkts) { for (int i = 0; i < pkts.length; i++) { rawpacket pkt = pkts[i]; pkts[i] = null; if (pkt != null) { if (pkt.isinvalid()) { \/* * return pkt to the pool because it is invalid and, * consequently, will not be made available to reading. *\/ poolrawpacket(pkt); } else { rawpacket oldpkt; synchronized (pktsyncroot) { oldpkt = this.pkt; this.pkt = pkt; }","code_context_20":"private void transferdata(rawpacket[] pkts) { for (int i = 0; i < pkts.length; i++) { rawpacket pkt = pkts[i]; pkts[i] = null; if (pkt != null) { if (pkt.isinvalid()) { \/* * return pkt to the pool because it is invalid and, * consequently, will not be made available to reading. *\/ poolrawpacket(pkt); } else { rawpacket oldpkt; synchronized (pktsyncroot) { oldpkt = this.pkt; this.pkt = pkt; } if (oldpkt != null) { \/* * return oldpkt to the pool because it was made * available to reading and it was not read. *\/ poolrawpacket(oldpkt); } if (transferhandler != null && !closed) {","repo":"GNUDimarik\/libjitsi"}
{"id":9378,"comment_id":3,"comment":"\/\/ xxx we cannot allow transferhandler to kill us.","code":"private void transferdata(rawpacket[] pkts) { for (int i = 0; i < pkts.length; i++) { rawpacket pkt = pkts[i]; pkts[i] = null; if (pkt != null) { if (pkt.isinvalid()) { \/* * return pkt to the pool because it is invalid and, * consequently, will not be made available to reading. *\/ poolrawpacket(pkt); } else { rawpacket oldpkt; synchronized (pktsyncroot) { oldpkt = this.pkt; this.pkt = pkt; } if (oldpkt != null) { \/* * return oldpkt to the pool because it was made * available to reading and it was not read. *\/ poolrawpacket(oldpkt); } if (transferhandler != null && !closed) { try { transferhandler.transferdata(this); } catch (throwable t) { \/\/ xxx we cannot allow transferhandler to kill us. if (t instanceof interruptedexception) { thread.currentthread().interrupt(); } else if (t instanceof threaddeath) { throw (threaddeath) t; } else { logger.warn( \"an rtp packet may have not been fully\" + \" handled.\", t); } } } } } } }","classification":"DESIGN","isFinished":true,"code_context_2":"catch (throwable t) { \/\/ xxx we cannot allow transferhandler to kill us. if (t instanceof interruptedexception) {","code_context_10":"poolrawpacket(oldpkt); } if (transferhandler != null && !closed) { try { transferhandler.transferdata(this); } catch (throwable t) { \/\/ xxx we cannot allow transferhandler to kill us. if (t instanceof interruptedexception) { thread.currentthread().interrupt(); } else if (t instanceof threaddeath) { throw (threaddeath) t; } else {","code_context_20":"{ oldpkt = this.pkt; this.pkt = pkt; } if (oldpkt != null) { \/* * return oldpkt to the pool because it was made * available to reading and it was not read. *\/ poolrawpacket(oldpkt); } if (transferhandler != null && !closed) { try { transferhandler.transferdata(this); } catch (throwable t) { \/\/ xxx we cannot allow transferhandler to kill us. if (t instanceof interruptedexception) { thread.currentthread().interrupt(); } else if (t instanceof threaddeath) { throw (threaddeath) t; } else { logger.warn( \"an rtp packet may have not been fully\" + \" handled.\", t); } } } } } }","repo":"GNUDimarik\/libjitsi"}
{"id":34098,"comment_id":0,"comment":"\/\/ todo: write your code here","code":"\/\/ todo: write your code here @override public void runopmode() { telemetry.adddata(\"status\", \"initialized\"); telemetry.update(); left_mtr = hardwaremap.dcmotor.get(\"left_mtr\"); right_mtr = hardwaremap.dcmotor.get(\"right_mtr\"); front_left_mtr = hardwaremap.dcmotor.get(\"front_left_mtr\"); front_right_mtr = hardwaremap.dcmotor.get(\"front_right_mtr\"); shooter = hardwaremap.dcmotor.get(\"shooter\"); conveyor = hardwaremap.dcmotor.get(\"conveyor\"); clow_moter = hardwaremap.dcmotor.get(\"clow moter\"); claw = hardwaremap.servo.get(\"claw\"); touchfront = hardwaremap.touchsensor.get(\"touchfront\"); touch2 = hardwaremap.touchsensor.get(\"touch2\"); \/\/ values is a reference to the hsvvalues array. float[] hsvvalues = new float[3]; final float values[] = hsvvalues; \/\/ bprevstate and bcurrstate keep track of the previous and current state of the button boolean bprevstate = false; boolean bcurrstate = false; string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); right_mtr.setmode(dcmotor.runmode.run_without_encoder); left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); \/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/ if (tfod != null) { tfod.activate(); \/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78); } \/** wait for the game to begin *\/ telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450); goforward(.5); haltsequence(150); turnleft(.5); haltsequence(450); goforward(0.4); sleep(450); halt(); sleep(1000); telemetry.adddata(\"status\", \"started\"); telemetry.update(); if (tfod != null) { \/\/ getupdatedrecognitions() will return null if no new information is available since \/\/ the last time that call was made. list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) { telemetry.adddata(\"# object detected\", updatedrecognitions.size()); if (updatedrecognitions.size() == 0) { mode = \"a\"; } \/\/ step through the list of recognitions and display boundary info. int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel()); if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } \/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\"); telemetry.update(); sleep(2000); } } } \/\/ go somewhere based on mode if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb(); } else if (mode == \"c\") { domodec(); } else { \/\/ not sure what to do here } if (tfod != null) { tfod.shutdown(); } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"@override public void runopmode() { telemetry.adddata(\"status\", \"initialized\"); telemetry.update(); left_mtr = hardwaremap.dcmotor.get(\"left_mtr\"); right_mtr = hardwaremap.dcmotor.get(\"right_mtr\"); front_left_mtr = hardwaremap.dcmotor.get(\"front_left_mtr\"); front_right_mtr = hardwaremap.dcmotor.get(\"front_right_mtr\"); shooter = hardwaremap.dcmotor.get(\"shooter\"); conveyor = hardwaremap.dcmotor.get(\"conveyor\"); clow_moter = hardwaremap.dcmotor.get(\"clow moter\"); claw = hardwaremap.servo.get(\"claw\"); touchfront = hardwaremap.touchsensor.get(\"touchfront\"); touch2 = hardwaremap.touchsensor.get(\"touch2\"); \/\/ values is a reference to the hsvvalues array. float[] hsvvalues = new float[3]; final float values[] = hsvvalues; \/\/ bprevstate and bcurrstate keep track of the previous and current state of the button boolean bprevstate = false; boolean bcurrstate = false; string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); right_mtr.setmode(dcmotor.runmode.run_without_encoder); left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); \/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/ if (tfod != null) { tfod.activate(); \/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78); } \/** wait for the game to begin *\/ telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450); goforward(.5); haltsequence(150); turnleft(.5); haltsequence(450); goforward(0.4); sleep(450); halt(); sleep(1000); telemetry.adddata(\"status\", \"started\"); telemetry.update(); if (tfod != null) { \/\/ getupdatedrecognitions() will return null if no new information is available since \/\/ the last time that call was made. list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) { telemetry.adddata(\"# object detected\", updatedrecognitions.size()); if (updatedrecognitions.size() == 0) { mode = \"a\"; } \/\/ step through the list of recognitions and display boundary info. int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel()); if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } \/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\"); telemetry.update(); sleep(2000); } } } \/\/ go somewhere based on mode if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb(); } else if (mode == \"c\") { domodec(); } else { \/\/ not sure what to do here } if (tfod != null) { tfod.shutdown(); } }","code_context_10":"@override public void runopmode() { telemetry.adddata(\"status\", \"initialized\"); telemetry.update(); left_mtr = hardwaremap.dcmotor.get(\"left_mtr\"); right_mtr = hardwaremap.dcmotor.get(\"right_mtr\"); front_left_mtr = hardwaremap.dcmotor.get(\"front_left_mtr\"); front_right_mtr = hardwaremap.dcmotor.get(\"front_right_mtr\"); shooter = hardwaremap.dcmotor.get(\"shooter\"); conveyor = hardwaremap.dcmotor.get(\"conveyor\"); clow_moter = hardwaremap.dcmotor.get(\"clow moter\"); claw = hardwaremap.servo.get(\"claw\"); touchfront = hardwaremap.touchsensor.get(\"touchfront\"); touch2 = hardwaremap.touchsensor.get(\"touch2\"); \/\/ values is a reference to the hsvvalues array. float[] hsvvalues = new float[3]; final float values[] = hsvvalues; \/\/ bprevstate and bcurrstate keep track of the previous and current state of the button boolean bprevstate = false; boolean bcurrstate = false; string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); right_mtr.setmode(dcmotor.runmode.run_without_encoder); left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); \/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/ if (tfod != null) { tfod.activate(); \/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78); } \/** wait for the game to begin *\/ telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450); goforward(.5); haltsequence(150); turnleft(.5); haltsequence(450); goforward(0.4); sleep(450); halt(); sleep(1000); telemetry.adddata(\"status\", \"started\"); telemetry.update(); if (tfod != null) { \/\/ getupdatedrecognitions() will return null if no new information is available since \/\/ the last time that call was made. list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) { telemetry.adddata(\"# object detected\", updatedrecognitions.size()); if (updatedrecognitions.size() == 0) { mode = \"a\"; } \/\/ step through the list of recognitions and display boundary info. int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel()); if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } \/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\"); telemetry.update(); sleep(2000); } } } \/\/ go somewhere based on mode if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb(); } else if (mode == \"c\") { domodec(); } else { \/\/ not sure what to do here } if (tfod != null) { tfod.shutdown(); } }","code_context_20":"@override public void runopmode() { telemetry.adddata(\"status\", \"initialized\"); telemetry.update(); left_mtr = hardwaremap.dcmotor.get(\"left_mtr\"); right_mtr = hardwaremap.dcmotor.get(\"right_mtr\"); front_left_mtr = hardwaremap.dcmotor.get(\"front_left_mtr\"); front_right_mtr = hardwaremap.dcmotor.get(\"front_right_mtr\"); shooter = hardwaremap.dcmotor.get(\"shooter\"); conveyor = hardwaremap.dcmotor.get(\"conveyor\"); clow_moter = hardwaremap.dcmotor.get(\"clow moter\"); claw = hardwaremap.servo.get(\"claw\"); touchfront = hardwaremap.touchsensor.get(\"touchfront\"); touch2 = hardwaremap.touchsensor.get(\"touch2\"); \/\/ values is a reference to the hsvvalues array. float[] hsvvalues = new float[3]; final float values[] = hsvvalues; \/\/ bprevstate and bcurrstate keep track of the previous and current state of the button boolean bprevstate = false; boolean bcurrstate = false; string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); right_mtr.setmode(dcmotor.runmode.run_without_encoder); left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); \/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/ if (tfod != null) { tfod.activate(); \/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78); } \/** wait for the game to begin *\/ telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450); goforward(.5); haltsequence(150); turnleft(.5); haltsequence(450); goforward(0.4); sleep(450); halt(); sleep(1000); telemetry.adddata(\"status\", \"started\"); telemetry.update(); if (tfod != null) { \/\/ getupdatedrecognitions() will return null if no new information is available since \/\/ the last time that call was made. list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) { telemetry.adddata(\"# object detected\", updatedrecognitions.size()); if (updatedrecognitions.size() == 0) { mode = \"a\"; } \/\/ step through the list of recognitions and display boundary info. int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel()); if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } \/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\"); telemetry.update(); sleep(2000); } } } \/\/ go somewhere based on mode if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb(); } else if (mode == \"c\") { domodec(); } else { \/\/ not sure what to do here } if (tfod != null) { tfod.shutdown(); } }","repo":"FTC16694\/FtcRobotController"}
{"id":34098,"comment_id":1,"comment":"\/\/ values is a reference to the hsvvalues array.","code":"@override public void runopmode() { telemetry.adddata(\"status\", \"initialized\"); telemetry.update(); left_mtr = hardwaremap.dcmotor.get(\"left_mtr\"); right_mtr = hardwaremap.dcmotor.get(\"right_mtr\"); front_left_mtr = hardwaremap.dcmotor.get(\"front_left_mtr\"); front_right_mtr = hardwaremap.dcmotor.get(\"front_right_mtr\"); shooter = hardwaremap.dcmotor.get(\"shooter\"); conveyor = hardwaremap.dcmotor.get(\"conveyor\"); clow_moter = hardwaremap.dcmotor.get(\"clow moter\"); claw = hardwaremap.servo.get(\"claw\"); touchfront = hardwaremap.touchsensor.get(\"touchfront\"); touch2 = hardwaremap.touchsensor.get(\"touch2\"); \/\/ values is a reference to the hsvvalues array. float[] hsvvalues = new float[3]; final float values[] = hsvvalues; \/\/ bprevstate and bcurrstate keep track of the previous and current state of the button boolean bprevstate = false; boolean bcurrstate = false; string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); right_mtr.setmode(dcmotor.runmode.run_without_encoder); left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); \/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/ if (tfod != null) { tfod.activate(); \/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78); } \/** wait for the game to begin *\/ telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450); goforward(.5); haltsequence(150); turnleft(.5); haltsequence(450); goforward(0.4); sleep(450); halt(); sleep(1000); telemetry.adddata(\"status\", \"started\"); telemetry.update(); if (tfod != null) { \/\/ getupdatedrecognitions() will return null if no new information is available since \/\/ the last time that call was made. list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) { telemetry.adddata(\"# object detected\", updatedrecognitions.size()); if (updatedrecognitions.size() == 0) { mode = \"a\"; } \/\/ step through the list of recognitions and display boundary info. int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel()); if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } \/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\"); telemetry.update(); sleep(2000); } } } \/\/ go somewhere based on mode if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb(); } else if (mode == \"c\") { domodec(); } else { \/\/ not sure what to do here } if (tfod != null) { tfod.shutdown(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"touchfront = hardwaremap.touchsensor.get(\"touchfront\"); touch2 = hardwaremap.touchsensor.get(\"touch2\"); \/\/ values is a reference to the hsvvalues array. float[] hsvvalues = new float[3]; final float values[] = hsvvalues;","code_context_10":"left_mtr = hardwaremap.dcmotor.get(\"left_mtr\"); right_mtr = hardwaremap.dcmotor.get(\"right_mtr\"); front_left_mtr = hardwaremap.dcmotor.get(\"front_left_mtr\"); front_right_mtr = hardwaremap.dcmotor.get(\"front_right_mtr\"); shooter = hardwaremap.dcmotor.get(\"shooter\"); conveyor = hardwaremap.dcmotor.get(\"conveyor\"); clow_moter = hardwaremap.dcmotor.get(\"clow moter\"); claw = hardwaremap.servo.get(\"claw\"); touchfront = hardwaremap.touchsensor.get(\"touchfront\"); touch2 = hardwaremap.touchsensor.get(\"touch2\"); \/\/ values is a reference to the hsvvalues array. float[] hsvvalues = new float[3]; final float values[] = hsvvalues; \/\/ bprevstate and bcurrstate keep track of the previous and current state of the button boolean bprevstate = false; boolean bcurrstate = false; string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake);","code_context_20":"@override public void runopmode() { telemetry.adddata(\"status\", \"initialized\"); telemetry.update(); left_mtr = hardwaremap.dcmotor.get(\"left_mtr\"); right_mtr = hardwaremap.dcmotor.get(\"right_mtr\"); front_left_mtr = hardwaremap.dcmotor.get(\"front_left_mtr\"); front_right_mtr = hardwaremap.dcmotor.get(\"front_right_mtr\"); shooter = hardwaremap.dcmotor.get(\"shooter\"); conveyor = hardwaremap.dcmotor.get(\"conveyor\"); clow_moter = hardwaremap.dcmotor.get(\"clow moter\"); claw = hardwaremap.servo.get(\"claw\"); touchfront = hardwaremap.touchsensor.get(\"touchfront\"); touch2 = hardwaremap.touchsensor.get(\"touch2\"); \/\/ values is a reference to the hsvvalues array. float[] hsvvalues = new float[3]; final float values[] = hsvvalues; \/\/ bprevstate and bcurrstate keep track of the previous and current state of the button boolean bprevstate = false; boolean bcurrstate = false; string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); right_mtr.setmode(dcmotor.runmode.run_without_encoder); left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); \/**","repo":"FTC16694\/FtcRobotController"}
{"id":34098,"comment_id":2,"comment":"\/\/ bprevstate and bcurrstate keep track of the previous and current state of the button","code":"@override public void runopmode() { telemetry.adddata(\"status\", \"initialized\"); telemetry.update(); left_mtr = hardwaremap.dcmotor.get(\"left_mtr\"); right_mtr = hardwaremap.dcmotor.get(\"right_mtr\"); front_left_mtr = hardwaremap.dcmotor.get(\"front_left_mtr\"); front_right_mtr = hardwaremap.dcmotor.get(\"front_right_mtr\"); shooter = hardwaremap.dcmotor.get(\"shooter\"); conveyor = hardwaremap.dcmotor.get(\"conveyor\"); clow_moter = hardwaremap.dcmotor.get(\"clow moter\"); claw = hardwaremap.servo.get(\"claw\"); touchfront = hardwaremap.touchsensor.get(\"touchfront\"); touch2 = hardwaremap.touchsensor.get(\"touch2\"); \/\/ values is a reference to the hsvvalues array. float[] hsvvalues = new float[3]; final float values[] = hsvvalues; \/\/ bprevstate and bcurrstate keep track of the previous and current state of the button boolean bprevstate = false; boolean bcurrstate = false; string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); right_mtr.setmode(dcmotor.runmode.run_without_encoder); left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); \/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/ if (tfod != null) { tfod.activate(); \/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78); } \/** wait for the game to begin *\/ telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450); goforward(.5); haltsequence(150); turnleft(.5); haltsequence(450); goforward(0.4); sleep(450); halt(); sleep(1000); telemetry.adddata(\"status\", \"started\"); telemetry.update(); if (tfod != null) { \/\/ getupdatedrecognitions() will return null if no new information is available since \/\/ the last time that call was made. list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) { telemetry.adddata(\"# object detected\", updatedrecognitions.size()); if (updatedrecognitions.size() == 0) { mode = \"a\"; } \/\/ step through the list of recognitions and display boundary info. int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel()); if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } \/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\"); telemetry.update(); sleep(2000); } } } \/\/ go somewhere based on mode if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb(); } else if (mode == \"c\") { domodec(); } else { \/\/ not sure what to do here } if (tfod != null) { tfod.shutdown(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"float[] hsvvalues = new float[3]; final float values[] = hsvvalues; \/\/ bprevstate and bcurrstate keep track of the previous and current state of the button boolean bprevstate = false; boolean bcurrstate = false;","code_context_10":"front_right_mtr = hardwaremap.dcmotor.get(\"front_right_mtr\"); shooter = hardwaremap.dcmotor.get(\"shooter\"); conveyor = hardwaremap.dcmotor.get(\"conveyor\"); clow_moter = hardwaremap.dcmotor.get(\"clow moter\"); claw = hardwaremap.servo.get(\"claw\"); touchfront = hardwaremap.touchsensor.get(\"touchfront\"); touch2 = hardwaremap.touchsensor.get(\"touch2\"); \/\/ values is a reference to the hsvvalues array. float[] hsvvalues = new float[3]; final float values[] = hsvvalues; \/\/ bprevstate and bcurrstate keep track of the previous and current state of the button boolean bprevstate = false; boolean bcurrstate = false; string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake);","code_context_20":"@override public void runopmode() { telemetry.adddata(\"status\", \"initialized\"); telemetry.update(); left_mtr = hardwaremap.dcmotor.get(\"left_mtr\"); right_mtr = hardwaremap.dcmotor.get(\"right_mtr\"); front_left_mtr = hardwaremap.dcmotor.get(\"front_left_mtr\"); front_right_mtr = hardwaremap.dcmotor.get(\"front_right_mtr\"); shooter = hardwaremap.dcmotor.get(\"shooter\"); conveyor = hardwaremap.dcmotor.get(\"conveyor\"); clow_moter = hardwaremap.dcmotor.get(\"clow moter\"); claw = hardwaremap.servo.get(\"claw\"); touchfront = hardwaremap.touchsensor.get(\"touchfront\"); touch2 = hardwaremap.touchsensor.get(\"touch2\"); \/\/ values is a reference to the hsvvalues array. float[] hsvvalues = new float[3]; final float values[] = hsvvalues; \/\/ bprevstate and bcurrstate keep track of the previous and current state of the button boolean bprevstate = false; boolean bcurrstate = false; string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); right_mtr.setmode(dcmotor.runmode.run_without_encoder); left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); \/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/","repo":"FTC16694\/FtcRobotController"}
{"id":34098,"comment_id":3,"comment":"\/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/","code":"@override public void runopmode() { telemetry.adddata(\"status\", \"initialized\"); telemetry.update(); left_mtr = hardwaremap.dcmotor.get(\"left_mtr\"); right_mtr = hardwaremap.dcmotor.get(\"right_mtr\"); front_left_mtr = hardwaremap.dcmotor.get(\"front_left_mtr\"); front_right_mtr = hardwaremap.dcmotor.get(\"front_right_mtr\"); shooter = hardwaremap.dcmotor.get(\"shooter\"); conveyor = hardwaremap.dcmotor.get(\"conveyor\"); clow_moter = hardwaremap.dcmotor.get(\"clow moter\"); claw = hardwaremap.servo.get(\"claw\"); touchfront = hardwaremap.touchsensor.get(\"touchfront\"); touch2 = hardwaremap.touchsensor.get(\"touch2\"); \/\/ values is a reference to the hsvvalues array. float[] hsvvalues = new float[3]; final float values[] = hsvvalues; \/\/ bprevstate and bcurrstate keep track of the previous and current state of the button boolean bprevstate = false; boolean bcurrstate = false; string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); right_mtr.setmode(dcmotor.runmode.run_without_encoder); left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); \/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/ if (tfod != null) { tfod.activate(); \/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78); } \/** wait for the game to begin *\/ telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450); goforward(.5); haltsequence(150); turnleft(.5); haltsequence(450); goforward(0.4); sleep(450); halt(); sleep(1000); telemetry.adddata(\"status\", \"started\"); telemetry.update(); if (tfod != null) { \/\/ getupdatedrecognitions() will return null if no new information is available since \/\/ the last time that call was made. list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) { telemetry.adddata(\"# object detected\", updatedrecognitions.size()); if (updatedrecognitions.size() == 0) { mode = \"a\"; } \/\/ step through the list of recognitions and display boundary info. int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel()); if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } \/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\"); telemetry.update(); sleep(2000); } } } \/\/ go somewhere based on mode if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb(); } else if (mode == \"c\") { domodec(); } else { \/\/ not sure what to do here } if (tfod != null) { tfod.shutdown(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"initvuforia(); inittfod(); \/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/ if (tfod != null) { tfod.activate();","code_context_10":"left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); right_mtr.setmode(dcmotor.runmode.run_without_encoder); left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); \/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/ if (tfod != null) { tfod.activate(); \/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78);","code_context_20":"\/\/ values is a reference to the hsvvalues array. float[] hsvvalues = new float[3]; final float values[] = hsvvalues; \/\/ bprevstate and bcurrstate keep track of the previous and current state of the button boolean bprevstate = false; boolean bcurrstate = false; string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); right_mtr.setmode(dcmotor.runmode.run_without_encoder); left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); \/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/ if (tfod != null) { tfod.activate(); \/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78); } \/** wait for the game to begin *\/ telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450);","repo":"FTC16694\/FtcRobotController"}
{"id":34098,"comment_id":4,"comment":"\/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78);","code":"@override public void runopmode() { telemetry.adddata(\"status\", \"initialized\"); telemetry.update(); left_mtr = hardwaremap.dcmotor.get(\"left_mtr\"); right_mtr = hardwaremap.dcmotor.get(\"right_mtr\"); front_left_mtr = hardwaremap.dcmotor.get(\"front_left_mtr\"); front_right_mtr = hardwaremap.dcmotor.get(\"front_right_mtr\"); shooter = hardwaremap.dcmotor.get(\"shooter\"); conveyor = hardwaremap.dcmotor.get(\"conveyor\"); clow_moter = hardwaremap.dcmotor.get(\"clow moter\"); claw = hardwaremap.servo.get(\"claw\"); touchfront = hardwaremap.touchsensor.get(\"touchfront\"); touch2 = hardwaremap.touchsensor.get(\"touch2\"); \/\/ values is a reference to the hsvvalues array. float[] hsvvalues = new float[3]; final float values[] = hsvvalues; \/\/ bprevstate and bcurrstate keep track of the previous and current state of the button boolean bprevstate = false; boolean bcurrstate = false; string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); right_mtr.setmode(dcmotor.runmode.run_without_encoder); left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); \/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/ if (tfod != null) { tfod.activate(); \/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78); } \/** wait for the game to begin *\/ telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450); goforward(.5); haltsequence(150); turnleft(.5); haltsequence(450); goforward(0.4); sleep(450); halt(); sleep(1000); telemetry.adddata(\"status\", \"started\"); telemetry.update(); if (tfod != null) { \/\/ getupdatedrecognitions() will return null if no new information is available since \/\/ the last time that call was made. list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) { telemetry.adddata(\"# object detected\", updatedrecognitions.size()); if (updatedrecognitions.size() == 0) { mode = \"a\"; } \/\/ step through the list of recognitions and display boundary info. int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel()); if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } \/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\"); telemetry.update(); sleep(2000); } } } \/\/ go somewhere based on mode if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb(); } else if (mode == \"c\") { domodec(); } else { \/\/ not sure what to do here } if (tfod != null) { tfod.shutdown(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"if (tfod != null) { tfod.activate(); \/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78); } \/** wait for the game to begin *\/","code_context_10":"front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); \/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/ if (tfod != null) { tfod.activate(); \/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78); } \/** wait for the game to begin *\/ telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450);","code_context_20":"string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); right_mtr.setmode(dcmotor.runmode.run_without_encoder); left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); \/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/ if (tfod != null) { tfod.activate(); \/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78); } \/** wait for the game to begin *\/ telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450); goforward(.5); haltsequence(150); turnleft(.5); haltsequence(450); goforward(0.4); sleep(450); halt(); sleep(1000); telemetry.adddata(\"status\", \"started\"); telemetry.update();","repo":"FTC16694\/FtcRobotController"}
{"id":34098,"comment_id":5,"comment":"\/** wait for the game to begin *\/","code":"@override public void runopmode() { telemetry.adddata(\"status\", \"initialized\"); telemetry.update(); left_mtr = hardwaremap.dcmotor.get(\"left_mtr\"); right_mtr = hardwaremap.dcmotor.get(\"right_mtr\"); front_left_mtr = hardwaremap.dcmotor.get(\"front_left_mtr\"); front_right_mtr = hardwaremap.dcmotor.get(\"front_right_mtr\"); shooter = hardwaremap.dcmotor.get(\"shooter\"); conveyor = hardwaremap.dcmotor.get(\"conveyor\"); clow_moter = hardwaremap.dcmotor.get(\"clow moter\"); claw = hardwaremap.servo.get(\"claw\"); touchfront = hardwaremap.touchsensor.get(\"touchfront\"); touch2 = hardwaremap.touchsensor.get(\"touch2\"); \/\/ values is a reference to the hsvvalues array. float[] hsvvalues = new float[3]; final float values[] = hsvvalues; \/\/ bprevstate and bcurrstate keep track of the previous and current state of the button boolean bprevstate = false; boolean bcurrstate = false; string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); right_mtr.setmode(dcmotor.runmode.run_without_encoder); left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); \/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/ if (tfod != null) { tfod.activate(); \/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78); } \/** wait for the game to begin *\/ telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450); goforward(.5); haltsequence(150); turnleft(.5); haltsequence(450); goforward(0.4); sleep(450); halt(); sleep(1000); telemetry.adddata(\"status\", \"started\"); telemetry.update(); if (tfod != null) { \/\/ getupdatedrecognitions() will return null if no new information is available since \/\/ the last time that call was made. list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) { telemetry.adddata(\"# object detected\", updatedrecognitions.size()); if (updatedrecognitions.size() == 0) { mode = \"a\"; } \/\/ step through the list of recognitions and display boundary info. int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel()); if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } \/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\"); telemetry.update(); sleep(2000); } } } \/\/ go somewhere based on mode if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb(); } else if (mode == \"c\") { domodec(); } else { \/\/ not sure what to do here } if (tfod != null) { tfod.shutdown(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/tfod.setzoom(2.5, 1.78); } \/** wait for the game to begin *\/ telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update();","code_context_10":"tfod.activate(); \/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78); } \/** wait for the game to begin *\/ telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450); goforward(.5); haltsequence(150);","code_context_20":"left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); \/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/ if (tfod != null) { tfod.activate(); \/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78); } \/** wait for the game to begin *\/ telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450); goforward(.5); haltsequence(150); turnleft(.5); haltsequence(450); goforward(0.4); sleep(450); halt(); sleep(1000); telemetry.adddata(\"status\", \"started\"); telemetry.update(); if (tfod != null) { \/\/ getupdatedrecognitions() will return null if no new information is available since","repo":"FTC16694\/FtcRobotController"}
{"id":34098,"comment_id":6,"comment":"\/\/ getupdatedrecognitions() will return null if no new information is available since \/\/ the last time that call was made.","code":"@override public void runopmode() { telemetry.adddata(\"status\", \"initialized\"); telemetry.update(); left_mtr = hardwaremap.dcmotor.get(\"left_mtr\"); right_mtr = hardwaremap.dcmotor.get(\"right_mtr\"); front_left_mtr = hardwaremap.dcmotor.get(\"front_left_mtr\"); front_right_mtr = hardwaremap.dcmotor.get(\"front_right_mtr\"); shooter = hardwaremap.dcmotor.get(\"shooter\"); conveyor = hardwaremap.dcmotor.get(\"conveyor\"); clow_moter = hardwaremap.dcmotor.get(\"clow moter\"); claw = hardwaremap.servo.get(\"claw\"); touchfront = hardwaremap.touchsensor.get(\"touchfront\"); touch2 = hardwaremap.touchsensor.get(\"touch2\"); \/\/ values is a reference to the hsvvalues array. float[] hsvvalues = new float[3]; final float values[] = hsvvalues; \/\/ bprevstate and bcurrstate keep track of the previous and current state of the button boolean bprevstate = false; boolean bcurrstate = false; string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); right_mtr.setmode(dcmotor.runmode.run_without_encoder); left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); \/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/ if (tfod != null) { tfod.activate(); \/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78); } \/** wait for the game to begin *\/ telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450); goforward(.5); haltsequence(150); turnleft(.5); haltsequence(450); goforward(0.4); sleep(450); halt(); sleep(1000); telemetry.adddata(\"status\", \"started\"); telemetry.update(); if (tfod != null) { \/\/ getupdatedrecognitions() will return null if no new information is available since \/\/ the last time that call was made. list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) { telemetry.adddata(\"# object detected\", updatedrecognitions.size()); if (updatedrecognitions.size() == 0) { mode = \"a\"; } \/\/ step through the list of recognitions and display boundary info. int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel()); if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } \/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\"); telemetry.update(); sleep(2000); } } } \/\/ go somewhere based on mode if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb(); } else if (mode == \"c\") { domodec(); } else { \/\/ not sure what to do here } if (tfod != null) { tfod.shutdown(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"telemetry.update(); if (tfod != null) { \/\/ getupdatedrecognitions() will return null if no new information is available since \/\/ the last time that call was made. list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) {","code_context_10":"haltsequence(150); turnleft(.5); haltsequence(450); goforward(0.4); sleep(450); halt(); sleep(1000); telemetry.adddata(\"status\", \"started\"); telemetry.update(); if (tfod != null) { \/\/ getupdatedrecognitions() will return null if no new information is available since \/\/ the last time that call was made. list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) { telemetry.adddata(\"# object detected\", updatedrecognitions.size()); if (updatedrecognitions.size() == 0) { mode = \"a\"; } \/\/ step through the list of recognitions and display boundary info. int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel());","code_context_20":"\/** wait for the game to begin *\/ telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450); goforward(.5); haltsequence(150); turnleft(.5); haltsequence(450); goforward(0.4); sleep(450); halt(); sleep(1000); telemetry.adddata(\"status\", \"started\"); telemetry.update(); if (tfod != null) { \/\/ getupdatedrecognitions() will return null if no new information is available since \/\/ the last time that call was made. list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) { telemetry.adddata(\"# object detected\", updatedrecognitions.size()); if (updatedrecognitions.size() == 0) { mode = \"a\"; } \/\/ step through the list of recognitions and display boundary info. int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel()); if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); }","repo":"FTC16694\/FtcRobotController"}
{"id":34098,"comment_id":7,"comment":"\/\/ step through the list of recognitions and display boundary info.","code":"@override public void runopmode() { telemetry.adddata(\"status\", \"initialized\"); telemetry.update(); left_mtr = hardwaremap.dcmotor.get(\"left_mtr\"); right_mtr = hardwaremap.dcmotor.get(\"right_mtr\"); front_left_mtr = hardwaremap.dcmotor.get(\"front_left_mtr\"); front_right_mtr = hardwaremap.dcmotor.get(\"front_right_mtr\"); shooter = hardwaremap.dcmotor.get(\"shooter\"); conveyor = hardwaremap.dcmotor.get(\"conveyor\"); clow_moter = hardwaremap.dcmotor.get(\"clow moter\"); claw = hardwaremap.servo.get(\"claw\"); touchfront = hardwaremap.touchsensor.get(\"touchfront\"); touch2 = hardwaremap.touchsensor.get(\"touch2\"); \/\/ values is a reference to the hsvvalues array. float[] hsvvalues = new float[3]; final float values[] = hsvvalues; \/\/ bprevstate and bcurrstate keep track of the previous and current state of the button boolean bprevstate = false; boolean bcurrstate = false; string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); right_mtr.setmode(dcmotor.runmode.run_without_encoder); left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); \/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/ if (tfod != null) { tfod.activate(); \/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78); } \/** wait for the game to begin *\/ telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450); goforward(.5); haltsequence(150); turnleft(.5); haltsequence(450); goforward(0.4); sleep(450); halt(); sleep(1000); telemetry.adddata(\"status\", \"started\"); telemetry.update(); if (tfod != null) { \/\/ getupdatedrecognitions() will return null if no new information is available since \/\/ the last time that call was made. list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) { telemetry.adddata(\"# object detected\", updatedrecognitions.size()); if (updatedrecognitions.size() == 0) { mode = \"a\"; } \/\/ step through the list of recognitions and display boundary info. int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel()); if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } \/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\"); telemetry.update(); sleep(2000); } } } \/\/ go somewhere based on mode if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb(); } else if (mode == \"c\") { domodec(); } else { \/\/ not sure what to do here } if (tfod != null) { tfod.shutdown(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"mode = \"a\"; } \/\/ step through the list of recognitions and display boundary info. int i = 0; for (recognition recognition : updatedrecognitions) {","code_context_10":"telemetry.update(); if (tfod != null) { \/\/ getupdatedrecognitions() will return null if no new information is available since \/\/ the last time that call was made. list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) { telemetry.adddata(\"# object detected\", updatedrecognitions.size()); if (updatedrecognitions.size() == 0) { mode = \"a\"; } \/\/ step through the list of recognitions and display boundary info. int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel()); if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop());","code_context_20":"haltsequence(450); goforward(.5); haltsequence(150); turnleft(.5); haltsequence(450); goforward(0.4); sleep(450); halt(); sleep(1000); telemetry.adddata(\"status\", \"started\"); telemetry.update(); if (tfod != null) { \/\/ getupdatedrecognitions() will return null if no new information is available since \/\/ the last time that call was made. list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) { telemetry.adddata(\"# object detected\", updatedrecognitions.size()); if (updatedrecognitions.size() == 0) { mode = \"a\"; } \/\/ step through the list of recognitions and display boundary info. int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel()); if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } \/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\"); telemetry.update(); sleep(2000); } } } \/\/ go somewhere based on mode","repo":"FTC16694\/FtcRobotController"}
{"id":34098,"comment_id":8,"comment":"\/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\");","code":"@override public void runopmode() { telemetry.adddata(\"status\", \"initialized\"); telemetry.update(); left_mtr = hardwaremap.dcmotor.get(\"left_mtr\"); right_mtr = hardwaremap.dcmotor.get(\"right_mtr\"); front_left_mtr = hardwaremap.dcmotor.get(\"front_left_mtr\"); front_right_mtr = hardwaremap.dcmotor.get(\"front_right_mtr\"); shooter = hardwaremap.dcmotor.get(\"shooter\"); conveyor = hardwaremap.dcmotor.get(\"conveyor\"); clow_moter = hardwaremap.dcmotor.get(\"clow moter\"); claw = hardwaremap.servo.get(\"claw\"); touchfront = hardwaremap.touchsensor.get(\"touchfront\"); touch2 = hardwaremap.touchsensor.get(\"touch2\"); \/\/ values is a reference to the hsvvalues array. float[] hsvvalues = new float[3]; final float values[] = hsvvalues; \/\/ bprevstate and bcurrstate keep track of the previous and current state of the button boolean bprevstate = false; boolean bcurrstate = false; string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); right_mtr.setmode(dcmotor.runmode.run_without_encoder); left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); \/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/ if (tfod != null) { tfod.activate(); \/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78); } \/** wait for the game to begin *\/ telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450); goforward(.5); haltsequence(150); turnleft(.5); haltsequence(450); goforward(0.4); sleep(450); halt(); sleep(1000); telemetry.adddata(\"status\", \"started\"); telemetry.update(); if (tfod != null) { \/\/ getupdatedrecognitions() will return null if no new information is available since \/\/ the last time that call was made. list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) { telemetry.adddata(\"# object detected\", updatedrecognitions.size()); if (updatedrecognitions.size() == 0) { mode = \"a\"; } \/\/ step through the list of recognitions and display boundary info. int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel()); if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } \/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\"); telemetry.update(); sleep(2000); } } } \/\/ go somewhere based on mode if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb(); } else if (mode == \"c\") { domodec(); } else { \/\/ not sure what to do here } if (tfod != null) { tfod.shutdown(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"recognition.getright(), recognition.getbottom()); } \/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\"); telemetry.update(); sleep(2000);","code_context_10":"if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } \/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\"); telemetry.update(); sleep(2000); } } } \/\/ go somewhere based on mode if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb();","code_context_20":"list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) { telemetry.adddata(\"# object detected\", updatedrecognitions.size()); if (updatedrecognitions.size() == 0) { mode = \"a\"; } \/\/ step through the list of recognitions and display boundary info. int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel()); if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } \/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\"); telemetry.update(); sleep(2000); } } } \/\/ go somewhere based on mode if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb(); } else if (mode == \"c\") { domodec(); } else { \/\/ not sure what to do here } if (tfod != null) { tfod.shutdown(); } }","repo":"FTC16694\/FtcRobotController"}
{"id":34098,"comment_id":9,"comment":"\/\/ go somewhere based on mode","code":"@override public void runopmode() { telemetry.adddata(\"status\", \"initialized\"); telemetry.update(); left_mtr = hardwaremap.dcmotor.get(\"left_mtr\"); right_mtr = hardwaremap.dcmotor.get(\"right_mtr\"); front_left_mtr = hardwaremap.dcmotor.get(\"front_left_mtr\"); front_right_mtr = hardwaremap.dcmotor.get(\"front_right_mtr\"); shooter = hardwaremap.dcmotor.get(\"shooter\"); conveyor = hardwaremap.dcmotor.get(\"conveyor\"); clow_moter = hardwaremap.dcmotor.get(\"clow moter\"); claw = hardwaremap.servo.get(\"claw\"); touchfront = hardwaremap.touchsensor.get(\"touchfront\"); touch2 = hardwaremap.touchsensor.get(\"touch2\"); \/\/ values is a reference to the hsvvalues array. float[] hsvvalues = new float[3]; final float values[] = hsvvalues; \/\/ bprevstate and bcurrstate keep track of the previous and current state of the button boolean bprevstate = false; boolean bcurrstate = false; string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); right_mtr.setmode(dcmotor.runmode.run_without_encoder); left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); \/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/ if (tfod != null) { tfod.activate(); \/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78); } \/** wait for the game to begin *\/ telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450); goforward(.5); haltsequence(150); turnleft(.5); haltsequence(450); goforward(0.4); sleep(450); halt(); sleep(1000); telemetry.adddata(\"status\", \"started\"); telemetry.update(); if (tfod != null) { \/\/ getupdatedrecognitions() will return null if no new information is available since \/\/ the last time that call was made. list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) { telemetry.adddata(\"# object detected\", updatedrecognitions.size()); if (updatedrecognitions.size() == 0) { mode = \"a\"; } \/\/ step through the list of recognitions and display boundary info. int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel()); if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } \/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\"); telemetry.update(); sleep(2000); } } } \/\/ go somewhere based on mode if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb(); } else if (mode == \"c\") { domodec(); } else { \/\/ not sure what to do here } if (tfod != null) { tfod.shutdown(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} } \/\/ go somewhere based on mode if (mode == \"a\") { domodea();","code_context_10":"recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } \/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\"); telemetry.update(); sleep(2000); } } } \/\/ go somewhere based on mode if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb(); } else if (mode == \"c\") { domodec(); } else { \/\/ not sure what to do here } if (tfod != null) {","code_context_20":"\/\/ step through the list of recognitions and display boundary info. int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel()); if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } \/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\"); telemetry.update(); sleep(2000); } } } \/\/ go somewhere based on mode if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb(); } else if (mode == \"c\") { domodec(); } else { \/\/ not sure what to do here } if (tfod != null) { tfod.shutdown(); } }","repo":"FTC16694\/FtcRobotController"}
{"id":34098,"comment_id":10,"comment":"\/\/ not sure what to do here","code":"@override public void runopmode() { telemetry.adddata(\"status\", \"initialized\"); telemetry.update(); left_mtr = hardwaremap.dcmotor.get(\"left_mtr\"); right_mtr = hardwaremap.dcmotor.get(\"right_mtr\"); front_left_mtr = hardwaremap.dcmotor.get(\"front_left_mtr\"); front_right_mtr = hardwaremap.dcmotor.get(\"front_right_mtr\"); shooter = hardwaremap.dcmotor.get(\"shooter\"); conveyor = hardwaremap.dcmotor.get(\"conveyor\"); clow_moter = hardwaremap.dcmotor.get(\"clow moter\"); claw = hardwaremap.servo.get(\"claw\"); touchfront = hardwaremap.touchsensor.get(\"touchfront\"); touch2 = hardwaremap.touchsensor.get(\"touch2\"); \/\/ values is a reference to the hsvvalues array. float[] hsvvalues = new float[3]; final float values[] = hsvvalues; \/\/ bprevstate and bcurrstate keep track of the previous and current state of the button boolean bprevstate = false; boolean bcurrstate = false; string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); right_mtr.setmode(dcmotor.runmode.run_without_encoder); left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); \/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/ if (tfod != null) { tfod.activate(); \/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78); } \/** wait for the game to begin *\/ telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450); goforward(.5); haltsequence(150); turnleft(.5); haltsequence(450); goforward(0.4); sleep(450); halt(); sleep(1000); telemetry.adddata(\"status\", \"started\"); telemetry.update(); if (tfod != null) { \/\/ getupdatedrecognitions() will return null if no new information is available since \/\/ the last time that call was made. list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) { telemetry.adddata(\"# object detected\", updatedrecognitions.size()); if (updatedrecognitions.size() == 0) { mode = \"a\"; } \/\/ step through the list of recognitions and display boundary info. int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel()); if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } \/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\"); telemetry.update(); sleep(2000); } } } \/\/ go somewhere based on mode if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb(); } else if (mode == \"c\") { domodec(); } else { \/\/ not sure what to do here } if (tfod != null) { tfod.shutdown(); } }","classification":"DESIGN","isFinished":true,"code_context_2":"domodec(); } else { \/\/ not sure what to do here } if (tfod != null) {","code_context_10":"} } \/\/ go somewhere based on mode if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb(); } else if (mode == \"c\") { domodec(); } else { \/\/ not sure what to do here } if (tfod != null) { tfod.shutdown(); } }","code_context_20":"} telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } \/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\"); telemetry.update(); sleep(2000); } } } \/\/ go somewhere based on mode if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb(); } else if (mode == \"c\") { domodec(); } else { \/\/ not sure what to do here } if (tfod != null) { tfod.shutdown(); } }","repo":"FTC16694\/FtcRobotController"}
{"id":9539,"comment_id":0,"comment":"\/\/todo escape special characters","code":"private void filter() { string text = drugmappingstringutilities.safetouppercase(searchfield.gettext()); if (text.length() == 0) { rowsorter.setrowfilter(null); } else { \/\/todo escape special characters rowsorter.setrowfilter(rowfilter.regexfilter(text)); } if (rowsorter.getviewrowcount() == 0) { ingredientmappinglogpanel.removeall(); ingredientmappingresultpanel.removeall(); mainframe.getframe().repaint(); } if (ingredientstable.getrowcount() > 0) { listselectionmodel selectionmodel = ingredientstable.getselectionmodel(); selectionmodel.setselectioninterval(0, 0); } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"} else { \/\/todo escape special characters rowsorter.setrowfilter(rowfilter.regexfilter(text)); }","code_context_10":"private void filter() { string text = drugmappingstringutilities.safetouppercase(searchfield.gettext()); if (text.length() == 0) { rowsorter.setrowfilter(null); } else { \/\/todo escape special characters rowsorter.setrowfilter(rowfilter.regexfilter(text)); } if (rowsorter.getviewrowcount() == 0) { ingredientmappinglogpanel.removeall(); ingredientmappingresultpanel.removeall(); mainframe.getframe().repaint(); } if (ingredientstable.getrowcount() > 0) { listselectionmodel selectionmodel = ingredientstable.getselectionmodel(); selectionmodel.setselectioninterval(0, 0);","code_context_20":"private void filter() { string text = drugmappingstringutilities.safetouppercase(searchfield.gettext()); if (text.length() == 0) { rowsorter.setrowfilter(null); } else { \/\/todo escape special characters rowsorter.setrowfilter(rowfilter.regexfilter(text)); } if (rowsorter.getviewrowcount() == 0) { ingredientmappinglogpanel.removeall(); ingredientmappingresultpanel.removeall(); mainframe.getframe().repaint(); } if (ingredientstable.getrowcount() > 0) { listselectionmodel selectionmodel = ingredientstable.getselectionmodel(); selectionmodel.setselectioninterval(0, 0); } }","repo":"EHDEN\/DrugMapping"}
{"id":9553,"comment_id":0,"comment":"\/\/todo: add pid to move method","code":"\/\/todo: add pid to move method public void move(double inches, double power) { robotinstance.drivetrain.povdrive(power, 0); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"public void move(double inches, double power) { robotinstance.drivetrain.povdrive(power, 0); }","code_context_10":"public void move(double inches, double power) { robotinstance.drivetrain.povdrive(power, 0); }","code_context_20":"public void move(double inches, double power) { robotinstance.drivetrain.povdrive(power, 0); }","repo":"Centennial-FTC-Robotics\/Omnitech2021-22"}
{"id":17777,"comment_id":0,"comment":"\/** * returns the pressed button of the alert. * that can be used to in a condition, eg.: * showalert(alerttype.confirmation, \"ok?\", \"is it ok?\") == buttontype.ok * * @param type the alert type * @param title the title of the alert * @param text the text of the alert * @param ontop the alert \"modality\"; true if the alert should be always * on top, false otherwise * @return the button type (depends on the alert type) *\/","code":"\/** * returns the pressed button of the alert. * that can be used to in a condition, eg.: * showalert(alerttype.confirmation, \"ok?\", \"is it ok?\") == buttontype.ok * * @param type the alert type * @param title the title of the alert * @param text the text of the alert * @param ontop the alert \"modality\"; true if the alert should be always * on top, false otherwise * @return the button type (depends on the alert type) *\/ public static buttontype showalert(alerttype type, string title, string text, boolean ontop) { \/\/ note: alert must be (re-)created everytime, otherwise the following hack doesn't work! alert alert = new alert(alerttype.none); alert.setalerttype(type); alert.settitle(title); alert.setheadertext(null); alert.setcontenttext(text); \/\/ hack: since it is not possible to set the owner of an javafx alert to \/\/ a swing frame, we use the following approach to set the modality! ((stage) alert.getdialogpane().getscene().getwindow()).setalwaysontop(ontop); \/\/ if no button was pressed, the dialog got canceled (esc, close) return alert.showandwait().orelse(buttontype.cancel); }","classification":"NONSATD","isFinished":true,"code_context_2":"public static buttontype showalert(alerttype type, string title, string text, boolean ontop) { \/\/ note: alert must be (re-)created everytime, otherwise the following hack doesn't work! alert alert = new alert(alerttype.none); alert.setalerttype(type); alert.settitle(title); alert.setheadertext(null); alert.setcontenttext(text); \/\/ hack: since it is not possible to set the owner of an javafx alert to \/\/ a swing frame, we use the following approach to set the modality! ((stage) alert.getdialogpane().getscene().getwindow()).setalwaysontop(ontop); \/\/ if no button was pressed, the dialog got canceled (esc, close) return alert.showandwait().orelse(buttontype.cancel); }","code_context_10":"public static buttontype showalert(alerttype type, string title, string text, boolean ontop) { \/\/ note: alert must be (re-)created everytime, otherwise the following hack doesn't work! alert alert = new alert(alerttype.none); alert.setalerttype(type); alert.settitle(title); alert.setheadertext(null); alert.setcontenttext(text); \/\/ hack: since it is not possible to set the owner of an javafx alert to \/\/ a swing frame, we use the following approach to set the modality! ((stage) alert.getdialogpane().getscene().getwindow()).setalwaysontop(ontop); \/\/ if no button was pressed, the dialog got canceled (esc, close) return alert.showandwait().orelse(buttontype.cancel); }","code_context_20":"public static buttontype showalert(alerttype type, string title, string text, boolean ontop) { \/\/ note: alert must be (re-)created everytime, otherwise the following hack doesn't work! alert alert = new alert(alerttype.none); alert.setalerttype(type); alert.settitle(title); alert.setheadertext(null); alert.setcontenttext(text); \/\/ hack: since it is not possible to set the owner of an javafx alert to \/\/ a swing frame, we use the following approach to set the modality! ((stage) alert.getdialogpane().getscene().getwindow()).setalwaysontop(ontop); \/\/ if no button was pressed, the dialog got canceled (esc, close) return alert.showandwait().orelse(buttontype.cancel); }","repo":"BerlinUnited\/NaoTH"}
{"id":17777,"comment_id":1,"comment":"\/\/ note: alert must be (re-)created everytime, otherwise the following hack doesn't work!","code":"public static buttontype showalert(alerttype type, string title, string text, boolean ontop) { \/\/ note: alert must be (re-)created everytime, otherwise the following hack doesn't work! alert alert = new alert(alerttype.none); alert.setalerttype(type); alert.settitle(title); alert.setheadertext(null); alert.setcontenttext(text); \/\/ hack: since it is not possible to set the owner of an javafx alert to \/\/ a swing frame, we use the following approach to set the modality! ((stage) alert.getdialogpane().getscene().getwindow()).setalwaysontop(ontop); \/\/ if no button was pressed, the dialog got canceled (esc, close) return alert.showandwait().orelse(buttontype.cancel); }","classification":"DESIGN","isFinished":true,"code_context_2":"public static buttontype showalert(alerttype type, string title, string text, boolean ontop) { \/\/ note: alert must be (re-)created everytime, otherwise the following hack doesn't work! alert alert = new alert(alerttype.none); alert.setalerttype(type);","code_context_10":"public static buttontype showalert(alerttype type, string title, string text, boolean ontop) { \/\/ note: alert must be (re-)created everytime, otherwise the following hack doesn't work! alert alert = new alert(alerttype.none); alert.setalerttype(type); alert.settitle(title); alert.setheadertext(null); alert.setcontenttext(text); \/\/ hack: since it is not possible to set the owner of an javafx alert to \/\/ a swing frame, we use the following approach to set the modality! ((stage) alert.getdialogpane().getscene().getwindow()).setalwaysontop(ontop); \/\/ if no button was pressed, the dialog got canceled (esc, close) return alert.showandwait().orelse(buttontype.cancel);","code_context_20":"public static buttontype showalert(alerttype type, string title, string text, boolean ontop) { \/\/ note: alert must be (re-)created everytime, otherwise the following hack doesn't work! alert alert = new alert(alerttype.none); alert.setalerttype(type); alert.settitle(title); alert.setheadertext(null); alert.setcontenttext(text); \/\/ hack: since it is not possible to set the owner of an javafx alert to \/\/ a swing frame, we use the following approach to set the modality! ((stage) alert.getdialogpane().getscene().getwindow()).setalwaysontop(ontop); \/\/ if no button was pressed, the dialog got canceled (esc, close) return alert.showandwait().orelse(buttontype.cancel); }","repo":"BerlinUnited\/NaoTH"}
{"id":17777,"comment_id":2,"comment":"\/\/ hack: since it is not possible to set the owner of an javafx alert to \/\/ a swing frame, we use the following approach to set the modality!","code":"public static buttontype showalert(alerttype type, string title, string text, boolean ontop) { \/\/ note: alert must be (re-)created everytime, otherwise the following hack doesn't work! alert alert = new alert(alerttype.none); alert.setalerttype(type); alert.settitle(title); alert.setheadertext(null); alert.setcontenttext(text); \/\/ hack: since it is not possible to set the owner of an javafx alert to \/\/ a swing frame, we use the following approach to set the modality! ((stage) alert.getdialogpane().getscene().getwindow()).setalwaysontop(ontop); \/\/ if no button was pressed, the dialog got canceled (esc, close) return alert.showandwait().orelse(buttontype.cancel); }","classification":"NONSATD","isFinished":true,"code_context_2":"alert.setheadertext(null); alert.setcontenttext(text); \/\/ hack: since it is not possible to set the owner of an javafx alert to \/\/ a swing frame, we use the following approach to set the modality! ((stage) alert.getdialogpane().getscene().getwindow()).setalwaysontop(ontop); \/\/ if no button was pressed, the dialog got canceled (esc, close)","code_context_10":"public static buttontype showalert(alerttype type, string title, string text, boolean ontop) { \/\/ note: alert must be (re-)created everytime, otherwise the following hack doesn't work! alert alert = new alert(alerttype.none); alert.setalerttype(type); alert.settitle(title); alert.setheadertext(null); alert.setcontenttext(text); \/\/ hack: since it is not possible to set the owner of an javafx alert to \/\/ a swing frame, we use the following approach to set the modality! ((stage) alert.getdialogpane().getscene().getwindow()).setalwaysontop(ontop); \/\/ if no button was pressed, the dialog got canceled (esc, close) return alert.showandwait().orelse(buttontype.cancel); }","code_context_20":"public static buttontype showalert(alerttype type, string title, string text, boolean ontop) { \/\/ note: alert must be (re-)created everytime, otherwise the following hack doesn't work! alert alert = new alert(alerttype.none); alert.setalerttype(type); alert.settitle(title); alert.setheadertext(null); alert.setcontenttext(text); \/\/ hack: since it is not possible to set the owner of an javafx alert to \/\/ a swing frame, we use the following approach to set the modality! ((stage) alert.getdialogpane().getscene().getwindow()).setalwaysontop(ontop); \/\/ if no button was pressed, the dialog got canceled (esc, close) return alert.showandwait().orelse(buttontype.cancel); }","repo":"BerlinUnited\/NaoTH"}
{"id":17777,"comment_id":3,"comment":"\/\/ if no button was pressed, the dialog got canceled (esc, close)","code":"public static buttontype showalert(alerttype type, string title, string text, boolean ontop) { \/\/ note: alert must be (re-)created everytime, otherwise the following hack doesn't work! alert alert = new alert(alerttype.none); alert.setalerttype(type); alert.settitle(title); alert.setheadertext(null); alert.setcontenttext(text); \/\/ hack: since it is not possible to set the owner of an javafx alert to \/\/ a swing frame, we use the following approach to set the modality! ((stage) alert.getdialogpane().getscene().getwindow()).setalwaysontop(ontop); \/\/ if no button was pressed, the dialog got canceled (esc, close) return alert.showandwait().orelse(buttontype.cancel); }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ a swing frame, we use the following approach to set the modality! ((stage) alert.getdialogpane().getscene().getwindow()).setalwaysontop(ontop); \/\/ if no button was pressed, the dialog got canceled (esc, close) return alert.showandwait().orelse(buttontype.cancel); }","code_context_10":"public static buttontype showalert(alerttype type, string title, string text, boolean ontop) { \/\/ note: alert must be (re-)created everytime, otherwise the following hack doesn't work! alert alert = new alert(alerttype.none); alert.setalerttype(type); alert.settitle(title); alert.setheadertext(null); alert.setcontenttext(text); \/\/ hack: since it is not possible to set the owner of an javafx alert to \/\/ a swing frame, we use the following approach to set the modality! ((stage) alert.getdialogpane().getscene().getwindow()).setalwaysontop(ontop); \/\/ if no button was pressed, the dialog got canceled (esc, close) return alert.showandwait().orelse(buttontype.cancel); }","code_context_20":"public static buttontype showalert(alerttype type, string title, string text, boolean ontop) { \/\/ note: alert must be (re-)created everytime, otherwise the following hack doesn't work! alert alert = new alert(alerttype.none); alert.setalerttype(type); alert.settitle(title); alert.setheadertext(null); alert.setcontenttext(text); \/\/ hack: since it is not possible to set the owner of an javafx alert to \/\/ a swing frame, we use the following approach to set the modality! ((stage) alert.getdialogpane().getscene().getwindow()).setalwaysontop(ontop); \/\/ if no button was pressed, the dialog got canceled (esc, close) return alert.showandwait().orelse(buttontype.cancel); }","repo":"BerlinUnited\/NaoTH"}
{"id":25987,"comment_id":0,"comment":"\/\/ todo: deep clone is more correct, but probably does not matter in practice","code":"@override public queryprofilevariant clone() { if (frozen) return this; try { queryprofilevariant clone = (queryprofilevariant)super.clone(); if (this.inherited != null) clone.inherited = new arraylist<>(this.inherited); \/\/ todo: deep clone is more correct, but probably does not matter in practice clone.values = copyonwritecontent.deepclone(this.values); return clone; } catch (clonenotsupportedexception e) { throw new runtimeexception(e); } }","classification":"DESIGN","isFinished":true,"code_context_2":"queryprofilevariant clone = (queryprofilevariant)super.clone(); if (this.inherited != null) clone.inherited = new arraylist<>(this.inherited); \/\/ todo: deep clone is more correct, but probably does not matter in practice clone.values = copyonwritecontent.deepclone(this.values); return clone;","code_context_10":"@override public queryprofilevariant clone() { if (frozen) return this; try { queryprofilevariant clone = (queryprofilevariant)super.clone(); if (this.inherited != null) clone.inherited = new arraylist<>(this.inherited); \/\/ todo: deep clone is more correct, but probably does not matter in practice clone.values = copyonwritecontent.deepclone(this.values); return clone; } catch (clonenotsupportedexception e) { throw new runtimeexception(e); } }","code_context_20":"@override public queryprofilevariant clone() { if (frozen) return this; try { queryprofilevariant clone = (queryprofilevariant)super.clone(); if (this.inherited != null) clone.inherited = new arraylist<>(this.inherited); \/\/ todo: deep clone is more correct, but probably does not matter in practice clone.values = copyonwritecontent.deepclone(this.values); return clone; } catch (clonenotsupportedexception e) { throw new runtimeexception(e); } }","repo":"Anlon-Burke\/vespa"}
{"id":9614,"comment_id":0,"comment":"\/\/ todo: get programs for a specific series && seasonid","code":"void loadui(empseries series) { this.episodescarouseladapter = new episodescarouseladapter(this, series); recyclerview episodescarousel = (recyclerview) findviewbyid(r.id.carousel_series_items); episodescarousel.setadapter(this.episodescarouseladapter); linearlayoutmanager layoutmanager = new linearlayoutmanager(this, linearlayoutmanager.horizontal, false); episodescarousel.setlayoutmanager(layoutmanager); if(series.episodes == null) { \/\/ todo: get programs for a specific series && seasonid } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"episodescarousel.setlayoutmanager(layoutmanager); if(series.episodes == null) { \/\/ todo: get programs for a specific series && seasonid } }","code_context_10":"void loadui(empseries series) { this.episodescarouseladapter = new episodescarouseladapter(this, series); recyclerview episodescarousel = (recyclerview) findviewbyid(r.id.carousel_series_items); episodescarousel.setadapter(this.episodescarouseladapter); linearlayoutmanager layoutmanager = new linearlayoutmanager(this, linearlayoutmanager.horizontal, false); episodescarousel.setlayoutmanager(layoutmanager); if(series.episodes == null) { \/\/ todo: get programs for a specific series && seasonid } }","code_context_20":"void loadui(empseries series) { this.episodescarouseladapter = new episodescarouseladapter(this, series); recyclerview episodescarousel = (recyclerview) findviewbyid(r.id.carousel_series_items); episodescarousel.setadapter(this.episodescarouseladapter); linearlayoutmanager layoutmanager = new linearlayoutmanager(this, linearlayoutmanager.horizontal, false); episodescarousel.setlayoutmanager(layoutmanager); if(series.episodes == null) { \/\/ todo: get programs for a specific series && seasonid } }","repo":"EricssonBroadcastServices\/AndroidClientReferenceApp"}
{"id":17865,"comment_id":0,"comment":"\/\/hacky assert but we know that this mockserver will create an exception that will be logged, if there's no log entry \/\/then there's no exception, which means that getcredentials didn't get called on the fetcher","code":"@test(expected = amazonclientexception.class) public void canbeconfiguredtoonlyrefreshcredentialsafterfirstcalltogetcredentials() throws interruptedexception { mockserver.setresponsefilename(\"sessionresponseexpired\"); mockserver.setavailablesecuritycredentials(\"test-credentials\"); instanceprofilecredentialsprovider credentialsprovider = instanceprofilecredentialsprovider.createasyncrefreshingprovider(false); thread.sleep(1000); \/\/hacky assert but we know that this mockserver will create an exception that will be logged, if there's no log entry \/\/then there's no exception, which means that getcredentials didn't get called on the fetcher assertthat(loggedevents(), is(empty())); credentialsprovider.getcredentials(); }","classification":"DESIGN","isFinished":true,"code_context_2":"instanceprofilecredentialsprovider credentialsprovider = instanceprofilecredentialsprovider.createasyncrefreshingprovider(false); thread.sleep(1000); \/\/hacky assert but we know that this mockserver will create an exception that will be logged, if there's no log entry \/\/then there's no exception, which means that getcredentials didn't get called on the fetcher assertthat(loggedevents(), is(empty())); credentialsprovider.getcredentials();","code_context_10":"@test(expected = amazonclientexception.class) public void canbeconfiguredtoonlyrefreshcredentialsafterfirstcalltogetcredentials() throws interruptedexception { mockserver.setresponsefilename(\"sessionresponseexpired\"); mockserver.setavailablesecuritycredentials(\"test-credentials\"); instanceprofilecredentialsprovider credentialsprovider = instanceprofilecredentialsprovider.createasyncrefreshingprovider(false); thread.sleep(1000); \/\/hacky assert but we know that this mockserver will create an exception that will be logged, if there's no log entry \/\/then there's no exception, which means that getcredentials didn't get called on the fetcher assertthat(loggedevents(), is(empty())); credentialsprovider.getcredentials(); }","code_context_20":"@test(expected = amazonclientexception.class) public void canbeconfiguredtoonlyrefreshcredentialsafterfirstcalltogetcredentials() throws interruptedexception { mockserver.setresponsefilename(\"sessionresponseexpired\"); mockserver.setavailablesecuritycredentials(\"test-credentials\"); instanceprofilecredentialsprovider credentialsprovider = instanceprofilecredentialsprovider.createasyncrefreshingprovider(false); thread.sleep(1000); \/\/hacky assert but we know that this mockserver will create an exception that will be logged, if there's no log entry \/\/then there's no exception, which means that getcredentials didn't get called on the fetcher assertthat(loggedevents(), is(empty())); credentialsprovider.getcredentials(); }","repo":"IBM\/ibm-cos-sdk-java"}
{"id":17941,"comment_id":0,"comment":"\/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink));","code":"@override public exportresult<calendarcontainerresource> export(tokenauthdata authdata) { request.builder calendarsbuilder = getbuilder(baseurl + calendars_url, authdata); list<calendarmodel> calendarmodels = new arraylist<>(); try (response graphresponse = client.newcall(calendarsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawcalendars = (list<map<string, object>>) graphmap.get(\"value\"); if (rawcalendars == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawcalendar : rawcalendars) { transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendarmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: \" + e.getmessage()); } list<calendareventmodel> calendareventmodels = new arraylist<>(); for (calendarmodel calendarmodel : calendarmodels) { string id = calendarmodel.getid(); request.builder eventsbuilder = getbuilder(calculateeventsurl(id), authdata); try (response graphresponse = client.newcall(eventsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawevents = (list<map<string, object>>) graphmap.get(\"value\"); if (rawevents == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawevent : rawevents) { map<string, string> properties = new hashmap<>(); properties.put(calendar_id, id); transformresult<calendareventmodel> result = transformerservice.transform(calendareventmodel.class, rawevent, properties); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendareventmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: \" + e.getmessage()); } } calendarcontainerresource resource = new calendarcontainerresource(calendarmodels, calendareventmodels); return new exportresult<>(exportresult.resulttype.end, resource, null); }","classification":"NONSATD","isFinished":true,"code_context_2":"string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawcalendars = (list<map<string, object>>) graphmap.get(\"value\"); if (rawcalendars == null) {","code_context_10":"public exportresult<calendarcontainerresource> export(tokenauthdata authdata) { request.builder calendarsbuilder = getbuilder(baseurl + calendars_url, authdata); list<calendarmodel> calendarmodels = new arraylist<>(); try (response graphresponse = client.newcall(calendarsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawcalendars = (list<map<string, object>>) graphmap.get(\"value\"); if (rawcalendars == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawcalendar : rawcalendars) { transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue;","code_context_20":"@override public exportresult<calendarcontainerresource> export(tokenauthdata authdata) { request.builder calendarsbuilder = getbuilder(baseurl + calendars_url, authdata); list<calendarmodel> calendarmodels = new arraylist<>(); try (response graphresponse = client.newcall(calendarsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawcalendars = (list<map<string, object>>) graphmap.get(\"value\"); if (rawcalendars == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawcalendar : rawcalendars) { transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendarmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: \" + e.getmessage()); } list<calendareventmodel> calendareventmodels = new arraylist<>(); for (calendarmodel calendarmodel : calendarmodels) { string id = calendarmodel.getid();","repo":"29e7e280-0d1c-4bba-98fe-f7cd3ca7500a\/data-transfer-project"}
{"id":17941,"comment_id":1,"comment":"\/\/ discard \/\/ fixme log problem","code":"@override public exportresult<calendarcontainerresource> export(tokenauthdata authdata) { request.builder calendarsbuilder = getbuilder(baseurl + calendars_url, authdata); list<calendarmodel> calendarmodels = new arraylist<>(); try (response graphresponse = client.newcall(calendarsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawcalendars = (list<map<string, object>>) graphmap.get(\"value\"); if (rawcalendars == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawcalendar : rawcalendars) { transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendarmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: \" + e.getmessage()); } list<calendareventmodel> calendareventmodels = new arraylist<>(); for (calendarmodel calendarmodel : calendarmodels) { string id = calendarmodel.getid(); request.builder eventsbuilder = getbuilder(calculateeventsurl(id), authdata); try (response graphresponse = client.newcall(eventsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawevents = (list<map<string, object>>) graphmap.get(\"value\"); if (rawevents == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawevent : rawevents) { map<string, string> properties = new hashmap<>(); properties.put(calendar_id, id); transformresult<calendareventmodel> result = transformerservice.transform(calendareventmodel.class, rawevent, properties); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendareventmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: \" + e.getmessage()); } } calendarcontainerresource resource = new calendarcontainerresource(calendarmodels, calendareventmodels); return new exportresult<>(exportresult.resulttype.end, resource, null); }","classification":"DEFECT","isFinished":true,"code_context_2":"transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; }","code_context_10":"map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawcalendars = (list<map<string, object>>) graphmap.get(\"value\"); if (rawcalendars == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawcalendar : rawcalendars) { transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendarmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: \" + e.getmessage()); } list<calendareventmodel> calendareventmodels = new arraylist<>(); for (calendarmodel calendarmodel : calendarmodels) {","code_context_20":"@override public exportresult<calendarcontainerresource> export(tokenauthdata authdata) { request.builder calendarsbuilder = getbuilder(baseurl + calendars_url, authdata); list<calendarmodel> calendarmodels = new arraylist<>(); try (response graphresponse = client.newcall(calendarsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawcalendars = (list<map<string, object>>) graphmap.get(\"value\"); if (rawcalendars == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawcalendar : rawcalendars) { transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendarmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: \" + e.getmessage()); } list<calendareventmodel> calendareventmodels = new arraylist<>(); for (calendarmodel calendarmodel : calendarmodels) { string id = calendarmodel.getid(); request.builder eventsbuilder = getbuilder(calculateeventsurl(id), authdata); try (response graphresponse = client.newcall(eventsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next);","repo":"29e7e280-0d1c-4bba-98fe-f7cd3ca7500a\/data-transfer-project"}
{"id":17941,"comment_id":2,"comment":"\/\/ fixme log error","code":"@override public exportresult<calendarcontainerresource> export(tokenauthdata authdata) { request.builder calendarsbuilder = getbuilder(baseurl + calendars_url, authdata); list<calendarmodel> calendarmodels = new arraylist<>(); try (response graphresponse = client.newcall(calendarsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawcalendars = (list<map<string, object>>) graphmap.get(\"value\"); if (rawcalendars == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawcalendar : rawcalendars) { transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendarmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: \" + e.getmessage()); } list<calendareventmodel> calendareventmodels = new arraylist<>(); for (calendarmodel calendarmodel : calendarmodels) { string id = calendarmodel.getid(); request.builder eventsbuilder = getbuilder(calculateeventsurl(id), authdata); try (response graphresponse = client.newcall(eventsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawevents = (list<map<string, object>>) graphmap.get(\"value\"); if (rawevents == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawevent : rawevents) { map<string, string> properties = new hashmap<>(); properties.put(calendar_id, id); transformresult<calendareventmodel> result = transformerservice.transform(calendareventmodel.class, rawevent, properties); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendareventmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: \" + e.getmessage()); } } calendarcontainerresource resource = new calendarcontainerresource(calendarmodels, calendareventmodels); return new exportresult<>(exportresult.resulttype.end, resource, null); }","classification":"DEFECT","isFinished":true,"code_context_2":"} } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: \" + e.getmessage()); }","code_context_10":"for (map<string, object> rawcalendar : rawcalendars) { transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendarmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: \" + e.getmessage()); } list<calendareventmodel> calendareventmodels = new arraylist<>(); for (calendarmodel calendarmodel : calendarmodels) { string id = calendarmodel.getid(); request.builder eventsbuilder = getbuilder(calculateeventsurl(id), authdata); try (response graphresponse = client.newcall(eventsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: response body was null\");","code_context_20":"return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawcalendars = (list<map<string, object>>) graphmap.get(\"value\"); if (rawcalendars == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawcalendar : rawcalendars) { transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendarmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: \" + e.getmessage()); } list<calendareventmodel> calendareventmodels = new arraylist<>(); for (calendarmodel calendarmodel : calendarmodels) { string id = calendarmodel.getid(); request.builder eventsbuilder = getbuilder(calculateeventsurl(id), authdata); try (response graphresponse = client.newcall(eventsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawevents = (list<map<string, object>>) graphmap.get(\"value\"); if (rawevents == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawevent : rawevents) {","repo":"29e7e280-0d1c-4bba-98fe-f7cd3ca7500a\/data-transfer-project"}
{"id":17941,"comment_id":3,"comment":"\/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink));","code":"@override public exportresult<calendarcontainerresource> export(tokenauthdata authdata) { request.builder calendarsbuilder = getbuilder(baseurl + calendars_url, authdata); list<calendarmodel> calendarmodels = new arraylist<>(); try (response graphresponse = client.newcall(calendarsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawcalendars = (list<map<string, object>>) graphmap.get(\"value\"); if (rawcalendars == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawcalendar : rawcalendars) { transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendarmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: \" + e.getmessage()); } list<calendareventmodel> calendareventmodels = new arraylist<>(); for (calendarmodel calendarmodel : calendarmodels) { string id = calendarmodel.getid(); request.builder eventsbuilder = getbuilder(calculateeventsurl(id), authdata); try (response graphresponse = client.newcall(eventsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawevents = (list<map<string, object>>) graphmap.get(\"value\"); if (rawevents == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawevent : rawevents) { map<string, string> properties = new hashmap<>(); properties.put(calendar_id, id); transformresult<calendareventmodel> result = transformerservice.transform(calendareventmodel.class, rawevent, properties); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendareventmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: \" + e.getmessage()); } } calendarcontainerresource resource = new calendarcontainerresource(calendarmodels, calendareventmodels); return new exportresult<>(exportresult.resulttype.end, resource, null); }","classification":"NONSATD","isFinished":true,"code_context_2":"string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawcalendars = (list<map<string, object>>) graphmap.get(\"value\"); if (rawcalendars == null) {","code_context_10":"public exportresult<calendarcontainerresource> export(tokenauthdata authdata) { request.builder calendarsbuilder = getbuilder(baseurl + calendars_url, authdata); list<calendarmodel> calendarmodels = new arraylist<>(); try (response graphresponse = client.newcall(calendarsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawcalendars = (list<map<string, object>>) graphmap.get(\"value\"); if (rawcalendars == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawcalendar : rawcalendars) { transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue;","code_context_20":"@override public exportresult<calendarcontainerresource> export(tokenauthdata authdata) { request.builder calendarsbuilder = getbuilder(baseurl + calendars_url, authdata); list<calendarmodel> calendarmodels = new arraylist<>(); try (response graphresponse = client.newcall(calendarsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawcalendars = (list<map<string, object>>) graphmap.get(\"value\"); if (rawcalendars == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawcalendar : rawcalendars) { transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendarmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: \" + e.getmessage()); } list<calendareventmodel> calendareventmodels = new arraylist<>(); for (calendarmodel calendarmodel : calendarmodels) { string id = calendarmodel.getid();","repo":"29e7e280-0d1c-4bba-98fe-f7cd3ca7500a\/data-transfer-project"}
{"id":17941,"comment_id":4,"comment":"\/\/ discard \/\/ fixme log problem","code":"@override public exportresult<calendarcontainerresource> export(tokenauthdata authdata) { request.builder calendarsbuilder = getbuilder(baseurl + calendars_url, authdata); list<calendarmodel> calendarmodels = new arraylist<>(); try (response graphresponse = client.newcall(calendarsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawcalendars = (list<map<string, object>>) graphmap.get(\"value\"); if (rawcalendars == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawcalendar : rawcalendars) { transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendarmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: \" + e.getmessage()); } list<calendareventmodel> calendareventmodels = new arraylist<>(); for (calendarmodel calendarmodel : calendarmodels) { string id = calendarmodel.getid(); request.builder eventsbuilder = getbuilder(calculateeventsurl(id), authdata); try (response graphresponse = client.newcall(eventsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawevents = (list<map<string, object>>) graphmap.get(\"value\"); if (rawevents == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawevent : rawevents) { map<string, string> properties = new hashmap<>(); properties.put(calendar_id, id); transformresult<calendareventmodel> result = transformerservice.transform(calendareventmodel.class, rawevent, properties); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendareventmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: \" + e.getmessage()); } } calendarcontainerresource resource = new calendarcontainerresource(calendarmodels, calendareventmodels); return new exportresult<>(exportresult.resulttype.end, resource, null); }","classification":"DEFECT","isFinished":true,"code_context_2":"transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; }","code_context_10":"map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawcalendars = (list<map<string, object>>) graphmap.get(\"value\"); if (rawcalendars == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawcalendar : rawcalendars) { transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendarmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: \" + e.getmessage()); } list<calendareventmodel> calendareventmodels = new arraylist<>(); for (calendarmodel calendarmodel : calendarmodels) {","code_context_20":"@override public exportresult<calendarcontainerresource> export(tokenauthdata authdata) { request.builder calendarsbuilder = getbuilder(baseurl + calendars_url, authdata); list<calendarmodel> calendarmodels = new arraylist<>(); try (response graphresponse = client.newcall(calendarsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawcalendars = (list<map<string, object>>) graphmap.get(\"value\"); if (rawcalendars == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawcalendar : rawcalendars) { transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendarmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: \" + e.getmessage()); } list<calendareventmodel> calendareventmodels = new arraylist<>(); for (calendarmodel calendarmodel : calendarmodels) { string id = calendarmodel.getid(); request.builder eventsbuilder = getbuilder(calculateeventsurl(id), authdata); try (response graphresponse = client.newcall(eventsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next);","repo":"29e7e280-0d1c-4bba-98fe-f7cd3ca7500a\/data-transfer-project"}
{"id":17941,"comment_id":5,"comment":"\/\/ fixme log error","code":"@override public exportresult<calendarcontainerresource> export(tokenauthdata authdata) { request.builder calendarsbuilder = getbuilder(baseurl + calendars_url, authdata); list<calendarmodel> calendarmodels = new arraylist<>(); try (response graphresponse = client.newcall(calendarsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawcalendars = (list<map<string, object>>) graphmap.get(\"value\"); if (rawcalendars == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawcalendar : rawcalendars) { transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendarmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: \" + e.getmessage()); } list<calendareventmodel> calendareventmodels = new arraylist<>(); for (calendarmodel calendarmodel : calendarmodels) { string id = calendarmodel.getid(); request.builder eventsbuilder = getbuilder(calculateeventsurl(id), authdata); try (response graphresponse = client.newcall(eventsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawevents = (list<map<string, object>>) graphmap.get(\"value\"); if (rawevents == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawevent : rawevents) { map<string, string> properties = new hashmap<>(); properties.put(calendar_id, id); transformresult<calendareventmodel> result = transformerservice.transform(calendareventmodel.class, rawevent, properties); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendareventmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: \" + e.getmessage()); } } calendarcontainerresource resource = new calendarcontainerresource(calendarmodels, calendareventmodels); return new exportresult<>(exportresult.resulttype.end, resource, null); }","classification":"DEFECT","isFinished":true,"code_context_2":"} } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: \" + e.getmessage()); }","code_context_10":"for (map<string, object> rawcalendar : rawcalendars) { transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendarmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: \" + e.getmessage()); } list<calendareventmodel> calendareventmodels = new arraylist<>(); for (calendarmodel calendarmodel : calendarmodels) { string id = calendarmodel.getid(); request.builder eventsbuilder = getbuilder(calculateeventsurl(id), authdata); try (response graphresponse = client.newcall(eventsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: response body was null\");","code_context_20":"return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawcalendars = (list<map<string, object>>) graphmap.get(\"value\"); if (rawcalendars == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawcalendar : rawcalendars) { transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { \/\/ discard \/\/ fixme log problem continue; } calendarmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); \/\/ fixme log error return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: \" + e.getmessage()); } list<calendareventmodel> calendareventmodels = new arraylist<>(); for (calendarmodel calendarmodel : calendarmodels) { string id = calendarmodel.getid(); request.builder eventsbuilder = getbuilder(calculateeventsurl(id), authdata); try (response graphresponse = client.newcall(eventsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); \/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink)); @suppresswarnings(\"unchecked\") list<map<string, object>> rawevents = (list<map<string, object>>) graphmap.get(\"value\"); if (rawevents == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawevent : rawevents) {","repo":"29e7e280-0d1c-4bba-98fe-f7cd3ca7500a\/data-transfer-project"}
{"id":9775,"comment_id":0,"comment":"\/\/ ouch, my fingers hurt! all this typing!","code":"public static void main(string[] args) { file dir = new file(\".\"); arrays.stream(dir.listfiles()).foreach(file -> { try { system.out.println(file.getcanonicalpath()); } catch (ioexception e) { throw new runtimeexception(e); } \/\/ ouch, my fingers hurt! all this typing! }); \/\/ todo use unchecked.consumer from jool library \/\/ solution( arrays.stream(dir.listfiles()).foreach(unchecked.consumer(file -> { system.out.println(file.getcanonicalpath()); })); \/\/ solution) }","classification":"NONSATD","isFinished":true,"code_context_2":"throw new runtimeexception(e); } \/\/ ouch, my fingers hurt! all this typing! }); \/\/ todo use unchecked.consumer from jool library","code_context_10":"public static void main(string[] args) { file dir = new file(\".\"); arrays.stream(dir.listfiles()).foreach(file -> { try { system.out.println(file.getcanonicalpath()); } catch (ioexception e) { throw new runtimeexception(e); } \/\/ ouch, my fingers hurt! all this typing! }); \/\/ todo use unchecked.consumer from jool library \/\/ solution( arrays.stream(dir.listfiles()).foreach(unchecked.consumer(file -> { system.out.println(file.getcanonicalpath()); })); \/\/ solution) }","code_context_20":"public static void main(string[] args) { file dir = new file(\".\"); arrays.stream(dir.listfiles()).foreach(file -> { try { system.out.println(file.getcanonicalpath()); } catch (ioexception e) { throw new runtimeexception(e); } \/\/ ouch, my fingers hurt! all this typing! }); \/\/ todo use unchecked.consumer from jool library \/\/ solution( arrays.stream(dir.listfiles()).foreach(unchecked.consumer(file -> { system.out.println(file.getcanonicalpath()); })); \/\/ solution) }","repo":"AdrianaDinca\/training"}
{"id":9775,"comment_id":1,"comment":"\/\/ todo use unchecked.consumer from jool library \/\/ solution(","code":"public static void main(string[] args) { file dir = new file(\".\"); arrays.stream(dir.listfiles()).foreach(file -> { try { system.out.println(file.getcanonicalpath()); } catch (ioexception e) { throw new runtimeexception(e); } \/\/ ouch, my fingers hurt! all this typing! }); \/\/ todo use unchecked.consumer from jool library \/\/ solution( arrays.stream(dir.listfiles()).foreach(unchecked.consumer(file -> { system.out.println(file.getcanonicalpath()); })); \/\/ solution) }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ ouch, my fingers hurt! all this typing! }); \/\/ todo use unchecked.consumer from jool library \/\/ solution( arrays.stream(dir.listfiles()).foreach(unchecked.consumer(file -> { system.out.println(file.getcanonicalpath());","code_context_10":"public static void main(string[] args) { file dir = new file(\".\"); arrays.stream(dir.listfiles()).foreach(file -> { try { system.out.println(file.getcanonicalpath()); } catch (ioexception e) { throw new runtimeexception(e); } \/\/ ouch, my fingers hurt! all this typing! }); \/\/ todo use unchecked.consumer from jool library \/\/ solution( arrays.stream(dir.listfiles()).foreach(unchecked.consumer(file -> { system.out.println(file.getcanonicalpath()); })); \/\/ solution) }","code_context_20":"public static void main(string[] args) { file dir = new file(\".\"); arrays.stream(dir.listfiles()).foreach(file -> { try { system.out.println(file.getcanonicalpath()); } catch (ioexception e) { throw new runtimeexception(e); } \/\/ ouch, my fingers hurt! all this typing! }); \/\/ todo use unchecked.consumer from jool library \/\/ solution( arrays.stream(dir.listfiles()).foreach(unchecked.consumer(file -> { system.out.println(file.getcanonicalpath()); })); \/\/ solution) }","repo":"AdrianaDinca\/training"}
{"id":9775,"comment_id":2,"comment":"\/\/ solution)","code":"public static void main(string[] args) { file dir = new file(\".\"); arrays.stream(dir.listfiles()).foreach(file -> { try { system.out.println(file.getcanonicalpath()); } catch (ioexception e) { throw new runtimeexception(e); } \/\/ ouch, my fingers hurt! all this typing! }); \/\/ todo use unchecked.consumer from jool library \/\/ solution( arrays.stream(dir.listfiles()).foreach(unchecked.consumer(file -> { system.out.println(file.getcanonicalpath()); })); \/\/ solution) }","classification":"NONSATD","isFinished":true,"code_context_2":"system.out.println(file.getcanonicalpath()); })); \/\/ solution) }","code_context_10":"} catch (ioexception e) { throw new runtimeexception(e); } \/\/ ouch, my fingers hurt! all this typing! }); \/\/ todo use unchecked.consumer from jool library \/\/ solution( arrays.stream(dir.listfiles()).foreach(unchecked.consumer(file -> { system.out.println(file.getcanonicalpath()); })); \/\/ solution) }","code_context_20":"public static void main(string[] args) { file dir = new file(\".\"); arrays.stream(dir.listfiles()).foreach(file -> { try { system.out.println(file.getcanonicalpath()); } catch (ioexception e) { throw new runtimeexception(e); } \/\/ ouch, my fingers hurt! all this typing! }); \/\/ todo use unchecked.consumer from jool library \/\/ solution( arrays.stream(dir.listfiles()).foreach(unchecked.consumer(file -> { system.out.println(file.getcanonicalpath()); })); \/\/ solution) }","repo":"AdrianaDinca\/training"}
{"id":1657,"comment_id":0,"comment":"\/** * replaces all except if a match is immediately preceded by a > sign, in which case this * match is not replaced *\/","code":"\/** * replaces all except if a match is immediately preceded by a > sign, in which case this * match is not replaced *\/ public static string replaceallifnotinsidetag(string origstr, string findthis, string replacewith) { if (origstr == null) { return null; } if (findthis == null) { return origstr; } if (replacewith == null) { replacewith = \"\"; } stringbuilder result = new stringbuilder(); int index = origstr.indexof(findthis); while (index >= 0) { result.append(origstr.substring(0, index)); if ((index > 0) && origstr.charat(index - 1) == '>') { result.append(findthis); } else { result.append(replacewith); } \/\/ todo :: improve speed by not calling substring but keeping track of start! origstr = origstr.substring(index + findthis.length()); index = origstr.indexof(findthis); } result.append(origstr); return result.tostring(); }","classification":"NONSATD","isFinished":true,"code_context_2":"public static string replaceallifnotinsidetag(string origstr, string findthis, string replacewith) { if (origstr == null) { return null; } if (findthis == null) { return origstr; } if (replacewith == null) { replacewith = \"\"; } stringbuilder result = new stringbuilder(); int index = origstr.indexof(findthis); while (index >= 0) { result.append(origstr.substring(0, index)); if ((index > 0) && origstr.charat(index - 1) == '>') { result.append(findthis); } else { result.append(replacewith); } \/\/ todo :: improve speed by not calling substring but keeping track of start! origstr = origstr.substring(index + findthis.length()); index = origstr.indexof(findthis); } result.append(origstr); return result.tostring(); }","code_context_10":"public static string replaceallifnotinsidetag(string origstr, string findthis, string replacewith) { if (origstr == null) { return null; } if (findthis == null) { return origstr; } if (replacewith == null) { replacewith = \"\"; } stringbuilder result = new stringbuilder(); int index = origstr.indexof(findthis); while (index >= 0) { result.append(origstr.substring(0, index)); if ((index > 0) && origstr.charat(index - 1) == '>') { result.append(findthis); } else { result.append(replacewith); } \/\/ todo :: improve speed by not calling substring but keeping track of start! origstr = origstr.substring(index + findthis.length()); index = origstr.indexof(findthis); } result.append(origstr); return result.tostring(); }","code_context_20":"public static string replaceallifnotinsidetag(string origstr, string findthis, string replacewith) { if (origstr == null) { return null; } if (findthis == null) { return origstr; } if (replacewith == null) { replacewith = \"\"; } stringbuilder result = new stringbuilder(); int index = origstr.indexof(findthis); while (index >= 0) { result.append(origstr.substring(0, index)); if ((index > 0) && origstr.charat(index - 1) == '>') { result.append(findthis); } else { result.append(replacewith); } \/\/ todo :: improve speed by not calling substring but keeping track of start! origstr = origstr.substring(index + findthis.length()); index = origstr.indexof(findthis); } result.append(origstr); return result.tostring(); }","repo":"ASofterSpace\/Toolbox-Java"}
{"id":1657,"comment_id":1,"comment":"\/\/ todo :: improve speed by not calling substring but keeping track of start!","code":"public static string replaceallifnotinsidetag(string origstr, string findthis, string replacewith) { if (origstr == null) { return null; } if (findthis == null) { return origstr; } if (replacewith == null) { replacewith = \"\"; } stringbuilder result = new stringbuilder(); int index = origstr.indexof(findthis); while (index >= 0) { result.append(origstr.substring(0, index)); if ((index > 0) && origstr.charat(index - 1) == '>') { result.append(findthis); } else { result.append(replacewith); } \/\/ todo :: improve speed by not calling substring but keeping track of start! origstr = origstr.substring(index + findthis.length()); index = origstr.indexof(findthis); } result.append(origstr); return result.tostring(); }","classification":"DESIGN","isFinished":true,"code_context_2":"result.append(replacewith); } \/\/ todo :: improve speed by not calling substring but keeping track of start! origstr = origstr.substring(index + findthis.length()); index = origstr.indexof(findthis);","code_context_10":"} stringbuilder result = new stringbuilder(); int index = origstr.indexof(findthis); while (index >= 0) { result.append(origstr.substring(0, index)); if ((index > 0) && origstr.charat(index - 1) == '>') { result.append(findthis); } else { result.append(replacewith); } \/\/ todo :: improve speed by not calling substring but keeping track of start! origstr = origstr.substring(index + findthis.length()); index = origstr.indexof(findthis); } result.append(origstr); return result.tostring(); }","code_context_20":"public static string replaceallifnotinsidetag(string origstr, string findthis, string replacewith) { if (origstr == null) { return null; } if (findthis == null) { return origstr; } if (replacewith == null) { replacewith = \"\"; } stringbuilder result = new stringbuilder(); int index = origstr.indexof(findthis); while (index >= 0) { result.append(origstr.substring(0, index)); if ((index > 0) && origstr.charat(index - 1) == '>') { result.append(findthis); } else { result.append(replacewith); } \/\/ todo :: improve speed by not calling substring but keeping track of start! origstr = origstr.substring(index + findthis.length()); index = origstr.indexof(findthis); } result.append(origstr); return result.tostring(); }","repo":"ASofterSpace\/Toolbox-Java"}
{"id":1659,"comment_id":0,"comment":"\/\/ todo :: improve speed by not calling substring but keeping track of start!","code":"private static string addafterlinescontainingex(string origstr, string findthis, string addthat, string eolmarker, boolean notinsidetag) { if (origstr == null) { return null; } if (findthis == null) { return origstr; } if ((addthat == null) || \"\".equals(addthat)) { return origstr; } if ((eolmarker == null) || \"\".equals(eolmarker)) { return origstr; } if (\"\".equals(findthis)) { return replaceall(origstr, \"\\n\", \"\\n\" + addthat) + \"\\n\" + addthat; } stringbuilder result = new stringbuilder(); int index = origstr.indexof(findthis); while (index >= 0) { if (notinsidetag) { if ((index > 0) && origstr.charat(index - 1) == '>') { index = origstr.indexof(findthis, index + 1); continue; } } int eol = origstr.indexof(eolmarker, index); if (eol < 0) { result.append(origstr); result.append(eolmarker); origstr = \"\"; } else { result.append(origstr.substring(0, eol + eolmarker.length())); \/\/ todo :: improve speed by not calling substring but keeping track of start! origstr = origstr.substring(eol + eolmarker.length()); } result.append(addthat); index = origstr.indexof(findthis); } result.append(origstr); return result.tostring(); }","classification":"DESIGN","isFinished":true,"code_context_2":"} else { result.append(origstr.substring(0, eol + eolmarker.length())); \/\/ todo :: improve speed by not calling substring but keeping track of start! origstr = origstr.substring(eol + eolmarker.length()); }","code_context_10":"continue; } } int eol = origstr.indexof(eolmarker, index); if (eol < 0) { result.append(origstr); result.append(eolmarker); origstr = \"\"; } else { result.append(origstr.substring(0, eol + eolmarker.length())); \/\/ todo :: improve speed by not calling substring but keeping track of start! origstr = origstr.substring(eol + eolmarker.length()); } result.append(addthat); index = origstr.indexof(findthis); } result.append(origstr); return result.tostring(); }","code_context_20":"} if (\"\".equals(findthis)) { return replaceall(origstr, \"\\n\", \"\\n\" + addthat) + \"\\n\" + addthat; } stringbuilder result = new stringbuilder(); int index = origstr.indexof(findthis); while (index >= 0) { if (notinsidetag) { if ((index > 0) && origstr.charat(index - 1) == '>') { index = origstr.indexof(findthis, index + 1); continue; } } int eol = origstr.indexof(eolmarker, index); if (eol < 0) { result.append(origstr); result.append(eolmarker); origstr = \"\"; } else { result.append(origstr.substring(0, eol + eolmarker.length())); \/\/ todo :: improve speed by not calling substring but keeping track of start! origstr = origstr.substring(eol + eolmarker.length()); } result.append(addthat); index = origstr.indexof(findthis); } result.append(origstr); return result.tostring(); }","repo":"ASofterSpace\/Toolbox-Java"}
{"id":9929,"comment_id":0,"comment":"\/** * returns the name of column used for partitioning. if this is set to null, we use the table level replica groups. * otherwise, we use the partition level replica groups. * todo: use partition info from segmentpartitionconfig * * @return name of partitioning column. *\/","code":"\/** * returns the name of column used for partitioning. if this is set to null, we use the table level replica groups. * otherwise, we use the partition level replica groups. * todo: use partition info from segmentpartitionconfig * * @return name of partitioning column. *\/ @nullable public string getpartitioncolumn() { return _partitioncolumn; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"@nullable public string getpartitioncolumn() { return _partitioncolumn; }","code_context_10":"@nullable public string getpartitioncolumn() { return _partitioncolumn; }","code_context_20":"@nullable public string getpartitioncolumn() { return _partitioncolumn; }","repo":"HoraceChoi95\/incubator-pinot"}
{"id":10010,"comment_id":0,"comment":"\/** * create a geopolygon using the specified points and holes and a test point. * * @param filteredpointlist is a filtered list of the geopoints to build an arbitrary polygon out of. * @param holes is a list of polygons representing \"holes\" in the outside polygon. null == none. * @param testpoint is a test point that is either known to be within the polygon area, or not. * @param testpointinside is true if the test point is within the area, false otherwise. * @return a geopolygon corresponding to what was specified, or null if what was specified * cannot be turned into a valid non-degenerate polygon. *\/","code":"\/** * create a geopolygon using the specified points and holes and a test point. * * @param filteredpointlist is a filtered list of the geopoints to build an arbitrary polygon out of. * @param holes is a list of polygons representing \"holes\" in the outside polygon. null == none. * @param testpoint is a test point that is either known to be within the polygon area, or not. * @param testpointinside is true if the test point is within the area, false otherwise. * @return a geopolygon corresponding to what was specified, or null if what was specified * cannot be turned into a valid non-degenerate polygon. *\/ static geopolygon generategeopolygon(final planetmodel planetmodel, final list<geopoint> filteredpointlist, final list<geopolygon> holes, final geopoint testpoint, final boolean testpointinside) { \/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } }","classification":"NONSATD","isFinished":true,"code_context_2":"static geopolygon generategeopolygon(final planetmodel planetmodel, final list<geopoint> filteredpointlist, final list<geopolygon> holes, final geopoint testpoint, final boolean testpointinside) { \/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } }","code_context_10":"static geopolygon generategeopolygon(final planetmodel planetmodel, final list<geopoint> filteredpointlist, final list<geopolygon> holes, final geopoint testpoint, final boolean testpointinside) { \/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } }","code_context_20":"static geopolygon generategeopolygon(final planetmodel planetmodel, final list<geopoint> filteredpointlist, final list<geopolygon> holes, final geopoint testpoint, final boolean testpointinside) { \/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } }","repo":"AliGhaff\/testLucene"}
{"id":10010,"comment_id":1,"comment":"\/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find.","code":"static geopolygon generategeopolygon(final planetmodel planetmodel, final list<geopoint> filteredpointlist, final list<geopolygon> holes, final geopoint testpoint, final boolean testpointinside) { \/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } }","classification":"NONSATD","isFinished":true,"code_context_2":"final geopoint testpoint, final boolean testpointinside) { \/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon.","code_context_10":"static geopolygon generategeopolygon(final planetmodel planetmodel, final list<geopoint> filteredpointlist, final list<geopolygon> holes, final geopoint testpoint, final boolean testpointinside) { \/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel);","code_context_20":"static geopolygon generategeopolygon(final planetmodel planetmodel, final list<geopoint> filteredpointlist, final list<geopolygon> holes, final geopoint testpoint, final boolean testpointinside) { \/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else {","repo":"AliGhaff\/testLucene"}
{"id":10010,"comment_id":2,"comment":"\/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities.","code":"static geopolygon generategeopolygon(final planetmodel planetmodel, final list<geopoint> filteredpointlist, final list<geopolygon> holes, final geopoint testpoint, final boolean testpointinside) { \/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean();","code_context_10":"static geopolygon generategeopolygon(final planetmodel planetmodel, final list<geopoint> filteredpointlist, final list<geopolygon> holes, final geopoint testpoint, final boolean testpointinside) { \/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval;","code_context_20":"static geopolygon generategeopolygon(final planetmodel planetmodel, final list<geopoint> filteredpointlist, final list<geopolygon> holes, final geopoint testpoint, final boolean testpointinside) { \/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built","repo":"AliGhaff\/testLucene"}
{"id":10010,"comment_id":3,"comment":"\/\/ the testpoint was within the shape. was that intended?","code":"static geopolygon generategeopolygon(final planetmodel planetmodel, final list<geopoint> filteredpointlist, final list<geopolygon> holes, final geopoint testpoint, final boolean testpointinside) { \/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } }","classification":"DESIGN","isFinished":true,"code_context_2":"mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real","code_context_10":"final boolean testpointinside) { \/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean();","code_context_20":"static geopolygon generategeopolygon(final planetmodel planetmodel, final list<geopoint> filteredpointlist, final list<geopolygon> holes, final geopoint testpoint, final boolean testpointinside) { \/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel);","repo":"AliGhaff\/testLucene"}
{"id":10010,"comment_id":4,"comment":"\/\/ yes: build it for real","code":"static geopolygon generategeopolygon(final planetmodel planetmodel, final list<geopoint> filteredpointlist, final list<geopolygon> holes, final geopoint testpoint, final boolean testpointinside) { \/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean();","code_context_10":"\/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval;","code_context_20":"static geopolygon generategeopolygon(final planetmodel planetmodel, final list<geopoint> filteredpointlist, final list<geopolygon> holes, final geopoint testpoint, final boolean testpointinside) { \/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null);","repo":"AliGhaff\/testLucene"}
{"id":10010,"comment_id":5,"comment":"\/\/ no: do the complement and return that.","code":"static geopolygon generategeopolygon(final planetmodel planetmodel, final list<geopoint> filteredpointlist, final list<geopolygon> holes, final geopoint testpoint, final boolean testpointinside) { \/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } }","classification":"NONSATD","isFinished":true,"code_context_2":"return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean();","code_context_10":"mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; }","code_context_20":"final list<geopolygon> holes, final geopoint testpoint, final boolean testpointinside) { \/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } }","repo":"AliGhaff\/testLucene"}
{"id":10010,"comment_id":6,"comment":"\/\/ the testpoint was outside the shape. was that intended?","code":"static geopolygon generategeopolygon(final planetmodel planetmodel, final list<geopoint> filteredpointlist, final list<geopolygon> holes, final geopoint testpoint, final boolean testpointinside) { \/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } }","classification":"DESIGN","isFinished":true,"code_context_2":"return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built","code_context_10":"seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; }","code_context_20":"final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } }","repo":"AliGhaff\/testLucene"}
{"id":10010,"comment_id":7,"comment":"\/\/ yes: return what we just built","code":"static geopolygon generategeopolygon(final planetmodel planetmodel, final list<geopoint> filteredpointlist, final list<geopolygon> holes, final geopoint testpoint, final boolean testpointinside) { \/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; }","code_context_10":"return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } }","code_context_20":"\/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } }","repo":"AliGhaff\/testLucene"}
{"id":10010,"comment_id":8,"comment":"\/\/ no: return the complement","code":"static geopolygon generategeopolygon(final planetmodel planetmodel, final list<geopoint> filteredpointlist, final list<geopolygon> holes, final geopoint testpoint, final boolean testpointinside) { \/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find. final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); \/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities. geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } }","classification":"NONSATD","isFinished":true,"code_context_2":"return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean();","code_context_10":"rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } }","code_context_20":"if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { \/\/ the testpoint was within the shape. was that intended? if (testpointinside) { \/\/ yes: build it for real rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } \/\/ no: do the complement and return that. rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { \/\/ the testpoint was outside the shape. was that intended? if (!testpointinside) { \/\/ yes: return what we just built return rval; } \/\/ no: return the complement rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } }","repo":"AliGhaff\/testLucene"}
{"id":10073,"comment_id":0,"comment":"\/** * set the message content for this message. * * @param content message body as a string. *\/","code":"\/** * set the message content for this message. * * @param content message body as a string. *\/ public void setmessagecontent(byte[] content, boolean strict, boolean computecontentlength, int givenlength) throws parseexception { \/\/ note that that this could be a double byte character \/\/ set - bug report by masafumi watanabe computecontentlength(content); if ((!computecontentlength)) { if ((!strict && this.contentlengthheader.getcontentlength() != givenlength) || this.contentlengthheader.getcontentlength() < givenlength) { throw new parseexception(\"invalid content length \" + this.contentlengthheader.getcontentlength() + \" \/ \" + givenlength, 0); } } messagecontent = null; messagecontentbytes = content; messagecontentobject = null; }","classification":"NONSATD","isFinished":true,"code_context_2":"public void setmessagecontent(byte[] content, boolean strict, boolean computecontentlength, int givenlength) throws parseexception { \/\/ note that that this could be a double byte character \/\/ set - bug report by masafumi watanabe computecontentlength(content); if ((!computecontentlength)) { if ((!strict && this.contentlengthheader.getcontentlength() != givenlength) || this.contentlengthheader.getcontentlength() < givenlength) { throw new parseexception(\"invalid content length \" + this.contentlengthheader.getcontentlength() + \" \/ \" + givenlength, 0); } } messagecontent = null; messagecontentbytes = content; messagecontentobject = null; }","code_context_10":"public void setmessagecontent(byte[] content, boolean strict, boolean computecontentlength, int givenlength) throws parseexception { \/\/ note that that this could be a double byte character \/\/ set - bug report by masafumi watanabe computecontentlength(content); if ((!computecontentlength)) { if ((!strict && this.contentlengthheader.getcontentlength() != givenlength) || this.contentlengthheader.getcontentlength() < givenlength) { throw new parseexception(\"invalid content length \" + this.contentlengthheader.getcontentlength() + \" \/ \" + givenlength, 0); } } messagecontent = null; messagecontentbytes = content; messagecontentobject = null; }","code_context_20":"public void setmessagecontent(byte[] content, boolean strict, boolean computecontentlength, int givenlength) throws parseexception { \/\/ note that that this could be a double byte character \/\/ set - bug report by masafumi watanabe computecontentlength(content); if ((!computecontentlength)) { if ((!strict && this.contentlengthheader.getcontentlength() != givenlength) || this.contentlengthheader.getcontentlength() < givenlength) { throw new parseexception(\"invalid content length \" + this.contentlengthheader.getcontentlength() + \" \/ \" + givenlength, 0); } } messagecontent = null; messagecontentbytes = content; messagecontentobject = null; }","repo":"E-C-Group\/jsip"}
{"id":10073,"comment_id":1,"comment":"\/\/ note that that this could be a double byte character \/\/ set - bug report by masafumi watanabe","code":"public void setmessagecontent(byte[] content, boolean strict, boolean computecontentlength, int givenlength) throws parseexception { \/\/ note that that this could be a double byte character \/\/ set - bug report by masafumi watanabe computecontentlength(content); if ((!computecontentlength)) { if ((!strict && this.contentlengthheader.getcontentlength() != givenlength) || this.contentlengthheader.getcontentlength() < givenlength) { throw new parseexception(\"invalid content length \" + this.contentlengthheader.getcontentlength() + \" \/ \" + givenlength, 0); } } messagecontent = null; messagecontentbytes = content; messagecontentobject = null; }","classification":"DEFECT","isFinished":true,"code_context_2":"public void setmessagecontent(byte[] content, boolean strict, boolean computecontentlength, int givenlength) throws parseexception { \/\/ note that that this could be a double byte character \/\/ set - bug report by masafumi watanabe computecontentlength(content); if ((!computecontentlength)) {","code_context_10":"public void setmessagecontent(byte[] content, boolean strict, boolean computecontentlength, int givenlength) throws parseexception { \/\/ note that that this could be a double byte character \/\/ set - bug report by masafumi watanabe computecontentlength(content); if ((!computecontentlength)) { if ((!strict && this.contentlengthheader.getcontentlength() != givenlength) || this.contentlengthheader.getcontentlength() < givenlength) { throw new parseexception(\"invalid content length \" + this.contentlengthheader.getcontentlength() + \" \/ \" + givenlength, 0); } } messagecontent = null; messagecontentbytes = content;","code_context_20":"public void setmessagecontent(byte[] content, boolean strict, boolean computecontentlength, int givenlength) throws parseexception { \/\/ note that that this could be a double byte character \/\/ set - bug report by masafumi watanabe computecontentlength(content); if ((!computecontentlength)) { if ((!strict && this.contentlengthheader.getcontentlength() != givenlength) || this.contentlengthheader.getcontentlength() < givenlength) { throw new parseexception(\"invalid content length \" + this.contentlengthheader.getcontentlength() + \" \/ \" + givenlength, 0); } } messagecontent = null; messagecontentbytes = content; messagecontentobject = null; }","repo":"E-C-Group\/jsip"}
{"id":2275,"comment_id":0,"comment":"\/\/mrenderthread = new renderthread(getresources(), surface, v); \/\/init","code":"void dojob() { \/\/mrenderthread = new renderthread(getresources(), surface, v); \/\/init final textureview tv = (textureview) findviewbyid(r.id.textureview1); surfacetexture surface = tv.getsurfacetexture(); texsurfacerendertarget rt = new texsurfacerendertarget(); view view = getwindow().getdecorview(); rt.init(surface); rt.begin(); int[] buf = new int[1]; glgentextures(1, buf, 0); int texname = buf[0]; glbindtexture(gles11ext.gl_texture_external_oes , texname); gltexparameterf(gl_texture_2d, gl_texture_min_filter, gl_nearest); gltexparameterf(gl_texture_2d, gl_texture_mag_filter, gl_linear); gltexparameteri(gl_texture_2d, gl_texture_wrap_s, gl_repeat); gltexparameteri(gl_texture_2d, gl_texture_wrap_t, gl_repeat); floatbuffer trianglevertices = bytebuffer.allocatedirect(mtriangleverticesdata.length * float_size_bytes).order(byteorder.nativeorder()).asfloatbuffer(); trianglevertices.put(mtriangleverticesdata).position(0); int program = buildprogram(ssimplevs, sbasicfs \/*ssimplefs*\/); int attribposition = glgetattriblocation(program, \"position\"); checkglerror(); int attribtexcoords = glgetattriblocation(program, \"texcoords\"); checkglerror(); int uniformtexture = glgetuniformlocation(program, \"texture\"); checkglerror(); int texturetranformhandle = glgetuniformlocation(program, \"texturetransform\"); checkglerror(); surfacetexture tex = new surfacetexture(texname);\/\/todo: wait for onframeavailable() ?? hwuirender render = hwuirender.create(this); render.setsurface(tex); \/\/draw for(int i=0;i<1;++i) { long starttime = system.currenttimemillis(); render.drawtosurface(view); rt.begin();\/\/todo: replace on check & makecurrent tex.updateteximage(); float[] textransform = new float[16]; tex.gettransformmatrix(textransform); glbindtexture(gles11ext.gl_texture_external_oes , texname); checkglerror(); gluseprogram(program); checkglerror(); glenablevertexattribarray(attribposition); checkglerror(); glenablevertexattribarray(attribtexcoords); checkglerror(); gluniform1i(uniformtexture, 0); gluniformmatrix4fv(texturetranformhandle, 1, false, textransform, 0); checkglerror(); trianglevertices.position(triangle_vertices_data_pos_offset); glvertexattribpointer(attribposition, 3, gl_float, false, triangle_vertices_data_stride_bytes, trianglevertices); checkglerror(); trianglevertices.position(triangle_vertices_data_uv_offset); glvertexattribpointer(attribtexcoords, 3, gl_float, false, triangle_vertices_data_stride_bytes, trianglevertices); gldrawarrays(gl_triangle_strip, 0, 4); rt.end(); mtogglebutton.settext(\"\" + (system.currenttimemillis() - starttime)); } render.setsurface(null); \/\/rt.cleanup(); }","classification":"NONSATD","isFinished":true,"code_context_2":"void dojob() { \/\/mrenderthread = new renderthread(getresources(), surface, v); \/\/init final textureview tv = (textureview) findviewbyid(r.id.textureview1); surfacetexture surface = tv.getsurfacetexture();","code_context_10":"void dojob() { \/\/mrenderthread = new renderthread(getresources(), surface, v); \/\/init final textureview tv = (textureview) findviewbyid(r.id.textureview1); surfacetexture surface = tv.getsurfacetexture(); texsurfacerendertarget rt = new texsurfacerendertarget(); view view = getwindow().getdecorview(); rt.init(surface); rt.begin(); int[] buf = new int[1]; glgentextures(1, buf, 0); int texname = buf[0]; glbindtexture(gles11ext.gl_texture_external_oes , texname);","code_context_20":"void dojob() { \/\/mrenderthread = new renderthread(getresources(), surface, v); \/\/init final textureview tv = (textureview) findviewbyid(r.id.textureview1); surfacetexture surface = tv.getsurfacetexture(); texsurfacerendertarget rt = new texsurfacerendertarget(); view view = getwindow().getdecorview(); rt.init(surface); rt.begin(); int[] buf = new int[1]; glgentextures(1, buf, 0); int texname = buf[0]; glbindtexture(gles11ext.gl_texture_external_oes , texname); gltexparameterf(gl_texture_2d, gl_texture_min_filter, gl_nearest); gltexparameterf(gl_texture_2d, gl_texture_mag_filter, gl_linear); gltexparameteri(gl_texture_2d, gl_texture_wrap_s, gl_repeat); gltexparameteri(gl_texture_2d, gl_texture_wrap_t, gl_repeat); floatbuffer trianglevertices = bytebuffer.allocatedirect(mtriangleverticesdata.length * float_size_bytes).order(byteorder.nativeorder()).asfloatbuffer(); trianglevertices.put(mtriangleverticesdata).position(0); int program = buildprogram(ssimplevs, sbasicfs \/*ssimplefs*\/); int attribposition = glgetattriblocation(program, \"position\"); checkglerror();","repo":"ChGen\/AndroidGpuGraphicsTest"}
{"id":2275,"comment_id":1,"comment":"\/*ssimplefs*\/","code":"void dojob() { \/\/mrenderthread = new renderthread(getresources(), surface, v); \/\/init final textureview tv = (textureview) findviewbyid(r.id.textureview1); surfacetexture surface = tv.getsurfacetexture(); texsurfacerendertarget rt = new texsurfacerendertarget(); view view = getwindow().getdecorview(); rt.init(surface); rt.begin(); int[] buf = new int[1]; glgentextures(1, buf, 0); int texname = buf[0]; glbindtexture(gles11ext.gl_texture_external_oes , texname); gltexparameterf(gl_texture_2d, gl_texture_min_filter, gl_nearest); gltexparameterf(gl_texture_2d, gl_texture_mag_filter, gl_linear); gltexparameteri(gl_texture_2d, gl_texture_wrap_s, gl_repeat); gltexparameteri(gl_texture_2d, gl_texture_wrap_t, gl_repeat); floatbuffer trianglevertices = bytebuffer.allocatedirect(mtriangleverticesdata.length * float_size_bytes).order(byteorder.nativeorder()).asfloatbuffer(); trianglevertices.put(mtriangleverticesdata).position(0); int program = buildprogram(ssimplevs, sbasicfs \/*ssimplefs*\/); int attribposition = glgetattriblocation(program, \"position\"); checkglerror(); int attribtexcoords = glgetattriblocation(program, \"texcoords\"); checkglerror(); int uniformtexture = glgetuniformlocation(program, \"texture\"); checkglerror(); int texturetranformhandle = glgetuniformlocation(program, \"texturetransform\"); checkglerror(); surfacetexture tex = new surfacetexture(texname);\/\/todo: wait for onframeavailable() ?? hwuirender render = hwuirender.create(this); render.setsurface(tex); \/\/draw for(int i=0;i<1;++i) { long starttime = system.currenttimemillis(); render.drawtosurface(view); rt.begin();\/\/todo: replace on check & makecurrent tex.updateteximage(); float[] textransform = new float[16]; tex.gettransformmatrix(textransform); glbindtexture(gles11ext.gl_texture_external_oes , texname); checkglerror(); gluseprogram(program); checkglerror(); glenablevertexattribarray(attribposition); checkglerror(); glenablevertexattribarray(attribtexcoords); checkglerror(); gluniform1i(uniformtexture, 0); gluniformmatrix4fv(texturetranformhandle, 1, false, textransform, 0); checkglerror(); trianglevertices.position(triangle_vertices_data_pos_offset); glvertexattribpointer(attribposition, 3, gl_float, false, triangle_vertices_data_stride_bytes, trianglevertices); checkglerror(); trianglevertices.position(triangle_vertices_data_uv_offset); glvertexattribpointer(attribtexcoords, 3, gl_float, false, triangle_vertices_data_stride_bytes, trianglevertices); gldrawarrays(gl_triangle_strip, 0, 4); rt.end(); mtogglebutton.settext(\"\" + (system.currenttimemillis() - starttime)); } render.setsurface(null); \/\/rt.cleanup(); }","classification":"NONSATD","isFinished":true,"code_context_2":"* float_size_bytes).order(byteorder.nativeorder()).asfloatbuffer(); trianglevertices.put(mtriangleverticesdata).position(0); int program = buildprogram(ssimplevs, sbasicfs \/*ssimplefs*\/); int attribposition = glgetattriblocation(program, \"position\"); checkglerror();","code_context_10":"glgentextures(1, buf, 0); int texname = buf[0]; glbindtexture(gles11ext.gl_texture_external_oes , texname); gltexparameterf(gl_texture_2d, gl_texture_min_filter, gl_nearest); gltexparameterf(gl_texture_2d, gl_texture_mag_filter, gl_linear); gltexparameteri(gl_texture_2d, gl_texture_wrap_s, gl_repeat); gltexparameteri(gl_texture_2d, gl_texture_wrap_t, gl_repeat); floatbuffer trianglevertices = bytebuffer.allocatedirect(mtriangleverticesdata.length * float_size_bytes).order(byteorder.nativeorder()).asfloatbuffer(); trianglevertices.put(mtriangleverticesdata).position(0); int program = buildprogram(ssimplevs, sbasicfs \/*ssimplefs*\/); int attribposition = glgetattriblocation(program, \"position\"); checkglerror(); int attribtexcoords = glgetattriblocation(program, \"texcoords\"); checkglerror(); int uniformtexture = glgetuniformlocation(program, \"texture\"); checkglerror(); int texturetranformhandle = glgetuniformlocation(program, \"texturetransform\"); checkglerror(); surfacetexture tex = new surfacetexture(texname);\/\/todo: wait for onframeavailable() ?? hwuirender render = hwuirender.create(this);","code_context_20":"void dojob() { \/\/mrenderthread = new renderthread(getresources(), surface, v); \/\/init final textureview tv = (textureview) findviewbyid(r.id.textureview1); surfacetexture surface = tv.getsurfacetexture(); texsurfacerendertarget rt = new texsurfacerendertarget(); view view = getwindow().getdecorview(); rt.init(surface); rt.begin(); int[] buf = new int[1]; glgentextures(1, buf, 0); int texname = buf[0]; glbindtexture(gles11ext.gl_texture_external_oes , texname); gltexparameterf(gl_texture_2d, gl_texture_min_filter, gl_nearest); gltexparameterf(gl_texture_2d, gl_texture_mag_filter, gl_linear); gltexparameteri(gl_texture_2d, gl_texture_wrap_s, gl_repeat); gltexparameteri(gl_texture_2d, gl_texture_wrap_t, gl_repeat); floatbuffer trianglevertices = bytebuffer.allocatedirect(mtriangleverticesdata.length * float_size_bytes).order(byteorder.nativeorder()).asfloatbuffer(); trianglevertices.put(mtriangleverticesdata).position(0); int program = buildprogram(ssimplevs, sbasicfs \/*ssimplefs*\/); int attribposition = glgetattriblocation(program, \"position\"); checkglerror(); int attribtexcoords = glgetattriblocation(program, \"texcoords\"); checkglerror(); int uniformtexture = glgetuniformlocation(program, \"texture\"); checkglerror(); int texturetranformhandle = glgetuniformlocation(program, \"texturetransform\"); checkglerror(); surfacetexture tex = new surfacetexture(texname);\/\/todo: wait for onframeavailable() ?? hwuirender render = hwuirender.create(this); render.setsurface(tex); \/\/draw for(int i=0;i<1;++i) { long starttime = system.currenttimemillis(); render.drawtosurface(view); rt.begin();\/\/todo: replace on check & makecurrent tex.updateteximage(); float[] textransform = new float[16]; tex.gettransformmatrix(textransform); glbindtexture(gles11ext.gl_texture_external_oes , texname);","repo":"ChGen\/AndroidGpuGraphicsTest"}
{"id":2275,"comment_id":2,"comment":"\/\/todo: wait for onframeavailable() ??","code":"void dojob() { \/\/mrenderthread = new renderthread(getresources(), surface, v); \/\/init final textureview tv = (textureview) findviewbyid(r.id.textureview1); surfacetexture surface = tv.getsurfacetexture(); texsurfacerendertarget rt = new texsurfacerendertarget(); view view = getwindow().getdecorview(); rt.init(surface); rt.begin(); int[] buf = new int[1]; glgentextures(1, buf, 0); int texname = buf[0]; glbindtexture(gles11ext.gl_texture_external_oes , texname); gltexparameterf(gl_texture_2d, gl_texture_min_filter, gl_nearest); gltexparameterf(gl_texture_2d, gl_texture_mag_filter, gl_linear); gltexparameteri(gl_texture_2d, gl_texture_wrap_s, gl_repeat); gltexparameteri(gl_texture_2d, gl_texture_wrap_t, gl_repeat); floatbuffer trianglevertices = bytebuffer.allocatedirect(mtriangleverticesdata.length * float_size_bytes).order(byteorder.nativeorder()).asfloatbuffer(); trianglevertices.put(mtriangleverticesdata).position(0); int program = buildprogram(ssimplevs, sbasicfs \/*ssimplefs*\/); int attribposition = glgetattriblocation(program, \"position\"); checkglerror(); int attribtexcoords = glgetattriblocation(program, \"texcoords\"); checkglerror(); int uniformtexture = glgetuniformlocation(program, \"texture\"); checkglerror(); int texturetranformhandle = glgetuniformlocation(program, \"texturetransform\"); checkglerror(); surfacetexture tex = new surfacetexture(texname);\/\/todo: wait for onframeavailable() ?? hwuirender render = hwuirender.create(this); render.setsurface(tex); \/\/draw for(int i=0;i<1;++i) { long starttime = system.currenttimemillis(); render.drawtosurface(view); rt.begin();\/\/todo: replace on check & makecurrent tex.updateteximage(); float[] textransform = new float[16]; tex.gettransformmatrix(textransform); glbindtexture(gles11ext.gl_texture_external_oes , texname); checkglerror(); gluseprogram(program); checkglerror(); glenablevertexattribarray(attribposition); checkglerror(); glenablevertexattribarray(attribtexcoords); checkglerror(); gluniform1i(uniformtexture, 0); gluniformmatrix4fv(texturetranformhandle, 1, false, textransform, 0); checkglerror(); trianglevertices.position(triangle_vertices_data_pos_offset); glvertexattribpointer(attribposition, 3, gl_float, false, triangle_vertices_data_stride_bytes, trianglevertices); checkglerror(); trianglevertices.position(triangle_vertices_data_uv_offset); glvertexattribpointer(attribtexcoords, 3, gl_float, false, triangle_vertices_data_stride_bytes, trianglevertices); gldrawarrays(gl_triangle_strip, 0, 4); rt.end(); mtogglebutton.settext(\"\" + (system.currenttimemillis() - starttime)); } render.setsurface(null); \/\/rt.cleanup(); }","classification":"NONSATD","isFinished":true,"code_context_2":"int texturetranformhandle = glgetuniformlocation(program, \"texturetransform\"); checkglerror(); surfacetexture tex = new surfacetexture(texname);\/\/todo: wait for onframeavailable() ?? hwuirender render = hwuirender.create(this); render.setsurface(tex);","code_context_10":"trianglevertices.put(mtriangleverticesdata).position(0); int program = buildprogram(ssimplevs, sbasicfs \/*ssimplefs*\/); int attribposition = glgetattriblocation(program, \"position\"); checkglerror(); int attribtexcoords = glgetattriblocation(program, \"texcoords\"); checkglerror(); int uniformtexture = glgetuniformlocation(program, \"texture\"); checkglerror(); int texturetranformhandle = glgetuniformlocation(program, \"texturetransform\"); checkglerror(); surfacetexture tex = new surfacetexture(texname);\/\/todo: wait for onframeavailable() ?? hwuirender render = hwuirender.create(this); render.setsurface(tex); \/\/draw for(int i=0;i<1;++i) { long starttime = system.currenttimemillis(); render.drawtosurface(view); rt.begin();\/\/todo: replace on check & makecurrent tex.updateteximage(); float[] textransform = new float[16]; tex.gettransformmatrix(textransform);","code_context_20":"int[] buf = new int[1]; glgentextures(1, buf, 0); int texname = buf[0]; glbindtexture(gles11ext.gl_texture_external_oes , texname); gltexparameterf(gl_texture_2d, gl_texture_min_filter, gl_nearest); gltexparameterf(gl_texture_2d, gl_texture_mag_filter, gl_linear); gltexparameteri(gl_texture_2d, gl_texture_wrap_s, gl_repeat); gltexparameteri(gl_texture_2d, gl_texture_wrap_t, gl_repeat); floatbuffer trianglevertices = bytebuffer.allocatedirect(mtriangleverticesdata.length * float_size_bytes).order(byteorder.nativeorder()).asfloatbuffer(); trianglevertices.put(mtriangleverticesdata).position(0); int program = buildprogram(ssimplevs, sbasicfs \/*ssimplefs*\/); int attribposition = glgetattriblocation(program, \"position\"); checkglerror(); int attribtexcoords = glgetattriblocation(program, \"texcoords\"); checkglerror(); int uniformtexture = glgetuniformlocation(program, \"texture\"); checkglerror(); int texturetranformhandle = glgetuniformlocation(program, \"texturetransform\"); checkglerror(); surfacetexture tex = new surfacetexture(texname);\/\/todo: wait for onframeavailable() ?? hwuirender render = hwuirender.create(this); render.setsurface(tex); \/\/draw for(int i=0;i<1;++i) { long starttime = system.currenttimemillis(); render.drawtosurface(view); rt.begin();\/\/todo: replace on check & makecurrent tex.updateteximage(); float[] textransform = new float[16]; tex.gettransformmatrix(textransform); glbindtexture(gles11ext.gl_texture_external_oes , texname); checkglerror(); gluseprogram(program); checkglerror(); glenablevertexattribarray(attribposition); checkglerror(); glenablevertexattribarray(attribtexcoords); checkglerror(); gluniform1i(uniformtexture, 0); gluniformmatrix4fv(texturetranformhandle, 1, false, textransform, 0);","repo":"ChGen\/AndroidGpuGraphicsTest"}
{"id":2275,"comment_id":3,"comment":"\/\/draw","code":"void dojob() { \/\/mrenderthread = new renderthread(getresources(), surface, v); \/\/init final textureview tv = (textureview) findviewbyid(r.id.textureview1); surfacetexture surface = tv.getsurfacetexture(); texsurfacerendertarget rt = new texsurfacerendertarget(); view view = getwindow().getdecorview(); rt.init(surface); rt.begin(); int[] buf = new int[1]; glgentextures(1, buf, 0); int texname = buf[0]; glbindtexture(gles11ext.gl_texture_external_oes , texname); gltexparameterf(gl_texture_2d, gl_texture_min_filter, gl_nearest); gltexparameterf(gl_texture_2d, gl_texture_mag_filter, gl_linear); gltexparameteri(gl_texture_2d, gl_texture_wrap_s, gl_repeat); gltexparameteri(gl_texture_2d, gl_texture_wrap_t, gl_repeat); floatbuffer trianglevertices = bytebuffer.allocatedirect(mtriangleverticesdata.length * float_size_bytes).order(byteorder.nativeorder()).asfloatbuffer(); trianglevertices.put(mtriangleverticesdata).position(0); int program = buildprogram(ssimplevs, sbasicfs \/*ssimplefs*\/); int attribposition = glgetattriblocation(program, \"position\"); checkglerror(); int attribtexcoords = glgetattriblocation(program, \"texcoords\"); checkglerror(); int uniformtexture = glgetuniformlocation(program, \"texture\"); checkglerror(); int texturetranformhandle = glgetuniformlocation(program, \"texturetransform\"); checkglerror(); surfacetexture tex = new surfacetexture(texname);\/\/todo: wait for onframeavailable() ?? hwuirender render = hwuirender.create(this); render.setsurface(tex); \/\/draw for(int i=0;i<1;++i) { long starttime = system.currenttimemillis(); render.drawtosurface(view); rt.begin();\/\/todo: replace on check & makecurrent tex.updateteximage(); float[] textransform = new float[16]; tex.gettransformmatrix(textransform); glbindtexture(gles11ext.gl_texture_external_oes , texname); checkglerror(); gluseprogram(program); checkglerror(); glenablevertexattribarray(attribposition); checkglerror(); glenablevertexattribarray(attribtexcoords); checkglerror(); gluniform1i(uniformtexture, 0); gluniformmatrix4fv(texturetranformhandle, 1, false, textransform, 0); checkglerror(); trianglevertices.position(triangle_vertices_data_pos_offset); glvertexattribpointer(attribposition, 3, gl_float, false, triangle_vertices_data_stride_bytes, trianglevertices); checkglerror(); trianglevertices.position(triangle_vertices_data_uv_offset); glvertexattribpointer(attribtexcoords, 3, gl_float, false, triangle_vertices_data_stride_bytes, trianglevertices); gldrawarrays(gl_triangle_strip, 0, 4); rt.end(); mtogglebutton.settext(\"\" + (system.currenttimemillis() - starttime)); } render.setsurface(null); \/\/rt.cleanup(); }","classification":"NONSATD","isFinished":true,"code_context_2":"hwuirender render = hwuirender.create(this); render.setsurface(tex); \/\/draw for(int i=0;i<1;++i) { long starttime = system.currenttimemillis();","code_context_10":"checkglerror(); int attribtexcoords = glgetattriblocation(program, \"texcoords\"); checkglerror(); int uniformtexture = glgetuniformlocation(program, \"texture\"); checkglerror(); int texturetranformhandle = glgetuniformlocation(program, \"texturetransform\"); checkglerror(); surfacetexture tex = new surfacetexture(texname);\/\/todo: wait for onframeavailable() ?? hwuirender render = hwuirender.create(this); render.setsurface(tex); \/\/draw for(int i=0;i<1;++i) { long starttime = system.currenttimemillis(); render.drawtosurface(view); rt.begin();\/\/todo: replace on check & makecurrent tex.updateteximage(); float[] textransform = new float[16]; tex.gettransformmatrix(textransform); glbindtexture(gles11ext.gl_texture_external_oes , texname); checkglerror(); gluseprogram(program);","code_context_20":"glbindtexture(gles11ext.gl_texture_external_oes , texname); gltexparameterf(gl_texture_2d, gl_texture_min_filter, gl_nearest); gltexparameterf(gl_texture_2d, gl_texture_mag_filter, gl_linear); gltexparameteri(gl_texture_2d, gl_texture_wrap_s, gl_repeat); gltexparameteri(gl_texture_2d, gl_texture_wrap_t, gl_repeat); floatbuffer trianglevertices = bytebuffer.allocatedirect(mtriangleverticesdata.length * float_size_bytes).order(byteorder.nativeorder()).asfloatbuffer(); trianglevertices.put(mtriangleverticesdata).position(0); int program = buildprogram(ssimplevs, sbasicfs \/*ssimplefs*\/); int attribposition = glgetattriblocation(program, \"position\"); checkglerror(); int attribtexcoords = glgetattriblocation(program, \"texcoords\"); checkglerror(); int uniformtexture = glgetuniformlocation(program, \"texture\"); checkglerror(); int texturetranformhandle = glgetuniformlocation(program, \"texturetransform\"); checkglerror(); surfacetexture tex = new surfacetexture(texname);\/\/todo: wait for onframeavailable() ?? hwuirender render = hwuirender.create(this); render.setsurface(tex); \/\/draw for(int i=0;i<1;++i) { long starttime = system.currenttimemillis(); render.drawtosurface(view); rt.begin();\/\/todo: replace on check & makecurrent tex.updateteximage(); float[] textransform = new float[16]; tex.gettransformmatrix(textransform); glbindtexture(gles11ext.gl_texture_external_oes , texname); checkglerror(); gluseprogram(program); checkglerror(); glenablevertexattribarray(attribposition); checkglerror(); glenablevertexattribarray(attribtexcoords); checkglerror(); gluniform1i(uniformtexture, 0); gluniformmatrix4fv(texturetranformhandle, 1, false, textransform, 0); checkglerror(); trianglevertices.position(triangle_vertices_data_pos_offset); glvertexattribpointer(attribposition, 3, gl_float, false,","repo":"ChGen\/AndroidGpuGraphicsTest"}
{"id":2275,"comment_id":4,"comment":"\/\/todo: replace on check & makecurrent","code":"void dojob() { \/\/mrenderthread = new renderthread(getresources(), surface, v); \/\/init final textureview tv = (textureview) findviewbyid(r.id.textureview1); surfacetexture surface = tv.getsurfacetexture(); texsurfacerendertarget rt = new texsurfacerendertarget(); view view = getwindow().getdecorview(); rt.init(surface); rt.begin(); int[] buf = new int[1]; glgentextures(1, buf, 0); int texname = buf[0]; glbindtexture(gles11ext.gl_texture_external_oes , texname); gltexparameterf(gl_texture_2d, gl_texture_min_filter, gl_nearest); gltexparameterf(gl_texture_2d, gl_texture_mag_filter, gl_linear); gltexparameteri(gl_texture_2d, gl_texture_wrap_s, gl_repeat); gltexparameteri(gl_texture_2d, gl_texture_wrap_t, gl_repeat); floatbuffer trianglevertices = bytebuffer.allocatedirect(mtriangleverticesdata.length * float_size_bytes).order(byteorder.nativeorder()).asfloatbuffer(); trianglevertices.put(mtriangleverticesdata).position(0); int program = buildprogram(ssimplevs, sbasicfs \/*ssimplefs*\/); int attribposition = glgetattriblocation(program, \"position\"); checkglerror(); int attribtexcoords = glgetattriblocation(program, \"texcoords\"); checkglerror(); int uniformtexture = glgetuniformlocation(program, \"texture\"); checkglerror(); int texturetranformhandle = glgetuniformlocation(program, \"texturetransform\"); checkglerror(); surfacetexture tex = new surfacetexture(texname);\/\/todo: wait for onframeavailable() ?? hwuirender render = hwuirender.create(this); render.setsurface(tex); \/\/draw for(int i=0;i<1;++i) { long starttime = system.currenttimemillis(); render.drawtosurface(view); rt.begin();\/\/todo: replace on check & makecurrent tex.updateteximage(); float[] textransform = new float[16]; tex.gettransformmatrix(textransform); glbindtexture(gles11ext.gl_texture_external_oes , texname); checkglerror(); gluseprogram(program); checkglerror(); glenablevertexattribarray(attribposition); checkglerror(); glenablevertexattribarray(attribtexcoords); checkglerror(); gluniform1i(uniformtexture, 0); gluniformmatrix4fv(texturetranformhandle, 1, false, textransform, 0); checkglerror(); trianglevertices.position(triangle_vertices_data_pos_offset); glvertexattribpointer(attribposition, 3, gl_float, false, triangle_vertices_data_stride_bytes, trianglevertices); checkglerror(); trianglevertices.position(triangle_vertices_data_uv_offset); glvertexattribpointer(attribtexcoords, 3, gl_float, false, triangle_vertices_data_stride_bytes, trianglevertices); gldrawarrays(gl_triangle_strip, 0, 4); rt.end(); mtogglebutton.settext(\"\" + (system.currenttimemillis() - starttime)); } render.setsurface(null); \/\/rt.cleanup(); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"long starttime = system.currenttimemillis(); render.drawtosurface(view); rt.begin();\/\/todo: replace on check & makecurrent tex.updateteximage(); float[] textransform = new float[16];","code_context_10":"checkglerror(); int texturetranformhandle = glgetuniformlocation(program, \"texturetransform\"); checkglerror(); surfacetexture tex = new surfacetexture(texname);\/\/todo: wait for onframeavailable() ?? hwuirender render = hwuirender.create(this); render.setsurface(tex); \/\/draw for(int i=0;i<1;++i) { long starttime = system.currenttimemillis(); render.drawtosurface(view); rt.begin();\/\/todo: replace on check & makecurrent tex.updateteximage(); float[] textransform = new float[16]; tex.gettransformmatrix(textransform); glbindtexture(gles11ext.gl_texture_external_oes , texname); checkglerror(); gluseprogram(program); checkglerror(); glenablevertexattribarray(attribposition); checkglerror(); glenablevertexattribarray(attribtexcoords);","code_context_20":"gltexparameteri(gl_texture_2d, gl_texture_wrap_t, gl_repeat); floatbuffer trianglevertices = bytebuffer.allocatedirect(mtriangleverticesdata.length * float_size_bytes).order(byteorder.nativeorder()).asfloatbuffer(); trianglevertices.put(mtriangleverticesdata).position(0); int program = buildprogram(ssimplevs, sbasicfs \/*ssimplefs*\/); int attribposition = glgetattriblocation(program, \"position\"); checkglerror(); int attribtexcoords = glgetattriblocation(program, \"texcoords\"); checkglerror(); int uniformtexture = glgetuniformlocation(program, \"texture\"); checkglerror(); int texturetranformhandle = glgetuniformlocation(program, \"texturetransform\"); checkglerror(); surfacetexture tex = new surfacetexture(texname);\/\/todo: wait for onframeavailable() ?? hwuirender render = hwuirender.create(this); render.setsurface(tex); \/\/draw for(int i=0;i<1;++i) { long starttime = system.currenttimemillis(); render.drawtosurface(view); rt.begin();\/\/todo: replace on check & makecurrent tex.updateteximage(); float[] textransform = new float[16]; tex.gettransformmatrix(textransform); glbindtexture(gles11ext.gl_texture_external_oes , texname); checkglerror(); gluseprogram(program); checkglerror(); glenablevertexattribarray(attribposition); checkglerror(); glenablevertexattribarray(attribtexcoords); checkglerror(); gluniform1i(uniformtexture, 0); gluniformmatrix4fv(texturetranformhandle, 1, false, textransform, 0); checkglerror(); trianglevertices.position(triangle_vertices_data_pos_offset); glvertexattribpointer(attribposition, 3, gl_float, false, triangle_vertices_data_stride_bytes, trianglevertices); checkglerror(); trianglevertices.position(triangle_vertices_data_uv_offset); glvertexattribpointer(attribtexcoords, 3, gl_float, false,","repo":"ChGen\/AndroidGpuGraphicsTest"}
{"id":2275,"comment_id":5,"comment":"\/\/rt.cleanup();","code":"void dojob() { \/\/mrenderthread = new renderthread(getresources(), surface, v); \/\/init final textureview tv = (textureview) findviewbyid(r.id.textureview1); surfacetexture surface = tv.getsurfacetexture(); texsurfacerendertarget rt = new texsurfacerendertarget(); view view = getwindow().getdecorview(); rt.init(surface); rt.begin(); int[] buf = new int[1]; glgentextures(1, buf, 0); int texname = buf[0]; glbindtexture(gles11ext.gl_texture_external_oes , texname); gltexparameterf(gl_texture_2d, gl_texture_min_filter, gl_nearest); gltexparameterf(gl_texture_2d, gl_texture_mag_filter, gl_linear); gltexparameteri(gl_texture_2d, gl_texture_wrap_s, gl_repeat); gltexparameteri(gl_texture_2d, gl_texture_wrap_t, gl_repeat); floatbuffer trianglevertices = bytebuffer.allocatedirect(mtriangleverticesdata.length * float_size_bytes).order(byteorder.nativeorder()).asfloatbuffer(); trianglevertices.put(mtriangleverticesdata).position(0); int program = buildprogram(ssimplevs, sbasicfs \/*ssimplefs*\/); int attribposition = glgetattriblocation(program, \"position\"); checkglerror(); int attribtexcoords = glgetattriblocation(program, \"texcoords\"); checkglerror(); int uniformtexture = glgetuniformlocation(program, \"texture\"); checkglerror(); int texturetranformhandle = glgetuniformlocation(program, \"texturetransform\"); checkglerror(); surfacetexture tex = new surfacetexture(texname);\/\/todo: wait for onframeavailable() ?? hwuirender render = hwuirender.create(this); render.setsurface(tex); \/\/draw for(int i=0;i<1;++i) { long starttime = system.currenttimemillis(); render.drawtosurface(view); rt.begin();\/\/todo: replace on check & makecurrent tex.updateteximage(); float[] textransform = new float[16]; tex.gettransformmatrix(textransform); glbindtexture(gles11ext.gl_texture_external_oes , texname); checkglerror(); gluseprogram(program); checkglerror(); glenablevertexattribarray(attribposition); checkglerror(); glenablevertexattribarray(attribtexcoords); checkglerror(); gluniform1i(uniformtexture, 0); gluniformmatrix4fv(texturetranformhandle, 1, false, textransform, 0); checkglerror(); trianglevertices.position(triangle_vertices_data_pos_offset); glvertexattribpointer(attribposition, 3, gl_float, false, triangle_vertices_data_stride_bytes, trianglevertices); checkglerror(); trianglevertices.position(triangle_vertices_data_uv_offset); glvertexattribpointer(attribtexcoords, 3, gl_float, false, triangle_vertices_data_stride_bytes, trianglevertices); gldrawarrays(gl_triangle_strip, 0, 4); rt.end(); mtogglebutton.settext(\"\" + (system.currenttimemillis() - starttime)); } render.setsurface(null); \/\/rt.cleanup(); }","classification":"NONSATD","isFinished":true,"code_context_2":"} render.setsurface(null); \/\/rt.cleanup(); }","code_context_10":"triangle_vertices_data_stride_bytes, trianglevertices); checkglerror(); trianglevertices.position(triangle_vertices_data_uv_offset); glvertexattribpointer(attribtexcoords, 3, gl_float, false, triangle_vertices_data_stride_bytes, trianglevertices); gldrawarrays(gl_triangle_strip, 0, 4); rt.end(); mtogglebutton.settext(\"\" + (system.currenttimemillis() - starttime)); } render.setsurface(null); \/\/rt.cleanup(); }","code_context_20":"checkglerror(); glenablevertexattribarray(attribposition); checkglerror(); glenablevertexattribarray(attribtexcoords); checkglerror(); gluniform1i(uniformtexture, 0); gluniformmatrix4fv(texturetranformhandle, 1, false, textransform, 0); checkglerror(); trianglevertices.position(triangle_vertices_data_pos_offset); glvertexattribpointer(attribposition, 3, gl_float, false, triangle_vertices_data_stride_bytes, trianglevertices); checkglerror(); trianglevertices.position(triangle_vertices_data_uv_offset); glvertexattribpointer(attribtexcoords, 3, gl_float, false, triangle_vertices_data_stride_bytes, trianglevertices); gldrawarrays(gl_triangle_strip, 0, 4); rt.end(); mtogglebutton.settext(\"\" + (system.currenttimemillis() - starttime)); } render.setsurface(null); \/\/rt.cleanup(); }","repo":"ChGen\/AndroidGpuGraphicsTest"}
{"id":18664,"comment_id":0,"comment":"\/** * fixme: delete this test with a workaround in the grafanaannotationtagstransformer * * @throws ioexception should never happen *\/","code":"\/** * fixme: delete this test with a workaround in the grafanaannotationtagstransformer * * @throws ioexception should never happen *\/ @test public void shouldaddnullsubprojectifprojectisdefined() throws ioexception { event event = eventbuilder.create(0, \"11203800-63fd-11e8-83e2-3a587d902000\"). tag(\"description\", variant.ofstring(\"this is the annotation\")). tag(\"tags\", variant.ofvector(vector.ofcontainers( container.builder().tag(\"key\", variant.ofstring(\"environment\")).tag(\"value\", variant.ofstring(\"staging\")).build(), container.builder().tag(\"key\", variant.ofstring(\"project\")).tag(\"value\", variant.ofstring(\"test\")).build()))). build(); properties properties = new properties(); properties.setproperty(\"file\", \"resource:\/\/annotation-event.mapping\"); eventtojsonformatter formatter = new eventtojsonformatter(properties); bytearrayoutputstream stream = new bytearrayoutputstream(); documentwriter.writeto(stream, formatter.format(event)); assertequals(\"{\" + \"\\\"@timestamp\\\":\\\"1970-01-01t00:00:00.000000000z\\\",\" + \"\\\"environment\\\":\\\"staging\\\",\" + \"\\\"project\\\":\\\"test\\\",\" + \"\\\"tags\\\":\\\"environment=staging,project=test,subproject=null\\\",\" + \"\\\"description\\\":\\\"this is the annotation\\\"\" + \"}\", stream.tostring(standardcharsets.utf_8.name()) ); }","classification":"DESIGN","isFinished":true,"code_context_2":"@test public void shouldaddnullsubprojectifprojectisdefined() throws ioexception { event event = eventbuilder.create(0, \"11203800-63fd-11e8-83e2-3a587d902000\"). tag(\"description\", variant.ofstring(\"this is the annotation\")). tag(\"tags\", variant.ofvector(vector.ofcontainers( container.builder().tag(\"key\", variant.ofstring(\"environment\")).tag(\"value\", variant.ofstring(\"staging\")).build(), container.builder().tag(\"key\", variant.ofstring(\"project\")).tag(\"value\", variant.ofstring(\"test\")).build()))). build(); properties properties = new properties(); properties.setproperty(\"file\", \"resource:\/\/annotation-event.mapping\"); eventtojsonformatter formatter = new eventtojsonformatter(properties); bytearrayoutputstream stream = new bytearrayoutputstream(); documentwriter.writeto(stream, formatter.format(event)); assertequals(\"{\" + \"\\\"@timestamp\\\":\\\"1970-01-01t00:00:00.000000000z\\\",\" + \"\\\"environment\\\":\\\"staging\\\",\" + \"\\\"project\\\":\\\"test\\\",\" + \"\\\"tags\\\":\\\"environment=staging,project=test,subproject=null\\\",\" + \"\\\"description\\\":\\\"this is the annotation\\\"\" + \"}\", stream.tostring(standardcharsets.utf_8.name()) ); }","code_context_10":"@test public void shouldaddnullsubprojectifprojectisdefined() throws ioexception { event event = eventbuilder.create(0, \"11203800-63fd-11e8-83e2-3a587d902000\"). tag(\"description\", variant.ofstring(\"this is the annotation\")). tag(\"tags\", variant.ofvector(vector.ofcontainers( container.builder().tag(\"key\", variant.ofstring(\"environment\")).tag(\"value\", variant.ofstring(\"staging\")).build(), container.builder().tag(\"key\", variant.ofstring(\"project\")).tag(\"value\", variant.ofstring(\"test\")).build()))). build(); properties properties = new properties(); properties.setproperty(\"file\", \"resource:\/\/annotation-event.mapping\"); eventtojsonformatter formatter = new eventtojsonformatter(properties); bytearrayoutputstream stream = new bytearrayoutputstream(); documentwriter.writeto(stream, formatter.format(event)); assertequals(\"{\" + \"\\\"@timestamp\\\":\\\"1970-01-01t00:00:00.000000000z\\\",\" + \"\\\"environment\\\":\\\"staging\\\",\" + \"\\\"project\\\":\\\"test\\\",\" + \"\\\"tags\\\":\\\"environment=staging,project=test,subproject=null\\\",\" + \"\\\"description\\\":\\\"this is the annotation\\\"\" + \"}\", stream.tostring(standardcharsets.utf_8.name()) ); }","code_context_20":"@test public void shouldaddnullsubprojectifprojectisdefined() throws ioexception { event event = eventbuilder.create(0, \"11203800-63fd-11e8-83e2-3a587d902000\"). tag(\"description\", variant.ofstring(\"this is the annotation\")). tag(\"tags\", variant.ofvector(vector.ofcontainers( container.builder().tag(\"key\", variant.ofstring(\"environment\")).tag(\"value\", variant.ofstring(\"staging\")).build(), container.builder().tag(\"key\", variant.ofstring(\"project\")).tag(\"value\", variant.ofstring(\"test\")).build()))). build(); properties properties = new properties(); properties.setproperty(\"file\", \"resource:\/\/annotation-event.mapping\"); eventtojsonformatter formatter = new eventtojsonformatter(properties); bytearrayoutputstream stream = new bytearrayoutputstream(); documentwriter.writeto(stream, formatter.format(event)); assertequals(\"{\" + \"\\\"@timestamp\\\":\\\"1970-01-01t00:00:00.000000000z\\\",\" + \"\\\"environment\\\":\\\"staging\\\",\" + \"\\\"project\\\":\\\"test\\\",\" + \"\\\"tags\\\":\\\"environment=staging,project=test,subproject=null\\\",\" + \"\\\"description\\\":\\\"this is the annotation\\\"\" + \"}\", stream.tostring(standardcharsets.utf_8.name()) ); }","repo":"InHavk\/hercules"}
{"id":18794,"comment_id":0,"comment":"\/\/ checking chain metrics","code":"@test public void test() { chatdirector chatdirector = new chatdirector(new file( this.getclass().getclassloader().getresource(\"modules\/common\/config.yml\").getfile())); asserttrue(chatdirector.load()); \/\/ checking chain metrics asserttrue(chatdirector.getchains().size() == 5); asserttrue(chatdirector.getchains().containskey(\"loading-test\")); asserttrue(chatdirector.getchains().containskey(\"breaking-test\")); asserttrue(chatdirector.getchains().containskey(\"echo-test\")); asserttrue(chatdirector.getchains().containskey(\"halt-test\")); asserttrue(chatdirector.getchains().containskey(\"reload-test\")); assertnotnull(chatdirector.getchains().get(\"loading-test\")); assertnotnull(chatdirector.getchains().get(\"breaking-test\")); assertnotnull(chatdirector.getchains().get(\"echo-test\")); assertnotnull(chatdirector.getchains().get(\"halt-test\")); assertnotnull(chatdirector.getchains().get(\"reload-test\")); \/\/ checking per chain metrics assertnotnull(chatdirector.getchains().get(\"loading-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"breaking-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"echo-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"halt-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"reload-test\").getitems()); asserttrue(chatdirector.getchains().get(\"loading-test\").getitems().size() == 9); asserttrue(chatdirector.getchains().get(\"breaking-test\").getitems().size() == 4); asserttrue(chatdirector.getchains().get(\"echo-test\").getitems().size() == 3); asserttrue(chatdirector.getchains().get(\"halt-test\").getitems().size() == 3); asserttrue(chatdirector.getchains().get(\"reload-test\").getitems().size() == 1); asserttrue(chatdirector.getchains().get(\"loading-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"breaking-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"echo-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"halt-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"reload-test\").isvalid()); \/\/ checking each item in chain iitem item = chatdirector.getchains().get(\"loading-test\").getitems().get(0); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(1); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(2); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(3); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(4); asserttrue(item instanceof echoitem); assertequals(\"%current%\", ((echoitem) item).format); item = chatdirector.getchains().get(\"loading-test\").getitems().get(5); asserttrue(item instanceof echoitem); assertequals(\"raw string\", ((echoitem) item).format); item = chatdirector.getchains().get(\"loading-test\").getitems().get(6); asserttrue(item instanceof echoitem); assertequals(\"\", ((echoitem) item).format); item = chatdirector.getchains().get(\"loading-test\").getitems().get(7); asserttrue(item instanceof reloaditem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(8); asserttrue(item instanceof reloaditem); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(0); asserttrue(item instanceof echoitem); assertequals(\"this is the first value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(1); asserttrue(item instanceof echoitem); assertequals(\"this is the second value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(2); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(3); asserttrue(item instanceof echoitem); assertequals(\"this is the third value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"echo-test\").getitems().get(0); asserttrue(item instanceof echoitem); assertequals(\"hello!\", ((echoitem) item).format); item = chatdirector.getchains().get(\"echo-test\").getitems().get(1); asserttrue(item instanceof echoitem); assertequals(\"this was >%current%<\", ((echoitem) item).format); item = chatdirector.getchains().get(\"echo-test\").getitems().get(2); asserttrue(item instanceof echoitem); assertequals(\"this was >%current%<, but before that it was >%last%<\", ((echoitem) item).format); item = chatdirector.getchains().get(\"halt-test\").getitems().get(0); asserttrue(item instanceof echoitem); assertequals(\"this is the first value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"halt-test\").getitems().get(1); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"halt-test\").getitems().get(2); asserttrue(item instanceof echoitem); assertequals(\"this is the second value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"reload-test\").getitems().get(0); asserttrue(item instanceof reloaditem); \/\/ todo: preform a check for reload? }","classification":"NONSATD","isFinished":true,"code_context_2":"this.getclass().getclassloader().getresource(\"modules\/common\/config.yml\").getfile())); asserttrue(chatdirector.load()); \/\/ checking chain metrics asserttrue(chatdirector.getchains().size() == 5); asserttrue(chatdirector.getchains().containskey(\"loading-test\"));","code_context_10":"@test public void test() { chatdirector chatdirector = new chatdirector(new file( this.getclass().getclassloader().getresource(\"modules\/common\/config.yml\").getfile())); asserttrue(chatdirector.load()); \/\/ checking chain metrics asserttrue(chatdirector.getchains().size() == 5); asserttrue(chatdirector.getchains().containskey(\"loading-test\")); asserttrue(chatdirector.getchains().containskey(\"breaking-test\")); asserttrue(chatdirector.getchains().containskey(\"echo-test\")); asserttrue(chatdirector.getchains().containskey(\"halt-test\")); asserttrue(chatdirector.getchains().containskey(\"reload-test\")); assertnotnull(chatdirector.getchains().get(\"loading-test\")); assertnotnull(chatdirector.getchains().get(\"breaking-test\")); assertnotnull(chatdirector.getchains().get(\"echo-test\")); assertnotnull(chatdirector.getchains().get(\"halt-test\"));","code_context_20":"@test public void test() { chatdirector chatdirector = new chatdirector(new file( this.getclass().getclassloader().getresource(\"modules\/common\/config.yml\").getfile())); asserttrue(chatdirector.load()); \/\/ checking chain metrics asserttrue(chatdirector.getchains().size() == 5); asserttrue(chatdirector.getchains().containskey(\"loading-test\")); asserttrue(chatdirector.getchains().containskey(\"breaking-test\")); asserttrue(chatdirector.getchains().containskey(\"echo-test\")); asserttrue(chatdirector.getchains().containskey(\"halt-test\")); asserttrue(chatdirector.getchains().containskey(\"reload-test\")); assertnotnull(chatdirector.getchains().get(\"loading-test\")); assertnotnull(chatdirector.getchains().get(\"breaking-test\")); assertnotnull(chatdirector.getchains().get(\"echo-test\")); assertnotnull(chatdirector.getchains().get(\"halt-test\")); assertnotnull(chatdirector.getchains().get(\"reload-test\")); \/\/ checking per chain metrics assertnotnull(chatdirector.getchains().get(\"loading-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"breaking-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"echo-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"halt-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"reload-test\").getitems()); asserttrue(chatdirector.getchains().get(\"loading-test\").getitems().size() == 9); asserttrue(chatdirector.getchains().get(\"breaking-test\").getitems().size() == 4); asserttrue(chatdirector.getchains().get(\"echo-test\").getitems().size() == 3);","repo":"AtomicPulsee\/ChatDirector"}
{"id":18794,"comment_id":1,"comment":"\/\/ checking per chain metrics","code":"@test public void test() { chatdirector chatdirector = new chatdirector(new file( this.getclass().getclassloader().getresource(\"modules\/common\/config.yml\").getfile())); asserttrue(chatdirector.load()); \/\/ checking chain metrics asserttrue(chatdirector.getchains().size() == 5); asserttrue(chatdirector.getchains().containskey(\"loading-test\")); asserttrue(chatdirector.getchains().containskey(\"breaking-test\")); asserttrue(chatdirector.getchains().containskey(\"echo-test\")); asserttrue(chatdirector.getchains().containskey(\"halt-test\")); asserttrue(chatdirector.getchains().containskey(\"reload-test\")); assertnotnull(chatdirector.getchains().get(\"loading-test\")); assertnotnull(chatdirector.getchains().get(\"breaking-test\")); assertnotnull(chatdirector.getchains().get(\"echo-test\")); assertnotnull(chatdirector.getchains().get(\"halt-test\")); assertnotnull(chatdirector.getchains().get(\"reload-test\")); \/\/ checking per chain metrics assertnotnull(chatdirector.getchains().get(\"loading-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"breaking-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"echo-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"halt-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"reload-test\").getitems()); asserttrue(chatdirector.getchains().get(\"loading-test\").getitems().size() == 9); asserttrue(chatdirector.getchains().get(\"breaking-test\").getitems().size() == 4); asserttrue(chatdirector.getchains().get(\"echo-test\").getitems().size() == 3); asserttrue(chatdirector.getchains().get(\"halt-test\").getitems().size() == 3); asserttrue(chatdirector.getchains().get(\"reload-test\").getitems().size() == 1); asserttrue(chatdirector.getchains().get(\"loading-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"breaking-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"echo-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"halt-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"reload-test\").isvalid()); \/\/ checking each item in chain iitem item = chatdirector.getchains().get(\"loading-test\").getitems().get(0); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(1); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(2); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(3); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(4); asserttrue(item instanceof echoitem); assertequals(\"%current%\", ((echoitem) item).format); item = chatdirector.getchains().get(\"loading-test\").getitems().get(5); asserttrue(item instanceof echoitem); assertequals(\"raw string\", ((echoitem) item).format); item = chatdirector.getchains().get(\"loading-test\").getitems().get(6); asserttrue(item instanceof echoitem); assertequals(\"\", ((echoitem) item).format); item = chatdirector.getchains().get(\"loading-test\").getitems().get(7); asserttrue(item instanceof reloaditem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(8); asserttrue(item instanceof reloaditem); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(0); asserttrue(item instanceof echoitem); assertequals(\"this is the first value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(1); asserttrue(item instanceof echoitem); assertequals(\"this is the second value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(2); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(3); asserttrue(item instanceof echoitem); assertequals(\"this is the third value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"echo-test\").getitems().get(0); asserttrue(item instanceof echoitem); assertequals(\"hello!\", ((echoitem) item).format); item = chatdirector.getchains().get(\"echo-test\").getitems().get(1); asserttrue(item instanceof echoitem); assertequals(\"this was >%current%<\", ((echoitem) item).format); item = chatdirector.getchains().get(\"echo-test\").getitems().get(2); asserttrue(item instanceof echoitem); assertequals(\"this was >%current%<, but before that it was >%last%<\", ((echoitem) item).format); item = chatdirector.getchains().get(\"halt-test\").getitems().get(0); asserttrue(item instanceof echoitem); assertequals(\"this is the first value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"halt-test\").getitems().get(1); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"halt-test\").getitems().get(2); asserttrue(item instanceof echoitem); assertequals(\"this is the second value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"reload-test\").getitems().get(0); asserttrue(item instanceof reloaditem); \/\/ todo: preform a check for reload? }","classification":"NONSATD","isFinished":true,"code_context_2":"assertnotnull(chatdirector.getchains().get(\"halt-test\")); assertnotnull(chatdirector.getchains().get(\"reload-test\")); \/\/ checking per chain metrics assertnotnull(chatdirector.getchains().get(\"loading-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"breaking-test\").getitems());","code_context_10":"asserttrue(chatdirector.getchains().containskey(\"loading-test\")); asserttrue(chatdirector.getchains().containskey(\"breaking-test\")); asserttrue(chatdirector.getchains().containskey(\"echo-test\")); asserttrue(chatdirector.getchains().containskey(\"halt-test\")); asserttrue(chatdirector.getchains().containskey(\"reload-test\")); assertnotnull(chatdirector.getchains().get(\"loading-test\")); assertnotnull(chatdirector.getchains().get(\"breaking-test\")); assertnotnull(chatdirector.getchains().get(\"echo-test\")); assertnotnull(chatdirector.getchains().get(\"halt-test\")); assertnotnull(chatdirector.getchains().get(\"reload-test\")); \/\/ checking per chain metrics assertnotnull(chatdirector.getchains().get(\"loading-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"breaking-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"echo-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"halt-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"reload-test\").getitems()); asserttrue(chatdirector.getchains().get(\"loading-test\").getitems().size() == 9); asserttrue(chatdirector.getchains().get(\"breaking-test\").getitems().size() == 4); asserttrue(chatdirector.getchains().get(\"echo-test\").getitems().size() == 3); asserttrue(chatdirector.getchains().get(\"halt-test\").getitems().size() == 3); asserttrue(chatdirector.getchains().get(\"reload-test\").getitems().size() == 1);","code_context_20":"@test public void test() { chatdirector chatdirector = new chatdirector(new file( this.getclass().getclassloader().getresource(\"modules\/common\/config.yml\").getfile())); asserttrue(chatdirector.load()); \/\/ checking chain metrics asserttrue(chatdirector.getchains().size() == 5); asserttrue(chatdirector.getchains().containskey(\"loading-test\")); asserttrue(chatdirector.getchains().containskey(\"breaking-test\")); asserttrue(chatdirector.getchains().containskey(\"echo-test\")); asserttrue(chatdirector.getchains().containskey(\"halt-test\")); asserttrue(chatdirector.getchains().containskey(\"reload-test\")); assertnotnull(chatdirector.getchains().get(\"loading-test\")); assertnotnull(chatdirector.getchains().get(\"breaking-test\")); assertnotnull(chatdirector.getchains().get(\"echo-test\")); assertnotnull(chatdirector.getchains().get(\"halt-test\")); assertnotnull(chatdirector.getchains().get(\"reload-test\")); \/\/ checking per chain metrics assertnotnull(chatdirector.getchains().get(\"loading-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"breaking-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"echo-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"halt-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"reload-test\").getitems()); asserttrue(chatdirector.getchains().get(\"loading-test\").getitems().size() == 9); asserttrue(chatdirector.getchains().get(\"breaking-test\").getitems().size() == 4); asserttrue(chatdirector.getchains().get(\"echo-test\").getitems().size() == 3); asserttrue(chatdirector.getchains().get(\"halt-test\").getitems().size() == 3); asserttrue(chatdirector.getchains().get(\"reload-test\").getitems().size() == 1); asserttrue(chatdirector.getchains().get(\"loading-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"breaking-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"echo-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"halt-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"reload-test\").isvalid()); \/\/ checking each item in chain iitem item = chatdirector.getchains().get(\"loading-test\").getitems().get(0); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(1); asserttrue(item instanceof breakitem);","repo":"AtomicPulsee\/ChatDirector"}
{"id":18794,"comment_id":2,"comment":"\/\/ checking each item in chain","code":"@test public void test() { chatdirector chatdirector = new chatdirector(new file( this.getclass().getclassloader().getresource(\"modules\/common\/config.yml\").getfile())); asserttrue(chatdirector.load()); \/\/ checking chain metrics asserttrue(chatdirector.getchains().size() == 5); asserttrue(chatdirector.getchains().containskey(\"loading-test\")); asserttrue(chatdirector.getchains().containskey(\"breaking-test\")); asserttrue(chatdirector.getchains().containskey(\"echo-test\")); asserttrue(chatdirector.getchains().containskey(\"halt-test\")); asserttrue(chatdirector.getchains().containskey(\"reload-test\")); assertnotnull(chatdirector.getchains().get(\"loading-test\")); assertnotnull(chatdirector.getchains().get(\"breaking-test\")); assertnotnull(chatdirector.getchains().get(\"echo-test\")); assertnotnull(chatdirector.getchains().get(\"halt-test\")); assertnotnull(chatdirector.getchains().get(\"reload-test\")); \/\/ checking per chain metrics assertnotnull(chatdirector.getchains().get(\"loading-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"breaking-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"echo-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"halt-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"reload-test\").getitems()); asserttrue(chatdirector.getchains().get(\"loading-test\").getitems().size() == 9); asserttrue(chatdirector.getchains().get(\"breaking-test\").getitems().size() == 4); asserttrue(chatdirector.getchains().get(\"echo-test\").getitems().size() == 3); asserttrue(chatdirector.getchains().get(\"halt-test\").getitems().size() == 3); asserttrue(chatdirector.getchains().get(\"reload-test\").getitems().size() == 1); asserttrue(chatdirector.getchains().get(\"loading-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"breaking-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"echo-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"halt-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"reload-test\").isvalid()); \/\/ checking each item in chain iitem item = chatdirector.getchains().get(\"loading-test\").getitems().get(0); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(1); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(2); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(3); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(4); asserttrue(item instanceof echoitem); assertequals(\"%current%\", ((echoitem) item).format); item = chatdirector.getchains().get(\"loading-test\").getitems().get(5); asserttrue(item instanceof echoitem); assertequals(\"raw string\", ((echoitem) item).format); item = chatdirector.getchains().get(\"loading-test\").getitems().get(6); asserttrue(item instanceof echoitem); assertequals(\"\", ((echoitem) item).format); item = chatdirector.getchains().get(\"loading-test\").getitems().get(7); asserttrue(item instanceof reloaditem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(8); asserttrue(item instanceof reloaditem); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(0); asserttrue(item instanceof echoitem); assertequals(\"this is the first value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(1); asserttrue(item instanceof echoitem); assertequals(\"this is the second value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(2); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(3); asserttrue(item instanceof echoitem); assertequals(\"this is the third value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"echo-test\").getitems().get(0); asserttrue(item instanceof echoitem); assertequals(\"hello!\", ((echoitem) item).format); item = chatdirector.getchains().get(\"echo-test\").getitems().get(1); asserttrue(item instanceof echoitem); assertequals(\"this was >%current%<\", ((echoitem) item).format); item = chatdirector.getchains().get(\"echo-test\").getitems().get(2); asserttrue(item instanceof echoitem); assertequals(\"this was >%current%<, but before that it was >%last%<\", ((echoitem) item).format); item = chatdirector.getchains().get(\"halt-test\").getitems().get(0); asserttrue(item instanceof echoitem); assertequals(\"this is the first value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"halt-test\").getitems().get(1); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"halt-test\").getitems().get(2); asserttrue(item instanceof echoitem); assertequals(\"this is the second value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"reload-test\").getitems().get(0); asserttrue(item instanceof reloaditem); \/\/ todo: preform a check for reload? }","classification":"NONSATD","isFinished":true,"code_context_2":"asserttrue(chatdirector.getchains().get(\"halt-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"reload-test\").isvalid()); \/\/ checking each item in chain iitem item = chatdirector.getchains().get(\"loading-test\").getitems().get(0); asserttrue(item instanceof breakitem);","code_context_10":"asserttrue(chatdirector.getchains().get(\"loading-test\").getitems().size() == 9); asserttrue(chatdirector.getchains().get(\"breaking-test\").getitems().size() == 4); asserttrue(chatdirector.getchains().get(\"echo-test\").getitems().size() == 3); asserttrue(chatdirector.getchains().get(\"halt-test\").getitems().size() == 3); asserttrue(chatdirector.getchains().get(\"reload-test\").getitems().size() == 1); asserttrue(chatdirector.getchains().get(\"loading-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"breaking-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"echo-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"halt-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"reload-test\").isvalid()); \/\/ checking each item in chain iitem item = chatdirector.getchains().get(\"loading-test\").getitems().get(0); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(1); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(2); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(3); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(4); asserttrue(item instanceof echoitem);","code_context_20":"assertnotnull(chatdirector.getchains().get(\"breaking-test\")); assertnotnull(chatdirector.getchains().get(\"echo-test\")); assertnotnull(chatdirector.getchains().get(\"halt-test\")); assertnotnull(chatdirector.getchains().get(\"reload-test\")); \/\/ checking per chain metrics assertnotnull(chatdirector.getchains().get(\"loading-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"breaking-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"echo-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"halt-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"reload-test\").getitems()); asserttrue(chatdirector.getchains().get(\"loading-test\").getitems().size() == 9); asserttrue(chatdirector.getchains().get(\"breaking-test\").getitems().size() == 4); asserttrue(chatdirector.getchains().get(\"echo-test\").getitems().size() == 3); asserttrue(chatdirector.getchains().get(\"halt-test\").getitems().size() == 3); asserttrue(chatdirector.getchains().get(\"reload-test\").getitems().size() == 1); asserttrue(chatdirector.getchains().get(\"loading-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"breaking-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"echo-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"halt-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"reload-test\").isvalid()); \/\/ checking each item in chain iitem item = chatdirector.getchains().get(\"loading-test\").getitems().get(0); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(1); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(2); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(3); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(4); asserttrue(item instanceof echoitem); assertequals(\"%current%\", ((echoitem) item).format); item = chatdirector.getchains().get(\"loading-test\").getitems().get(5); asserttrue(item instanceof echoitem); assertequals(\"raw string\", ((echoitem) item).format); item = chatdirector.getchains().get(\"loading-test\").getitems().get(6); asserttrue(item instanceof echoitem); assertequals(\"\", ((echoitem) item).format); item = chatdirector.getchains().get(\"loading-test\").getitems().get(7); asserttrue(item instanceof reloaditem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(8);","repo":"AtomicPulsee\/ChatDirector"}
{"id":18794,"comment_id":3,"comment":"\/\/ todo: preform a check for reload?","code":"@test public void test() { chatdirector chatdirector = new chatdirector(new file( this.getclass().getclassloader().getresource(\"modules\/common\/config.yml\").getfile())); asserttrue(chatdirector.load()); \/\/ checking chain metrics asserttrue(chatdirector.getchains().size() == 5); asserttrue(chatdirector.getchains().containskey(\"loading-test\")); asserttrue(chatdirector.getchains().containskey(\"breaking-test\")); asserttrue(chatdirector.getchains().containskey(\"echo-test\")); asserttrue(chatdirector.getchains().containskey(\"halt-test\")); asserttrue(chatdirector.getchains().containskey(\"reload-test\")); assertnotnull(chatdirector.getchains().get(\"loading-test\")); assertnotnull(chatdirector.getchains().get(\"breaking-test\")); assertnotnull(chatdirector.getchains().get(\"echo-test\")); assertnotnull(chatdirector.getchains().get(\"halt-test\")); assertnotnull(chatdirector.getchains().get(\"reload-test\")); \/\/ checking per chain metrics assertnotnull(chatdirector.getchains().get(\"loading-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"breaking-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"echo-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"halt-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"reload-test\").getitems()); asserttrue(chatdirector.getchains().get(\"loading-test\").getitems().size() == 9); asserttrue(chatdirector.getchains().get(\"breaking-test\").getitems().size() == 4); asserttrue(chatdirector.getchains().get(\"echo-test\").getitems().size() == 3); asserttrue(chatdirector.getchains().get(\"halt-test\").getitems().size() == 3); asserttrue(chatdirector.getchains().get(\"reload-test\").getitems().size() == 1); asserttrue(chatdirector.getchains().get(\"loading-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"breaking-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"echo-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"halt-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"reload-test\").isvalid()); \/\/ checking each item in chain iitem item = chatdirector.getchains().get(\"loading-test\").getitems().get(0); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(1); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(2); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(3); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(4); asserttrue(item instanceof echoitem); assertequals(\"%current%\", ((echoitem) item).format); item = chatdirector.getchains().get(\"loading-test\").getitems().get(5); asserttrue(item instanceof echoitem); assertequals(\"raw string\", ((echoitem) item).format); item = chatdirector.getchains().get(\"loading-test\").getitems().get(6); asserttrue(item instanceof echoitem); assertequals(\"\", ((echoitem) item).format); item = chatdirector.getchains().get(\"loading-test\").getitems().get(7); asserttrue(item instanceof reloaditem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(8); asserttrue(item instanceof reloaditem); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(0); asserttrue(item instanceof echoitem); assertequals(\"this is the first value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(1); asserttrue(item instanceof echoitem); assertequals(\"this is the second value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(2); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(3); asserttrue(item instanceof echoitem); assertequals(\"this is the third value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"echo-test\").getitems().get(0); asserttrue(item instanceof echoitem); assertequals(\"hello!\", ((echoitem) item).format); item = chatdirector.getchains().get(\"echo-test\").getitems().get(1); asserttrue(item instanceof echoitem); assertequals(\"this was >%current%<\", ((echoitem) item).format); item = chatdirector.getchains().get(\"echo-test\").getitems().get(2); asserttrue(item instanceof echoitem); assertequals(\"this was >%current%<, but before that it was >%last%<\", ((echoitem) item).format); item = chatdirector.getchains().get(\"halt-test\").getitems().get(0); asserttrue(item instanceof echoitem); assertequals(\"this is the first value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"halt-test\").getitems().get(1); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"halt-test\").getitems().get(2); asserttrue(item instanceof echoitem); assertequals(\"this is the second value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"reload-test\").getitems().get(0); asserttrue(item instanceof reloaditem); \/\/ todo: preform a check for reload? }","classification":"DESIGN","isFinished":true,"code_context_2":"item = chatdirector.getchains().get(\"reload-test\").getitems().get(0); asserttrue(item instanceof reloaditem); \/\/ todo: preform a check for reload? }","code_context_10":"item = chatdirector.getchains().get(\"halt-test\").getitems().get(0); asserttrue(item instanceof echoitem); assertequals(\"this is the first value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"halt-test\").getitems().get(1); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"halt-test\").getitems().get(2); asserttrue(item instanceof echoitem); assertequals(\"this is the second value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"reload-test\").getitems().get(0); asserttrue(item instanceof reloaditem); \/\/ todo: preform a check for reload? }","code_context_20":"assertequals(\"this is the third value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"echo-test\").getitems().get(0); asserttrue(item instanceof echoitem); assertequals(\"hello!\", ((echoitem) item).format); item = chatdirector.getchains().get(\"echo-test\").getitems().get(1); asserttrue(item instanceof echoitem); assertequals(\"this was >%current%<\", ((echoitem) item).format); item = chatdirector.getchains().get(\"echo-test\").getitems().get(2); asserttrue(item instanceof echoitem); assertequals(\"this was >%current%<, but before that it was >%last%<\", ((echoitem) item).format); item = chatdirector.getchains().get(\"halt-test\").getitems().get(0); asserttrue(item instanceof echoitem); assertequals(\"this is the first value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"halt-test\").getitems().get(1); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"halt-test\").getitems().get(2); asserttrue(item instanceof echoitem); assertequals(\"this is the second value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"reload-test\").getitems().get(0); asserttrue(item instanceof reloaditem); \/\/ todo: preform a check for reload? }","repo":"AtomicPulsee\/ChatDirector"}
{"id":18795,"comment_id":0,"comment":"\/\/ load the quiz","code":"@override public void initialize(url location, resourcebundle resources) { \/\/ load the quiz for (question question : quiz.questions) { questionslist.getitems().add(question.title); } populateview(); questiontextfield.setonkeyreleased(e -> { questionslist.getitems().set(currentquestionindex, questiontextfield.gettext()); quiz.questions.get(currentquestionindex).title = questiontextfield.gettext(); saved = false; }); newanswerbutton.setonmouseclicked(e -> { quiz.questions.get(currentquestionindex).options.add(new option(\"\")); addanswer(questionstilepane.getchildren().size()); saved = false; }); rightanswercombobox.setonaction(e -> { if (rightanswercombobox.getitems().size() > 0) { currentquestion.answer = rightanswercombobox.getselectionmodel().getselectedindex(); } saved = false; }); questionslist.setonmouseclicked(e -> { int selectedindex = questionslist.getselectionmodel().getselectedindex(); if (selectedindex < quiz.questions.size() && selectedindex >= 0) { currentquestionindex = selectedindex; currentquestion = quiz.questions.get(selectedindex); } populateview(); saved = false; }); newquestionbutton.setonaction(e -> { newquestion(); questionslist.getitems().add(\"\"); currentquestion = this.quiz.questions.get(currentquestionindex); populateview(); saved = false; }); deletequestionbutton.setonaction(e -> removequestion()); quizoptionsbutton.setonaction(e -> { stage stage = new stage(); window win = new window(window.getapp(), stage, \"settings for '\" + quiz.name + \"'\"); win.openview(new quizsettingspopupcontrol(quiz)); saved = false; }); maxpointstextinput.addeventfilter(keyevent.key_typed, e -> { if (e.getcharacter().matches(\"[\\\\d]\")) { e.consume(); } }); maxpointstextinput.setonkeyreleased(e -> { if (!maxpointstextinput.gettext().isempty()) { currentquestion.maxreward = integer.parseint(maxpointstextinput.gettext()); } else { currentquestion.maxreward = 50; \/\/ todo un hardcode this } saved = false; }); filemenu.getitems().get(2).setonaction(e -> { if (!saved) { askforsave(); closeapp = false; } else { window.openview(new choosequizscreencontrol(true)); } }); filemenu.getitems().get(0).setonaction(e -> initsave()); filemenu.getitems().get(1).setonaction(e -> { opensavedialog(); }); window.getstage().setoncloserequest(e -> { if (!saved) { e.consume(); askforsave(); closeapp = true; } }); }","classification":"NONSATD","isFinished":true,"code_context_2":"@override public void initialize(url location, resourcebundle resources) { \/\/ load the quiz for (question question : quiz.questions) { questionslist.getitems().add(question.title);","code_context_10":"@override public void initialize(url location, resourcebundle resources) { \/\/ load the quiz for (question question : quiz.questions) { questionslist.getitems().add(question.title); } populateview(); questiontextfield.setonkeyreleased(e -> { questionslist.getitems().set(currentquestionindex, questiontextfield.gettext()); quiz.questions.get(currentquestionindex).title = questiontextfield.gettext(); saved = false; }); newanswerbutton.setonmouseclicked(e -> {","code_context_20":"@override public void initialize(url location, resourcebundle resources) { \/\/ load the quiz for (question question : quiz.questions) { questionslist.getitems().add(question.title); } populateview(); questiontextfield.setonkeyreleased(e -> { questionslist.getitems().set(currentquestionindex, questiontextfield.gettext()); quiz.questions.get(currentquestionindex).title = questiontextfield.gettext(); saved = false; }); newanswerbutton.setonmouseclicked(e -> { quiz.questions.get(currentquestionindex).options.add(new option(\"\")); addanswer(questionstilepane.getchildren().size()); saved = false; }); rightanswercombobox.setonaction(e -> { if (rightanswercombobox.getitems().size() > 0) { currentquestion.answer = rightanswercombobox.getselectionmodel().getselectedindex(); } saved = false; });","repo":"ExodiusStudios\/quizzibles"}
{"id":18795,"comment_id":1,"comment":"\/\/ todo un hardcode this","code":"@override public void initialize(url location, resourcebundle resources) { \/\/ load the quiz for (question question : quiz.questions) { questionslist.getitems().add(question.title); } populateview(); questiontextfield.setonkeyreleased(e -> { questionslist.getitems().set(currentquestionindex, questiontextfield.gettext()); quiz.questions.get(currentquestionindex).title = questiontextfield.gettext(); saved = false; }); newanswerbutton.setonmouseclicked(e -> { quiz.questions.get(currentquestionindex).options.add(new option(\"\")); addanswer(questionstilepane.getchildren().size()); saved = false; }); rightanswercombobox.setonaction(e -> { if (rightanswercombobox.getitems().size() > 0) { currentquestion.answer = rightanswercombobox.getselectionmodel().getselectedindex(); } saved = false; }); questionslist.setonmouseclicked(e -> { int selectedindex = questionslist.getselectionmodel().getselectedindex(); if (selectedindex < quiz.questions.size() && selectedindex >= 0) { currentquestionindex = selectedindex; currentquestion = quiz.questions.get(selectedindex); } populateview(); saved = false; }); newquestionbutton.setonaction(e -> { newquestion(); questionslist.getitems().add(\"\"); currentquestion = this.quiz.questions.get(currentquestionindex); populateview(); saved = false; }); deletequestionbutton.setonaction(e -> removequestion()); quizoptionsbutton.setonaction(e -> { stage stage = new stage(); window win = new window(window.getapp(), stage, \"settings for '\" + quiz.name + \"'\"); win.openview(new quizsettingspopupcontrol(quiz)); saved = false; }); maxpointstextinput.addeventfilter(keyevent.key_typed, e -> { if (e.getcharacter().matches(\"[\\\\d]\")) { e.consume(); } }); maxpointstextinput.setonkeyreleased(e -> { if (!maxpointstextinput.gettext().isempty()) { currentquestion.maxreward = integer.parseint(maxpointstextinput.gettext()); } else { currentquestion.maxreward = 50; \/\/ todo un hardcode this } saved = false; }); filemenu.getitems().get(2).setonaction(e -> { if (!saved) { askforsave(); closeapp = false; } else { window.openview(new choosequizscreencontrol(true)); } }); filemenu.getitems().get(0).setonaction(e -> initsave()); filemenu.getitems().get(1).setonaction(e -> { opensavedialog(); }); window.getstage().setoncloserequest(e -> { if (!saved) { e.consume(); askforsave(); closeapp = true; } }); }","classification":"DESIGN","isFinished":true,"code_context_2":"currentquestion.maxreward = integer.parseint(maxpointstextinput.gettext()); } else { currentquestion.maxreward = 50; \/\/ todo un hardcode this } saved = false;","code_context_10":"}); maxpointstextinput.addeventfilter(keyevent.key_typed, e -> { if (e.getcharacter().matches(\"[\\\\d]\")) { e.consume(); } }); maxpointstextinput.setonkeyreleased(e -> { if (!maxpointstextinput.gettext().isempty()) { currentquestion.maxreward = integer.parseint(maxpointstextinput.gettext()); } else { currentquestion.maxreward = 50; \/\/ todo un hardcode this } saved = false; }); filemenu.getitems().get(2).setonaction(e -> { if (!saved) { askforsave(); closeapp = false; } else { window.openview(new choosequizscreencontrol(true)); }","code_context_20":"currentquestion = this.quiz.questions.get(currentquestionindex); populateview(); saved = false; }); deletequestionbutton.setonaction(e -> removequestion()); quizoptionsbutton.setonaction(e -> { stage stage = new stage(); window win = new window(window.getapp(), stage, \"settings for '\" + quiz.name + \"'\"); win.openview(new quizsettingspopupcontrol(quiz)); saved = false; }); maxpointstextinput.addeventfilter(keyevent.key_typed, e -> { if (e.getcharacter().matches(\"[\\\\d]\")) { e.consume(); } }); maxpointstextinput.setonkeyreleased(e -> { if (!maxpointstextinput.gettext().isempty()) { currentquestion.maxreward = integer.parseint(maxpointstextinput.gettext()); } else { currentquestion.maxreward = 50; \/\/ todo un hardcode this } saved = false; }); filemenu.getitems().get(2).setonaction(e -> { if (!saved) { askforsave(); closeapp = false; } else { window.openview(new choosequizscreencontrol(true)); } }); filemenu.getitems().get(0).setonaction(e -> initsave()); filemenu.getitems().get(1).setonaction(e -> { opensavedialog(); }); window.getstage().setoncloserequest(e -> { if (!saved) { e.consume(); askforsave(); closeapp = true;","repo":"ExodiusStudios\/quizzibles"}
{"id":10647,"comment_id":0,"comment":"\/\/ this is testing a work-around for a xerces bug \/\/ http:\/\/nagoya.apache.org\/bugzilla\/show_bug.cgi?id=27583 \/\/ that reports this as an ioexception rather than a saxexception","code":"\/\/ this is testing a work-around for a xerces bug \/\/ http:\/\/nagoya.apache.org\/bugzilla\/show_bug.cgi?id=27583 \/\/ that reports this as an ioexception rather than a saxexception public void testbuildmalformeddocumentwithunpairedsurrogate() throws ioexception { string doc = \"<doc>a\\ud800a<\/doc>\"; try { builder.build(doc, \"http:\/\/www.example.com\"); fail(\"allowed malformed doc\"); } catch (parsingexception success) { assertnotnull(success.getmessage()); assertequals(\"http:\/\/www.example.com\/\", success.geturi()); } }","classification":"DESIGN","isFinished":true,"code_context_2":"public void testbuildmalformeddocumentwithunpairedsurrogate() throws ioexception { string doc = \"<doc>a\\ud800a<\/doc>\"; try { builder.build(doc, \"http:\/\/www.example.com\"); fail(\"allowed malformed doc\"); } catch (parsingexception success) { assertnotnull(success.getmessage()); assertequals(\"http:\/\/www.example.com\/\", success.geturi()); } }","code_context_10":"public void testbuildmalformeddocumentwithunpairedsurrogate() throws ioexception { string doc = \"<doc>a\\ud800a<\/doc>\"; try { builder.build(doc, \"http:\/\/www.example.com\"); fail(\"allowed malformed doc\"); } catch (parsingexception success) { assertnotnull(success.getmessage()); assertequals(\"http:\/\/www.example.com\/\", success.geturi()); } }","code_context_20":"public void testbuildmalformeddocumentwithunpairedsurrogate() throws ioexception { string doc = \"<doc>a\\ud800a<\/doc>\"; try { builder.build(doc, \"http:\/\/www.example.com\"); fail(\"allowed malformed doc\"); } catch (parsingexception success) { assertnotnull(success.getmessage()); assertequals(\"http:\/\/www.example.com\/\", success.geturi()); } }","repo":"Evegen55\/TIJ4_code"}
{"id":2472,"comment_id":0,"comment":"\/\/todo: implement this in the future \/\/c.securesettingname = settings.secure.enabled_custom_tile_listeners;","code":"@override protected config getconfig() { config c = new config(); c.caption = \"custom tile listener\"; c.serviceinterface = customtilelistenerservice.service_interface; \/\/todo: implement this in the future \/\/c.securesettingname = settings.secure.enabled_custom_tile_listeners; c.bindpermission = cyanogenmod.platform.manifest.permission.bind_custom_tile_listener_service; \/\/todo: implement this in the future \/\/c.settingsaction = settings.action_custom_tile_listener_settings; c.clientlabel = r.string.custom_tile_listener_binding_label; return c; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"c.caption = \"custom tile listener\"; c.serviceinterface = customtilelistenerservice.service_interface; \/\/todo: implement this in the future \/\/c.securesettingname = settings.secure.enabled_custom_tile_listeners; c.bindpermission = cyanogenmod.platform.manifest.permission.bind_custom_tile_listener_service;","code_context_10":"@override protected config getconfig() { config c = new config(); c.caption = \"custom tile listener\"; c.serviceinterface = customtilelistenerservice.service_interface; \/\/todo: implement this in the future \/\/c.securesettingname = settings.secure.enabled_custom_tile_listeners; c.bindpermission = cyanogenmod.platform.manifest.permission.bind_custom_tile_listener_service; \/\/todo: implement this in the future \/\/c.settingsaction = settings.action_custom_tile_listener_settings; c.clientlabel = r.string.custom_tile_listener_binding_label; return c; }","code_context_20":"@override protected config getconfig() { config c = new config(); c.caption = \"custom tile listener\"; c.serviceinterface = customtilelistenerservice.service_interface; \/\/todo: implement this in the future \/\/c.securesettingname = settings.secure.enabled_custom_tile_listeners; c.bindpermission = cyanogenmod.platform.manifest.permission.bind_custom_tile_listener_service; \/\/todo: implement this in the future \/\/c.settingsaction = settings.action_custom_tile_listener_settings; c.clientlabel = r.string.custom_tile_listener_binding_label; return c; }","repo":"Ant-OS\/android_vendor_cmsdk"}
{"id":2472,"comment_id":1,"comment":"\/\/todo: implement this in the future \/\/c.settingsaction = settings.action_custom_tile_listener_settings;","code":"@override protected config getconfig() { config c = new config(); c.caption = \"custom tile listener\"; c.serviceinterface = customtilelistenerservice.service_interface; \/\/todo: implement this in the future \/\/c.securesettingname = settings.secure.enabled_custom_tile_listeners; c.bindpermission = cyanogenmod.platform.manifest.permission.bind_custom_tile_listener_service; \/\/todo: implement this in the future \/\/c.settingsaction = settings.action_custom_tile_listener_settings; c.clientlabel = r.string.custom_tile_listener_binding_label; return c; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"c.caption = \"custom tile listener\"; c.serviceinterface = customtilelistenerservice.service_interface; \/\/todo: implement this in the future \/\/c.securesettingname = settings.secure.enabled_custom_tile_listeners; c.bindpermission = cyanogenmod.platform.manifest.permission.bind_custom_tile_listener_service;","code_context_10":"@override protected config getconfig() { config c = new config(); c.caption = \"custom tile listener\"; c.serviceinterface = customtilelistenerservice.service_interface; \/\/todo: implement this in the future \/\/c.securesettingname = settings.secure.enabled_custom_tile_listeners; c.bindpermission = cyanogenmod.platform.manifest.permission.bind_custom_tile_listener_service; \/\/todo: implement this in the future \/\/c.settingsaction = settings.action_custom_tile_listener_settings; c.clientlabel = r.string.custom_tile_listener_binding_label; return c; }","code_context_20":"@override protected config getconfig() { config c = new config(); c.caption = \"custom tile listener\"; c.serviceinterface = customtilelistenerservice.service_interface; \/\/todo: implement this in the future \/\/c.securesettingname = settings.secure.enabled_custom_tile_listeners; c.bindpermission = cyanogenmod.platform.manifest.permission.bind_custom_tile_listener_service; \/\/todo: implement this in the future \/\/c.settingsaction = settings.action_custom_tile_listener_settings; c.clientlabel = r.string.custom_tile_listener_binding_label; return c; }","repo":"Ant-OS\/android_vendor_cmsdk"}
{"id":18884,"comment_id":0,"comment":"\/\/ todo somehow connect the cancel back to netsession","code":"@override public void offer(httpcontent chunk) { if (this.channel.isclosed()) return; \/\/ todo somehow connect the cancel back to netsession if (chunk.content().readablebytes() > this.max) { this.channel.abort(); \/\/ todo somehow connect the cancel back to netsession return; } bytebuf bb = chunk.content(); bb.retain(); \/\/ we will use it in upcoming send system.out.println(\"ref count a: \" + bb.refcnt()); streammessage b = new streammessage(\"block\", bb); b.setfield(\"sequence\", this.seq); operationresult or = this.channel.send(b); \/\/ bb should now be back to 1 system.out.println(\"ref count b: \" + bb.refcnt()); if (or.haserrors()) { this.channel.close(); return; } this.seq++; \/\/ todo track progress if possible \/\/ final only if not canceled if (chunk instanceof lasthttpcontent) this.channel.send(messageutil.streamfinal()); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"public void offer(httpcontent chunk) { if (this.channel.isclosed()) return; \/\/ todo somehow connect the cancel back to netsession if (chunk.content().readablebytes() > this.max) { this.channel.abort(); \/\/ todo somehow connect the cancel back to netsession","code_context_10":"@override public void offer(httpcontent chunk) { if (this.channel.isclosed()) return; \/\/ todo somehow connect the cancel back to netsession if (chunk.content().readablebytes() > this.max) { this.channel.abort(); \/\/ todo somehow connect the cancel back to netsession return; } bytebuf bb = chunk.content(); bb.retain(); \/\/ we will use it in upcoming send system.out.println(\"ref count a: \" + bb.refcnt()); streammessage b = new streammessage(\"block\", bb); b.setfield(\"sequence\", this.seq); operationresult or = this.channel.send(b);","code_context_20":"@override public void offer(httpcontent chunk) { if (this.channel.isclosed()) return; \/\/ todo somehow connect the cancel back to netsession if (chunk.content().readablebytes() > this.max) { this.channel.abort(); \/\/ todo somehow connect the cancel back to netsession return; } bytebuf bb = chunk.content(); bb.retain(); \/\/ we will use it in upcoming send system.out.println(\"ref count a: \" + bb.refcnt()); streammessage b = new streammessage(\"block\", bb); b.setfield(\"sequence\", this.seq); operationresult or = this.channel.send(b); \/\/ bb should now be back to 1 system.out.println(\"ref count b: \" + bb.refcnt()); if (or.haserrors()) { this.channel.close(); return; } this.seq++; \/\/ todo track progress if possible \/\/ final only if not canceled if (chunk instanceof lasthttpcontent)","repo":"Gadreel\/divconq"}
{"id":18884,"comment_id":1,"comment":"\/\/ todo somehow connect the cancel back to netsession","code":"@override public void offer(httpcontent chunk) { if (this.channel.isclosed()) return; \/\/ todo somehow connect the cancel back to netsession if (chunk.content().readablebytes() > this.max) { this.channel.abort(); \/\/ todo somehow connect the cancel back to netsession return; } bytebuf bb = chunk.content(); bb.retain(); \/\/ we will use it in upcoming send system.out.println(\"ref count a: \" + bb.refcnt()); streammessage b = new streammessage(\"block\", bb); b.setfield(\"sequence\", this.seq); operationresult or = this.channel.send(b); \/\/ bb should now be back to 1 system.out.println(\"ref count b: \" + bb.refcnt()); if (or.haserrors()) { this.channel.close(); return; } this.seq++; \/\/ todo track progress if possible \/\/ final only if not canceled if (chunk instanceof lasthttpcontent) this.channel.send(messageutil.streamfinal()); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"public void offer(httpcontent chunk) { if (this.channel.isclosed()) return; \/\/ todo somehow connect the cancel back to netsession if (chunk.content().readablebytes() > this.max) { this.channel.abort(); \/\/ todo somehow connect the cancel back to netsession","code_context_10":"@override public void offer(httpcontent chunk) { if (this.channel.isclosed()) return; \/\/ todo somehow connect the cancel back to netsession if (chunk.content().readablebytes() > this.max) { this.channel.abort(); \/\/ todo somehow connect the cancel back to netsession return; } bytebuf bb = chunk.content(); bb.retain(); \/\/ we will use it in upcoming send system.out.println(\"ref count a: \" + bb.refcnt()); streammessage b = new streammessage(\"block\", bb); b.setfield(\"sequence\", this.seq); operationresult or = this.channel.send(b);","code_context_20":"@override public void offer(httpcontent chunk) { if (this.channel.isclosed()) return; \/\/ todo somehow connect the cancel back to netsession if (chunk.content().readablebytes() > this.max) { this.channel.abort(); \/\/ todo somehow connect the cancel back to netsession return; } bytebuf bb = chunk.content(); bb.retain(); \/\/ we will use it in upcoming send system.out.println(\"ref count a: \" + bb.refcnt()); streammessage b = new streammessage(\"block\", bb); b.setfield(\"sequence\", this.seq); operationresult or = this.channel.send(b); \/\/ bb should now be back to 1 system.out.println(\"ref count b: \" + bb.refcnt()); if (or.haserrors()) { this.channel.close(); return; } this.seq++; \/\/ todo track progress if possible \/\/ final only if not canceled if (chunk instanceof lasthttpcontent)","repo":"Gadreel\/divconq"}
{"id":18884,"comment_id":2,"comment":"\/\/ we will use it in upcoming send","code":"@override public void offer(httpcontent chunk) { if (this.channel.isclosed()) return; \/\/ todo somehow connect the cancel back to netsession if (chunk.content().readablebytes() > this.max) { this.channel.abort(); \/\/ todo somehow connect the cancel back to netsession return; } bytebuf bb = chunk.content(); bb.retain(); \/\/ we will use it in upcoming send system.out.println(\"ref count a: \" + bb.refcnt()); streammessage b = new streammessage(\"block\", bb); b.setfield(\"sequence\", this.seq); operationresult or = this.channel.send(b); \/\/ bb should now be back to 1 system.out.println(\"ref count b: \" + bb.refcnt()); if (or.haserrors()) { this.channel.close(); return; } this.seq++; \/\/ todo track progress if possible \/\/ final only if not canceled if (chunk instanceof lasthttpcontent) this.channel.send(messageutil.streamfinal()); }","classification":"NONSATD","isFinished":true,"code_context_2":"} bytebuf bb = chunk.content(); bb.retain(); \/\/ we will use it in upcoming send system.out.println(\"ref count a: \" + bb.refcnt()); streammessage b = new streammessage(\"block\", bb);","code_context_10":"@override public void offer(httpcontent chunk) { if (this.channel.isclosed()) return; \/\/ todo somehow connect the cancel back to netsession if (chunk.content().readablebytes() > this.max) { this.channel.abort(); \/\/ todo somehow connect the cancel back to netsession return; } bytebuf bb = chunk.content(); bb.retain(); \/\/ we will use it in upcoming send system.out.println(\"ref count a: \" + bb.refcnt()); streammessage b = new streammessage(\"block\", bb); b.setfield(\"sequence\", this.seq); operationresult or = this.channel.send(b); \/\/ bb should now be back to 1 system.out.println(\"ref count b: \" + bb.refcnt()); if (or.haserrors()) { this.channel.close(); return; }","code_context_20":"@override public void offer(httpcontent chunk) { if (this.channel.isclosed()) return; \/\/ todo somehow connect the cancel back to netsession if (chunk.content().readablebytes() > this.max) { this.channel.abort(); \/\/ todo somehow connect the cancel back to netsession return; } bytebuf bb = chunk.content(); bb.retain(); \/\/ we will use it in upcoming send system.out.println(\"ref count a: \" + bb.refcnt()); streammessage b = new streammessage(\"block\", bb); b.setfield(\"sequence\", this.seq); operationresult or = this.channel.send(b); \/\/ bb should now be back to 1 system.out.println(\"ref count b: \" + bb.refcnt()); if (or.haserrors()) { this.channel.close(); return; } this.seq++; \/\/ todo track progress if possible \/\/ final only if not canceled if (chunk instanceof lasthttpcontent) this.channel.send(messageutil.streamfinal()); }","repo":"Gadreel\/divconq"}
{"id":18884,"comment_id":3,"comment":"\/\/ bb should now be back to 1","code":"@override public void offer(httpcontent chunk) { if (this.channel.isclosed()) return; \/\/ todo somehow connect the cancel back to netsession if (chunk.content().readablebytes() > this.max) { this.channel.abort(); \/\/ todo somehow connect the cancel back to netsession return; } bytebuf bb = chunk.content(); bb.retain(); \/\/ we will use it in upcoming send system.out.println(\"ref count a: \" + bb.refcnt()); streammessage b = new streammessage(\"block\", bb); b.setfield(\"sequence\", this.seq); operationresult or = this.channel.send(b); \/\/ bb should now be back to 1 system.out.println(\"ref count b: \" + bb.refcnt()); if (or.haserrors()) { this.channel.close(); return; } this.seq++; \/\/ todo track progress if possible \/\/ final only if not canceled if (chunk instanceof lasthttpcontent) this.channel.send(messageutil.streamfinal()); }","classification":"NONSATD","isFinished":true,"code_context_2":"b.setfield(\"sequence\", this.seq); operationresult or = this.channel.send(b); \/\/ bb should now be back to 1 system.out.println(\"ref count b: \" + bb.refcnt()); if (or.haserrors()) {","code_context_10":"if (chunk.content().readablebytes() > this.max) { this.channel.abort(); \/\/ todo somehow connect the cancel back to netsession return; } bytebuf bb = chunk.content(); bb.retain(); \/\/ we will use it in upcoming send system.out.println(\"ref count a: \" + bb.refcnt()); streammessage b = new streammessage(\"block\", bb); b.setfield(\"sequence\", this.seq); operationresult or = this.channel.send(b); \/\/ bb should now be back to 1 system.out.println(\"ref count b: \" + bb.refcnt()); if (or.haserrors()) { this.channel.close(); return; } this.seq++; \/\/ todo track progress if possible \/\/ final only if not canceled if (chunk instanceof lasthttpcontent) this.channel.send(messageutil.streamfinal());","code_context_20":"@override public void offer(httpcontent chunk) { if (this.channel.isclosed()) return; \/\/ todo somehow connect the cancel back to netsession if (chunk.content().readablebytes() > this.max) { this.channel.abort(); \/\/ todo somehow connect the cancel back to netsession return; } bytebuf bb = chunk.content(); bb.retain(); \/\/ we will use it in upcoming send system.out.println(\"ref count a: \" + bb.refcnt()); streammessage b = new streammessage(\"block\", bb); b.setfield(\"sequence\", this.seq); operationresult or = this.channel.send(b); \/\/ bb should now be back to 1 system.out.println(\"ref count b: \" + bb.refcnt()); if (or.haserrors()) { this.channel.close(); return; } this.seq++; \/\/ todo track progress if possible \/\/ final only if not canceled if (chunk instanceof lasthttpcontent) this.channel.send(messageutil.streamfinal()); }","repo":"Gadreel\/divconq"}
{"id":18884,"comment_id":4,"comment":"\/\/ todo track progress if possible \/\/ final only if not canceled","code":"@override public void offer(httpcontent chunk) { if (this.channel.isclosed()) return; \/\/ todo somehow connect the cancel back to netsession if (chunk.content().readablebytes() > this.max) { this.channel.abort(); \/\/ todo somehow connect the cancel back to netsession return; } bytebuf bb = chunk.content(); bb.retain(); \/\/ we will use it in upcoming send system.out.println(\"ref count a: \" + bb.refcnt()); streammessage b = new streammessage(\"block\", bb); b.setfield(\"sequence\", this.seq); operationresult or = this.channel.send(b); \/\/ bb should now be back to 1 system.out.println(\"ref count b: \" + bb.refcnt()); if (or.haserrors()) { this.channel.close(); return; } this.seq++; \/\/ todo track progress if possible \/\/ final only if not canceled if (chunk instanceof lasthttpcontent) this.channel.send(messageutil.streamfinal()); }","classification":"DESIGN","isFinished":true,"code_context_2":"} this.seq++; \/\/ todo track progress if possible \/\/ final only if not canceled if (chunk instanceof lasthttpcontent) this.channel.send(messageutil.streamfinal());","code_context_10":"streammessage b = new streammessage(\"block\", bb); b.setfield(\"sequence\", this.seq); operationresult or = this.channel.send(b); \/\/ bb should now be back to 1 system.out.println(\"ref count b: \" + bb.refcnt()); if (or.haserrors()) { this.channel.close(); return; } this.seq++; \/\/ todo track progress if possible \/\/ final only if not canceled if (chunk instanceof lasthttpcontent) this.channel.send(messageutil.streamfinal()); }","code_context_20":"public void offer(httpcontent chunk) { if (this.channel.isclosed()) return; \/\/ todo somehow connect the cancel back to netsession if (chunk.content().readablebytes() > this.max) { this.channel.abort(); \/\/ todo somehow connect the cancel back to netsession return; } bytebuf bb = chunk.content(); bb.retain(); \/\/ we will use it in upcoming send system.out.println(\"ref count a: \" + bb.refcnt()); streammessage b = new streammessage(\"block\", bb); b.setfield(\"sequence\", this.seq); operationresult or = this.channel.send(b); \/\/ bb should now be back to 1 system.out.println(\"ref count b: \" + bb.refcnt()); if (or.haserrors()) { this.channel.close(); return; } this.seq++; \/\/ todo track progress if possible \/\/ final only if not canceled if (chunk instanceof lasthttpcontent) this.channel.send(messageutil.streamfinal()); }","repo":"Gadreel\/divconq"}
{"id":10828,"comment_id":0,"comment":"\/\/ todo(bazel-team): support \\x escapes","code":"private printer escapecharacter(char c) { if (c == '\"') { return backslashchar(c); } switch (c) { case '\\\\': return backslashchar('\\\\'); case '\\r': return backslashchar('r'); case '\\n': return backslashchar('n'); case '\\t': return backslashchar('t'); default: if (c < 32) { \/\/ todo(bazel-team): support \\x escapes return this.append(string.format(\"\\\\x%02x\", (int) c)); } return this.append(c); \/\/ no need to support utf-8 } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"default: if (c < 32) { \/\/ todo(bazel-team): support \\x escapes return this.append(string.format(\"\\\\x%02x\", (int) c)); }","code_context_10":"case '\\\\': return backslashchar('\\\\'); case '\\r': return backslashchar('r'); case '\\n': return backslashchar('n'); case '\\t': return backslashchar('t'); default: if (c < 32) { \/\/ todo(bazel-team): support \\x escapes return this.append(string.format(\"\\\\x%02x\", (int) c)); } return this.append(c); \/\/ no need to support utf-8 } }","code_context_20":"private printer escapecharacter(char c) { if (c == '\"') { return backslashchar(c); } switch (c) { case '\\\\': return backslashchar('\\\\'); case '\\r': return backslashchar('r'); case '\\n': return backslashchar('n'); case '\\t': return backslashchar('t'); default: if (c < 32) { \/\/ todo(bazel-team): support \\x escapes return this.append(string.format(\"\\\\x%02x\", (int) c)); } return this.append(c); \/\/ no need to support utf-8 } }","repo":"AyuMol758\/bazel"}
{"id":10828,"comment_id":1,"comment":"\/\/ no need to support utf-8","code":"private printer escapecharacter(char c) { if (c == '\"') { return backslashchar(c); } switch (c) { case '\\\\': return backslashchar('\\\\'); case '\\r': return backslashchar('r'); case '\\n': return backslashchar('n'); case '\\t': return backslashchar('t'); default: if (c < 32) { \/\/ todo(bazel-team): support \\x escapes return this.append(string.format(\"\\\\x%02x\", (int) c)); } return this.append(c); \/\/ no need to support utf-8 } }","classification":"NONSATD","isFinished":true,"code_context_2":"return this.append(string.format(\"\\\\x%02x\", (int) c)); } return this.append(c); \/\/ no need to support utf-8 } }","code_context_10":"return backslashchar('r'); case '\\n': return backslashchar('n'); case '\\t': return backslashchar('t'); default: if (c < 32) { \/\/ todo(bazel-team): support \\x escapes return this.append(string.format(\"\\\\x%02x\", (int) c)); } return this.append(c); \/\/ no need to support utf-8 } }","code_context_20":"private printer escapecharacter(char c) { if (c == '\"') { return backslashchar(c); } switch (c) { case '\\\\': return backslashchar('\\\\'); case '\\r': return backslashchar('r'); case '\\n': return backslashchar('n'); case '\\t': return backslashchar('t'); default: if (c < 32) { \/\/ todo(bazel-team): support \\x escapes return this.append(string.format(\"\\\\x%02x\", (int) c)); } return this.append(c); \/\/ no need to support utf-8 } }","repo":"AyuMol758\/bazel"}
{"id":10844,"comment_id":0,"comment":"\/\/todo: we do not support projections from multiple pig statements yet","code":"@override public void meet(projection node) throws runtimeexception { super.meet(node); projectionelemlist list = node.getprojectionelemlist(); string set = null; stringbuilder projlist = new stringbuilder(); boolean first = true; \/\/todo: we do not support projections from multiple pig statements yet for (string name : list.gettargetnames()) { set = vartoset.get(name); \/\/todo: overwrite if (set == null) { throw new illegalargumentexception(\"have not found any pig logic for name[\" + name + \"]\"); } if (!first) { projlist.append(\",\"); } first = false; projlist.append(name); } if (set == null) throw new illegalargumentexception(\"\"); \/\/todo: fill this \/\/suborg = foreach suborg_l generate dept, univ; pigscriptbuilder.append(\"proj = foreach \").append(set).append(\" generate \").append(projlist.tostring()).append(\";\\n\"); }","classification":"DESIGN","isFinished":true,"code_context_2":"stringbuilder projlist = new stringbuilder(); boolean first = true; \/\/todo: we do not support projections from multiple pig statements yet for (string name : list.gettargetnames()) { set = vartoset.get(name); \/\/todo: overwrite","code_context_10":"@override public void meet(projection node) throws runtimeexception { super.meet(node); projectionelemlist list = node.getprojectionelemlist(); string set = null; stringbuilder projlist = new stringbuilder(); boolean first = true; \/\/todo: we do not support projections from multiple pig statements yet for (string name : list.gettargetnames()) { set = vartoset.get(name); \/\/todo: overwrite if (set == null) { throw new illegalargumentexception(\"have not found any pig logic for name[\" + name + \"]\"); } if (!first) { projlist.append(\",\"); } first = false; projlist.append(name);","code_context_20":"@override public void meet(projection node) throws runtimeexception { super.meet(node); projectionelemlist list = node.getprojectionelemlist(); string set = null; stringbuilder projlist = new stringbuilder(); boolean first = true; \/\/todo: we do not support projections from multiple pig statements yet for (string name : list.gettargetnames()) { set = vartoset.get(name); \/\/todo: overwrite if (set == null) { throw new illegalargumentexception(\"have not found any pig logic for name[\" + name + \"]\"); } if (!first) { projlist.append(\",\"); } first = false; projlist.append(name); } if (set == null) throw new illegalargumentexception(\"\"); \/\/todo: fill this \/\/suborg = foreach suborg_l generate dept, univ; pigscriptbuilder.append(\"proj = foreach \").append(set).append(\" generate \").append(projlist.tostring()).append(\";\\n\"); }","repo":"DLotts\/incubator-rya"}
{"id":10844,"comment_id":1,"comment":"\/\/todo: overwrite","code":"@override public void meet(projection node) throws runtimeexception { super.meet(node); projectionelemlist list = node.getprojectionelemlist(); string set = null; stringbuilder projlist = new stringbuilder(); boolean first = true; \/\/todo: we do not support projections from multiple pig statements yet for (string name : list.gettargetnames()) { set = vartoset.get(name); \/\/todo: overwrite if (set == null) { throw new illegalargumentexception(\"have not found any pig logic for name[\" + name + \"]\"); } if (!first) { projlist.append(\",\"); } first = false; projlist.append(name); } if (set == null) throw new illegalargumentexception(\"\"); \/\/todo: fill this \/\/suborg = foreach suborg_l generate dept, univ; pigscriptbuilder.append(\"proj = foreach \").append(set).append(\" generate \").append(projlist.tostring()).append(\";\\n\"); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"\/\/todo: we do not support projections from multiple pig statements yet for (string name : list.gettargetnames()) { set = vartoset.get(name); \/\/todo: overwrite if (set == null) { throw new illegalargumentexception(\"have not found any pig logic for name[\" + name + \"]\");","code_context_10":"@override public void meet(projection node) throws runtimeexception { super.meet(node); projectionelemlist list = node.getprojectionelemlist(); string set = null; stringbuilder projlist = new stringbuilder(); boolean first = true; \/\/todo: we do not support projections from multiple pig statements yet for (string name : list.gettargetnames()) { set = vartoset.get(name); \/\/todo: overwrite if (set == null) { throw new illegalargumentexception(\"have not found any pig logic for name[\" + name + \"]\"); } if (!first) { projlist.append(\",\"); } first = false; projlist.append(name); } if (set == null)","code_context_20":"@override public void meet(projection node) throws runtimeexception { super.meet(node); projectionelemlist list = node.getprojectionelemlist(); string set = null; stringbuilder projlist = new stringbuilder(); boolean first = true; \/\/todo: we do not support projections from multiple pig statements yet for (string name : list.gettargetnames()) { set = vartoset.get(name); \/\/todo: overwrite if (set == null) { throw new illegalargumentexception(\"have not found any pig logic for name[\" + name + \"]\"); } if (!first) { projlist.append(\",\"); } first = false; projlist.append(name); } if (set == null) throw new illegalargumentexception(\"\"); \/\/todo: fill this \/\/suborg = foreach suborg_l generate dept, univ; pigscriptbuilder.append(\"proj = foreach \").append(set).append(\" generate \").append(projlist.tostring()).append(\";\\n\"); }","repo":"DLotts\/incubator-rya"}
{"id":10844,"comment_id":2,"comment":"\/\/todo: fill this","code":"@override public void meet(projection node) throws runtimeexception { super.meet(node); projectionelemlist list = node.getprojectionelemlist(); string set = null; stringbuilder projlist = new stringbuilder(); boolean first = true; \/\/todo: we do not support projections from multiple pig statements yet for (string name : list.gettargetnames()) { set = vartoset.get(name); \/\/todo: overwrite if (set == null) { throw new illegalargumentexception(\"have not found any pig logic for name[\" + name + \"]\"); } if (!first) { projlist.append(\",\"); } first = false; projlist.append(name); } if (set == null) throw new illegalargumentexception(\"\"); \/\/todo: fill this \/\/suborg = foreach suborg_l generate dept, univ; pigscriptbuilder.append(\"proj = foreach \").append(set).append(\" generate \").append(projlist.tostring()).append(\";\\n\"); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"} if (set == null) throw new illegalargumentexception(\"\"); \/\/todo: fill this \/\/suborg = foreach suborg_l generate dept, univ; pigscriptbuilder.append(\"proj = foreach \").append(set).append(\" generate \").append(projlist.tostring()).append(\";\\n\");","code_context_10":"if (set == null) { throw new illegalargumentexception(\"have not found any pig logic for name[\" + name + \"]\"); } if (!first) { projlist.append(\",\"); } first = false; projlist.append(name); } if (set == null) throw new illegalargumentexception(\"\"); \/\/todo: fill this \/\/suborg = foreach suborg_l generate dept, univ; pigscriptbuilder.append(\"proj = foreach \").append(set).append(\" generate \").append(projlist.tostring()).append(\";\\n\"); }","code_context_20":"@override public void meet(projection node) throws runtimeexception { super.meet(node); projectionelemlist list = node.getprojectionelemlist(); string set = null; stringbuilder projlist = new stringbuilder(); boolean first = true; \/\/todo: we do not support projections from multiple pig statements yet for (string name : list.gettargetnames()) { set = vartoset.get(name); \/\/todo: overwrite if (set == null) { throw new illegalargumentexception(\"have not found any pig logic for name[\" + name + \"]\"); } if (!first) { projlist.append(\",\"); } first = false; projlist.append(name); } if (set == null) throw new illegalargumentexception(\"\"); \/\/todo: fill this \/\/suborg = foreach suborg_l generate dept, univ; pigscriptbuilder.append(\"proj = foreach \").append(set).append(\" generate \").append(projlist.tostring()).append(\";\\n\"); }","repo":"DLotts\/incubator-rya"}
{"id":10844,"comment_id":3,"comment":"\/\/suborg = foreach suborg_l generate dept, univ;","code":"@override public void meet(projection node) throws runtimeexception { super.meet(node); projectionelemlist list = node.getprojectionelemlist(); string set = null; stringbuilder projlist = new stringbuilder(); boolean first = true; \/\/todo: we do not support projections from multiple pig statements yet for (string name : list.gettargetnames()) { set = vartoset.get(name); \/\/todo: overwrite if (set == null) { throw new illegalargumentexception(\"have not found any pig logic for name[\" + name + \"]\"); } if (!first) { projlist.append(\",\"); } first = false; projlist.append(name); } if (set == null) throw new illegalargumentexception(\"\"); \/\/todo: fill this \/\/suborg = foreach suborg_l generate dept, univ; pigscriptbuilder.append(\"proj = foreach \").append(set).append(\" generate \").append(projlist.tostring()).append(\";\\n\"); }","classification":"NONSATD","isFinished":true,"code_context_2":"if (set == null) throw new illegalargumentexception(\"\"); \/\/todo: fill this \/\/suborg = foreach suborg_l generate dept, univ; pigscriptbuilder.append(\"proj = foreach \").append(set).append(\" generate \").append(projlist.tostring()).append(\";\\n\"); }","code_context_10":"throw new illegalargumentexception(\"have not found any pig logic for name[\" + name + \"]\"); } if (!first) { projlist.append(\",\"); } first = false; projlist.append(name); } if (set == null) throw new illegalargumentexception(\"\"); \/\/todo: fill this \/\/suborg = foreach suborg_l generate dept, univ; pigscriptbuilder.append(\"proj = foreach \").append(set).append(\" generate \").append(projlist.tostring()).append(\";\\n\"); }","code_context_20":"public void meet(projection node) throws runtimeexception { super.meet(node); projectionelemlist list = node.getprojectionelemlist(); string set = null; stringbuilder projlist = new stringbuilder(); boolean first = true; \/\/todo: we do not support projections from multiple pig statements yet for (string name : list.gettargetnames()) { set = vartoset.get(name); \/\/todo: overwrite if (set == null) { throw new illegalargumentexception(\"have not found any pig logic for name[\" + name + \"]\"); } if (!first) { projlist.append(\",\"); } first = false; projlist.append(name); } if (set == null) throw new illegalargumentexception(\"\"); \/\/todo: fill this \/\/suborg = foreach suborg_l generate dept, univ; pigscriptbuilder.append(\"proj = foreach \").append(set).append(\" generate \").append(projlist.tostring()).append(\";\\n\"); }","repo":"DLotts\/incubator-rya"}
{"id":2684,"comment_id":0,"comment":"\/* todo: support tagging in multiple locations to support all locations: 1- taxonomies\/policytags have to be created in each required location 2- update the tagger cloud function to read one mapping per location for now, we don't submit tasks for tables in other locations than the policytag location *\/","code":"public list<jsonmessage> processdatasets(list<string> datasetincludelist, list<string> datasetexcludelist, list<string> tableexcludelist, string dataregionid) throws ioexception, interruptedexception, nonretryableapplicationexception { list<string> tablesincludelist = new arraylist<>(); for (string dataset : datasetincludelist) { try { if (!datasetexcludelist.contains(dataset)) { list<string> tokens = utils.tokenize(dataset, \".\", true); string projectid = tokens.get(0); string datasetid = tokens.get(1); string datasetlocation = bqservice.getdatasetlocation(projectid, datasetid); \/* todo: support tagging in multiple locations to support all locations: 1- taxonomies\/policytags have to be created in each required location 2- update the tagger cloud function to read one mapping per location for now, we don't submit tasks for tables in other locations than the policytag location *\/ if (!datasetlocation.tolowercase().equals(dataregionid.tolowercase())) { logger.logwarnwithtracker(runid, string.format( \"ignoring dataset %s in location %s. only location %s is configured\", dataset, datasetlocation, dataregionid) ); continue; } \/\/ get all tables that have dlp findings list<string> datasettables = scanner.listchildren(projectid, datasetid); tablesincludelist.addall(datasettables); if (datasettables.isempty()) { string msg = string.format( \"no tables found under dataset '%s'\", dataset); logger.logwarnwithtracker(runid, msg); } else { logger.loginfowithtracker(runid, string.format(\"tables found in dataset %s : %s\", dataset, datasettables)); } } } catch (exception exception) { \/\/ log and continue logger.logfaileddispatcherentityid(runid, dataset, exception); } } return processtables(tablesincludelist, tableexcludelist); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"string datasetid = tokens.get(1); string datasetlocation = bqservice.getdatasetlocation(projectid, datasetid); \/* todo: support tagging in multiple locations to support all locations: 1- taxonomies\/policytags have to be created in each required location 2- update the tagger cloud function to read one mapping per location for now, we don't submit tasks for tables in other locations than the policytag location *\/ if (!datasetlocation.tolowercase().equals(dataregionid.tolowercase())) { logger.logwarnwithtracker(runid,","code_context_10":"list<string> tableexcludelist, string dataregionid) throws ioexception, interruptedexception, nonretryableapplicationexception { list<string> tablesincludelist = new arraylist<>(); for (string dataset : datasetincludelist) { try { if (!datasetexcludelist.contains(dataset)) { list<string> tokens = utils.tokenize(dataset, \".\", true); string projectid = tokens.get(0); string datasetid = tokens.get(1); string datasetlocation = bqservice.getdatasetlocation(projectid, datasetid); \/* todo: support tagging in multiple locations to support all locations: 1- taxonomies\/policytags have to be created in each required location 2- update the tagger cloud function to read one mapping per location for now, we don't submit tasks for tables in other locations than the policytag location *\/ if (!datasetlocation.tolowercase().equals(dataregionid.tolowercase())) { logger.logwarnwithtracker(runid, string.format( \"ignoring dataset %s in location %s. only location %s is configured\", dataset, datasetlocation, dataregionid) ); continue; }","code_context_20":"public list<jsonmessage> processdatasets(list<string> datasetincludelist, list<string> datasetexcludelist, list<string> tableexcludelist, string dataregionid) throws ioexception, interruptedexception, nonretryableapplicationexception { list<string> tablesincludelist = new arraylist<>(); for (string dataset : datasetincludelist) { try { if (!datasetexcludelist.contains(dataset)) { list<string> tokens = utils.tokenize(dataset, \".\", true); string projectid = tokens.get(0); string datasetid = tokens.get(1); string datasetlocation = bqservice.getdatasetlocation(projectid, datasetid); \/* todo: support tagging in multiple locations to support all locations: 1- taxonomies\/policytags have to be created in each required location 2- update the tagger cloud function to read one mapping per location for now, we don't submit tasks for tables in other locations than the policytag location *\/ if (!datasetlocation.tolowercase().equals(dataregionid.tolowercase())) { logger.logwarnwithtracker(runid, string.format( \"ignoring dataset %s in location %s. only location %s is configured\", dataset, datasetlocation, dataregionid) ); continue; } \/\/ get all tables that have dlp findings list<string> datasettables = scanner.listchildren(projectid, datasetid); tablesincludelist.addall(datasettables); if (datasettables.isempty()) { string msg = string.format( \"no tables found under dataset '%s'\", dataset); logger.logwarnwithtracker(runid, msg); } else { logger.loginfowithtracker(runid, string.format(\"tables found in dataset %s : %s\", dataset, datasettables));","repo":"GoogleCloudPlatform\/bq-pii-classifier"}
{"id":2684,"comment_id":1,"comment":"\/\/ get all tables that have dlp findings","code":"public list<jsonmessage> processdatasets(list<string> datasetincludelist, list<string> datasetexcludelist, list<string> tableexcludelist, string dataregionid) throws ioexception, interruptedexception, nonretryableapplicationexception { list<string> tablesincludelist = new arraylist<>(); for (string dataset : datasetincludelist) { try { if (!datasetexcludelist.contains(dataset)) { list<string> tokens = utils.tokenize(dataset, \".\", true); string projectid = tokens.get(0); string datasetid = tokens.get(1); string datasetlocation = bqservice.getdatasetlocation(projectid, datasetid); \/* todo: support tagging in multiple locations to support all locations: 1- taxonomies\/policytags have to be created in each required location 2- update the tagger cloud function to read one mapping per location for now, we don't submit tasks for tables in other locations than the policytag location *\/ if (!datasetlocation.tolowercase().equals(dataregionid.tolowercase())) { logger.logwarnwithtracker(runid, string.format( \"ignoring dataset %s in location %s. only location %s is configured\", dataset, datasetlocation, dataregionid) ); continue; } \/\/ get all tables that have dlp findings list<string> datasettables = scanner.listchildren(projectid, datasetid); tablesincludelist.addall(datasettables); if (datasettables.isempty()) { string msg = string.format( \"no tables found under dataset '%s'\", dataset); logger.logwarnwithtracker(runid, msg); } else { logger.loginfowithtracker(runid, string.format(\"tables found in dataset %s : %s\", dataset, datasettables)); } } } catch (exception exception) { \/\/ log and continue logger.logfaileddispatcherentityid(runid, dataset, exception); } } return processtables(tablesincludelist, tableexcludelist); }","classification":"NONSATD","isFinished":true,"code_context_2":"continue; } \/\/ get all tables that have dlp findings list<string> datasettables = scanner.listchildren(projectid, datasetid); tablesincludelist.addall(datasettables);","code_context_10":"if (!datasetlocation.tolowercase().equals(dataregionid.tolowercase())) { logger.logwarnwithtracker(runid, string.format( \"ignoring dataset %s in location %s. only location %s is configured\", dataset, datasetlocation, dataregionid) ); continue; } \/\/ get all tables that have dlp findings list<string> datasettables = scanner.listchildren(projectid, datasetid); tablesincludelist.addall(datasettables); if (datasettables.isempty()) { string msg = string.format( \"no tables found under dataset '%s'\", dataset); logger.logwarnwithtracker(runid, msg); } else { logger.loginfowithtracker(runid, string.format(\"tables found in dataset %s : %s\", dataset, datasettables)); }","code_context_20":"string projectid = tokens.get(0); string datasetid = tokens.get(1); string datasetlocation = bqservice.getdatasetlocation(projectid, datasetid); \/* todo: support tagging in multiple locations to support all locations: 1- taxonomies\/policytags have to be created in each required location 2- update the tagger cloud function to read one mapping per location for now, we don't submit tasks for tables in other locations than the policytag location *\/ if (!datasetlocation.tolowercase().equals(dataregionid.tolowercase())) { logger.logwarnwithtracker(runid, string.format( \"ignoring dataset %s in location %s. only location %s is configured\", dataset, datasetlocation, dataregionid) ); continue; } \/\/ get all tables that have dlp findings list<string> datasettables = scanner.listchildren(projectid, datasetid); tablesincludelist.addall(datasettables); if (datasettables.isempty()) { string msg = string.format( \"no tables found under dataset '%s'\", dataset); logger.logwarnwithtracker(runid, msg); } else { logger.loginfowithtracker(runid, string.format(\"tables found in dataset %s : %s\", dataset, datasettables)); } } } catch (exception exception) { \/\/ log and continue logger.logfaileddispatcherentityid(runid, dataset, exception); } } return processtables(tablesincludelist, tableexcludelist); }","repo":"GoogleCloudPlatform\/bq-pii-classifier"}
{"id":2684,"comment_id":2,"comment":"\/\/ log and continue","code":"public list<jsonmessage> processdatasets(list<string> datasetincludelist, list<string> datasetexcludelist, list<string> tableexcludelist, string dataregionid) throws ioexception, interruptedexception, nonretryableapplicationexception { list<string> tablesincludelist = new arraylist<>(); for (string dataset : datasetincludelist) { try { if (!datasetexcludelist.contains(dataset)) { list<string> tokens = utils.tokenize(dataset, \".\", true); string projectid = tokens.get(0); string datasetid = tokens.get(1); string datasetlocation = bqservice.getdatasetlocation(projectid, datasetid); \/* todo: support tagging in multiple locations to support all locations: 1- taxonomies\/policytags have to be created in each required location 2- update the tagger cloud function to read one mapping per location for now, we don't submit tasks for tables in other locations than the policytag location *\/ if (!datasetlocation.tolowercase().equals(dataregionid.tolowercase())) { logger.logwarnwithtracker(runid, string.format( \"ignoring dataset %s in location %s. only location %s is configured\", dataset, datasetlocation, dataregionid) ); continue; } \/\/ get all tables that have dlp findings list<string> datasettables = scanner.listchildren(projectid, datasetid); tablesincludelist.addall(datasettables); if (datasettables.isempty()) { string msg = string.format( \"no tables found under dataset '%s'\", dataset); logger.logwarnwithtracker(runid, msg); } else { logger.loginfowithtracker(runid, string.format(\"tables found in dataset %s : %s\", dataset, datasettables)); } } } catch (exception exception) { \/\/ log and continue logger.logfaileddispatcherentityid(runid, dataset, exception); } } return processtables(tablesincludelist, tableexcludelist); }","classification":"NONSATD","isFinished":true,"code_context_2":"} } catch (exception exception) { \/\/ log and continue logger.logfaileddispatcherentityid(runid, dataset, exception); }","code_context_10":"if (datasettables.isempty()) { string msg = string.format( \"no tables found under dataset '%s'\", dataset); logger.logwarnwithtracker(runid, msg); } else { logger.loginfowithtracker(runid, string.format(\"tables found in dataset %s : %s\", dataset, datasettables)); } } } catch (exception exception) { \/\/ log and continue logger.logfaileddispatcherentityid(runid, dataset, exception); } } return processtables(tablesincludelist, tableexcludelist); }","code_context_20":"\"ignoring dataset %s in location %s. only location %s is configured\", dataset, datasetlocation, dataregionid) ); continue; } \/\/ get all tables that have dlp findings list<string> datasettables = scanner.listchildren(projectid, datasetid); tablesincludelist.addall(datasettables); if (datasettables.isempty()) { string msg = string.format( \"no tables found under dataset '%s'\", dataset); logger.logwarnwithtracker(runid, msg); } else { logger.loginfowithtracker(runid, string.format(\"tables found in dataset %s : %s\", dataset, datasettables)); } } } catch (exception exception) { \/\/ log and continue logger.logfaileddispatcherentityid(runid, dataset, exception); } } return processtables(tablesincludelist, tableexcludelist); }","repo":"GoogleCloudPlatform\/bq-pii-classifier"}
{"id":10989,"comment_id":0,"comment":"\/** * control this view's display\/prompt\/action loop until the user chooses and * action that causes this view to close. *\/","code":"\/** * control this view's display\/prompt\/action loop until the user chooses and * action that causes this view to close. *\/ @override \/\/using this override to place getannualreport and gameshouldend inside displayview while loop. public void displayview() { boolean keepgoing = true; while (keepgoing == true) { \/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview livetheyear(); getannualreport(); if (gamecontrol.gameshouldend(0)) { \/\/todo when fully implemented, this will contain mortality rate variable from annual report this.console.println(\"more than 50% of your population died, therefore this game is over. repent and try again.\"); return; } else if (gamecontrol.gamematures(1)) { \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. this.console.println(\"ten glorious years have passed, therefore this game is over. congratulations on a successful game!\"); return; } \/\/ get message that should be displayed \/\/ only print if it is non-null string message = getmessage(); if (message != null) { this.console.println(getmessage()); } string[] inputs = getinputs(); keepgoing = doaction(inputs); } }","classification":"NONSATD","isFinished":true,"code_context_2":"@override \/\/using this override to place getannualreport and gameshouldend inside displayview while loop. public void displayview() { boolean keepgoing = true; while (keepgoing == true) { \/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview livetheyear(); getannualreport(); if (gamecontrol.gameshouldend(0)) { \/\/todo when fully implemented, this will contain mortality rate variable from annual report this.console.println(\"more than 50% of your population died, therefore this game is over. repent and try again.\"); return; } else if (gamecontrol.gamematures(1)) { \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. this.console.println(\"ten glorious years have passed, therefore this game is over. congratulations on a successful game!\"); return; } \/\/ get message that should be displayed \/\/ only print if it is non-null string message = getmessage(); if (message != null) { this.console.println(getmessage()); } string[] inputs = getinputs(); keepgoing = doaction(inputs); } }","code_context_10":"@override \/\/using this override to place getannualreport and gameshouldend inside displayview while loop. public void displayview() { boolean keepgoing = true; while (keepgoing == true) { \/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview livetheyear(); getannualreport(); if (gamecontrol.gameshouldend(0)) { \/\/todo when fully implemented, this will contain mortality rate variable from annual report this.console.println(\"more than 50% of your population died, therefore this game is over. repent and try again.\"); return; } else if (gamecontrol.gamematures(1)) { \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. this.console.println(\"ten glorious years have passed, therefore this game is over. congratulations on a successful game!\"); return; } \/\/ get message that should be displayed \/\/ only print if it is non-null string message = getmessage(); if (message != null) { this.console.println(getmessage()); } string[] inputs = getinputs(); keepgoing = doaction(inputs); } }","code_context_20":"@override \/\/using this override to place getannualreport and gameshouldend inside displayview while loop. public void displayview() { boolean keepgoing = true; while (keepgoing == true) { \/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview livetheyear(); getannualreport(); if (gamecontrol.gameshouldend(0)) { \/\/todo when fully implemented, this will contain mortality rate variable from annual report this.console.println(\"more than 50% of your population died, therefore this game is over. repent and try again.\"); return; } else if (gamecontrol.gamematures(1)) { \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. this.console.println(\"ten glorious years have passed, therefore this game is over. congratulations on a successful game!\"); return; } \/\/ get message that should be displayed \/\/ only print if it is non-null string message = getmessage(); if (message != null) { this.console.println(getmessage()); } string[] inputs = getinputs(); keepgoing = doaction(inputs); } }","repo":"Hsia-Esther\/CityOfAaronGroup1"}
{"id":10989,"comment_id":1,"comment":"\/\/using this override to place getannualreport and gameshouldend inside displayview while loop.","code":"@override \/\/using this override to place getannualreport and gameshouldend inside displayview while loop. public void displayview() { boolean keepgoing = true; while (keepgoing == true) { \/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview livetheyear(); getannualreport(); if (gamecontrol.gameshouldend(0)) { \/\/todo when fully implemented, this will contain mortality rate variable from annual report this.console.println(\"more than 50% of your population died, therefore this game is over. repent and try again.\"); return; } else if (gamecontrol.gamematures(1)) { \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. this.console.println(\"ten glorious years have passed, therefore this game is over. congratulations on a successful game!\"); return; } \/\/ get message that should be displayed \/\/ only print if it is non-null string message = getmessage(); if (message != null) { this.console.println(getmessage()); } string[] inputs = getinputs(); keepgoing = doaction(inputs); } }","classification":"NONSATD","isFinished":true,"code_context_2":"@override \/\/using this override to place getannualreport and gameshouldend inside displayview while loop. public void displayview() { boolean keepgoing = true;","code_context_10":"@override \/\/using this override to place getannualreport and gameshouldend inside displayview while loop. public void displayview() { boolean keepgoing = true; while (keepgoing == true) { \/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview livetheyear();","code_context_20":"@override \/\/using this override to place getannualreport and gameshouldend inside displayview while loop. public void displayview() { boolean keepgoing = true; while (keepgoing == true) { \/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview livetheyear(); getannualreport(); if (gamecontrol.gameshouldend(0)) { \/\/todo when fully implemented, this will contain mortality rate variable from annual report this.console.println(\"more than 50% of your population died, therefore this game is over. repent and try again.\"); return; } else if (gamecontrol.gamematures(1)) { \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. this.console.println(\"ten glorious years have passed, therefore this game is over. congratulations on a successful game!\"); return;","repo":"Hsia-Esther\/CityOfAaronGroup1"}
{"id":10989,"comment_id":2,"comment":"\/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview","code":"@override \/\/using this override to place getannualreport and gameshouldend inside displayview while loop. public void displayview() { boolean keepgoing = true; while (keepgoing == true) { \/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview livetheyear(); getannualreport(); if (gamecontrol.gameshouldend(0)) { \/\/todo when fully implemented, this will contain mortality rate variable from annual report this.console.println(\"more than 50% of your population died, therefore this game is over. repent and try again.\"); return; } else if (gamecontrol.gamematures(1)) { \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. this.console.println(\"ten glorious years have passed, therefore this game is over. congratulations on a successful game!\"); return; } \/\/ get message that should be displayed \/\/ only print if it is non-null string message = getmessage(); if (message != null) { this.console.println(getmessage()); } string[] inputs = getinputs(); keepgoing = doaction(inputs); } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"boolean keepgoing = true; while (keepgoing == true) { \/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview livetheyear(); getannualreport();","code_context_10":"@override \/\/using this override to place getannualreport and gameshouldend inside displayview while loop. public void displayview() { boolean keepgoing = true; while (keepgoing == true) { \/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview livetheyear(); getannualreport(); if (gamecontrol.gameshouldend(0)) { \/\/todo when fully implemented, this will contain mortality rate variable from annual report this.console.println(\"more than 50% of your population died, therefore this game is over. repent and try again.\"); return; } else if (gamecontrol.gamematures(1)) { \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. this.console.println(\"ten glorious years have passed, therefore this game is over. congratulations on a successful game!\");","code_context_20":"@override \/\/using this override to place getannualreport and gameshouldend inside displayview while loop. public void displayview() { boolean keepgoing = true; while (keepgoing == true) { \/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview livetheyear(); getannualreport(); if (gamecontrol.gameshouldend(0)) { \/\/todo when fully implemented, this will contain mortality rate variable from annual report this.console.println(\"more than 50% of your population died, therefore this game is over. repent and try again.\"); return; } else if (gamecontrol.gamematures(1)) { \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. this.console.println(\"ten glorious years have passed, therefore this game is over. congratulations on a successful game!\"); return; } \/\/ get message that should be displayed \/\/ only print if it is non-null string message = getmessage(); if (message != null) { this.console.println(getmessage()); } string[] inputs = getinputs(); keepgoing = doaction(inputs);","repo":"Hsia-Esther\/CityOfAaronGroup1"}
{"id":10989,"comment_id":3,"comment":"\/\/todo when fully implemented, this will contain mortality rate variable from annual report","code":"@override \/\/using this override to place getannualreport and gameshouldend inside displayview while loop. public void displayview() { boolean keepgoing = true; while (keepgoing == true) { \/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview livetheyear(); getannualreport(); if (gamecontrol.gameshouldend(0)) { \/\/todo when fully implemented, this will contain mortality rate variable from annual report this.console.println(\"more than 50% of your population died, therefore this game is over. repent and try again.\"); return; } else if (gamecontrol.gamematures(1)) { \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. this.console.println(\"ten glorious years have passed, therefore this game is over. congratulations on a successful game!\"); return; } \/\/ get message that should be displayed \/\/ only print if it is non-null string message = getmessage(); if (message != null) { this.console.println(getmessage()); } string[] inputs = getinputs(); keepgoing = doaction(inputs); } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"\/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year.","code_context_10":"@override \/\/using this override to place getannualreport and gameshouldend inside displayview while loop. public void displayview() { boolean keepgoing = true; while (keepgoing == true) { \/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview livetheyear(); getannualreport(); if (gamecontrol.gameshouldend(0)) { \/\/todo when fully implemented, this will contain mortality rate variable from annual report this.console.println(\"more than 50% of your population died, therefore this game is over. repent and try again.\"); return; } else if (gamecontrol.gamematures(1)) {","code_context_20":"@override \/\/using this override to place getannualreport and gameshouldend inside displayview while loop. public void displayview() { boolean keepgoing = true; while (keepgoing == true) { \/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview livetheyear(); getannualreport(); if (gamecontrol.gameshouldend(0)) { \/\/todo when fully implemented, this will contain mortality rate variable from annual report this.console.println(\"more than 50% of your population died, therefore this game is over. repent and try again.\"); return; } else if (gamecontrol.gamematures(1)) { \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. this.console.println(\"ten glorious years have passed, therefore this game is over. congratulations on a successful game!\"); return; } \/\/ get message that should be displayed \/\/ only print if it is non-null string message = getmessage(); if (message != null) { this.console.println(getmessage());","repo":"Hsia-Esther\/CityOfAaronGroup1"}
{"id":10989,"comment_id":4,"comment":"\/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year.","code":"@override \/\/using this override to place getannualreport and gameshouldend inside displayview while loop. public void displayview() { boolean keepgoing = true; while (keepgoing == true) { \/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview livetheyear(); getannualreport(); if (gamecontrol.gameshouldend(0)) { \/\/todo when fully implemented, this will contain mortality rate variable from annual report this.console.println(\"more than 50% of your population died, therefore this game is over. repent and try again.\"); return; } else if (gamecontrol.gamematures(1)) { \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. this.console.println(\"ten glorious years have passed, therefore this game is over. congratulations on a successful game!\"); return; } \/\/ get message that should be displayed \/\/ only print if it is non-null string message = getmessage(); if (message != null) { this.console.println(getmessage()); } string[] inputs = getinputs(); keepgoing = doaction(inputs); } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"\/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview livetheyear();","code_context_10":"@override \/\/using this override to place getannualreport and gameshouldend inside displayview while loop. public void displayview() { boolean keepgoing = true; while (keepgoing == true) { \/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview livetheyear(); getannualreport(); if (gamecontrol.gameshouldend(0)) { \/\/todo when fully implemented, this will contain mortality rate variable from annual report this.console.println(\"more than 50% of your population died, therefore this game is over. repent and try again.\"); return; } else if (gamecontrol.gamematures(1)) { \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year.","code_context_20":"@override \/\/using this override to place getannualreport and gameshouldend inside displayview while loop. public void displayview() { boolean keepgoing = true; while (keepgoing == true) { \/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview livetheyear(); getannualreport(); if (gamecontrol.gameshouldend(0)) { \/\/todo when fully implemented, this will contain mortality rate variable from annual report this.console.println(\"more than 50% of your population died, therefore this game is over. repent and try again.\"); return; } else if (gamecontrol.gamematures(1)) { \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. this.console.println(\"ten glorious years have passed, therefore this game is over. congratulations on a successful game!\"); return; } \/\/ get message that should be displayed \/\/ only print if it is non-null string message = getmessage(); if (message != null) { this.console.println(getmessage()); } string[] inputs = getinputs();","repo":"Hsia-Esther\/CityOfAaronGroup1"}
{"id":10989,"comment_id":5,"comment":"\/\/ get message that should be displayed \/\/ only print if it is non-null","code":"@override \/\/using this override to place getannualreport and gameshouldend inside displayview while loop. public void displayview() { boolean keepgoing = true; while (keepgoing == true) { \/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview livetheyear(); getannualreport(); if (gamecontrol.gameshouldend(0)) { \/\/todo when fully implemented, this will contain mortality rate variable from annual report this.console.println(\"more than 50% of your population died, therefore this game is over. repent and try again.\"); return; } else if (gamecontrol.gamematures(1)) { \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. this.console.println(\"ten glorious years have passed, therefore this game is over. congratulations on a successful game!\"); return; } \/\/ get message that should be displayed \/\/ only print if it is non-null string message = getmessage(); if (message != null) { this.console.println(getmessage()); } string[] inputs = getinputs(); keepgoing = doaction(inputs); } }","classification":"NONSATD","isFinished":true,"code_context_2":"return; } \/\/ get message that should be displayed \/\/ only print if it is non-null string message = getmessage(); if (message != null) {","code_context_10":"if (gamecontrol.gameshouldend(0)) { \/\/todo when fully implemented, this will contain mortality rate variable from annual report this.console.println(\"more than 50% of your population died, therefore this game is over. repent and try again.\"); return; } else if (gamecontrol.gamematures(1)) { \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. this.console.println(\"ten glorious years have passed, therefore this game is over. congratulations on a successful game!\"); return; } \/\/ get message that should be displayed \/\/ only print if it is non-null string message = getmessage(); if (message != null) { this.console.println(getmessage()); } string[] inputs = getinputs(); keepgoing = doaction(inputs); } }","code_context_20":"boolean keepgoing = true; while (keepgoing == true) { \/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview livetheyear(); getannualreport(); if (gamecontrol.gameshouldend(0)) { \/\/todo when fully implemented, this will contain mortality rate variable from annual report this.console.println(\"more than 50% of your population died, therefore this game is over. repent and try again.\"); return; } else if (gamecontrol.gamematures(1)) { \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. this.console.println(\"ten glorious years have passed, therefore this game is over. congratulations on a successful game!\"); return; } \/\/ get message that should be displayed \/\/ only print if it is non-null string message = getmessage(); if (message != null) { this.console.println(getmessage()); } string[] inputs = getinputs(); keepgoing = doaction(inputs); } }","repo":"Hsia-Esther\/CityOfAaronGroup1"}
{"id":2869,"comment_id":0,"comment":"\/** * not sure what this does * * @param x * x coordinate * @param y * y coordinate * @param heading * idk *\/","code":"\/** * not sure what this does * * @param x * x coordinate * @param y * y coordinate * @param heading * idk *\/ public void updateposlog(double x, double y, double heading) { \/\/ reference positions by doing point# * 3 + (0 for \/\/ x, 1 for y, 2 for heading) poslog.add(x); poslog.add(y); poslog.add(heading); }","classification":"DESIGN","isFinished":true,"code_context_2":"public void updateposlog(double x, double y, double heading) { \/\/ reference positions by doing point# * 3 + (0 for \/\/ x, 1 for y, 2 for heading) poslog.add(x); poslog.add(y); poslog.add(heading); }","code_context_10":"public void updateposlog(double x, double y, double heading) { \/\/ reference positions by doing point# * 3 + (0 for \/\/ x, 1 for y, 2 for heading) poslog.add(x); poslog.add(y); poslog.add(heading); }","code_context_20":"public void updateposlog(double x, double y, double heading) { \/\/ reference positions by doing point# * 3 + (0 for \/\/ x, 1 for y, 2 for heading) poslog.add(x); poslog.add(y); poslog.add(heading); }","repo":"AutonomousCarProject\/Steering"}
{"id":2869,"comment_id":1,"comment":"\/\/ reference positions by doing point# * 3 + (0 for","code":"public void updateposlog(double x, double y, double heading) { \/\/ reference positions by doing point# * 3 + (0 for \/\/ x, 1 for y, 2 for heading) poslog.add(x); poslog.add(y); poslog.add(heading); }","classification":"NONSATD","isFinished":true,"code_context_2":"public void updateposlog(double x, double y, double heading) { \/\/ reference positions by doing point# * 3 + (0 for \/\/ x, 1 for y, 2 for heading) poslog.add(x);","code_context_10":"public void updateposlog(double x, double y, double heading) { \/\/ reference positions by doing point# * 3 + (0 for \/\/ x, 1 for y, 2 for heading) poslog.add(x); poslog.add(y); poslog.add(heading); }","code_context_20":"public void updateposlog(double x, double y, double heading) { \/\/ reference positions by doing point# * 3 + (0 for \/\/ x, 1 for y, 2 for heading) poslog.add(x); poslog.add(y); poslog.add(heading); }","repo":"AutonomousCarProject\/Steering"}
{"id":2869,"comment_id":2,"comment":"\/\/ x, 1 for y, 2 for heading)","code":"public void updateposlog(double x, double y, double heading) { \/\/ reference positions by doing point# * 3 + (0 for \/\/ x, 1 for y, 2 for heading) poslog.add(x); poslog.add(y); poslog.add(heading); }","classification":"NONSATD","isFinished":true,"code_context_2":"public void updateposlog(double x, double y, double heading) { \/\/ reference positions by doing point# * 3 + (0 for \/\/ x, 1 for y, 2 for heading) poslog.add(x); poslog.add(y);","code_context_10":"public void updateposlog(double x, double y, double heading) { \/\/ reference positions by doing point# * 3 + (0 for \/\/ x, 1 for y, 2 for heading) poslog.add(x); poslog.add(y); poslog.add(heading); }","code_context_20":"public void updateposlog(double x, double y, double heading) { \/\/ reference positions by doing point# * 3 + (0 for \/\/ x, 1 for y, 2 for heading) poslog.add(x); poslog.add(y); poslog.add(heading); }","repo":"AutonomousCarProject\/Steering"}
{"id":11109,"comment_id":0,"comment":"\/\/ make sure app is embedded in a correct div","code":"@override protected void configure() { install(new defaultmodule.builder().placemanager(perunplacemanager.class).build()); \/\/ make sure app is embedded in a correct div bind(rootpresenter.class).to(perunrootpresenter.class).aseagersingleton(); \/\/ main application must bind generic presenter and custom view !! bindpresenter(peruncabinetpresenter.class, peruncabinetpresenter.myview.class, peruncabinetview.class, peruncabinetpresenter.myproxy.class); \/\/ bind app-specific pages \/\/ todo - implement pages bindpresenter(publicationspresenter.class, publicationspresenter.myview.class, publicationsview.class, publicationspresenter.myproxy.class); bindpresenter(newpublicationpresenter.class, newpublicationpresenter.myview.class, newpublicationview.class, newpublicationpresenter.myproxy.class); \/\/ pre-defined places bindconstant().annotatedwith(defaultplace.class).to(peruncabinetplacetokens.publications); bindconstant().annotatedwith(errorplace.class).to(peruncabinetplacetokens.not_found); bindconstant().annotatedwith(unauthorizedplace.class).to(peruncabinetplacetokens.unauthorized); \/\/ generic pages bindpresenter(notauthorizedpresenter.class, notauthorizedpresenter.myview.class, notauthorizedview.class, notauthorizedpresenter.myproxy.class); bindpresenter(notfoundpresenter.class, notfoundpresenter.myview.class, notfoundview.class, notfoundpresenter.myproxy.class); bindpresenter(logoutpresenter.class, logoutpresenter.myview.class, logoutview.class, logoutpresenter.myproxy.class); bindpresenter(notuserpresenter.class, notuserpresenter.myview.class, notuserview.class, notuserpresenter.myproxy.class); }","classification":"NONSATD","isFinished":true,"code_context_2":"protected void configure() { install(new defaultmodule.builder().placemanager(perunplacemanager.class).build()); \/\/ make sure app is embedded in a correct div bind(rootpresenter.class).to(perunrootpresenter.class).aseagersingleton(); \/\/ main application must bind generic presenter and custom view !!","code_context_10":"@override protected void configure() { install(new defaultmodule.builder().placemanager(perunplacemanager.class).build()); \/\/ make sure app is embedded in a correct div bind(rootpresenter.class).to(perunrootpresenter.class).aseagersingleton(); \/\/ main application must bind generic presenter and custom view !! bindpresenter(peruncabinetpresenter.class, peruncabinetpresenter.myview.class, peruncabinetview.class, peruncabinetpresenter.myproxy.class); \/\/ bind app-specific pages \/\/ todo - implement pages bindpresenter(publicationspresenter.class, publicationspresenter.myview.class, publicationsview.class, publicationspresenter.myproxy.class); bindpresenter(newpublicationpresenter.class, newpublicationpresenter.myview.class, newpublicationview.class, newpublicationpresenter.myproxy.class); \/\/ pre-defined places bindconstant().annotatedwith(defaultplace.class).to(peruncabinetplacetokens.publications); bindconstant().annotatedwith(errorplace.class).to(peruncabinetplacetokens.not_found);","code_context_20":"@override protected void configure() { install(new defaultmodule.builder().placemanager(perunplacemanager.class).build()); \/\/ make sure app is embedded in a correct div bind(rootpresenter.class).to(perunrootpresenter.class).aseagersingleton(); \/\/ main application must bind generic presenter and custom view !! bindpresenter(peruncabinetpresenter.class, peruncabinetpresenter.myview.class, peruncabinetview.class, peruncabinetpresenter.myproxy.class); \/\/ bind app-specific pages \/\/ todo - implement pages bindpresenter(publicationspresenter.class, publicationspresenter.myview.class, publicationsview.class, publicationspresenter.myproxy.class); bindpresenter(newpublicationpresenter.class, newpublicationpresenter.myview.class, newpublicationview.class, newpublicationpresenter.myproxy.class); \/\/ pre-defined places bindconstant().annotatedwith(defaultplace.class).to(peruncabinetplacetokens.publications); bindconstant().annotatedwith(errorplace.class).to(peruncabinetplacetokens.not_found); bindconstant().annotatedwith(unauthorizedplace.class).to(peruncabinetplacetokens.unauthorized); \/\/ generic pages bindpresenter(notauthorizedpresenter.class, notauthorizedpresenter.myview.class, notauthorizedview.class, notauthorizedpresenter.myproxy.class); bindpresenter(notfoundpresenter.class, notfoundpresenter.myview.class, notfoundview.class, notfoundpresenter.myproxy.class); bindpresenter(logoutpresenter.class, logoutpresenter.myview.class, logoutview.class, logoutpresenter.myproxy.class); bindpresenter(notuserpresenter.class, notuserpresenter.myview.class, notuserview.class, notuserpresenter.myproxy.class); }","repo":"Gaeldrin\/perun-wui"}
{"id":11109,"comment_id":1,"comment":"\/\/ main application must bind generic presenter and custom view !!","code":"@override protected void configure() { install(new defaultmodule.builder().placemanager(perunplacemanager.class).build()); \/\/ make sure app is embedded in a correct div bind(rootpresenter.class).to(perunrootpresenter.class).aseagersingleton(); \/\/ main application must bind generic presenter and custom view !! bindpresenter(peruncabinetpresenter.class, peruncabinetpresenter.myview.class, peruncabinetview.class, peruncabinetpresenter.myproxy.class); \/\/ bind app-specific pages \/\/ todo - implement pages bindpresenter(publicationspresenter.class, publicationspresenter.myview.class, publicationsview.class, publicationspresenter.myproxy.class); bindpresenter(newpublicationpresenter.class, newpublicationpresenter.myview.class, newpublicationview.class, newpublicationpresenter.myproxy.class); \/\/ pre-defined places bindconstant().annotatedwith(defaultplace.class).to(peruncabinetplacetokens.publications); bindconstant().annotatedwith(errorplace.class).to(peruncabinetplacetokens.not_found); bindconstant().annotatedwith(unauthorizedplace.class).to(peruncabinetplacetokens.unauthorized); \/\/ generic pages bindpresenter(notauthorizedpresenter.class, notauthorizedpresenter.myview.class, notauthorizedview.class, notauthorizedpresenter.myproxy.class); bindpresenter(notfoundpresenter.class, notfoundpresenter.myview.class, notfoundview.class, notfoundpresenter.myproxy.class); bindpresenter(logoutpresenter.class, logoutpresenter.myview.class, logoutview.class, logoutpresenter.myproxy.class); bindpresenter(notuserpresenter.class, notuserpresenter.myview.class, notuserview.class, notuserpresenter.myproxy.class); }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ make sure app is embedded in a correct div bind(rootpresenter.class).to(perunrootpresenter.class).aseagersingleton(); \/\/ main application must bind generic presenter and custom view !! bindpresenter(peruncabinetpresenter.class, peruncabinetpresenter.myview.class, peruncabinetview.class, peruncabinetpresenter.myproxy.class); \/\/ bind app-specific pages","code_context_10":"@override protected void configure() { install(new defaultmodule.builder().placemanager(perunplacemanager.class).build()); \/\/ make sure app is embedded in a correct div bind(rootpresenter.class).to(perunrootpresenter.class).aseagersingleton(); \/\/ main application must bind generic presenter and custom view !! bindpresenter(peruncabinetpresenter.class, peruncabinetpresenter.myview.class, peruncabinetview.class, peruncabinetpresenter.myproxy.class); \/\/ bind app-specific pages \/\/ todo - implement pages bindpresenter(publicationspresenter.class, publicationspresenter.myview.class, publicationsview.class, publicationspresenter.myproxy.class); bindpresenter(newpublicationpresenter.class, newpublicationpresenter.myview.class, newpublicationview.class, newpublicationpresenter.myproxy.class); \/\/ pre-defined places bindconstant().annotatedwith(defaultplace.class).to(peruncabinetplacetokens.publications); bindconstant().annotatedwith(errorplace.class).to(peruncabinetplacetokens.not_found); bindconstant().annotatedwith(unauthorizedplace.class).to(peruncabinetplacetokens.unauthorized); \/\/ generic pages","code_context_20":"@override protected void configure() { install(new defaultmodule.builder().placemanager(perunplacemanager.class).build()); \/\/ make sure app is embedded in a correct div bind(rootpresenter.class).to(perunrootpresenter.class).aseagersingleton(); \/\/ main application must bind generic presenter and custom view !! bindpresenter(peruncabinetpresenter.class, peruncabinetpresenter.myview.class, peruncabinetview.class, peruncabinetpresenter.myproxy.class); \/\/ bind app-specific pages \/\/ todo - implement pages bindpresenter(publicationspresenter.class, publicationspresenter.myview.class, publicationsview.class, publicationspresenter.myproxy.class); bindpresenter(newpublicationpresenter.class, newpublicationpresenter.myview.class, newpublicationview.class, newpublicationpresenter.myproxy.class); \/\/ pre-defined places bindconstant().annotatedwith(defaultplace.class).to(peruncabinetplacetokens.publications); bindconstant().annotatedwith(errorplace.class).to(peruncabinetplacetokens.not_found); bindconstant().annotatedwith(unauthorizedplace.class).to(peruncabinetplacetokens.unauthorized); \/\/ generic pages bindpresenter(notauthorizedpresenter.class, notauthorizedpresenter.myview.class, notauthorizedview.class, notauthorizedpresenter.myproxy.class); bindpresenter(notfoundpresenter.class, notfoundpresenter.myview.class, notfoundview.class, notfoundpresenter.myproxy.class); bindpresenter(logoutpresenter.class, logoutpresenter.myview.class, logoutview.class, logoutpresenter.myproxy.class); bindpresenter(notuserpresenter.class, notuserpresenter.myview.class, notuserview.class, notuserpresenter.myproxy.class); }","repo":"Gaeldrin\/perun-wui"}
{"id":11109,"comment_id":2,"comment":"\/\/ bind app-specific pages \/\/ todo - implement pages","code":"@override protected void configure() { install(new defaultmodule.builder().placemanager(perunplacemanager.class).build()); \/\/ make sure app is embedded in a correct div bind(rootpresenter.class).to(perunrootpresenter.class).aseagersingleton(); \/\/ main application must bind generic presenter and custom view !! bindpresenter(peruncabinetpresenter.class, peruncabinetpresenter.myview.class, peruncabinetview.class, peruncabinetpresenter.myproxy.class); \/\/ bind app-specific pages \/\/ todo - implement pages bindpresenter(publicationspresenter.class, publicationspresenter.myview.class, publicationsview.class, publicationspresenter.myproxy.class); bindpresenter(newpublicationpresenter.class, newpublicationpresenter.myview.class, newpublicationview.class, newpublicationpresenter.myproxy.class); \/\/ pre-defined places bindconstant().annotatedwith(defaultplace.class).to(peruncabinetplacetokens.publications); bindconstant().annotatedwith(errorplace.class).to(peruncabinetplacetokens.not_found); bindconstant().annotatedwith(unauthorizedplace.class).to(peruncabinetplacetokens.unauthorized); \/\/ generic pages bindpresenter(notauthorizedpresenter.class, notauthorizedpresenter.myview.class, notauthorizedview.class, notauthorizedpresenter.myproxy.class); bindpresenter(notfoundpresenter.class, notfoundpresenter.myview.class, notfoundview.class, notfoundpresenter.myproxy.class); bindpresenter(logoutpresenter.class, logoutpresenter.myview.class, logoutview.class, logoutpresenter.myproxy.class); bindpresenter(notuserpresenter.class, notuserpresenter.myview.class, notuserview.class, notuserpresenter.myproxy.class); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"\/\/ main application must bind generic presenter and custom view !! bindpresenter(peruncabinetpresenter.class, peruncabinetpresenter.myview.class, peruncabinetview.class, peruncabinetpresenter.myproxy.class); \/\/ bind app-specific pages \/\/ todo - implement pages bindpresenter(publicationspresenter.class, publicationspresenter.myview.class, publicationsview.class, publicationspresenter.myproxy.class); bindpresenter(newpublicationpresenter.class, newpublicationpresenter.myview.class, newpublicationview.class, newpublicationpresenter.myproxy.class);","code_context_10":"@override protected void configure() { install(new defaultmodule.builder().placemanager(perunplacemanager.class).build()); \/\/ make sure app is embedded in a correct div bind(rootpresenter.class).to(perunrootpresenter.class).aseagersingleton(); \/\/ main application must bind generic presenter and custom view !! bindpresenter(peruncabinetpresenter.class, peruncabinetpresenter.myview.class, peruncabinetview.class, peruncabinetpresenter.myproxy.class); \/\/ bind app-specific pages \/\/ todo - implement pages bindpresenter(publicationspresenter.class, publicationspresenter.myview.class, publicationsview.class, publicationspresenter.myproxy.class); bindpresenter(newpublicationpresenter.class, newpublicationpresenter.myview.class, newpublicationview.class, newpublicationpresenter.myproxy.class); \/\/ pre-defined places bindconstant().annotatedwith(defaultplace.class).to(peruncabinetplacetokens.publications); bindconstant().annotatedwith(errorplace.class).to(peruncabinetplacetokens.not_found); bindconstant().annotatedwith(unauthorizedplace.class).to(peruncabinetplacetokens.unauthorized); \/\/ generic pages bindpresenter(notauthorizedpresenter.class, notauthorizedpresenter.myview.class, notauthorizedview.class, notauthorizedpresenter.myproxy.class); bindpresenter(notfoundpresenter.class, notfoundpresenter.myview.class, notfoundview.class, notfoundpresenter.myproxy.class); bindpresenter(logoutpresenter.class, logoutpresenter.myview.class, logoutview.class, logoutpresenter.myproxy.class);","code_context_20":"@override protected void configure() { install(new defaultmodule.builder().placemanager(perunplacemanager.class).build()); \/\/ make sure app is embedded in a correct div bind(rootpresenter.class).to(perunrootpresenter.class).aseagersingleton(); \/\/ main application must bind generic presenter and custom view !! bindpresenter(peruncabinetpresenter.class, peruncabinetpresenter.myview.class, peruncabinetview.class, peruncabinetpresenter.myproxy.class); \/\/ bind app-specific pages \/\/ todo - implement pages bindpresenter(publicationspresenter.class, publicationspresenter.myview.class, publicationsview.class, publicationspresenter.myproxy.class); bindpresenter(newpublicationpresenter.class, newpublicationpresenter.myview.class, newpublicationview.class, newpublicationpresenter.myproxy.class); \/\/ pre-defined places bindconstant().annotatedwith(defaultplace.class).to(peruncabinetplacetokens.publications); bindconstant().annotatedwith(errorplace.class).to(peruncabinetplacetokens.not_found); bindconstant().annotatedwith(unauthorizedplace.class).to(peruncabinetplacetokens.unauthorized); \/\/ generic pages bindpresenter(notauthorizedpresenter.class, notauthorizedpresenter.myview.class, notauthorizedview.class, notauthorizedpresenter.myproxy.class); bindpresenter(notfoundpresenter.class, notfoundpresenter.myview.class, notfoundview.class, notfoundpresenter.myproxy.class); bindpresenter(logoutpresenter.class, logoutpresenter.myview.class, logoutview.class, logoutpresenter.myproxy.class); bindpresenter(notuserpresenter.class, notuserpresenter.myview.class, notuserview.class, notuserpresenter.myproxy.class); }","repo":"Gaeldrin\/perun-wui"}
{"id":11109,"comment_id":3,"comment":"\/\/ pre-defined places","code":"@override protected void configure() { install(new defaultmodule.builder().placemanager(perunplacemanager.class).build()); \/\/ make sure app is embedded in a correct div bind(rootpresenter.class).to(perunrootpresenter.class).aseagersingleton(); \/\/ main application must bind generic presenter and custom view !! bindpresenter(peruncabinetpresenter.class, peruncabinetpresenter.myview.class, peruncabinetview.class, peruncabinetpresenter.myproxy.class); \/\/ bind app-specific pages \/\/ todo - implement pages bindpresenter(publicationspresenter.class, publicationspresenter.myview.class, publicationsview.class, publicationspresenter.myproxy.class); bindpresenter(newpublicationpresenter.class, newpublicationpresenter.myview.class, newpublicationview.class, newpublicationpresenter.myproxy.class); \/\/ pre-defined places bindconstant().annotatedwith(defaultplace.class).to(peruncabinetplacetokens.publications); bindconstant().annotatedwith(errorplace.class).to(peruncabinetplacetokens.not_found); bindconstant().annotatedwith(unauthorizedplace.class).to(peruncabinetplacetokens.unauthorized); \/\/ generic pages bindpresenter(notauthorizedpresenter.class, notauthorizedpresenter.myview.class, notauthorizedview.class, notauthorizedpresenter.myproxy.class); bindpresenter(notfoundpresenter.class, notfoundpresenter.myview.class, notfoundview.class, notfoundpresenter.myproxy.class); bindpresenter(logoutpresenter.class, logoutpresenter.myview.class, logoutview.class, logoutpresenter.myproxy.class); bindpresenter(notuserpresenter.class, notuserpresenter.myview.class, notuserview.class, notuserpresenter.myproxy.class); }","classification":"NONSATD","isFinished":true,"code_context_2":"bindpresenter(publicationspresenter.class, publicationspresenter.myview.class, publicationsview.class, publicationspresenter.myproxy.class); bindpresenter(newpublicationpresenter.class, newpublicationpresenter.myview.class, newpublicationview.class, newpublicationpresenter.myproxy.class); \/\/ pre-defined places bindconstant().annotatedwith(defaultplace.class).to(peruncabinetplacetokens.publications); bindconstant().annotatedwith(errorplace.class).to(peruncabinetplacetokens.not_found);","code_context_10":"protected void configure() { install(new defaultmodule.builder().placemanager(perunplacemanager.class).build()); \/\/ make sure app is embedded in a correct div bind(rootpresenter.class).to(perunrootpresenter.class).aseagersingleton(); \/\/ main application must bind generic presenter and custom view !! bindpresenter(peruncabinetpresenter.class, peruncabinetpresenter.myview.class, peruncabinetview.class, peruncabinetpresenter.myproxy.class); \/\/ bind app-specific pages \/\/ todo - implement pages bindpresenter(publicationspresenter.class, publicationspresenter.myview.class, publicationsview.class, publicationspresenter.myproxy.class); bindpresenter(newpublicationpresenter.class, newpublicationpresenter.myview.class, newpublicationview.class, newpublicationpresenter.myproxy.class); \/\/ pre-defined places bindconstant().annotatedwith(defaultplace.class).to(peruncabinetplacetokens.publications); bindconstant().annotatedwith(errorplace.class).to(peruncabinetplacetokens.not_found); bindconstant().annotatedwith(unauthorizedplace.class).to(peruncabinetplacetokens.unauthorized); \/\/ generic pages bindpresenter(notauthorizedpresenter.class, notauthorizedpresenter.myview.class, notauthorizedview.class, notauthorizedpresenter.myproxy.class); bindpresenter(notfoundpresenter.class, notfoundpresenter.myview.class, notfoundview.class, notfoundpresenter.myproxy.class); bindpresenter(logoutpresenter.class, logoutpresenter.myview.class, logoutview.class, logoutpresenter.myproxy.class); bindpresenter(notuserpresenter.class, notuserpresenter.myview.class, notuserview.class, notuserpresenter.myproxy.class); }","code_context_20":"@override protected void configure() { install(new defaultmodule.builder().placemanager(perunplacemanager.class).build()); \/\/ make sure app is embedded in a correct div bind(rootpresenter.class).to(perunrootpresenter.class).aseagersingleton(); \/\/ main application must bind generic presenter and custom view !! bindpresenter(peruncabinetpresenter.class, peruncabinetpresenter.myview.class, peruncabinetview.class, peruncabinetpresenter.myproxy.class); \/\/ bind app-specific pages \/\/ todo - implement pages bindpresenter(publicationspresenter.class, publicationspresenter.myview.class, publicationsview.class, publicationspresenter.myproxy.class); bindpresenter(newpublicationpresenter.class, newpublicationpresenter.myview.class, newpublicationview.class, newpublicationpresenter.myproxy.class); \/\/ pre-defined places bindconstant().annotatedwith(defaultplace.class).to(peruncabinetplacetokens.publications); bindconstant().annotatedwith(errorplace.class).to(peruncabinetplacetokens.not_found); bindconstant().annotatedwith(unauthorizedplace.class).to(peruncabinetplacetokens.unauthorized); \/\/ generic pages bindpresenter(notauthorizedpresenter.class, notauthorizedpresenter.myview.class, notauthorizedview.class, notauthorizedpresenter.myproxy.class); bindpresenter(notfoundpresenter.class, notfoundpresenter.myview.class, notfoundview.class, notfoundpresenter.myproxy.class); bindpresenter(logoutpresenter.class, logoutpresenter.myview.class, logoutview.class, logoutpresenter.myproxy.class); bindpresenter(notuserpresenter.class, notuserpresenter.myview.class, notuserview.class, notuserpresenter.myproxy.class); }","repo":"Gaeldrin\/perun-wui"}
{"id":11109,"comment_id":4,"comment":"\/\/ generic pages","code":"@override protected void configure() { install(new defaultmodule.builder().placemanager(perunplacemanager.class).build()); \/\/ make sure app is embedded in a correct div bind(rootpresenter.class).to(perunrootpresenter.class).aseagersingleton(); \/\/ main application must bind generic presenter and custom view !! bindpresenter(peruncabinetpresenter.class, peruncabinetpresenter.myview.class, peruncabinetview.class, peruncabinetpresenter.myproxy.class); \/\/ bind app-specific pages \/\/ todo - implement pages bindpresenter(publicationspresenter.class, publicationspresenter.myview.class, publicationsview.class, publicationspresenter.myproxy.class); bindpresenter(newpublicationpresenter.class, newpublicationpresenter.myview.class, newpublicationview.class, newpublicationpresenter.myproxy.class); \/\/ pre-defined places bindconstant().annotatedwith(defaultplace.class).to(peruncabinetplacetokens.publications); bindconstant().annotatedwith(errorplace.class).to(peruncabinetplacetokens.not_found); bindconstant().annotatedwith(unauthorizedplace.class).to(peruncabinetplacetokens.unauthorized); \/\/ generic pages bindpresenter(notauthorizedpresenter.class, notauthorizedpresenter.myview.class, notauthorizedview.class, notauthorizedpresenter.myproxy.class); bindpresenter(notfoundpresenter.class, notfoundpresenter.myview.class, notfoundview.class, notfoundpresenter.myproxy.class); bindpresenter(logoutpresenter.class, logoutpresenter.myview.class, logoutview.class, logoutpresenter.myproxy.class); bindpresenter(notuserpresenter.class, notuserpresenter.myview.class, notuserview.class, notuserpresenter.myproxy.class); }","classification":"NONSATD","isFinished":true,"code_context_2":"bindconstant().annotatedwith(errorplace.class).to(peruncabinetplacetokens.not_found); bindconstant().annotatedwith(unauthorizedplace.class).to(peruncabinetplacetokens.unauthorized); \/\/ generic pages bindpresenter(notauthorizedpresenter.class, notauthorizedpresenter.myview.class, notauthorizedview.class, notauthorizedpresenter.myproxy.class); bindpresenter(notfoundpresenter.class, notfoundpresenter.myview.class, notfoundview.class, notfoundpresenter.myproxy.class);","code_context_10":"\/\/ main application must bind generic presenter and custom view !! bindpresenter(peruncabinetpresenter.class, peruncabinetpresenter.myview.class, peruncabinetview.class, peruncabinetpresenter.myproxy.class); \/\/ bind app-specific pages \/\/ todo - implement pages bindpresenter(publicationspresenter.class, publicationspresenter.myview.class, publicationsview.class, publicationspresenter.myproxy.class); bindpresenter(newpublicationpresenter.class, newpublicationpresenter.myview.class, newpublicationview.class, newpublicationpresenter.myproxy.class); \/\/ pre-defined places bindconstant().annotatedwith(defaultplace.class).to(peruncabinetplacetokens.publications); bindconstant().annotatedwith(errorplace.class).to(peruncabinetplacetokens.not_found); bindconstant().annotatedwith(unauthorizedplace.class).to(peruncabinetplacetokens.unauthorized); \/\/ generic pages bindpresenter(notauthorizedpresenter.class, notauthorizedpresenter.myview.class, notauthorizedview.class, notauthorizedpresenter.myproxy.class); bindpresenter(notfoundpresenter.class, notfoundpresenter.myview.class, notfoundview.class, notfoundpresenter.myproxy.class); bindpresenter(logoutpresenter.class, logoutpresenter.myview.class, logoutview.class, logoutpresenter.myproxy.class); bindpresenter(notuserpresenter.class, notuserpresenter.myview.class, notuserview.class, notuserpresenter.myproxy.class); }","code_context_20":"@override protected void configure() { install(new defaultmodule.builder().placemanager(perunplacemanager.class).build()); \/\/ make sure app is embedded in a correct div bind(rootpresenter.class).to(perunrootpresenter.class).aseagersingleton(); \/\/ main application must bind generic presenter and custom view !! bindpresenter(peruncabinetpresenter.class, peruncabinetpresenter.myview.class, peruncabinetview.class, peruncabinetpresenter.myproxy.class); \/\/ bind app-specific pages \/\/ todo - implement pages bindpresenter(publicationspresenter.class, publicationspresenter.myview.class, publicationsview.class, publicationspresenter.myproxy.class); bindpresenter(newpublicationpresenter.class, newpublicationpresenter.myview.class, newpublicationview.class, newpublicationpresenter.myproxy.class); \/\/ pre-defined places bindconstant().annotatedwith(defaultplace.class).to(peruncabinetplacetokens.publications); bindconstant().annotatedwith(errorplace.class).to(peruncabinetplacetokens.not_found); bindconstant().annotatedwith(unauthorizedplace.class).to(peruncabinetplacetokens.unauthorized); \/\/ generic pages bindpresenter(notauthorizedpresenter.class, notauthorizedpresenter.myview.class, notauthorizedview.class, notauthorizedpresenter.myproxy.class); bindpresenter(notfoundpresenter.class, notfoundpresenter.myview.class, notfoundview.class, notfoundpresenter.myproxy.class); bindpresenter(logoutpresenter.class, logoutpresenter.myview.class, logoutview.class, logoutpresenter.myproxy.class); bindpresenter(notuserpresenter.class, notuserpresenter.myview.class, notuserview.class, notuserpresenter.myproxy.class); }","repo":"Gaeldrin\/perun-wui"}
{"id":3131,"comment_id":0,"comment":"\/** * restore process to a saved checkpoint. *\/","code":"\/** * restore process to a saved checkpoint. *\/ public checkpointinfo restorecheckpoint(processkey processkey, uuid checkpointid) { try (temporarypath checkpointarchive = ioutils.tempfile(\"checkpoint\", \".zip\")) { string checkpointname = export(processkey, checkpointid, checkpointarchive.path()); if (checkpointname == null) { return null; } try (temporarypath extracteddir = ioutils.tempdir(\"unzipped-checkpoint\")) { ioutils.unzip(checkpointarchive.path(), extracteddir.path()); \/\/ todo: only for v1 runtime string eventname = readcheckpointeventname(extracteddir.path()); statemanager.tx(tx -> { statemanager.deletedirectory(tx, processkey, constants.files.concord_system_dir_name); statemanager.deletedirectory(tx, processkey, constants.files.job_attachments_dir_name); statemanager.importpath(tx, processkey, null, extracteddir.path(), (p, attrs) -> true); }); map<string, object> out = outvariablesutils.read(extracteddir.path().resolve(constants.files.job_attachments_dir_name)); if (out.isempty()) { queuedao.removemeta(processkey, \"out\"); } else { queuedao.updatemeta(processkey, collections.singletonmap(\"out\", out)); } return checkpointinfo.of(checkpointname, eventname); } } catch (exception e) { throw new runtimeexception(\"restore checkpoint '\" + checkpointid + \"' error\", e); } }","classification":"NONSATD","isFinished":true,"code_context_2":"public checkpointinfo restorecheckpoint(processkey processkey, uuid checkpointid) { try (temporarypath checkpointarchive = ioutils.tempfile(\"checkpoint\", \".zip\")) { string checkpointname = export(processkey, checkpointid, checkpointarchive.path()); if (checkpointname == null) { return null; } try (temporarypath extracteddir = ioutils.tempdir(\"unzipped-checkpoint\")) { ioutils.unzip(checkpointarchive.path(), extracteddir.path()); \/\/ todo: only for v1 runtime string eventname = readcheckpointeventname(extracteddir.path()); statemanager.tx(tx -> { statemanager.deletedirectory(tx, processkey, constants.files.concord_system_dir_name); statemanager.deletedirectory(tx, processkey, constants.files.job_attachments_dir_name); statemanager.importpath(tx, processkey, null, extracteddir.path(), (p, attrs) -> true); }); map<string, object> out = outvariablesutils.read(extracteddir.path().resolve(constants.files.job_attachments_dir_name)); if (out.isempty()) { queuedao.removemeta(processkey, \"out\"); } else { queuedao.updatemeta(processkey, collections.singletonmap(\"out\", out)); } return checkpointinfo.of(checkpointname, eventname); } } catch (exception e) { throw new runtimeexception(\"restore checkpoint '\" + checkpointid + \"' error\", e); } }","code_context_10":"public checkpointinfo restorecheckpoint(processkey processkey, uuid checkpointid) { try (temporarypath checkpointarchive = ioutils.tempfile(\"checkpoint\", \".zip\")) { string checkpointname = export(processkey, checkpointid, checkpointarchive.path()); if (checkpointname == null) { return null; } try (temporarypath extracteddir = ioutils.tempdir(\"unzipped-checkpoint\")) { ioutils.unzip(checkpointarchive.path(), extracteddir.path()); \/\/ todo: only for v1 runtime string eventname = readcheckpointeventname(extracteddir.path()); statemanager.tx(tx -> { statemanager.deletedirectory(tx, processkey, constants.files.concord_system_dir_name); statemanager.deletedirectory(tx, processkey, constants.files.job_attachments_dir_name); statemanager.importpath(tx, processkey, null, extracteddir.path(), (p, attrs) -> true); }); map<string, object> out = outvariablesutils.read(extracteddir.path().resolve(constants.files.job_attachments_dir_name)); if (out.isempty()) { queuedao.removemeta(processkey, \"out\"); } else { queuedao.updatemeta(processkey, collections.singletonmap(\"out\", out)); } return checkpointinfo.of(checkpointname, eventname); } } catch (exception e) { throw new runtimeexception(\"restore checkpoint '\" + checkpointid + \"' error\", e); } }","code_context_20":"public checkpointinfo restorecheckpoint(processkey processkey, uuid checkpointid) { try (temporarypath checkpointarchive = ioutils.tempfile(\"checkpoint\", \".zip\")) { string checkpointname = export(processkey, checkpointid, checkpointarchive.path()); if (checkpointname == null) { return null; } try (temporarypath extracteddir = ioutils.tempdir(\"unzipped-checkpoint\")) { ioutils.unzip(checkpointarchive.path(), extracteddir.path()); \/\/ todo: only for v1 runtime string eventname = readcheckpointeventname(extracteddir.path()); statemanager.tx(tx -> { statemanager.deletedirectory(tx, processkey, constants.files.concord_system_dir_name); statemanager.deletedirectory(tx, processkey, constants.files.job_attachments_dir_name); statemanager.importpath(tx, processkey, null, extracteddir.path(), (p, attrs) -> true); }); map<string, object> out = outvariablesutils.read(extracteddir.path().resolve(constants.files.job_attachments_dir_name)); if (out.isempty()) { queuedao.removemeta(processkey, \"out\"); } else { queuedao.updatemeta(processkey, collections.singletonmap(\"out\", out)); } return checkpointinfo.of(checkpointname, eventname); } } catch (exception e) { throw new runtimeexception(\"restore checkpoint '\" + checkpointid + \"' error\", e); } }","repo":"700software\/concord"}
{"id":3131,"comment_id":1,"comment":"\/\/ todo: only for v1 runtime","code":"public checkpointinfo restorecheckpoint(processkey processkey, uuid checkpointid) { try (temporarypath checkpointarchive = ioutils.tempfile(\"checkpoint\", \".zip\")) { string checkpointname = export(processkey, checkpointid, checkpointarchive.path()); if (checkpointname == null) { return null; } try (temporarypath extracteddir = ioutils.tempdir(\"unzipped-checkpoint\")) { ioutils.unzip(checkpointarchive.path(), extracteddir.path()); \/\/ todo: only for v1 runtime string eventname = readcheckpointeventname(extracteddir.path()); statemanager.tx(tx -> { statemanager.deletedirectory(tx, processkey, constants.files.concord_system_dir_name); statemanager.deletedirectory(tx, processkey, constants.files.job_attachments_dir_name); statemanager.importpath(tx, processkey, null, extracteddir.path(), (p, attrs) -> true); }); map<string, object> out = outvariablesutils.read(extracteddir.path().resolve(constants.files.job_attachments_dir_name)); if (out.isempty()) { queuedao.removemeta(processkey, \"out\"); } else { queuedao.updatemeta(processkey, collections.singletonmap(\"out\", out)); } return checkpointinfo.of(checkpointname, eventname); } } catch (exception e) { throw new runtimeexception(\"restore checkpoint '\" + checkpointid + \"' error\", e); } }","classification":"DESIGN","isFinished":true,"code_context_2":"try (temporarypath extracteddir = ioutils.tempdir(\"unzipped-checkpoint\")) { ioutils.unzip(checkpointarchive.path(), extracteddir.path()); \/\/ todo: only for v1 runtime string eventname = readcheckpointeventname(extracteddir.path()); statemanager.tx(tx -> {","code_context_10":"public checkpointinfo restorecheckpoint(processkey processkey, uuid checkpointid) { try (temporarypath checkpointarchive = ioutils.tempfile(\"checkpoint\", \".zip\")) { string checkpointname = export(processkey, checkpointid, checkpointarchive.path()); if (checkpointname == null) { return null; } try (temporarypath extracteddir = ioutils.tempdir(\"unzipped-checkpoint\")) { ioutils.unzip(checkpointarchive.path(), extracteddir.path()); \/\/ todo: only for v1 runtime string eventname = readcheckpointeventname(extracteddir.path()); statemanager.tx(tx -> { statemanager.deletedirectory(tx, processkey, constants.files.concord_system_dir_name); statemanager.deletedirectory(tx, processkey, constants.files.job_attachments_dir_name); statemanager.importpath(tx, processkey, null, extracteddir.path(), (p, attrs) -> true); }); map<string, object> out = outvariablesutils.read(extracteddir.path().resolve(constants.files.job_attachments_dir_name)); if (out.isempty()) { queuedao.removemeta(processkey, \"out\"); } else {","code_context_20":"public checkpointinfo restorecheckpoint(processkey processkey, uuid checkpointid) { try (temporarypath checkpointarchive = ioutils.tempfile(\"checkpoint\", \".zip\")) { string checkpointname = export(processkey, checkpointid, checkpointarchive.path()); if (checkpointname == null) { return null; } try (temporarypath extracteddir = ioutils.tempdir(\"unzipped-checkpoint\")) { ioutils.unzip(checkpointarchive.path(), extracteddir.path()); \/\/ todo: only for v1 runtime string eventname = readcheckpointeventname(extracteddir.path()); statemanager.tx(tx -> { statemanager.deletedirectory(tx, processkey, constants.files.concord_system_dir_name); statemanager.deletedirectory(tx, processkey, constants.files.job_attachments_dir_name); statemanager.importpath(tx, processkey, null, extracteddir.path(), (p, attrs) -> true); }); map<string, object> out = outvariablesutils.read(extracteddir.path().resolve(constants.files.job_attachments_dir_name)); if (out.isempty()) { queuedao.removemeta(processkey, \"out\"); } else { queuedao.updatemeta(processkey, collections.singletonmap(\"out\", out)); } return checkpointinfo.of(checkpointname, eventname); } } catch (exception e) { throw new runtimeexception(\"restore checkpoint '\" + checkpointid + \"' error\", e); } }","repo":"700software\/concord"}
{"id":19591,"comment_id":0,"comment":"\/** * a factory method pattern which creates an empty a backedlist * implementation * * @return document me! *\/","code":"\/** * a factory method pattern which creates an empty a backedlist * implementation * * @return document me! *\/ protected list createemptylist() { return new backedlist(this, contentlist(), 0); }","classification":"DOCUMENTATION","isFinished":true,"code_context_2":"protected list createemptylist() { return new backedlist(this, contentlist(), 0); }","code_context_10":"protected list createemptylist() { return new backedlist(this, contentlist(), 0); }","code_context_20":"protected list createemptylist() { return new backedlist(this, contentlist(), 0); }","repo":"Gravitational-Field\/Dive-In-Java"}
{"id":3223,"comment_id":0,"comment":"\/\/ central directory structure \/ central file header signature","code":"protected void initfromrafile() throws ioexception { \/\/ central directory structure \/ central file header signature int censig = rafile.readint( fileoffset ); if( censig!=censig ) { throw new zipexception(\"expected censic not found in central directory (at end of zip file)\"); } else if( log.isloggable(level.fine) ) { log.fine( \"found censigoffset=\" + fileoffset ); } short flag = rafile.readshort( fileoffset + 8 ); this.isencrypted = (flag&1)>0; this.filenamelength = rafile.readshort( fileoffset + 28 ); byte[] filenamebytes = rafile.readbytearray( fileoffset + 46, filenamelength ); this.filename = new string( filenamebytes, aeszipfiledecrypter.charset ); if( log.isloggable(level.fine) ) { log.fine( \"filename = \" + this.filename ); } this.extrafieldoffset = this.fileoffset + 46 + this.filenamelength; this.extrafieldlength = rafile.readshort( fileoffset + 30 ); this.localheaderoffset = rafile.readint( fileoffset + 28 + 14 ); if( log.isloggable(level.fine) ) { log.fine( \"cds - extrafieldoffset =\" + long.tohexstring(this.extrafieldoffset) ); log.fine( \"cds - extrafieldlength =\" + this.extrafieldlength ); log.fine( \"cds - localheaderoffset=\" + long.tohexstring(this.localheaderoffset) ); } \/\/ todo - check, why we have to use the local header instead of the cds sometimes... if( this.isencrypted ) { byte[] efhid = rafile.readbytearray( this.extrafieldoffset, 2 ); if( efhid[0]!=0x01 || efhid[1]!=(byte)0x99 ) { this.extrafieldoffset = localheaderoffset+30+filenamelength; this.extrafieldlength = rafile.readshort( localheaderoffset+28 ); if( log.isloggable(level.fine) ) { log.fine( \"local header - extrafieldoffset=\" + long.tohexstring(this.extrafieldoffset) ); log.fine( \"local header - extrafieldlength=\" + long.tohexstring(this.extrafieldlength) ); } if( 0==extrafieldlength ) { throw new zipexception(\"extra field is of length 0 - this is probably not a winzip aes encrypted entry\"); } efhid = rafile.readbytearray( extrafieldoffset, 2); if( efhid[0]==0x01 && efhid[1]==(byte)0x99 ) { this.isaesencrypted = true; } } else { this.isaesencrypted = true; } if( this.isaesencrypted ) { this.actualcompressionmethod = rafile.readshort( getextrafieldoffset() + 9 ); this.localheadersize = 30 + getextrafieldlength() + getfilenamelength(); } } this.compressedsize = rafile.readint( fileoffset + 20 ); this.uncompressedsize = rafile.readint( fileoffset + 24 ); }","classification":"NONSATD","isFinished":true,"code_context_2":"protected void initfromrafile() throws ioexception { \/\/ central directory structure \/ central file header signature int censig = rafile.readint( fileoffset ); if( censig!=censig ) {","code_context_10":"protected void initfromrafile() throws ioexception { \/\/ central directory structure \/ central file header signature int censig = rafile.readint( fileoffset ); if( censig!=censig ) { throw new zipexception(\"expected censic not found in central directory (at end of zip file)\"); } else if( log.isloggable(level.fine) ) { log.fine( \"found censigoffset=\" + fileoffset ); } short flag = rafile.readshort( fileoffset + 8 ); this.isencrypted = (flag&1)>0; this.filenamelength = rafile.readshort( fileoffset + 28 ); byte[] filenamebytes = rafile.readbytearray( fileoffset + 46, filenamelength );","code_context_20":"protected void initfromrafile() throws ioexception { \/\/ central directory structure \/ central file header signature int censig = rafile.readint( fileoffset ); if( censig!=censig ) { throw new zipexception(\"expected censic not found in central directory (at end of zip file)\"); } else if( log.isloggable(level.fine) ) { log.fine( \"found censigoffset=\" + fileoffset ); } short flag = rafile.readshort( fileoffset + 8 ); this.isencrypted = (flag&1)>0; this.filenamelength = rafile.readshort( fileoffset + 28 ); byte[] filenamebytes = rafile.readbytearray( fileoffset + 46, filenamelength ); this.filename = new string( filenamebytes, aeszipfiledecrypter.charset ); if( log.isloggable(level.fine) ) { log.fine( \"filename = \" + this.filename ); } this.extrafieldoffset = this.fileoffset + 46 + this.filenamelength; this.extrafieldlength = rafile.readshort( fileoffset + 30 ); this.localheaderoffset = rafile.readint( fileoffset + 28 + 14 ); if( log.isloggable(level.fine) ) { log.fine( \"cds - extrafieldoffset =\" + long.tohexstring(this.extrafieldoffset) ); log.fine( \"cds - extrafieldlength =\" + this.extrafieldlength );","repo":"CATION-M\/X-moe"}
{"id":3223,"comment_id":1,"comment":"\/\/ todo - check, why we have to use the local header instead of the cds sometimes...","code":"protected void initfromrafile() throws ioexception { \/\/ central directory structure \/ central file header signature int censig = rafile.readint( fileoffset ); if( censig!=censig ) { throw new zipexception(\"expected censic not found in central directory (at end of zip file)\"); } else if( log.isloggable(level.fine) ) { log.fine( \"found censigoffset=\" + fileoffset ); } short flag = rafile.readshort( fileoffset + 8 ); this.isencrypted = (flag&1)>0; this.filenamelength = rafile.readshort( fileoffset + 28 ); byte[] filenamebytes = rafile.readbytearray( fileoffset + 46, filenamelength ); this.filename = new string( filenamebytes, aeszipfiledecrypter.charset ); if( log.isloggable(level.fine) ) { log.fine( \"filename = \" + this.filename ); } this.extrafieldoffset = this.fileoffset + 46 + this.filenamelength; this.extrafieldlength = rafile.readshort( fileoffset + 30 ); this.localheaderoffset = rafile.readint( fileoffset + 28 + 14 ); if( log.isloggable(level.fine) ) { log.fine( \"cds - extrafieldoffset =\" + long.tohexstring(this.extrafieldoffset) ); log.fine( \"cds - extrafieldlength =\" + this.extrafieldlength ); log.fine( \"cds - localheaderoffset=\" + long.tohexstring(this.localheaderoffset) ); } \/\/ todo - check, why we have to use the local header instead of the cds sometimes... if( this.isencrypted ) { byte[] efhid = rafile.readbytearray( this.extrafieldoffset, 2 ); if( efhid[0]!=0x01 || efhid[1]!=(byte)0x99 ) { this.extrafieldoffset = localheaderoffset+30+filenamelength; this.extrafieldlength = rafile.readshort( localheaderoffset+28 ); if( log.isloggable(level.fine) ) { log.fine( \"local header - extrafieldoffset=\" + long.tohexstring(this.extrafieldoffset) ); log.fine( \"local header - extrafieldlength=\" + long.tohexstring(this.extrafieldlength) ); } if( 0==extrafieldlength ) { throw new zipexception(\"extra field is of length 0 - this is probably not a winzip aes encrypted entry\"); } efhid = rafile.readbytearray( extrafieldoffset, 2); if( efhid[0]==0x01 && efhid[1]==(byte)0x99 ) { this.isaesencrypted = true; } } else { this.isaesencrypted = true; } if( this.isaesencrypted ) { this.actualcompressionmethod = rafile.readshort( getextrafieldoffset() + 9 ); this.localheadersize = 30 + getextrafieldlength() + getfilenamelength(); } } this.compressedsize = rafile.readint( fileoffset + 20 ); this.uncompressedsize = rafile.readint( fileoffset + 24 ); }","classification":"DESIGN","isFinished":true,"code_context_2":"log.fine( \"cds - localheaderoffset=\" + long.tohexstring(this.localheaderoffset) ); } \/\/ todo - check, why we have to use the local header instead of the cds sometimes... if( this.isencrypted ) { byte[] efhid = rafile.readbytearray( this.extrafieldoffset, 2 );","code_context_10":"log.fine( \"filename = \" + this.filename ); } this.extrafieldoffset = this.fileoffset + 46 + this.filenamelength; this.extrafieldlength = rafile.readshort( fileoffset + 30 ); this.localheaderoffset = rafile.readint( fileoffset + 28 + 14 ); if( log.isloggable(level.fine) ) { log.fine( \"cds - extrafieldoffset =\" + long.tohexstring(this.extrafieldoffset) ); log.fine( \"cds - extrafieldlength =\" + this.extrafieldlength ); log.fine( \"cds - localheaderoffset=\" + long.tohexstring(this.localheaderoffset) ); } \/\/ todo - check, why we have to use the local header instead of the cds sometimes... if( this.isencrypted ) { byte[] efhid = rafile.readbytearray( this.extrafieldoffset, 2 ); if( efhid[0]!=0x01 || efhid[1]!=(byte)0x99 ) { this.extrafieldoffset = localheaderoffset+30+filenamelength; this.extrafieldlength = rafile.readshort( localheaderoffset+28 ); if( log.isloggable(level.fine) ) { log.fine( \"local header - extrafieldoffset=\" + long.tohexstring(this.extrafieldoffset) ); log.fine( \"local header - extrafieldlength=\" + long.tohexstring(this.extrafieldlength) ); } if( 0==extrafieldlength ) {","code_context_20":"throw new zipexception(\"expected censic not found in central directory (at end of zip file)\"); } else if( log.isloggable(level.fine) ) { log.fine( \"found censigoffset=\" + fileoffset ); } short flag = rafile.readshort( fileoffset + 8 ); this.isencrypted = (flag&1)>0; this.filenamelength = rafile.readshort( fileoffset + 28 ); byte[] filenamebytes = rafile.readbytearray( fileoffset + 46, filenamelength ); this.filename = new string( filenamebytes, aeszipfiledecrypter.charset ); if( log.isloggable(level.fine) ) { log.fine( \"filename = \" + this.filename ); } this.extrafieldoffset = this.fileoffset + 46 + this.filenamelength; this.extrafieldlength = rafile.readshort( fileoffset + 30 ); this.localheaderoffset = rafile.readint( fileoffset + 28 + 14 ); if( log.isloggable(level.fine) ) { log.fine( \"cds - extrafieldoffset =\" + long.tohexstring(this.extrafieldoffset) ); log.fine( \"cds - extrafieldlength =\" + this.extrafieldlength ); log.fine( \"cds - localheaderoffset=\" + long.tohexstring(this.localheaderoffset) ); } \/\/ todo - check, why we have to use the local header instead of the cds sometimes... if( this.isencrypted ) { byte[] efhid = rafile.readbytearray( this.extrafieldoffset, 2 ); if( efhid[0]!=0x01 || efhid[1]!=(byte)0x99 ) { this.extrafieldoffset = localheaderoffset+30+filenamelength; this.extrafieldlength = rafile.readshort( localheaderoffset+28 ); if( log.isloggable(level.fine) ) { log.fine( \"local header - extrafieldoffset=\" + long.tohexstring(this.extrafieldoffset) ); log.fine( \"local header - extrafieldlength=\" + long.tohexstring(this.extrafieldlength) ); } if( 0==extrafieldlength ) { throw new zipexception(\"extra field is of length 0 - this is probably not a winzip aes encrypted entry\"); } efhid = rafile.readbytearray( extrafieldoffset, 2); if( efhid[0]==0x01 && efhid[1]==(byte)0x99 ) { this.isaesencrypted = true; } } else { this.isaesencrypted = true; } if( this.isaesencrypted ) {","repo":"CATION-M\/X-moe"}
{"id":3224,"comment_id":0,"comment":"\/** fixed 256 key size, 16 bytes salt + 2 bytes pwverification *\/","code":"\/** fixed 256 key size, 16 bytes salt + 2 bytes pwverification *\/ public short getcryptoheaderlength() { \/\/ todo support 128+192 byte keys reduces the salt byte size to 8+2 or 12+2 return 18; }","classification":"NONSATD","isFinished":true,"code_context_2":"public short getcryptoheaderlength() { \/\/ todo support 128+192 byte keys reduces the salt byte size to 8+2 or 12+2 return 18; }","code_context_10":"public short getcryptoheaderlength() { \/\/ todo support 128+192 byte keys reduces the salt byte size to 8+2 or 12+2 return 18; }","code_context_20":"public short getcryptoheaderlength() { \/\/ todo support 128+192 byte keys reduces the salt byte size to 8+2 or 12+2 return 18; }","repo":"CATION-M\/X-moe"}
{"id":3224,"comment_id":1,"comment":"\/\/ todo support 128+192 byte keys reduces the salt byte size to 8+2 or 12+2","code":"public short getcryptoheaderlength() { \/\/ todo support 128+192 byte keys reduces the salt byte size to 8+2 or 12+2 return 18; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"public short getcryptoheaderlength() { \/\/ todo support 128+192 byte keys reduces the salt byte size to 8+2 or 12+2 return 18; }","code_context_10":"public short getcryptoheaderlength() { \/\/ todo support 128+192 byte keys reduces the salt byte size to 8+2 or 12+2 return 18; }","code_context_20":"public short getcryptoheaderlength() { \/\/ todo support 128+192 byte keys reduces the salt byte size to 8+2 or 12+2 return 18; }","repo":"CATION-M\/X-moe"}
{"id":11510,"comment_id":0,"comment":"\/** * @brief compute justifications for the predefined assertion. * * note that this will not contain tbox-assertions (i.e. subclassof, ...) * @return a set of justifications for the assertion (basically a set of wrappers around sets of owl-axioms) *\/","code":"\/** * @brief compute justifications for the predefined assertion. * * note that this will not contain tbox-assertions (i.e. subclassof, ...) * @return a set of justifications for the assertion (basically a set of wrappers around sets of owl-axioms) *\/ @override public set< justification > computejustifications() { set< set< owlaxiom > > justifications = null; try { justifications = explainaxiom( axiom_ ); } catch ( owlexception e ) { throw new runtimeexception( e ); } \/\/ we represent justifications as instances of a custom class outside of this function, which requires transitioning \/\/ this is done in order to hide usage of the owlapi in code that does not need to rely directly on it. set< justification > return_justifications = new treeset< justification > (); \/\/ order is important for hitting set computation -> use treeset! \/* \/\/todo use this if printing is not desired for ( set< owlaxiom > justification : justifications ) { \/\/ java 8: \/\/ justification.removeif( ( owlaxiom a ) -> { return a.isoftype( axiomtype.tboxandrboxaxiomtypes ) } ); \/\/ \/\/ java < 8 (there is probably a better way even then): for ( iterator< owlaxiom > it = justification.iterator(); it.hasnext(); ) { owlaxiom a = it.next(); if ( a.isoftype( axiomtype.tboxandrboxaxiomtypes ) ) { it.remove(); } } return_justifications.add( new justification( justification ) ); } *\/ for ( set< owlaxiom > justification : justifications ) { return_justifications.add( new justification( justification ) ); } \/\/if ( sparqlupdater.verbose_level > 0 ) { \/\/justification.print( return_justifications, axiom_ ); \/\/} \/\/ we only consider abox axioms for deletion. therefore, we remove tbox and rbox assertions. \/\/ todo if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the justification class. for ( justification justification : return_justifications ) { justification.removetboxandrboxaxioms(); } return return_justifications; }","classification":"NONSATD","isFinished":true,"code_context_2":"@override public set< justification > computejustifications() { set< set< owlaxiom > > justifications = null; try { justifications = explainaxiom( axiom_ ); } catch ( owlexception e ) { throw new runtimeexception( e ); } \/\/ we represent justifications as instances of a custom class outside of this function, which requires transitioning \/\/ this is done in order to hide usage of the owlapi in code that does not need to rely directly on it. set< justification > return_justifications = new treeset< justification > (); \/\/ order is important for hitting set computation -> use treeset! \/* \/\/todo use this if printing is not desired for ( set< owlaxiom > justification : justifications ) { \/\/ java 8: \/\/ justification.removeif( ( owlaxiom a ) -> { return a.isoftype( axiomtype.tboxandrboxaxiomtypes ) } ); \/\/ \/\/ java < 8 (there is probably a better way even then): for ( iterator< owlaxiom > it = justification.iterator(); it.hasnext(); ) { owlaxiom a = it.next(); if ( a.isoftype( axiomtype.tboxandrboxaxiomtypes ) ) { it.remove(); } } return_justifications.add( new justification( justification ) ); } *\/ for ( set< owlaxiom > justification : justifications ) { return_justifications.add( new justification( justification ) ); } \/\/if ( sparqlupdater.verbose_level > 0 ) { \/\/justification.print( return_justifications, axiom_ ); \/\/} \/\/ we only consider abox axioms for deletion. therefore, we remove tbox and rbox assertions. \/\/ todo if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the justification class. for ( justification justification : return_justifications ) { justification.removetboxandrboxaxioms(); } return return_justifications; }","code_context_10":"@override public set< justification > computejustifications() { set< set< owlaxiom > > justifications = null; try { justifications = explainaxiom( axiom_ ); } catch ( owlexception e ) { throw new runtimeexception( e ); } \/\/ we represent justifications as instances of a custom class outside of this function, which requires transitioning \/\/ this is done in order to hide usage of the owlapi in code that does not need to rely directly on it. set< justification > return_justifications = new treeset< justification > (); \/\/ order is important for hitting set computation -> use treeset! \/* \/\/todo use this if printing is not desired for ( set< owlaxiom > justification : justifications ) { \/\/ java 8: \/\/ justification.removeif( ( owlaxiom a ) -> { return a.isoftype( axiomtype.tboxandrboxaxiomtypes ) } ); \/\/ \/\/ java < 8 (there is probably a better way even then): for ( iterator< owlaxiom > it = justification.iterator(); it.hasnext(); ) { owlaxiom a = it.next(); if ( a.isoftype( axiomtype.tboxandrboxaxiomtypes ) ) { it.remove(); } } return_justifications.add( new justification( justification ) ); } *\/ for ( set< owlaxiom > justification : justifications ) { return_justifications.add( new justification( justification ) ); } \/\/if ( sparqlupdater.verbose_level > 0 ) { \/\/justification.print( return_justifications, axiom_ ); \/\/} \/\/ we only consider abox axioms for deletion. therefore, we remove tbox and rbox assertions. \/\/ todo if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the justification class. for ( justification justification : return_justifications ) { justification.removetboxandrboxaxioms(); } return return_justifications; }","code_context_20":"@override public set< justification > computejustifications() { set< set< owlaxiom > > justifications = null; try { justifications = explainaxiom( axiom_ ); } catch ( owlexception e ) { throw new runtimeexception( e ); } \/\/ we represent justifications as instances of a custom class outside of this function, which requires transitioning \/\/ this is done in order to hide usage of the owlapi in code that does not need to rely directly on it. set< justification > return_justifications = new treeset< justification > (); \/\/ order is important for hitting set computation -> use treeset! \/* \/\/todo use this if printing is not desired for ( set< owlaxiom > justification : justifications ) { \/\/ java 8: \/\/ justification.removeif( ( owlaxiom a ) -> { return a.isoftype( axiomtype.tboxandrboxaxiomtypes ) } ); \/\/ \/\/ java < 8 (there is probably a better way even then): for ( iterator< owlaxiom > it = justification.iterator(); it.hasnext(); ) { owlaxiom a = it.next(); if ( a.isoftype( axiomtype.tboxandrboxaxiomtypes ) ) { it.remove(); } } return_justifications.add( new justification( justification ) ); } *\/ for ( set< owlaxiom > justification : justifications ) { return_justifications.add( new justification( justification ) ); } \/\/if ( sparqlupdater.verbose_level > 0 ) { \/\/justification.print( return_justifications, axiom_ ); \/\/} \/\/ we only consider abox axioms for deletion. therefore, we remove tbox and rbox assertions. \/\/ todo if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the justification class. for ( justification justification : return_justifications ) { justification.removetboxandrboxaxioms(); } return return_justifications; }","repo":"Institute-Web-Science-and-Technologies\/SparqlUpdater"}
{"id":11510,"comment_id":1,"comment":"\/\/ we represent justifications as instances of a custom class outside of this function, which requires transitioning \/\/ this is done in order to hide usage of the owlapi in code that does not need to rely directly on it.","code":"@override public set< justification > computejustifications() { set< set< owlaxiom > > justifications = null; try { justifications = explainaxiom( axiom_ ); } catch ( owlexception e ) { throw new runtimeexception( e ); } \/\/ we represent justifications as instances of a custom class outside of this function, which requires transitioning \/\/ this is done in order to hide usage of the owlapi in code that does not need to rely directly on it. set< justification > return_justifications = new treeset< justification > (); \/\/ order is important for hitting set computation -> use treeset! \/* \/\/todo use this if printing is not desired for ( set< owlaxiom > justification : justifications ) { \/\/ java 8: \/\/ justification.removeif( ( owlaxiom a ) -> { return a.isoftype( axiomtype.tboxandrboxaxiomtypes ) } ); \/\/ \/\/ java < 8 (there is probably a better way even then): for ( iterator< owlaxiom > it = justification.iterator(); it.hasnext(); ) { owlaxiom a = it.next(); if ( a.isoftype( axiomtype.tboxandrboxaxiomtypes ) ) { it.remove(); } } return_justifications.add( new justification( justification ) ); } *\/ for ( set< owlaxiom > justification : justifications ) { return_justifications.add( new justification( justification ) ); } \/\/if ( sparqlupdater.verbose_level > 0 ) { \/\/justification.print( return_justifications, axiom_ ); \/\/} \/\/ we only consider abox axioms for deletion. therefore, we remove tbox and rbox assertions. \/\/ todo if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the justification class. for ( justification justification : return_justifications ) { justification.removetboxandrboxaxioms(); } return return_justifications; }","classification":"NONSATD","isFinished":true,"code_context_2":"throw new runtimeexception( e ); } \/\/ we represent justifications as instances of a custom class outside of this function, which requires transitioning \/\/ this is done in order to hide usage of the owlapi in code that does not need to rely directly on it. set< justification > return_justifications = new treeset< justification > (); \/\/ order is important for hitting set computation -> use treeset! \/* \/\/todo use this if printing is not desired","code_context_10":"@override public set< justification > computejustifications() { set< set< owlaxiom > > justifications = null; try { justifications = explainaxiom( axiom_ ); } catch ( owlexception e ) { throw new runtimeexception( e ); } \/\/ we represent justifications as instances of a custom class outside of this function, which requires transitioning \/\/ this is done in order to hide usage of the owlapi in code that does not need to rely directly on it. set< justification > return_justifications = new treeset< justification > (); \/\/ order is important for hitting set computation -> use treeset! \/* \/\/todo use this if printing is not desired for ( set< owlaxiom > justification : justifications ) { \/\/ java 8: \/\/ justification.removeif( ( owlaxiom a ) -> { return a.isoftype( axiomtype.tboxandrboxaxiomtypes ) } ); \/\/ \/\/ java < 8 (there is probably a better way even then): for ( iterator< owlaxiom > it = justification.iterator(); it.hasnext(); ) { owlaxiom a = it.next(); if ( a.isoftype( axiomtype.tboxandrboxaxiomtypes ) ) {","code_context_20":"@override public set< justification > computejustifications() { set< set< owlaxiom > > justifications = null; try { justifications = explainaxiom( axiom_ ); } catch ( owlexception e ) { throw new runtimeexception( e ); } \/\/ we represent justifications as instances of a custom class outside of this function, which requires transitioning \/\/ this is done in order to hide usage of the owlapi in code that does not need to rely directly on it. set< justification > return_justifications = new treeset< justification > (); \/\/ order is important for hitting set computation -> use treeset! \/* \/\/todo use this if printing is not desired for ( set< owlaxiom > justification : justifications ) { \/\/ java 8: \/\/ justification.removeif( ( owlaxiom a ) -> { return a.isoftype( axiomtype.tboxandrboxaxiomtypes ) } ); \/\/ \/\/ java < 8 (there is probably a better way even then): for ( iterator< owlaxiom > it = justification.iterator(); it.hasnext(); ) { owlaxiom a = it.next(); if ( a.isoftype( axiomtype.tboxandrboxaxiomtypes ) ) { it.remove(); } } return_justifications.add( new justification( justification ) ); } *\/ for ( set< owlaxiom > justification : justifications ) { return_justifications.add( new justification( justification ) ); } \/\/if ( sparqlupdater.verbose_level > 0 ) {","repo":"Institute-Web-Science-and-Technologies\/SparqlUpdater"}
{"id":11510,"comment_id":2,"comment":"\/\/ order is important for hitting set computation -> use treeset!","code":"@override public set< justification > computejustifications() { set< set< owlaxiom > > justifications = null; try { justifications = explainaxiom( axiom_ ); } catch ( owlexception e ) { throw new runtimeexception( e ); } \/\/ we represent justifications as instances of a custom class outside of this function, which requires transitioning \/\/ this is done in order to hide usage of the owlapi in code that does not need to rely directly on it. set< justification > return_justifications = new treeset< justification > (); \/\/ order is important for hitting set computation -> use treeset! \/* \/\/todo use this if printing is not desired for ( set< owlaxiom > justification : justifications ) { \/\/ java 8: \/\/ justification.removeif( ( owlaxiom a ) -> { return a.isoftype( axiomtype.tboxandrboxaxiomtypes ) } ); \/\/ \/\/ java < 8 (there is probably a better way even then): for ( iterator< owlaxiom > it = justification.iterator(); it.hasnext(); ) { owlaxiom a = it.next(); if ( a.isoftype( axiomtype.tboxandrboxaxiomtypes ) ) { it.remove(); } } return_justifications.add( new justification( justification ) ); } *\/ for ( set< owlaxiom > justification : justifications ) { return_justifications.add( new justification( justification ) ); } \/\/if ( sparqlupdater.verbose_level > 0 ) { \/\/justification.print( return_justifications, axiom_ ); \/\/} \/\/ we only consider abox axioms for deletion. therefore, we remove tbox and rbox assertions. \/\/ todo if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the justification class. for ( justification justification : return_justifications ) { justification.removetboxandrboxaxioms(); } return return_justifications; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ we represent justifications as instances of a custom class outside of this function, which requires transitioning \/\/ this is done in order to hide usage of the owlapi in code that does not need to rely directly on it. set< justification > return_justifications = new treeset< justification > (); \/\/ order is important for hitting set computation -> use treeset! \/* \/\/todo use this if printing is not desired for ( set< owlaxiom > justification : justifications ) {","code_context_10":"public set< justification > computejustifications() { set< set< owlaxiom > > justifications = null; try { justifications = explainaxiom( axiom_ ); } catch ( owlexception e ) { throw new runtimeexception( e ); } \/\/ we represent justifications as instances of a custom class outside of this function, which requires transitioning \/\/ this is done in order to hide usage of the owlapi in code that does not need to rely directly on it. set< justification > return_justifications = new treeset< justification > (); \/\/ order is important for hitting set computation -> use treeset! \/* \/\/todo use this if printing is not desired for ( set< owlaxiom > justification : justifications ) { \/\/ java 8: \/\/ justification.removeif( ( owlaxiom a ) -> { return a.isoftype( axiomtype.tboxandrboxaxiomtypes ) } ); \/\/ \/\/ java < 8 (there is probably a better way even then): for ( iterator< owlaxiom > it = justification.iterator(); it.hasnext(); ) { owlaxiom a = it.next(); if ( a.isoftype( axiomtype.tboxandrboxaxiomtypes ) ) { it.remove();","code_context_20":"@override public set< justification > computejustifications() { set< set< owlaxiom > > justifications = null; try { justifications = explainaxiom( axiom_ ); } catch ( owlexception e ) { throw new runtimeexception( e ); } \/\/ we represent justifications as instances of a custom class outside of this function, which requires transitioning \/\/ this is done in order to hide usage of the owlapi in code that does not need to rely directly on it. set< justification > return_justifications = new treeset< justification > (); \/\/ order is important for hitting set computation -> use treeset! \/* \/\/todo use this if printing is not desired for ( set< owlaxiom > justification : justifications ) { \/\/ java 8: \/\/ justification.removeif( ( owlaxiom a ) -> { return a.isoftype( axiomtype.tboxandrboxaxiomtypes ) } ); \/\/ \/\/ java < 8 (there is probably a better way even then): for ( iterator< owlaxiom > it = justification.iterator(); it.hasnext(); ) { owlaxiom a = it.next(); if ( a.isoftype( axiomtype.tboxandrboxaxiomtypes ) ) { it.remove(); } } return_justifications.add( new justification( justification ) ); } *\/ for ( set< owlaxiom > justification : justifications ) { return_justifications.add( new justification( justification ) ); } \/\/if ( sparqlupdater.verbose_level > 0 ) { \/\/justification.print( return_justifications, axiom_ );","repo":"Institute-Web-Science-and-Technologies\/SparqlUpdater"}
{"id":11510,"comment_id":3,"comment":"\/* \/\/todo use this if printing is not desired for ( set< owlaxiom > justification : justifications ) { \/\/ java 8: \/\/ justification.removeif( ( owlaxiom a ) -> { return a.isoftype( axiomtype.tboxandrboxaxiomtypes ) } ); \/\/ \/\/ java < 8 (there is probably a better way even then): for ( iterator< owlaxiom > it = justification.iterator(); it.hasnext(); ) { owlaxiom a = it.next(); if ( a.isoftype( axiomtype.tboxandrboxaxiomtypes ) ) { it.remove(); } } return_justifications.add( new justification( justification ) ); } *\/","code":"@override public set< justification > computejustifications() { set< set< owlaxiom > > justifications = null; try { justifications = explainaxiom( axiom_ ); } catch ( owlexception e ) { throw new runtimeexception( e ); } \/\/ we represent justifications as instances of a custom class outside of this function, which requires transitioning \/\/ this is done in order to hide usage of the owlapi in code that does not need to rely directly on it. set< justification > return_justifications = new treeset< justification > (); \/\/ order is important for hitting set computation -> use treeset! \/* \/\/todo use this if printing is not desired for ( set< owlaxiom > justification : justifications ) { \/\/ java 8: \/\/ justification.removeif( ( owlaxiom a ) -> { return a.isoftype( axiomtype.tboxandrboxaxiomtypes ) } ); \/\/ \/\/ java < 8 (there is probably a better way even then): for ( iterator< owlaxiom > it = justification.iterator(); it.hasnext(); ) { owlaxiom a = it.next(); if ( a.isoftype( axiomtype.tboxandrboxaxiomtypes ) ) { it.remove(); } } return_justifications.add( new justification( justification ) ); } *\/ for ( set< owlaxiom > justification : justifications ) { return_justifications.add( new justification( justification ) ); } \/\/if ( sparqlupdater.verbose_level > 0 ) { \/\/justification.print( return_justifications, axiom_ ); \/\/} \/\/ we only consider abox axioms for deletion. therefore, we remove tbox and rbox assertions. \/\/ todo if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the justification class. for ( justification justification : return_justifications ) { justification.removetboxandrboxaxioms(); } return return_justifications; }","classification":"DESIGN","isFinished":true,"code_context_2":"\/\/ this is done in order to hide usage of the owlapi in code that does not need to rely directly on it. set< justification > return_justifications = new treeset< justification > (); \/\/ order is important for hitting set computation -> use treeset! \/* \/\/todo use this if printing is not desired for ( set< owlaxiom > justification : justifications ) { \/\/ java 8: \/\/ justification.removeif( ( owlaxiom a ) -> { return a.isoftype( axiomtype.tboxandrboxaxiomtypes ) } ); \/\/ \/\/ java < 8 (there is probably a better way even then): for ( iterator< owlaxiom > it = justification.iterator(); it.hasnext(); ) { owlaxiom a = it.next(); if ( a.isoftype( axiomtype.tboxandrboxaxiomtypes ) ) { it.remove(); } } return_justifications.add( new justification( justification ) ); } *\/ for ( set< owlaxiom > justification : justifications ) { return_justifications.add( new justification( justification ) );","code_context_10":"set< set< owlaxiom > > justifications = null; try { justifications = explainaxiom( axiom_ ); } catch ( owlexception e ) { throw new runtimeexception( e ); } \/\/ we represent justifications as instances of a custom class outside of this function, which requires transitioning \/\/ this is done in order to hide usage of the owlapi in code that does not need to rely directly on it. set< justification > return_justifications = new treeset< justification > (); \/\/ order is important for hitting set computation -> use treeset! \/* \/\/todo use this if printing is not desired for ( set< owlaxiom > justification : justifications ) { \/\/ java 8: \/\/ justification.removeif( ( owlaxiom a ) -> { return a.isoftype( axiomtype.tboxandrboxaxiomtypes ) } ); \/\/ \/\/ java < 8 (there is probably a better way even then): for ( iterator< owlaxiom > it = justification.iterator(); it.hasnext(); ) { owlaxiom a = it.next(); if ( a.isoftype( axiomtype.tboxandrboxaxiomtypes ) ) { it.remove(); } } return_justifications.add( new justification( justification ) ); } *\/ for ( set< owlaxiom > justification : justifications ) { return_justifications.add( new justification( justification ) ); } \/\/if ( sparqlupdater.verbose_level > 0 ) { \/\/justification.print( return_justifications, axiom_ ); \/\/} \/\/ we only consider abox axioms for deletion. therefore, we remove tbox and rbox assertions. \/\/ todo if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the justification class. for ( justification justification : return_justifications ) { justification.removetboxandrboxaxioms();","code_context_20":"@override public set< justification > computejustifications() { set< set< owlaxiom > > justifications = null; try { justifications = explainaxiom( axiom_ ); } catch ( owlexception e ) { throw new runtimeexception( e ); } \/\/ we represent justifications as instances of a custom class outside of this function, which requires transitioning \/\/ this is done in order to hide usage of the owlapi in code that does not need to rely directly on it. set< justification > return_justifications = new treeset< justification > (); \/\/ order is important for hitting set computation -> use treeset! \/* \/\/todo use this if printing is not desired for ( set< owlaxiom > justification : justifications ) { \/\/ java 8: \/\/ justification.removeif( ( owlaxiom a ) -> { return a.isoftype( axiomtype.tboxandrboxaxiomtypes ) } ); \/\/ \/\/ java < 8 (there is probably a better way even then): for ( iterator< owlaxiom > it = justification.iterator(); it.hasnext(); ) { owlaxiom a = it.next(); if ( a.isoftype( axiomtype.tboxandrboxaxiomtypes ) ) { it.remove(); } } return_justifications.add( new justification( justification ) ); } *\/ for ( set< owlaxiom > justification : justifications ) { return_justifications.add( new justification( justification ) ); } \/\/if ( sparqlupdater.verbose_level > 0 ) { \/\/justification.print( return_justifications, axiom_ ); \/\/} \/\/ we only consider abox axioms for deletion. therefore, we remove tbox and rbox assertions. \/\/ todo if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the justification class. for ( justification justification : return_justifications ) { justification.removetboxandrboxaxioms(); } return return_justifications; }","repo":"Institute-Web-Science-and-Technologies\/SparqlUpdater"}
{"id":11510,"comment_id":4,"comment":"\/\/if ( sparqlupdater.verbose_level > 0 ) { \/\/justification.print( return_justifications, axiom_ ); \/\/} \/\/ we only consider abox axioms for deletion. therefore, we remove tbox and rbox assertions. \/\/ todo if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the justification class.","code":"@override public set< justification > computejustifications() { set< set< owlaxiom > > justifications = null; try { justifications = explainaxiom( axiom_ ); } catch ( owlexception e ) { throw new runtimeexception( e ); } \/\/ we represent justifications as instances of a custom class outside of this function, which requires transitioning \/\/ this is done in order to hide usage of the owlapi in code that does not need to rely directly on it. set< justification > return_justifications = new treeset< justification > (); \/\/ order is important for hitting set computation -> use treeset! \/* \/\/todo use this if printing is not desired for ( set< owlaxiom > justification : justifications ) { \/\/ java 8: \/\/ justification.removeif( ( owlaxiom a ) -> { return a.isoftype( axiomtype.tboxandrboxaxiomtypes ) } ); \/\/ \/\/ java < 8 (there is probably a better way even then): for ( iterator< owlaxiom > it = justification.iterator(); it.hasnext(); ) { owlaxiom a = it.next(); if ( a.isoftype( axiomtype.tboxandrboxaxiomtypes ) ) { it.remove(); } } return_justifications.add( new justification( justification ) ); } *\/ for ( set< owlaxiom > justification : justifications ) { return_justifications.add( new justification( justification ) ); } \/\/if ( sparqlupdater.verbose_level > 0 ) { \/\/justification.print( return_justifications, axiom_ ); \/\/} \/\/ we only consider abox axioms for deletion. therefore, we remove tbox and rbox assertions. \/\/ todo if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the justification class. for ( justification justification : return_justifications ) { justification.removetboxandrboxaxioms(); } return return_justifications; }","classification":"DESIGN","isFinished":true,"code_context_2":"return_justifications.add( new justification( justification ) ); } \/\/if ( sparqlupdater.verbose_level > 0 ) { \/\/justification.print( return_justifications, axiom_ ); \/\/} \/\/ we only consider abox axioms for deletion. therefore, we remove tbox and rbox assertions. \/\/ todo if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the justification class. for ( justification justification : return_justifications ) { justification.removetboxandrboxaxioms();","code_context_10":"if ( a.isoftype( axiomtype.tboxandrboxaxiomtypes ) ) { it.remove(); } } return_justifications.add( new justification( justification ) ); } *\/ for ( set< owlaxiom > justification : justifications ) { return_justifications.add( new justification( justification ) ); } \/\/if ( sparqlupdater.verbose_level > 0 ) { \/\/justification.print( return_justifications, axiom_ ); \/\/} \/\/ we only consider abox axioms for deletion. therefore, we remove tbox and rbox assertions. \/\/ todo if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the justification class. for ( justification justification : return_justifications ) { justification.removetboxandrboxaxioms(); } return return_justifications; }","code_context_20":"\/\/ this is done in order to hide usage of the owlapi in code that does not need to rely directly on it. set< justification > return_justifications = new treeset< justification > (); \/\/ order is important for hitting set computation -> use treeset! \/* \/\/todo use this if printing is not desired for ( set< owlaxiom > justification : justifications ) { \/\/ java 8: \/\/ justification.removeif( ( owlaxiom a ) -> { return a.isoftype( axiomtype.tboxandrboxaxiomtypes ) } ); \/\/ \/\/ java < 8 (there is probably a better way even then): for ( iterator< owlaxiom > it = justification.iterator(); it.hasnext(); ) { owlaxiom a = it.next(); if ( a.isoftype( axiomtype.tboxandrboxaxiomtypes ) ) { it.remove(); } } return_justifications.add( new justification( justification ) ); } *\/ for ( set< owlaxiom > justification : justifications ) { return_justifications.add( new justification( justification ) ); } \/\/if ( sparqlupdater.verbose_level > 0 ) { \/\/justification.print( return_justifications, axiom_ ); \/\/} \/\/ we only consider abox axioms for deletion. therefore, we remove tbox and rbox assertions. \/\/ todo if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the justification class. for ( justification justification : return_justifications ) { justification.removetboxandrboxaxioms(); } return return_justifications; }","repo":"Institute-Web-Science-and-Technologies\/SparqlUpdater"}
{"id":19708,"comment_id":0,"comment":"\/** * can they kick? * * @param name * @return *\/","code":"\/** * can they kick? * * @param name * @return *\/ public boolean cankick(string name) { if (isfounder(name)) { return true; } if (getrank(name) >= whocankick) { return true; } return false; }","classification":"TEST","isFinished":true,"code_context_2":"public boolean cankick(string name) { if (isfounder(name)) { return true; } if (getrank(name) >= whocankick) { return true; } return false; }","code_context_10":"public boolean cankick(string name) { if (isfounder(name)) { return true; } if (getrank(name) >= whocankick) { return true; } return false; }","code_context_20":"public boolean cankick(string name) { if (isfounder(name)) { return true; } if (getrank(name) >= whocankick) { return true; } return false; }","repo":"CoderMMK\/RSPS"}
{"id":19709,"comment_id":0,"comment":"\/** * can they ban? * * @param name * @return *\/","code":"\/** * can they ban? * * @param name * @return *\/ public boolean canban(string name) { if (isfounder(name)) { return true; } if (getrank(name) >= whocanban) { return true; } return false; }","classification":"TEST","isFinished":true,"code_context_2":"public boolean canban(string name) { if (isfounder(name)) { return true; } if (getrank(name) >= whocanban) { return true; } return false; }","code_context_10":"public boolean canban(string name) { if (isfounder(name)) { return true; } if (getrank(name) >= whocanban) { return true; } return false; }","code_context_20":"public boolean canban(string name) { if (isfounder(name)) { return true; } if (getrank(name) >= whocanban) { return true; } return false; }","repo":"CoderMMK\/RSPS"}
{"id":3404,"comment_id":0,"comment":"\/\/ todo: this endpoint supports post if the query string is too long","code":"public void getlivetvprogramsasync(programquery query, final response<itemsresult> response) { if (query == null) { throw new illegalargumentexception(\"query\"); } querystringdictionary dict = new querystringdictionary (); string isodateformat = \"o\"; if (query.getmaxenddate() != null) { dict.add(\"maxenddate\", getisostring(query.getmaxenddate())); } if (query.getmaxstartdate() != null) { dict.add(\"maxstartdate\", getisostring(query.getmaxstartdate())); } if (query.getminenddate() != null) { dict.add(\"minenddate\", getisostring(query.getminenddate())); } if (query.getminstartdate() != null) { dict.add(\"minstartdate\", getisostring(query.getminstartdate())); } if (!query.getenabletotalrecordcount()) { dict.add(\"enabletotalrecordcount\", \"false\"); } dict.addifnotnull(\"enableimages\", query.getenableimages()); dict.addifnotnull(\"imagetypelimit\", query.getimagetypelimit()); dict.addifnotnull(\"enableimagetypes\", query.getenableimagetypes()); dict.addifnotnull(\"fields\", query.getfields()); dict.addifnotnull(\"sortby\", query.getsortby()); dict.addifnotnullorempty(\"userid\", query.getuserid()); if (query.getchannelids() != null) { dict.add(\"channelids\", tangible.dotnettojavastringhelper.join(\",\", query.getchannelids())); } \/\/ todo: this endpoint supports post if the query string is too long string url = getapiurl(\"livetv\/programs\", dict); url = adddataformat(url); send(url, \"get\", new serializedresponse<>(response, jsonserializer, itemsresult.class)); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"dict.add(\"channelids\", tangible.dotnettojavastringhelper.join(\",\", query.getchannelids())); } \/\/ todo: this endpoint supports post if the query string is too long string url = getapiurl(\"livetv\/programs\", dict); url = adddataformat(url);","code_context_10":"dict.addifnotnull(\"enableimages\", query.getenableimages()); dict.addifnotnull(\"imagetypelimit\", query.getimagetypelimit()); dict.addifnotnull(\"enableimagetypes\", query.getenableimagetypes()); dict.addifnotnull(\"fields\", query.getfields()); dict.addifnotnull(\"sortby\", query.getsortby()); dict.addifnotnullorempty(\"userid\", query.getuserid()); if (query.getchannelids() != null) { dict.add(\"channelids\", tangible.dotnettojavastringhelper.join(\",\", query.getchannelids())); } \/\/ todo: this endpoint supports post if the query string is too long string url = getapiurl(\"livetv\/programs\", dict); url = adddataformat(url); send(url, \"get\", new serializedresponse<>(response, jsonserializer, itemsresult.class)); }","code_context_20":"dict.add(\"minenddate\", getisostring(query.getminenddate())); } if (query.getminstartdate() != null) { dict.add(\"minstartdate\", getisostring(query.getminstartdate())); } if (!query.getenabletotalrecordcount()) { dict.add(\"enabletotalrecordcount\", \"false\"); } dict.addifnotnull(\"enableimages\", query.getenableimages()); dict.addifnotnull(\"imagetypelimit\", query.getimagetypelimit()); dict.addifnotnull(\"enableimagetypes\", query.getenableimagetypes()); dict.addifnotnull(\"fields\", query.getfields()); dict.addifnotnull(\"sortby\", query.getsortby()); dict.addifnotnullorempty(\"userid\", query.getuserid()); if (query.getchannelids() != null) { dict.add(\"channelids\", tangible.dotnettojavastringhelper.join(\",\", query.getchannelids())); } \/\/ todo: this endpoint supports post if the query string is too long string url = getapiurl(\"livetv\/programs\", dict); url = adddataformat(url); send(url, \"get\", new serializedresponse<>(response, jsonserializer, itemsresult.class)); }","repo":"AndreasGB\/jellyfin-apiclient-java"}
{"id":19828,"comment_id":0,"comment":"\/** * tests that the component will be initialized correctly. *\/","code":"\/** * tests that the component will be initialized correctly. *\/ @test public void testpositionconstructor() { position = new position(rowinrange, cellinrange); \/\/ i know tests need to be independent but not sure how else to do this assertequals(rowinrange, position.getrow()); assertequals(cellinrange, position.getcell()); }","classification":"NONSATD","isFinished":true,"code_context_2":"@test public void testpositionconstructor() { position = new position(rowinrange, cellinrange); \/\/ i know tests need to be independent but not sure how else to do this assertequals(rowinrange, position.getrow()); assertequals(cellinrange, position.getcell()); }","code_context_10":"@test public void testpositionconstructor() { position = new position(rowinrange, cellinrange); \/\/ i know tests need to be independent but not sure how else to do this assertequals(rowinrange, position.getrow()); assertequals(cellinrange, position.getcell()); }","code_context_20":"@test public void testpositionconstructor() { position = new position(rowinrange, cellinrange); \/\/ i know tests need to be independent but not sure how else to do this assertequals(rowinrange, position.getrow()); assertequals(cellinrange, position.getcell()); }","repo":"DaniloSosa98\/SE-WebCheckers"}
{"id":19828,"comment_id":1,"comment":"\/\/ i know tests need to be independent but not sure how else to do this","code":"@test public void testpositionconstructor() { position = new position(rowinrange, cellinrange); \/\/ i know tests need to be independent but not sure how else to do this assertequals(rowinrange, position.getrow()); assertequals(cellinrange, position.getcell()); }","classification":"DESIGN","isFinished":true,"code_context_2":"public void testpositionconstructor() { position = new position(rowinrange, cellinrange); \/\/ i know tests need to be independent but not sure how else to do this assertequals(rowinrange, position.getrow()); assertequals(cellinrange, position.getcell());","code_context_10":"@test public void testpositionconstructor() { position = new position(rowinrange, cellinrange); \/\/ i know tests need to be independent but not sure how else to do this assertequals(rowinrange, position.getrow()); assertequals(cellinrange, position.getcell()); }","code_context_20":"@test public void testpositionconstructor() { position = new position(rowinrange, cellinrange); \/\/ i know tests need to be independent but not sure how else to do this assertequals(rowinrange, position.getrow()); assertequals(cellinrange, position.getcell()); }","repo":"DaniloSosa98\/SE-WebCheckers"}
{"id":11711,"comment_id":0,"comment":"\/\/ nre: todo: why not guess by extension?","code":"@get @path(\"{connectorid}\/contents\") public response gettypedcontent(@pathparam(\"connectorid\") long connectorid, @queryparam(\"nodeid\") string nodeid, @queryparam(\"type\") connectornodetype type) { connector connector = getconnector(connectorid); inputstream content = connector.getcontent(new connectornode(nodeid, null, type)); if (content == null) { return jaxrsutil.createresponse().status(response.status.not_found).build(); } \/\/ nre: todo: why not guess by extension? try { return jaxrsutil.createresponse().status(status.ok).entity(ioutil.readinputstream(content, connectorid + \"-\" + nodeid + \"-content-stream\")) .header(\"content-type\", type.getmimetype()) .build(); } finally { ioutil.closesilently(content); } }","classification":"DESIGN","isFinished":true,"code_context_2":"return jaxrsutil.createresponse().status(response.status.not_found).build(); } \/\/ nre: todo: why not guess by extension? try { return jaxrsutil.createresponse().status(status.ok).entity(ioutil.readinputstream(content, connectorid + \"-\" + nodeid + \"-content-stream\"))","code_context_10":"@get @path(\"{connectorid}\/contents\") public response gettypedcontent(@pathparam(\"connectorid\") long connectorid, @queryparam(\"nodeid\") string nodeid, @queryparam(\"type\") connectornodetype type) { connector connector = getconnector(connectorid); inputstream content = connector.getcontent(new connectornode(nodeid, null, type)); if (content == null) { return jaxrsutil.createresponse().status(response.status.not_found).build(); } \/\/ nre: todo: why not guess by extension? try { return jaxrsutil.createresponse().status(status.ok).entity(ioutil.readinputstream(content, connectorid + \"-\" + nodeid + \"-content-stream\")) .header(\"content-type\", type.getmimetype()) .build(); } finally { ioutil.closesilently(content); } }","code_context_20":"@get @path(\"{connectorid}\/contents\") public response gettypedcontent(@pathparam(\"connectorid\") long connectorid, @queryparam(\"nodeid\") string nodeid, @queryparam(\"type\") connectornodetype type) { connector connector = getconnector(connectorid); inputstream content = connector.getcontent(new connectornode(nodeid, null, type)); if (content == null) { return jaxrsutil.createresponse().status(response.status.not_found).build(); } \/\/ nre: todo: why not guess by extension? try { return jaxrsutil.createresponse().status(status.ok).entity(ioutil.readinputstream(content, connectorid + \"-\" + nodeid + \"-content-stream\")) .header(\"content-type\", type.getmimetype()) .build(); } finally { ioutil.closesilently(content); } }","repo":"1and1\/camunda-bpm-platform"}
{"id":3528,"comment_id":0,"comment":"\/\/todo this needs to be updated if actual values are used in the distribution system","code":"private complex getfeederloadva(string sourcebusid) { bus3phase sourcebus = (bus3phase) this.net.getbus(sourcebusid); complex3x1 vabc_1 = sourcebus.get3phasevotlages(); complex3x1 currinj3phase = new complex3x1(); for(branch bra: sourcebus.getconnectedphysicalbranchlist()){ if(bra.isactive()){ branch3phase acline = (branch3phase) bra; complex3x1 isource = null; if(bra.getfrombus().getid().equals(sourcebus.getid())){ bus3phase tobus = (bus3phase) bra.gettobus(); complex3x1 vabc_2 = tobus.get3phasevotlages(); complex3x3 yft = acline.getyftabc(); complex3x3 yff = acline.getyffabc(); isource = yff.multiply(vabc_1).add(yft.multiply(vabc_2)); currinj3phase = currinj3phase.subtract(isource ); } else{ bus3phase frombus = (bus3phase) bra.getfrombus(); complex3x1 vabc_2 = frombus.get3phasevotlages(); complex3x3 ytf = acline.getytfabc(); complex3x3 ytt = acline.getyttabc(); isource = ytt.multiply(vabc_1).add(ytf.multiply(vabc_2)); currinj3phase = currinj3phase.subtract(isource); } } } \/\/todo this needs to be updated if actual values are used in the distribution system double distvabase = this.net.getbasemva()*1.0e6; bus3phase sourcebus3ph = (bus3phase) sourcebus; \/\/ from distribution to transmission complex totalpower = sourcebus3ph.get3phasevotlages().dotproduct(currinj3phase.conjugate()).divide(3.0).multiply(distvabase); return totalpower.multiply(-1.0); }","classification":"DESIGN","isFinished":true,"code_context_2":"} } \/\/todo this needs to be updated if actual values are used in the distribution system double distvabase = this.net.getbasemva()*1.0e6; bus3phase sourcebus3ph = (bus3phase) sourcebus;","code_context_10":"else{ bus3phase frombus = (bus3phase) bra.getfrombus(); complex3x1 vabc_2 = frombus.get3phasevotlages(); complex3x3 ytf = acline.getytfabc(); complex3x3 ytt = acline.getyttabc(); isource = ytt.multiply(vabc_1).add(ytf.multiply(vabc_2)); currinj3phase = currinj3phase.subtract(isource); } } } \/\/todo this needs to be updated if actual values are used in the distribution system double distvabase = this.net.getbasemva()*1.0e6; bus3phase sourcebus3ph = (bus3phase) sourcebus; \/\/ from distribution to transmission complex totalpower = sourcebus3ph.get3phasevotlages().dotproduct(currinj3phase.conjugate()).divide(3.0).multiply(distvabase); return totalpower.multiply(-1.0); }","code_context_20":"branch3phase acline = (branch3phase) bra; complex3x1 isource = null; if(bra.getfrombus().getid().equals(sourcebus.getid())){ bus3phase tobus = (bus3phase) bra.gettobus(); complex3x1 vabc_2 = tobus.get3phasevotlages(); complex3x3 yft = acline.getyftabc(); complex3x3 yff = acline.getyffabc(); isource = yff.multiply(vabc_1).add(yft.multiply(vabc_2)); currinj3phase = currinj3phase.subtract(isource ); } else{ bus3phase frombus = (bus3phase) bra.getfrombus(); complex3x1 vabc_2 = frombus.get3phasevotlages(); complex3x3 ytf = acline.getytfabc(); complex3x3 ytt = acline.getyttabc(); isource = ytt.multiply(vabc_1).add(ytf.multiply(vabc_2)); currinj3phase = currinj3phase.subtract(isource); } } } \/\/todo this needs to be updated if actual values are used in the distribution system double distvabase = this.net.getbasemva()*1.0e6; bus3phase sourcebus3ph = (bus3phase) sourcebus; \/\/ from distribution to transmission complex totalpower = sourcebus3ph.get3phasevotlages().dotproduct(currinj3phase.conjugate()).divide(3.0).multiply(distvabase); return totalpower.multiply(-1.0); }","repo":"GMLC-TDC\/Use-Cases"}
{"id":3528,"comment_id":1,"comment":"\/\/ from distribution to transmission","code":"private complex getfeederloadva(string sourcebusid) { bus3phase sourcebus = (bus3phase) this.net.getbus(sourcebusid); complex3x1 vabc_1 = sourcebus.get3phasevotlages(); complex3x1 currinj3phase = new complex3x1(); for(branch bra: sourcebus.getconnectedphysicalbranchlist()){ if(bra.isactive()){ branch3phase acline = (branch3phase) bra; complex3x1 isource = null; if(bra.getfrombus().getid().equals(sourcebus.getid())){ bus3phase tobus = (bus3phase) bra.gettobus(); complex3x1 vabc_2 = tobus.get3phasevotlages(); complex3x3 yft = acline.getyftabc(); complex3x3 yff = acline.getyffabc(); isource = yff.multiply(vabc_1).add(yft.multiply(vabc_2)); currinj3phase = currinj3phase.subtract(isource ); } else{ bus3phase frombus = (bus3phase) bra.getfrombus(); complex3x1 vabc_2 = frombus.get3phasevotlages(); complex3x3 ytf = acline.getytfabc(); complex3x3 ytt = acline.getyttabc(); isource = ytt.multiply(vabc_1).add(ytf.multiply(vabc_2)); currinj3phase = currinj3phase.subtract(isource); } } } \/\/todo this needs to be updated if actual values are used in the distribution system double distvabase = this.net.getbasemva()*1.0e6; bus3phase sourcebus3ph = (bus3phase) sourcebus; \/\/ from distribution to transmission complex totalpower = sourcebus3ph.get3phasevotlages().dotproduct(currinj3phase.conjugate()).divide(3.0).multiply(distvabase); return totalpower.multiply(-1.0); }","classification":"NONSATD","isFinished":true,"code_context_2":"double distvabase = this.net.getbasemva()*1.0e6; bus3phase sourcebus3ph = (bus3phase) sourcebus; \/\/ from distribution to transmission complex totalpower = sourcebus3ph.get3phasevotlages().dotproduct(currinj3phase.conjugate()).divide(3.0).multiply(distvabase); return totalpower.multiply(-1.0);","code_context_10":"complex3x3 ytf = acline.getytfabc(); complex3x3 ytt = acline.getyttabc(); isource = ytt.multiply(vabc_1).add(ytf.multiply(vabc_2)); currinj3phase = currinj3phase.subtract(isource); } } } \/\/todo this needs to be updated if actual values are used in the distribution system double distvabase = this.net.getbasemva()*1.0e6; bus3phase sourcebus3ph = (bus3phase) sourcebus; \/\/ from distribution to transmission complex totalpower = sourcebus3ph.get3phasevotlages().dotproduct(currinj3phase.conjugate()).divide(3.0).multiply(distvabase); return totalpower.multiply(-1.0); }","code_context_20":"bus3phase tobus = (bus3phase) bra.gettobus(); complex3x1 vabc_2 = tobus.get3phasevotlages(); complex3x3 yft = acline.getyftabc(); complex3x3 yff = acline.getyffabc(); isource = yff.multiply(vabc_1).add(yft.multiply(vabc_2)); currinj3phase = currinj3phase.subtract(isource ); } else{ bus3phase frombus = (bus3phase) bra.getfrombus(); complex3x1 vabc_2 = frombus.get3phasevotlages(); complex3x3 ytf = acline.getytfabc(); complex3x3 ytt = acline.getyttabc(); isource = ytt.multiply(vabc_1).add(ytf.multiply(vabc_2)); currinj3phase = currinj3phase.subtract(isource); } } } \/\/todo this needs to be updated if actual values are used in the distribution system double distvabase = this.net.getbasemva()*1.0e6; bus3phase sourcebus3ph = (bus3phase) sourcebus; \/\/ from distribution to transmission complex totalpower = sourcebus3ph.get3phasevotlages().dotproduct(currinj3phase.conjugate()).divide(3.0).multiply(distvabase); return totalpower.multiply(-1.0); }","repo":"GMLC-TDC\/Use-Cases"}
{"id":11856,"comment_id":0,"comment":"\/\/ @override \/\/ public void apply(object key, offheapinternalcacheentry value) { \/\/ if (filter.shouldloadkey((k)key)) { \/\/ action.apply((k)key, value); \/\/ } \/\/ }","code":"@override public <k> void executetask( final advancedcacheloader.keyfilter<k> filter, final paralleliterablemap.keyvalueaction<object, internalcacheentry> action ) throws interruptedexception{ if (filter == null) throw new illegalargumentexception(\"no filter specified\"); if (action == null) throw new illegalargumentexception(\"no action specified\"); paralleliterablemap<object, internalcacheentry> map = (paralleliterablemap<object, internalcacheentry>) entries; map.foreach(512, new paralleliterablemap.keyvalueaction<object, internalcacheentry>() { @override public void apply(object o, internalcacheentry internalcacheentry) { } \/\/ @override \/\/ public void apply(object key, offheapinternalcacheentry value) { \/\/ if (filter.shouldloadkey((k)key)) { \/\/ action.apply((k)key, value); \/\/ } \/\/ } }); \/\/todo figure out the way how to do interruption better (during iteration) if(thread.currentthread().isinterrupted()){ throw new interruptedexception(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"public void apply(object o, internalcacheentry internalcacheentry) { } \/\/ @override \/\/ public void apply(object key, offheapinternalcacheentry value) { \/\/ if (filter.shouldloadkey((k)key)) { \/\/ action.apply((k)key, value); \/\/ } \/\/ } }); \/\/todo figure out the way how to do interruption better (during iteration)","code_context_10":"if (filter == null) throw new illegalargumentexception(\"no filter specified\"); if (action == null) throw new illegalargumentexception(\"no action specified\"); paralleliterablemap<object, internalcacheentry> map = (paralleliterablemap<object, internalcacheentry>) entries; map.foreach(512, new paralleliterablemap.keyvalueaction<object, internalcacheentry>() { @override public void apply(object o, internalcacheentry internalcacheentry) { } \/\/ @override \/\/ public void apply(object key, offheapinternalcacheentry value) { \/\/ if (filter.shouldloadkey((k)key)) { \/\/ action.apply((k)key, value); \/\/ } \/\/ } }); \/\/todo figure out the way how to do interruption better (during iteration) if(thread.currentthread().isinterrupted()){ throw new interruptedexception(); } }","code_context_20":"@override public <k> void executetask( final advancedcacheloader.keyfilter<k> filter, final paralleliterablemap.keyvalueaction<object, internalcacheentry> action ) throws interruptedexception{ if (filter == null) throw new illegalargumentexception(\"no filter specified\"); if (action == null) throw new illegalargumentexception(\"no action specified\"); paralleliterablemap<object, internalcacheentry> map = (paralleliterablemap<object, internalcacheentry>) entries; map.foreach(512, new paralleliterablemap.keyvalueaction<object, internalcacheentry>() { @override public void apply(object o, internalcacheentry internalcacheentry) { } \/\/ @override \/\/ public void apply(object key, offheapinternalcacheentry value) { \/\/ if (filter.shouldloadkey((k)key)) { \/\/ action.apply((k)key, value); \/\/ } \/\/ } }); \/\/todo figure out the way how to do interruption better (during iteration) if(thread.currentthread().isinterrupted()){ throw new interruptedexception(); } }","repo":"Cotton-Ben\/infinispan"}
{"id":11856,"comment_id":1,"comment":"\/\/todo figure out the way how to do interruption better (during iteration)","code":"@override public <k> void executetask( final advancedcacheloader.keyfilter<k> filter, final paralleliterablemap.keyvalueaction<object, internalcacheentry> action ) throws interruptedexception{ if (filter == null) throw new illegalargumentexception(\"no filter specified\"); if (action == null) throw new illegalargumentexception(\"no action specified\"); paralleliterablemap<object, internalcacheentry> map = (paralleliterablemap<object, internalcacheentry>) entries; map.foreach(512, new paralleliterablemap.keyvalueaction<object, internalcacheentry>() { @override public void apply(object o, internalcacheentry internalcacheentry) { } \/\/ @override \/\/ public void apply(object key, offheapinternalcacheentry value) { \/\/ if (filter.shouldloadkey((k)key)) { \/\/ action.apply((k)key, value); \/\/ } \/\/ } }); \/\/todo figure out the way how to do interruption better (during iteration) if(thread.currentthread().isinterrupted()){ throw new interruptedexception(); } }","classification":"DESIGN","isFinished":true,"code_context_2":"\/\/ } }); \/\/todo figure out the way how to do interruption better (during iteration) if(thread.currentthread().isinterrupted()){ throw new interruptedexception();","code_context_10":"@override public void apply(object o, internalcacheentry internalcacheentry) { } \/\/ @override \/\/ public void apply(object key, offheapinternalcacheentry value) { \/\/ if (filter.shouldloadkey((k)key)) { \/\/ action.apply((k)key, value); \/\/ } \/\/ } }); \/\/todo figure out the way how to do interruption better (during iteration) if(thread.currentthread().isinterrupted()){ throw new interruptedexception(); } }","code_context_20":"final advancedcacheloader.keyfilter<k> filter, final paralleliterablemap.keyvalueaction<object, internalcacheentry> action ) throws interruptedexception{ if (filter == null) throw new illegalargumentexception(\"no filter specified\"); if (action == null) throw new illegalargumentexception(\"no action specified\"); paralleliterablemap<object, internalcacheentry> map = (paralleliterablemap<object, internalcacheentry>) entries; map.foreach(512, new paralleliterablemap.keyvalueaction<object, internalcacheentry>() { @override public void apply(object o, internalcacheentry internalcacheentry) { } \/\/ @override \/\/ public void apply(object key, offheapinternalcacheentry value) { \/\/ if (filter.shouldloadkey((k)key)) { \/\/ action.apply((k)key, value); \/\/ } \/\/ } }); \/\/todo figure out the way how to do interruption better (during iteration) if(thread.currentthread().isinterrupted()){ throw new interruptedexception(); } }","repo":"Cotton-Ben\/infinispan"}
{"id":11891,"comment_id":0,"comment":"\/\/ todo: the max time this can take is actually n * timeout. consider fixing this.","code":"@override public final v get(long timeout, timeunit unit) throws interruptedexception, executionexception, timeoutexception { iterator<integer> indexitr = order.iterator(); v result = initresult(); for (future<k> future : futures) { \/\/ todo: the max time this can take is actually n * timeout. consider fixing this. result = aggregate(future.get(timeout, unit), indexitr, result); } return result; }","classification":"DESIGN","isFinished":true,"code_context_2":"v result = initresult(); for (future<k> future : futures) { \/\/ todo: the max time this can take is actually n * timeout. consider fixing this. result = aggregate(future.get(timeout, unit), indexitr, result); }","code_context_10":"@override public final v get(long timeout, timeunit unit) throws interruptedexception, executionexception, timeoutexception { iterator<integer> indexitr = order.iterator(); v result = initresult(); for (future<k> future : futures) { \/\/ todo: the max time this can take is actually n * timeout. consider fixing this. result = aggregate(future.get(timeout, unit), indexitr, result); } return result; }","code_context_20":"@override public final v get(long timeout, timeunit unit) throws interruptedexception, executionexception, timeoutexception { iterator<integer> indexitr = order.iterator(); v result = initresult(); for (future<k> future : futures) { \/\/ todo: the max time this can take is actually n * timeout. consider fixing this. result = aggregate(future.get(timeout, unit), indexitr, result); } return result; }","repo":"CyberFlameGO\/appengine-java-standard"}
{"id":11905,"comment_id":0,"comment":"\/\/ todo: modlog?","code":"private void processcommands(guildmessagereceivedevent event, guilddata guilddata, string trigger, string[] args, boolean ismention) { icommandmain cmd = cascadebot.ins.getcommandmanager().getcommand(trigger, event.getauthor(), guilddata); if (cmd != null) { if (cmd.getmodule().ispublicmodule() && !guilddata.ismoduleenabled(cmd.getmodule())) { if (guilddata.getsettings().willdisplaymoduleerrors() || environment.isdevelopment()) { embedbuilder builder = messagingobjects.getclearthreadlocalembedbuilder(); builder.setdescription(string.format(\"the module `%s` for command `%s` is disabled!\", cmd.getmodule().tostring(), trigger)); builder.settimestamp(instant.now()); builder.setfooter(\"requested by \" + event.getauthor().getastag(), event.getauthor().geteffectiveavatarurl()); messaging.senddangermessage(event.getchannel(), builder, guilddata.getsettings().useembedformessages()); } \/\/ todo: modlog? return; } commandcontext context = new commandcontext( event.getjda(), event.getchannel(), event.getmessage(), event.getguild(), guilddata, args, event.getmember(), trigger, ismention ); if (args.length >= 1) { if (processsubcommands(cmd, args, context)) { return; } } dispatchcommand(cmd, context); } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"messaging.senddangermessage(event.getchannel(), builder, guilddata.getsettings().useembedformessages()); } \/\/ todo: modlog? return; }","code_context_10":"if (cmd != null) { if (cmd.getmodule().ispublicmodule() && !guilddata.ismoduleenabled(cmd.getmodule())) { if (guilddata.getsettings().willdisplaymoduleerrors() || environment.isdevelopment()) { embedbuilder builder = messagingobjects.getclearthreadlocalembedbuilder(); builder.setdescription(string.format(\"the module `%s` for command `%s` is disabled!\", cmd.getmodule().tostring(), trigger)); builder.settimestamp(instant.now()); builder.setfooter(\"requested by \" + event.getauthor().getastag(), event.getauthor().geteffectiveavatarurl()); messaging.senddangermessage(event.getchannel(), builder, guilddata.getsettings().useembedformessages()); } \/\/ todo: modlog? return; } commandcontext context = new commandcontext( event.getjda(), event.getchannel(), event.getmessage(), event.getguild(), guilddata, args, event.getmember(),","code_context_20":"private void processcommands(guildmessagereceivedevent event, guilddata guilddata, string trigger, string[] args, boolean ismention) { icommandmain cmd = cascadebot.ins.getcommandmanager().getcommand(trigger, event.getauthor(), guilddata); if (cmd != null) { if (cmd.getmodule().ispublicmodule() && !guilddata.ismoduleenabled(cmd.getmodule())) { if (guilddata.getsettings().willdisplaymoduleerrors() || environment.isdevelopment()) { embedbuilder builder = messagingobjects.getclearthreadlocalembedbuilder(); builder.setdescription(string.format(\"the module `%s` for command `%s` is disabled!\", cmd.getmodule().tostring(), trigger)); builder.settimestamp(instant.now()); builder.setfooter(\"requested by \" + event.getauthor().getastag(), event.getauthor().geteffectiveavatarurl()); messaging.senddangermessage(event.getchannel(), builder, guilddata.getsettings().useembedformessages()); } \/\/ todo: modlog? return; } commandcontext context = new commandcontext( event.getjda(), event.getchannel(), event.getmessage(), event.getguild(), guilddata, args, event.getmember(), trigger, ismention ); if (args.length >= 1) { if (processsubcommands(cmd, args, context)) { return; } } dispatchcommand(cmd, context); }","repo":"Ikinon\/CascadeBot"}
{"id":3730,"comment_id":0,"comment":"\/\/ weird implementation of clone() is ok on final classes","code":"\/\/ weird implementation of clone() is ok on final classes @override public mutablelist<t> clone() { return new fastlist<t>(this); }","classification":"DESIGN","isFinished":true,"code_context_2":"@override public mutablelist<t> clone() { return new fastlist<t>(this); }","code_context_10":"@override public mutablelist<t> clone() { return new fastlist<t>(this); }","code_context_20":"@override public mutablelist<t> clone() { return new fastlist<t>(this); }","repo":"DiegoEliasCosta\/gs-collections"}
{"id":3764,"comment_id":0,"comment":"\/\/todo: refatorar","code":"\/\/todo: refatorar @postmapping(\"{id}\/bloqueio\") public responseentity<?> bloquear(httpservletrequest request, @pathvariable string id){ string ip = request.getremoteaddr(); string useragent = request.getheader(httpheaders.user_agent); optional<proposta> possivelproposta = propostarepository.findbynumerocartao(id); if(possivelproposta.isempty()){ logger.info(\"tentativa de bloqueio, cartao: {} n\u00e3o encontrado\", id); return responseentity.notfound().build(); } proposta proposta = possivelproposta.get(); if(proposta.establoqueado()){ logger.info(\"tentativa de bloqueio, cartao: {} j\u00e1 bloqueado\", id); return responseentity.status(httpstatus.unprocessable_entity).build(); } if(!notificarlegado(id)){ return responseentity.status(httpstatus.bad_gateway) .body(map.of(\"message\", \"n\u00e3o foi possivel concluir a a\u00e7\u00e3o, tente mais tarde\")); } proposta.bloquear(ip, useragent); propostarepository.save(proposta); logger.info(\"cart\u00e3o: {} bloqueado com sucesso\", id); return responseentity.ok().build(); }","classification":"DESIGN","isFinished":true,"code_context_2":"@postmapping(\"{id}\/bloqueio\") public responseentity<?> bloquear(httpservletrequest request, @pathvariable string id){ string ip = request.getremoteaddr(); string useragent = request.getheader(httpheaders.user_agent); optional<proposta> possivelproposta = propostarepository.findbynumerocartao(id); if(possivelproposta.isempty()){ logger.info(\"tentativa de bloqueio, cartao: {} n\u00e3o encontrado\", id); return responseentity.notfound().build(); } proposta proposta = possivelproposta.get(); if(proposta.establoqueado()){ logger.info(\"tentativa de bloqueio, cartao: {} j\u00e1 bloqueado\", id); return responseentity.status(httpstatus.unprocessable_entity).build(); } if(!notificarlegado(id)){ return responseentity.status(httpstatus.bad_gateway) .body(map.of(\"message\", \"n\u00e3o foi possivel concluir a a\u00e7\u00e3o, tente mais tarde\")); } proposta.bloquear(ip, useragent); propostarepository.save(proposta); logger.info(\"cart\u00e3o: {} bloqueado com sucesso\", id); return responseentity.ok().build(); }","code_context_10":"@postmapping(\"{id}\/bloqueio\") public responseentity<?> bloquear(httpservletrequest request, @pathvariable string id){ string ip = request.getremoteaddr(); string useragent = request.getheader(httpheaders.user_agent); optional<proposta> possivelproposta = propostarepository.findbynumerocartao(id); if(possivelproposta.isempty()){ logger.info(\"tentativa de bloqueio, cartao: {} n\u00e3o encontrado\", id); return responseentity.notfound().build(); } proposta proposta = possivelproposta.get(); if(proposta.establoqueado()){ logger.info(\"tentativa de bloqueio, cartao: {} j\u00e1 bloqueado\", id); return responseentity.status(httpstatus.unprocessable_entity).build(); } if(!notificarlegado(id)){ return responseentity.status(httpstatus.bad_gateway) .body(map.of(\"message\", \"n\u00e3o foi possivel concluir a a\u00e7\u00e3o, tente mais tarde\")); } proposta.bloquear(ip, useragent); propostarepository.save(proposta); logger.info(\"cart\u00e3o: {} bloqueado com sucesso\", id); return responseentity.ok().build(); }","code_context_20":"@postmapping(\"{id}\/bloqueio\") public responseentity<?> bloquear(httpservletrequest request, @pathvariable string id){ string ip = request.getremoteaddr(); string useragent = request.getheader(httpheaders.user_agent); optional<proposta> possivelproposta = propostarepository.findbynumerocartao(id); if(possivelproposta.isempty()){ logger.info(\"tentativa de bloqueio, cartao: {} n\u00e3o encontrado\", id); return responseentity.notfound().build(); } proposta proposta = possivelproposta.get(); if(proposta.establoqueado()){ logger.info(\"tentativa de bloqueio, cartao: {} j\u00e1 bloqueado\", id); return responseentity.status(httpstatus.unprocessable_entity).build(); } if(!notificarlegado(id)){ return responseentity.status(httpstatus.bad_gateway) .body(map.of(\"message\", \"n\u00e3o foi possivel concluir a a\u00e7\u00e3o, tente mais tarde\")); } proposta.bloquear(ip, useragent); propostarepository.save(proposta); logger.info(\"cart\u00e3o: {} bloqueado com sucesso\", id); return responseentity.ok().build(); }","repo":"EDUMATT3\/orange-talents-06-template-proposta"}
{"id":20267,"comment_id":0,"comment":"\/\/todo: refactor with if\/else","code":"\/\/todo: refactor with if\/else @override public void onclick(view view) { switch (view.getid()) { case r.id.send_to_this_address_action: { if (onsendtoaddressclicklistener != null) { onsendtoaddressclicklistener.onclick(view); } break; } case r.id.add_custom_token_action: { if (onaddcustontokenclicklistener != null) { onaddcustontokenclicklistener.onclick(view); } break; } case r.id.watch_account_action: { if (onwatchwalletclicklistener != null) { onwatchwalletclicklistener.onclick(view); } break; } case r.id.open_in_etherscan_action: { if (onopeninetherscanclicklistener != null) { onopeninetherscanclicklistener.onclick(view); } break; } case r.id.close_action: { if (oncloseactionlistener != null) { oncloseactionlistener.onclick(view); } break; } } }","classification":"DESIGN","isFinished":true,"code_context_2":"@override public void onclick(view view) { switch (view.getid()) { case r.id.send_to_this_address_action: { if (onsendtoaddressclicklistener != null) { onsendtoaddressclicklistener.onclick(view); } break; } case r.id.add_custom_token_action: { if (onaddcustontokenclicklistener != null) { onaddcustontokenclicklistener.onclick(view); } break; } case r.id.watch_account_action: { if (onwatchwalletclicklistener != null) { onwatchwalletclicklistener.onclick(view); } break; } case r.id.open_in_etherscan_action: { if (onopeninetherscanclicklistener != null) { onopeninetherscanclicklistener.onclick(view); } break; } case r.id.close_action: { if (oncloseactionlistener != null) { oncloseactionlistener.onclick(view); } break; } } }","code_context_10":"@override public void onclick(view view) { switch (view.getid()) { case r.id.send_to_this_address_action: { if (onsendtoaddressclicklistener != null) { onsendtoaddressclicklistener.onclick(view); } break; } case r.id.add_custom_token_action: { if (onaddcustontokenclicklistener != null) { onaddcustontokenclicklistener.onclick(view); } break; } case r.id.watch_account_action: { if (onwatchwalletclicklistener != null) { onwatchwalletclicklistener.onclick(view); } break; } case r.id.open_in_etherscan_action: { if (onopeninetherscanclicklistener != null) { onopeninetherscanclicklistener.onclick(view); } break; } case r.id.close_action: { if (oncloseactionlistener != null) { oncloseactionlistener.onclick(view); } break; } } }","code_context_20":"@override public void onclick(view view) { switch (view.getid()) { case r.id.send_to_this_address_action: { if (onsendtoaddressclicklistener != null) { onsendtoaddressclicklistener.onclick(view); } break; } case r.id.add_custom_token_action: { if (onaddcustontokenclicklistener != null) { onaddcustontokenclicklistener.onclick(view); } break; } case r.id.watch_account_action: { if (onwatchwalletclicklistener != null) { onwatchwalletclicklistener.onclick(view); } break; } case r.id.open_in_etherscan_action: { if (onopeninetherscanclicklistener != null) { onopeninetherscanclicklistener.onclick(view); } break; } case r.id.close_action: { if (oncloseactionlistener != null) { oncloseactionlistener.onclick(view); } break; } } }","repo":"HTSUPK\/alpha-wallet-android"}
{"id":20270,"comment_id":0,"comment":"\/\/ spec: 'the receiver must reject the request if the source url is the same as the target url.'","code":"private void processrequest(@notnull httpservletrequest req) throws badrequestexception { if (!expected_content_type.issamemimetype(contenttype.parse(req.getcontenttype()))) { throw new badrequestexception(\"content type must be '%s'.\".formatted(expected_content_type.getmimetype())); } uri source = extractparameterasuri(req, \"source\"); uri target = extractparameterasuri(req, \"target\"); \/\/ spec: 'the receiver must reject the request if the source url is the same as the target url.' if (source.equals(target)) { throw new badrequestexception(\"source and target url must not be identical.\"); } \/\/ todo: allow configuration of allowed target uri hosts. logger.debug(\"received webmention submission request with source='{}' and target='{}'.\", source, target); \/\/ todo: perform check async \/* * spec: * 'if the receiver is going to use the webmention in some way, (displaying it as a comment on a post, * incrementing a \"like\" counter, notifying the author of a post), then it must perform an http get request * on source [...] to confirm that it actually mentions the target. *\/ try { if (verificationservice.issubmissionvalid(httpclient, source, target)) { logger.debug(\"webmention submission request with source='{}' and target='{}' passed verification.\", source, target); } else { throw new badrequestexception(\"source does not contain link to target url.\"); } } catch (ioexception e) { \/\/ in theory i\/o failures cold also be issues on our side (e.g. trusted cas being wrong), but \/\/ differentiating between those and issues on the source uris side (e.g. 404s) seems hard. throw new badrequestexception(\"verification of source url could not be performed.\", e); } catch (verificationservice.unsupportedcontenttypeexception e) { throw new badrequestexception( \"verification of source url failed due to no supported content type being served.\", e); } handlesubmission(source, target); }","classification":"NONSATD","isFinished":true,"code_context_2":"uri source = extractparameterasuri(req, \"source\"); uri target = extractparameterasuri(req, \"target\"); \/\/ spec: 'the receiver must reject the request if the source url is the same as the target url.' if (source.equals(target)) { throw new badrequestexception(\"source and target url must not be identical.\");","code_context_10":"private void processrequest(@notnull httpservletrequest req) throws badrequestexception { if (!expected_content_type.issamemimetype(contenttype.parse(req.getcontenttype()))) { throw new badrequestexception(\"content type must be '%s'.\".formatted(expected_content_type.getmimetype())); } uri source = extractparameterasuri(req, \"source\"); uri target = extractparameterasuri(req, \"target\"); \/\/ spec: 'the receiver must reject the request if the source url is the same as the target url.' if (source.equals(target)) { throw new badrequestexception(\"source and target url must not be identical.\"); } \/\/ todo: allow configuration of allowed target uri hosts. logger.debug(\"received webmention submission request with source='{}' and target='{}'.\", source, target); \/\/ todo: perform check async \/* * spec: * 'if the receiver is going to use the webmention in some way, (displaying it as a comment on a post, * incrementing a \"like\" counter, notifying the author of a post), then it must perform an http get request","code_context_20":"private void processrequest(@notnull httpservletrequest req) throws badrequestexception { if (!expected_content_type.issamemimetype(contenttype.parse(req.getcontenttype()))) { throw new badrequestexception(\"content type must be '%s'.\".formatted(expected_content_type.getmimetype())); } uri source = extractparameterasuri(req, \"source\"); uri target = extractparameterasuri(req, \"target\"); \/\/ spec: 'the receiver must reject the request if the source url is the same as the target url.' if (source.equals(target)) { throw new badrequestexception(\"source and target url must not be identical.\"); } \/\/ todo: allow configuration of allowed target uri hosts. logger.debug(\"received webmention submission request with source='{}' and target='{}'.\", source, target); \/\/ todo: perform check async \/* * spec: * 'if the receiver is going to use the webmention in some way, (displaying it as a comment on a post, * incrementing a \"like\" counter, notifying the author of a post), then it must perform an http get request * on source [...] to confirm that it actually mentions the target. *\/ try { if (verificationservice.issubmissionvalid(httpclient, source, target)) { logger.debug(\"webmention submission request with source='{}' and target='{}' passed verification.\", source, target); } else { throw new badrequestexception(\"source does not contain link to target url.\"); }","repo":"FelixRilling\/webmention4j"}
{"id":20270,"comment_id":1,"comment":"\/\/ todo: allow configuration of allowed target uri hosts.","code":"private void processrequest(@notnull httpservletrequest req) throws badrequestexception { if (!expected_content_type.issamemimetype(contenttype.parse(req.getcontenttype()))) { throw new badrequestexception(\"content type must be '%s'.\".formatted(expected_content_type.getmimetype())); } uri source = extractparameterasuri(req, \"source\"); uri target = extractparameterasuri(req, \"target\"); \/\/ spec: 'the receiver must reject the request if the source url is the same as the target url.' if (source.equals(target)) { throw new badrequestexception(\"source and target url must not be identical.\"); } \/\/ todo: allow configuration of allowed target uri hosts. logger.debug(\"received webmention submission request with source='{}' and target='{}'.\", source, target); \/\/ todo: perform check async \/* * spec: * 'if the receiver is going to use the webmention in some way, (displaying it as a comment on a post, * incrementing a \"like\" counter, notifying the author of a post), then it must perform an http get request * on source [...] to confirm that it actually mentions the target. *\/ try { if (verificationservice.issubmissionvalid(httpclient, source, target)) { logger.debug(\"webmention submission request with source='{}' and target='{}' passed verification.\", source, target); } else { throw new badrequestexception(\"source does not contain link to target url.\"); } } catch (ioexception e) { \/\/ in theory i\/o failures cold also be issues on our side (e.g. trusted cas being wrong), but \/\/ differentiating between those and issues on the source uris side (e.g. 404s) seems hard. throw new badrequestexception(\"verification of source url could not be performed.\", e); } catch (verificationservice.unsupportedcontenttypeexception e) { throw new badrequestexception( \"verification of source url failed due to no supported content type being served.\", e); } handlesubmission(source, target); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"throw new badrequestexception(\"source and target url must not be identical.\"); } \/\/ todo: allow configuration of allowed target uri hosts. logger.debug(\"received webmention submission request with source='{}' and target='{}'.\", source, target); \/\/ todo: perform check async","code_context_10":"private void processrequest(@notnull httpservletrequest req) throws badrequestexception { if (!expected_content_type.issamemimetype(contenttype.parse(req.getcontenttype()))) { throw new badrequestexception(\"content type must be '%s'.\".formatted(expected_content_type.getmimetype())); } uri source = extractparameterasuri(req, \"source\"); uri target = extractparameterasuri(req, \"target\"); \/\/ spec: 'the receiver must reject the request if the source url is the same as the target url.' if (source.equals(target)) { throw new badrequestexception(\"source and target url must not be identical.\"); } \/\/ todo: allow configuration of allowed target uri hosts. logger.debug(\"received webmention submission request with source='{}' and target='{}'.\", source, target); \/\/ todo: perform check async \/* * spec: * 'if the receiver is going to use the webmention in some way, (displaying it as a comment on a post, * incrementing a \"like\" counter, notifying the author of a post), then it must perform an http get request * on source [...] to confirm that it actually mentions the target. *\/ try { if (verificationservice.issubmissionvalid(httpclient, source, target)) {","code_context_20":"private void processrequest(@notnull httpservletrequest req) throws badrequestexception { if (!expected_content_type.issamemimetype(contenttype.parse(req.getcontenttype()))) { throw new badrequestexception(\"content type must be '%s'.\".formatted(expected_content_type.getmimetype())); } uri source = extractparameterasuri(req, \"source\"); uri target = extractparameterasuri(req, \"target\"); \/\/ spec: 'the receiver must reject the request if the source url is the same as the target url.' if (source.equals(target)) { throw new badrequestexception(\"source and target url must not be identical.\"); } \/\/ todo: allow configuration of allowed target uri hosts. logger.debug(\"received webmention submission request with source='{}' and target='{}'.\", source, target); \/\/ todo: perform check async \/* * spec: * 'if the receiver is going to use the webmention in some way, (displaying it as a comment on a post, * incrementing a \"like\" counter, notifying the author of a post), then it must perform an http get request * on source [...] to confirm that it actually mentions the target. *\/ try { if (verificationservice.issubmissionvalid(httpclient, source, target)) { logger.debug(\"webmention submission request with source='{}' and target='{}' passed verification.\", source, target); } else { throw new badrequestexception(\"source does not contain link to target url.\"); } } catch (ioexception e) { \/\/ in theory i\/o failures cold also be issues on our side (e.g. trusted cas being wrong), but \/\/ differentiating between those and issues on the source uris side (e.g. 404s) seems hard. throw new badrequestexception(\"verification of source url could not be performed.\", e);","repo":"FelixRilling\/webmention4j"}
{"id":20270,"comment_id":2,"comment":"\/\/ todo: perform check async \/* * spec: * 'if the receiver is going to use the webmention in some way, (displaying it as a comment on a post, * incrementing a \"like\" counter, notifying the author of a post), then it must perform an http get request * on source [...] to confirm that it actually mentions the target. *\/","code":"private void processrequest(@notnull httpservletrequest req) throws badrequestexception { if (!expected_content_type.issamemimetype(contenttype.parse(req.getcontenttype()))) { throw new badrequestexception(\"content type must be '%s'.\".formatted(expected_content_type.getmimetype())); } uri source = extractparameterasuri(req, \"source\"); uri target = extractparameterasuri(req, \"target\"); \/\/ spec: 'the receiver must reject the request if the source url is the same as the target url.' if (source.equals(target)) { throw new badrequestexception(\"source and target url must not be identical.\"); } \/\/ todo: allow configuration of allowed target uri hosts. logger.debug(\"received webmention submission request with source='{}' and target='{}'.\", source, target); \/\/ todo: perform check async \/* * spec: * 'if the receiver is going to use the webmention in some way, (displaying it as a comment on a post, * incrementing a \"like\" counter, notifying the author of a post), then it must perform an http get request * on source [...] to confirm that it actually mentions the target. *\/ try { if (verificationservice.issubmissionvalid(httpclient, source, target)) { logger.debug(\"webmention submission request with source='{}' and target='{}' passed verification.\", source, target); } else { throw new badrequestexception(\"source does not contain link to target url.\"); } } catch (ioexception e) { \/\/ in theory i\/o failures cold also be issues on our side (e.g. trusted cas being wrong), but \/\/ differentiating between those and issues on the source uris side (e.g. 404s) seems hard. throw new badrequestexception(\"verification of source url could not be performed.\", e); } catch (verificationservice.unsupportedcontenttypeexception e) { throw new badrequestexception( \"verification of source url failed due to no supported content type being served.\", e); } handlesubmission(source, target); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"\/\/ todo: allow configuration of allowed target uri hosts. logger.debug(\"received webmention submission request with source='{}' and target='{}'.\", source, target); \/\/ todo: perform check async \/* * spec: * 'if the receiver is going to use the webmention in some way, (displaying it as a comment on a post, * incrementing a \"like\" counter, notifying the author of a post), then it must perform an http get request * on source [...] to confirm that it actually mentions the target. *\/ try { if (verificationservice.issubmissionvalid(httpclient, source, target)) {","code_context_10":"throw new badrequestexception(\"content type must be '%s'.\".formatted(expected_content_type.getmimetype())); } uri source = extractparameterasuri(req, \"source\"); uri target = extractparameterasuri(req, \"target\"); \/\/ spec: 'the receiver must reject the request if the source url is the same as the target url.' if (source.equals(target)) { throw new badrequestexception(\"source and target url must not be identical.\"); } \/\/ todo: allow configuration of allowed target uri hosts. logger.debug(\"received webmention submission request with source='{}' and target='{}'.\", source, target); \/\/ todo: perform check async \/* * spec: * 'if the receiver is going to use the webmention in some way, (displaying it as a comment on a post, * incrementing a \"like\" counter, notifying the author of a post), then it must perform an http get request * on source [...] to confirm that it actually mentions the target. *\/ try { if (verificationservice.issubmissionvalid(httpclient, source, target)) { logger.debug(\"webmention submission request with source='{}' and target='{}' passed verification.\", source, target); } else { throw new badrequestexception(\"source does not contain link to target url.\"); } } catch (ioexception e) { \/\/ in theory i\/o failures cold also be issues on our side (e.g. trusted cas being wrong), but","code_context_20":"private void processrequest(@notnull httpservletrequest req) throws badrequestexception { if (!expected_content_type.issamemimetype(contenttype.parse(req.getcontenttype()))) { throw new badrequestexception(\"content type must be '%s'.\".formatted(expected_content_type.getmimetype())); } uri source = extractparameterasuri(req, \"source\"); uri target = extractparameterasuri(req, \"target\"); \/\/ spec: 'the receiver must reject the request if the source url is the same as the target url.' if (source.equals(target)) { throw new badrequestexception(\"source and target url must not be identical.\"); } \/\/ todo: allow configuration of allowed target uri hosts. logger.debug(\"received webmention submission request with source='{}' and target='{}'.\", source, target); \/\/ todo: perform check async \/* * spec: * 'if the receiver is going to use the webmention in some way, (displaying it as a comment on a post, * incrementing a \"like\" counter, notifying the author of a post), then it must perform an http get request * on source [...] to confirm that it actually mentions the target. *\/ try { if (verificationservice.issubmissionvalid(httpclient, source, target)) { logger.debug(\"webmention submission request with source='{}' and target='{}' passed verification.\", source, target); } else { throw new badrequestexception(\"source does not contain link to target url.\"); } } catch (ioexception e) { \/\/ in theory i\/o failures cold also be issues on our side (e.g. trusted cas being wrong), but \/\/ differentiating between those and issues on the source uris side (e.g. 404s) seems hard. throw new badrequestexception(\"verification of source url could not be performed.\", e); } catch (verificationservice.unsupportedcontenttypeexception e) { throw new badrequestexception( \"verification of source url failed due to no supported content type being served.\", e); } handlesubmission(source, target); }","repo":"FelixRilling\/webmention4j"}
{"id":20270,"comment_id":3,"comment":"\/\/ in theory i\/o failures cold also be issues on our side (e.g. trusted cas being wrong), but \/\/ differentiating between those and issues on the source uris side (e.g. 404s) seems hard.","code":"private void processrequest(@notnull httpservletrequest req) throws badrequestexception { if (!expected_content_type.issamemimetype(contenttype.parse(req.getcontenttype()))) { throw new badrequestexception(\"content type must be '%s'.\".formatted(expected_content_type.getmimetype())); } uri source = extractparameterasuri(req, \"source\"); uri target = extractparameterasuri(req, \"target\"); \/\/ spec: 'the receiver must reject the request if the source url is the same as the target url.' if (source.equals(target)) { throw new badrequestexception(\"source and target url must not be identical.\"); } \/\/ todo: allow configuration of allowed target uri hosts. logger.debug(\"received webmention submission request with source='{}' and target='{}'.\", source, target); \/\/ todo: perform check async \/* * spec: * 'if the receiver is going to use the webmention in some way, (displaying it as a comment on a post, * incrementing a \"like\" counter, notifying the author of a post), then it must perform an http get request * on source [...] to confirm that it actually mentions the target. *\/ try { if (verificationservice.issubmissionvalid(httpclient, source, target)) { logger.debug(\"webmention submission request with source='{}' and target='{}' passed verification.\", source, target); } else { throw new badrequestexception(\"source does not contain link to target url.\"); } } catch (ioexception e) { \/\/ in theory i\/o failures cold also be issues on our side (e.g. trusted cas being wrong), but \/\/ differentiating between those and issues on the source uris side (e.g. 404s) seems hard. throw new badrequestexception(\"verification of source url could not be performed.\", e); } catch (verificationservice.unsupportedcontenttypeexception e) { throw new badrequestexception( \"verification of source url failed due to no supported content type being served.\", e); } handlesubmission(source, target); }","classification":"DESIGN","isFinished":true,"code_context_2":"} } catch (ioexception e) { \/\/ in theory i\/o failures cold also be issues on our side (e.g. trusted cas being wrong), but \/\/ differentiating between those and issues on the source uris side (e.g. 404s) seems hard. throw new badrequestexception(\"verification of source url could not be performed.\", e); } catch (verificationservice.unsupportedcontenttypeexception e) {","code_context_10":"*\/ try { if (verificationservice.issubmissionvalid(httpclient, source, target)) { logger.debug(\"webmention submission request with source='{}' and target='{}' passed verification.\", source, target); } else { throw new badrequestexception(\"source does not contain link to target url.\"); } } catch (ioexception e) { \/\/ in theory i\/o failures cold also be issues on our side (e.g. trusted cas being wrong), but \/\/ differentiating between those and issues on the source uris side (e.g. 404s) seems hard. throw new badrequestexception(\"verification of source url could not be performed.\", e); } catch (verificationservice.unsupportedcontenttypeexception e) { throw new badrequestexception( \"verification of source url failed due to no supported content type being served.\", e); } handlesubmission(source, target); }","code_context_20":"throw new badrequestexception(\"source and target url must not be identical.\"); } \/\/ todo: allow configuration of allowed target uri hosts. logger.debug(\"received webmention submission request with source='{}' and target='{}'.\", source, target); \/\/ todo: perform check async \/* * spec: * 'if the receiver is going to use the webmention in some way, (displaying it as a comment on a post, * incrementing a \"like\" counter, notifying the author of a post), then it must perform an http get request * on source [...] to confirm that it actually mentions the target. *\/ try { if (verificationservice.issubmissionvalid(httpclient, source, target)) { logger.debug(\"webmention submission request with source='{}' and target='{}' passed verification.\", source, target); } else { throw new badrequestexception(\"source does not contain link to target url.\"); } } catch (ioexception e) { \/\/ in theory i\/o failures cold also be issues on our side (e.g. trusted cas being wrong), but \/\/ differentiating between those and issues on the source uris side (e.g. 404s) seems hard. throw new badrequestexception(\"verification of source url could not be performed.\", e); } catch (verificationservice.unsupportedcontenttypeexception e) { throw new badrequestexception( \"verification of source url failed due to no supported content type being served.\", e); } handlesubmission(source, target); }","repo":"FelixRilling\/webmention4j"}
{"id":20319,"comment_id":0,"comment":"\/\/ hack our routebuilder into the context. bean definition \/ componentscan doesn't work for routebuilders.","code":"@beforeeach public void setup() throws exception { \/\/ hack our routebuilder into the context. bean definition \/ componentscan doesn't work for routebuilders. if (camelcontext.getroute(camelcustomerratingserviceadapter.uri) == null) { camelcontext.addroutes(ccrsadapter); } if (camelcontext.getroute(camelcustomerratingserviceclient.uri) == null) { camelcontext.addroutes(ccrsclient); } }","classification":"DEFECT","isFinished":true,"code_context_2":"@beforeeach public void setup() throws exception { \/\/ hack our routebuilder into the context. bean definition \/ componentscan doesn't work for routebuilders. if (camelcontext.getroute(camelcustomerratingserviceadapter.uri) == null) { camelcontext.addroutes(ccrsadapter);","code_context_10":"@beforeeach public void setup() throws exception { \/\/ hack our routebuilder into the context. bean definition \/ componentscan doesn't work for routebuilders. if (camelcontext.getroute(camelcustomerratingserviceadapter.uri) == null) { camelcontext.addroutes(ccrsadapter); } if (camelcontext.getroute(camelcustomerratingserviceclient.uri) == null) { camelcontext.addroutes(ccrsclient); } }","code_context_20":"@beforeeach public void setup() throws exception { \/\/ hack our routebuilder into the context. bean definition \/ componentscan doesn't work for routebuilders. if (camelcontext.getroute(camelcustomerratingserviceadapter.uri) == null) { camelcontext.addroutes(ccrsadapter); } if (camelcontext.getroute(camelcustomerratingserviceclient.uri) == null) { camelcontext.addroutes(ccrsclient); } }","repo":"BertKoor\/camelCase"}
{"id":20732,"comment_id":0,"comment":"\/** * show the export file dialog and export the current selected task graph using the selected * <code>fileimportexportdecorator.exportworkflow<\/code> method. *\/","code":"\/** * show the export file dialog and export the current selected task graph using the selected * <code>fileimportexportdecorator.exportworkflow<\/code> method. *\/ public static void exporttaskgraph() { final tfilechooser fc = new tfilechooser(export_taskgraph_dir); final fileimportexportdecorator chooser = new fileimportexportdecorator(fc); int result = chooser.showexportdialog(guienv.getapplicationframe()); if (result == tfilechooser.approve_option) { thread thread = new thread() { public void run() { trianaprogressbar pb = null; string filename = \"\"; try { \/\/ bug fix for not picking up file name text. if (fc.getui() instanceof basicfilechooserui) { filename = ((basicfilechooserui) fc.getui()).getfilename(); } pb = new trianaprogressbar(\"exporting: \" + filename, false); chooser.exportworkflow(guienv.getapplicationframe().getselectedtaskgraphpanel().gettaskgraph()); } catch (ioexception e) { errordialog.show(\"error exporting taskgraph\", e.getmessage()); e.printstacktrace(); } catch (taskgraphexception e) { errordialog.show(\"error exporting taskgraph\", e.getmessage()); e.printstacktrace(); } finally { if (pb != null) { pb.disposeprogressbar(); } } } }; thread.setname(\"export task graph\"); thread.setpriority(thread.norm_priority); thread.start(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"public static void exporttaskgraph() { final tfilechooser fc = new tfilechooser(export_taskgraph_dir); final fileimportexportdecorator chooser = new fileimportexportdecorator(fc); int result = chooser.showexportdialog(guienv.getapplicationframe()); if (result == tfilechooser.approve_option) { thread thread = new thread() { public void run() { trianaprogressbar pb = null; string filename = \"\"; try { \/\/ bug fix for not picking up file name text. if (fc.getui() instanceof basicfilechooserui) { filename = ((basicfilechooserui) fc.getui()).getfilename(); } pb = new trianaprogressbar(\"exporting: \" + filename, false); chooser.exportworkflow(guienv.getapplicationframe().getselectedtaskgraphpanel().gettaskgraph()); } catch (ioexception e) { errordialog.show(\"error exporting taskgraph\", e.getmessage()); e.printstacktrace(); } catch (taskgraphexception e) { errordialog.show(\"error exporting taskgraph\", e.getmessage()); e.printstacktrace(); } finally { if (pb != null) { pb.disposeprogressbar(); } } } }; thread.setname(\"export task graph\"); thread.setpriority(thread.norm_priority); thread.start(); } }","code_context_10":"public static void exporttaskgraph() { final tfilechooser fc = new tfilechooser(export_taskgraph_dir); final fileimportexportdecorator chooser = new fileimportexportdecorator(fc); int result = chooser.showexportdialog(guienv.getapplicationframe()); if (result == tfilechooser.approve_option) { thread thread = new thread() { public void run() { trianaprogressbar pb = null; string filename = \"\"; try { \/\/ bug fix for not picking up file name text. if (fc.getui() instanceof basicfilechooserui) { filename = ((basicfilechooserui) fc.getui()).getfilename(); } pb = new trianaprogressbar(\"exporting: \" + filename, false); chooser.exportworkflow(guienv.getapplicationframe().getselectedtaskgraphpanel().gettaskgraph()); } catch (ioexception e) { errordialog.show(\"error exporting taskgraph\", e.getmessage()); e.printstacktrace(); } catch (taskgraphexception e) { errordialog.show(\"error exporting taskgraph\", e.getmessage()); e.printstacktrace(); } finally { if (pb != null) { pb.disposeprogressbar(); } } } }; thread.setname(\"export task graph\"); thread.setpriority(thread.norm_priority); thread.start(); } }","code_context_20":"public static void exporttaskgraph() { final tfilechooser fc = new tfilechooser(export_taskgraph_dir); final fileimportexportdecorator chooser = new fileimportexportdecorator(fc); int result = chooser.showexportdialog(guienv.getapplicationframe()); if (result == tfilechooser.approve_option) { thread thread = new thread() { public void run() { trianaprogressbar pb = null; string filename = \"\"; try { \/\/ bug fix for not picking up file name text. if (fc.getui() instanceof basicfilechooserui) { filename = ((basicfilechooserui) fc.getui()).getfilename(); } pb = new trianaprogressbar(\"exporting: \" + filename, false); chooser.exportworkflow(guienv.getapplicationframe().getselectedtaskgraphpanel().gettaskgraph()); } catch (ioexception e) { errordialog.show(\"error exporting taskgraph\", e.getmessage()); e.printstacktrace(); } catch (taskgraphexception e) { errordialog.show(\"error exporting taskgraph\", e.getmessage()); e.printstacktrace(); } finally { if (pb != null) { pb.disposeprogressbar(); } } } }; thread.setname(\"export task graph\"); thread.setpriority(thread.norm_priority); thread.start(); } }","repo":"CSCSI\/Triana"}
{"id":20732,"comment_id":1,"comment":"\/\/ bug fix for not picking up file name text.","code":"public static void exporttaskgraph() { final tfilechooser fc = new tfilechooser(export_taskgraph_dir); final fileimportexportdecorator chooser = new fileimportexportdecorator(fc); int result = chooser.showexportdialog(guienv.getapplicationframe()); if (result == tfilechooser.approve_option) { thread thread = new thread() { public void run() { trianaprogressbar pb = null; string filename = \"\"; try { \/\/ bug fix for not picking up file name text. if (fc.getui() instanceof basicfilechooserui) { filename = ((basicfilechooserui) fc.getui()).getfilename(); } pb = new trianaprogressbar(\"exporting: \" + filename, false); chooser.exportworkflow(guienv.getapplicationframe().getselectedtaskgraphpanel().gettaskgraph()); } catch (ioexception e) { errordialog.show(\"error exporting taskgraph\", e.getmessage()); e.printstacktrace(); } catch (taskgraphexception e) { errordialog.show(\"error exporting taskgraph\", e.getmessage()); e.printstacktrace(); } finally { if (pb != null) { pb.disposeprogressbar(); } } } }; thread.setname(\"export task graph\"); thread.setpriority(thread.norm_priority); thread.start(); } }","classification":"DEFECT","isFinished":true,"code_context_2":"string filename = \"\"; try { \/\/ bug fix for not picking up file name text. if (fc.getui() instanceof basicfilechooserui) { filename = ((basicfilechooserui) fc.getui()).getfilename();","code_context_10":"public static void exporttaskgraph() { final tfilechooser fc = new tfilechooser(export_taskgraph_dir); final fileimportexportdecorator chooser = new fileimportexportdecorator(fc); int result = chooser.showexportdialog(guienv.getapplicationframe()); if (result == tfilechooser.approve_option) { thread thread = new thread() { public void run() { trianaprogressbar pb = null; string filename = \"\"; try { \/\/ bug fix for not picking up file name text. if (fc.getui() instanceof basicfilechooserui) { filename = ((basicfilechooserui) fc.getui()).getfilename(); } pb = new trianaprogressbar(\"exporting: \" + filename, false); chooser.exportworkflow(guienv.getapplicationframe().getselectedtaskgraphpanel().gettaskgraph()); } catch (ioexception e) { errordialog.show(\"error exporting taskgraph\", e.getmessage()); e.printstacktrace(); } catch (taskgraphexception e) { errordialog.show(\"error exporting taskgraph\", e.getmessage());","code_context_20":"public static void exporttaskgraph() { final tfilechooser fc = new tfilechooser(export_taskgraph_dir); final fileimportexportdecorator chooser = new fileimportexportdecorator(fc); int result = chooser.showexportdialog(guienv.getapplicationframe()); if (result == tfilechooser.approve_option) { thread thread = new thread() { public void run() { trianaprogressbar pb = null; string filename = \"\"; try { \/\/ bug fix for not picking up file name text. if (fc.getui() instanceof basicfilechooserui) { filename = ((basicfilechooserui) fc.getui()).getfilename(); } pb = new trianaprogressbar(\"exporting: \" + filename, false); chooser.exportworkflow(guienv.getapplicationframe().getselectedtaskgraphpanel().gettaskgraph()); } catch (ioexception e) { errordialog.show(\"error exporting taskgraph\", e.getmessage()); e.printstacktrace(); } catch (taskgraphexception e) { errordialog.show(\"error exporting taskgraph\", e.getmessage()); e.printstacktrace(); } finally { if (pb != null) { pb.disposeprogressbar(); } } } }; thread.setname(\"export task graph\"); thread.setpriority(thread.norm_priority);","repo":"CSCSI\/Triana"}
{"id":20999,"comment_id":0,"comment":"\/\/ todo: cleanup the clientrequests after the requests are completed","code":"@override public kvmessage putkv(final int clientport, final string key, final string value) throws invalidmessageexception { logger.info(clientport + \"> put for key=\" + key + \" value=\" + value); kvmessage res; statustype putstat; \/\/ todo: cleanup the clientrequests after the requests are completed clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() { @override public void run() { logger.info(clientport + \"> starting pruning thread\"); do { \/\/ logger.debug(\"prune waiting\"); } while (!clientrequests.get(key).isempty()); clientrequests.remove(key); if (cache != null) { cache.remove(key); } file file = new file(storagedirectory + key); file.delete(); logger.info(clientport + \"> \" + key + \" successfully pruned\"); } }; clientrequests.get(key).startpruning(prunedelete); } else { logger.info(clientport + \"> key does not exist - marked for deletion!\"); putstat = statustype.delete_error; } } catch (exception e) { logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error; } } else { \/\/ insert\/update the key logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close(); \/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000); } catch (exception e) { logger.error(e); exceptionlogger(e); putstat = statustype.put_error; } } \/\/ remove the top item from the list for this key removetopqueue(key); logger.info(clientport + \"> !!!!===removing from queue===!!!!\"); try { res = new kvmessage(key, value, putstat); } catch (invalidmessageexception ime) { throw ime; } return res; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"kvmessage res; statustype putstat; \/\/ todo: cleanup the clientrequests after the requests are completed clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write;","code_context_10":"@override public kvmessage putkv(final int clientport, final string key, final string value) throws invalidmessageexception { logger.info(clientport + \"> put for key=\" + key + \" value=\" + value); kvmessage res; statustype putstat; \/\/ todo: cleanup the clientrequests after the requests are completed clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\");","code_context_20":"@override public kvmessage putkv(final int clientport, final string key, final string value) throws invalidmessageexception { logger.info(clientport + \"> put for key=\" + key + \" value=\" + value); kvmessage res; statustype putstat; \/\/ todo: cleanup the clientrequests after the requests are completed clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) {","repo":"CAPIndustries\/capDB"}
{"id":20999,"comment_id":1,"comment":"\/\/ add thread to back of list for this key - add is thread safe","code":"@override public kvmessage putkv(final int clientport, final string key, final string value) throws invalidmessageexception { logger.info(clientport + \"> put for key=\" + key + \" value=\" + value); kvmessage res; statustype putstat; \/\/ todo: cleanup the clientrequests after the requests are completed clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() { @override public void run() { logger.info(clientport + \"> starting pruning thread\"); do { \/\/ logger.debug(\"prune waiting\"); } while (!clientrequests.get(key).isempty()); clientrequests.remove(key); if (cache != null) { cache.remove(key); } file file = new file(storagedirectory + key); file.delete(); logger.info(clientport + \"> \" + key + \" successfully pruned\"); } }; clientrequests.get(key).startpruning(prunedelete); } else { logger.info(clientport + \"> key does not exist - marked for deletion!\"); putstat = statustype.delete_error; } } catch (exception e) { logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error; } } else { \/\/ insert\/update the key logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close(); \/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000); } catch (exception e) { logger.error(e); exceptionlogger(e); putstat = statustype.put_error; } } \/\/ remove the top item from the list for this key removetopqueue(key); logger.info(clientport + \"> !!!!===removing from queue===!!!!\"); try { res = new kvmessage(key, value, putstat); } catch (invalidmessageexception ime) { throw ime; } return res; }","classification":"NONSATD","isFinished":true,"code_context_2":"clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node);","code_context_10":"@override public kvmessage putkv(final int clientport, final string key, final string value) throws invalidmessageexception { logger.info(clientport + \"> put for key=\" + key + \" value=\" + value); kvmessage res; statustype putstat; \/\/ todo: cleanup the clientrequests after the requests are completed clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer","code_context_20":"@override public kvmessage putkv(final int clientport, final string key, final string value) throws invalidmessageexception { logger.info(clientport + \"> put for key=\" + key + \" value=\" + value); kvmessage res; statustype putstat; \/\/ todo: cleanup the clientrequests after the requests are completed clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success;","repo":"CAPIndustries\/capDB"}
{"id":20999,"comment_id":2,"comment":"\/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work","code":"@override public kvmessage putkv(final int clientport, final string key, final string value) throws invalidmessageexception { logger.info(clientport + \"> put for key=\" + key + \" value=\" + value); kvmessage res; statustype putstat; \/\/ todo: cleanup the clientrequests after the requests are completed clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() { @override public void run() { logger.info(clientport + \"> starting pruning thread\"); do { \/\/ logger.debug(\"prune waiting\"); } while (!clientrequests.get(key).isempty()); clientrequests.remove(key); if (cache != null) { cache.remove(key); } file file = new file(storagedirectory + key); file.delete(); logger.info(clientport + \"> \" + key + \" successfully pruned\"); } }; clientrequests.get(key).startpruning(prunedelete); } else { logger.info(clientport + \"> key does not exist - marked for deletion!\"); putstat = statustype.delete_error; } } catch (exception e) { logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error; } } else { \/\/ insert\/update the key logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close(); \/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000); } catch (exception e) { logger.error(e); exceptionlogger(e); putstat = statustype.put_error; } } \/\/ remove the top item from the list for this key removetopqueue(key); logger.info(clientport + \"> !!!!===removing from queue===!!!!\"); try { res = new kvmessage(key, value, putstat); } catch (invalidmessageexception ime) { throw ime; } return res; }","classification":"DESIGN","isFinished":true,"code_context_2":"logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ;","code_context_10":"nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try {","code_context_20":"@override public kvmessage putkv(final int clientport, final string key, final string value) throws invalidmessageexception { logger.info(clientport + \"> put for key=\" + key + \" value=\" + value); kvmessage res; statustype putstat; \/\/ todo: cleanup the clientrequests after the requests are completed clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key","repo":"CAPIndustries\/capDB"}
{"id":20999,"comment_id":3,"comment":"\/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads);","code":"@override public kvmessage putkv(final int clientport, final string key, final string value) throws invalidmessageexception { logger.info(clientport + \"> put for key=\" + key + \" value=\" + value); kvmessage res; statustype putstat; \/\/ todo: cleanup the clientrequests after the requests are completed clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() { @override public void run() { logger.info(clientport + \"> starting pruning thread\"); do { \/\/ logger.debug(\"prune waiting\"); } while (!clientrequests.get(key).isempty()); clientrequests.remove(key); if (cache != null) { cache.remove(key); } file file = new file(storagedirectory + key); file.delete(); logger.info(clientport + \"> \" + key + \" successfully pruned\"); } }; clientrequests.get(key).startpruning(prunedelete); } else { logger.info(clientport + \"> key does not exist - marked for deletion!\"); putstat = statustype.delete_error; } } catch (exception e) { logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error; } } else { \/\/ insert\/update the key logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close(); \/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000); } catch (exception e) { logger.error(e); exceptionlogger(e); putstat = statustype.put_error; } } \/\/ remove the top item from the list for this key removetopqueue(key); logger.info(clientport + \"> !!!!===removing from queue===!!!!\"); try { res = new kvmessage(key, value, putstat); } catch (invalidmessageexception ime) { throw ime; } return res; }","classification":"NONSATD","isFinished":true,"code_context_2":"while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) {","code_context_10":"logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to","code_context_20":"logger.info(clientport + \"> put for key=\" + key + \" value=\" + value); kvmessage res; statustype putstat; \/\/ todo: cleanup the clientrequests after the requests are completed clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) {","repo":"CAPIndustries\/capDB"}
{"id":20999,"comment_id":4,"comment":"\/\/ delete the key","code":"@override public kvmessage putkv(final int clientport, final string key, final string value) throws invalidmessageexception { logger.info(clientport + \"> put for key=\" + key + \" value=\" + value); kvmessage res; statustype putstat; \/\/ todo: cleanup the clientrequests after the requests are completed clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() { @override public void run() { logger.info(clientport + \"> starting pruning thread\"); do { \/\/ logger.debug(\"prune waiting\"); } while (!clientrequests.get(key).isempty()); clientrequests.remove(key); if (cache != null) { cache.remove(key); } file file = new file(storagedirectory + key); file.delete(); logger.info(clientport + \"> \" + key + \" successfully pruned\"); } }; clientrequests.get(key).startpruning(prunedelete); } else { logger.info(clientport + \"> key does not exist - marked for deletion!\"); putstat = statustype.delete_error; } } catch (exception e) { logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error; } } else { \/\/ insert\/update the key logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close(); \/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000); } catch (exception e) { logger.error(e); exceptionlogger(e); putstat = statustype.put_error; } } \/\/ remove the top item from the list for this key removetopqueue(key); logger.info(clientport + \"> !!!!===removing from queue===!!!!\"); try { res = new kvmessage(key, value, putstat); } catch (invalidmessageexception ime) { throw ime; } return res; }","classification":"NONSATD","isFinished":true,"code_context_2":"logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success;","code_context_10":"} \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then","code_context_20":"clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() {","repo":"CAPIndustries\/capDB"}
{"id":20999,"comment_id":5,"comment":"\/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key","code":"@override public kvmessage putkv(final int clientport, final string key, final string value) throws invalidmessageexception { logger.info(clientport + \"> put for key=\" + key + \" value=\" + value); kvmessage res; statustype putstat; \/\/ todo: cleanup the clientrequests after the requests are completed clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() { @override public void run() { logger.info(clientport + \"> starting pruning thread\"); do { \/\/ logger.debug(\"prune waiting\"); } while (!clientrequests.get(key).isempty()); clientrequests.remove(key); if (cache != null) { cache.remove(key); } file file = new file(storagedirectory + key); file.delete(); logger.info(clientport + \"> \" + key + \" successfully pruned\"); } }; clientrequests.get(key).startpruning(prunedelete); } else { logger.info(clientport + \"> key does not exist - marked for deletion!\"); putstat = statustype.delete_error; } } catch (exception e) { logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error; } } else { \/\/ insert\/update the key logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close(); \/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000); } catch (exception e) { logger.error(e); exceptionlogger(e); putstat = statustype.put_error; } } \/\/ remove the top item from the list for this key removetopqueue(key); logger.info(clientport + \"> !!!!===removing from queue===!!!!\"); try { res = new kvmessage(key, value, putstat); } catch (invalidmessageexception ime) { throw ime; } return res; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\");","code_context_10":"while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() { @override public void run() { logger.info(clientport + \"> starting pruning thread\");","code_context_20":"clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() { @override public void run() { logger.info(clientport + \"> starting pruning thread\"); do { \/\/ logger.debug(\"prune waiting\"); } while (!clientrequests.get(key).isempty()); clientrequests.remove(key); if (cache != null) { cache.remove(key); } file file = new file(storagedirectory + key); file.delete(); logger.info(clientport + \"> \" + key + \" successfully pruned\");","repo":"CAPIndustries\/capDB"}
{"id":20999,"comment_id":6,"comment":"\/\/ logger.debug(\"prune waiting\");","code":"@override public kvmessage putkv(final int clientport, final string key, final string value) throws invalidmessageexception { logger.info(clientport + \"> put for key=\" + key + \" value=\" + value); kvmessage res; statustype putstat; \/\/ todo: cleanup the clientrequests after the requests are completed clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() { @override public void run() { logger.info(clientport + \"> starting pruning thread\"); do { \/\/ logger.debug(\"prune waiting\"); } while (!clientrequests.get(key).isempty()); clientrequests.remove(key); if (cache != null) { cache.remove(key); } file file = new file(storagedirectory + key); file.delete(); logger.info(clientport + \"> \" + key + \" successfully pruned\"); } }; clientrequests.get(key).startpruning(prunedelete); } else { logger.info(clientport + \"> key does not exist - marked for deletion!\"); putstat = statustype.delete_error; } } catch (exception e) { logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error; } } else { \/\/ insert\/update the key logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close(); \/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000); } catch (exception e) { logger.error(e); exceptionlogger(e); putstat = statustype.put_error; } } \/\/ remove the top item from the list for this key removetopqueue(key); logger.info(clientport + \"> !!!!===removing from queue===!!!!\"); try { res = new kvmessage(key, value, putstat); } catch (invalidmessageexception ime) { throw ime; } return res; }","classification":"NONSATD","isFinished":true,"code_context_2":"logger.info(clientport + \"> starting pruning thread\"); do { \/\/ logger.debug(\"prune waiting\"); } while (!clientrequests.get(key).isempty()); clientrequests.remove(key);","code_context_10":"logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() { @override public void run() { logger.info(clientport + \"> starting pruning thread\"); do { \/\/ logger.debug(\"prune waiting\"); } while (!clientrequests.get(key).isempty()); clientrequests.remove(key); if (cache != null) { cache.remove(key); } file file = new file(storagedirectory + key); file.delete(); logger.info(clientport + \"> \" + key + \" successfully pruned\"); } };","code_context_20":"\/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() { @override public void run() { logger.info(clientport + \"> starting pruning thread\"); do { \/\/ logger.debug(\"prune waiting\"); } while (!clientrequests.get(key).isempty()); clientrequests.remove(key); if (cache != null) { cache.remove(key); } file file = new file(storagedirectory + key); file.delete(); logger.info(clientport + \"> \" + key + \" successfully pruned\"); } }; clientrequests.get(key).startpruning(prunedelete); } else { logger.info(clientport + \"> key does not exist - marked for deletion!\"); putstat = statustype.delete_error; } } catch (exception e) { logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error;","repo":"CAPIndustries\/capDB"}
{"id":20999,"comment_id":7,"comment":"\/\/ insert\/update the key","code":"@override public kvmessage putkv(final int clientport, final string key, final string value) throws invalidmessageexception { logger.info(clientport + \"> put for key=\" + key + \" value=\" + value); kvmessage res; statustype putstat; \/\/ todo: cleanup the clientrequests after the requests are completed clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() { @override public void run() { logger.info(clientport + \"> starting pruning thread\"); do { \/\/ logger.debug(\"prune waiting\"); } while (!clientrequests.get(key).isempty()); clientrequests.remove(key); if (cache != null) { cache.remove(key); } file file = new file(storagedirectory + key); file.delete(); logger.info(clientport + \"> \" + key + \" successfully pruned\"); } }; clientrequests.get(key).startpruning(prunedelete); } else { logger.info(clientport + \"> key does not exist - marked for deletion!\"); putstat = statustype.delete_error; } } catch (exception e) { logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error; } } else { \/\/ insert\/update the key logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close(); \/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000); } catch (exception e) { logger.error(e); exceptionlogger(e); putstat = statustype.put_error; } } \/\/ remove the top item from the list for this key removetopqueue(key); logger.info(clientport + \"> !!!!===removing from queue===!!!!\"); try { res = new kvmessage(key, value, putstat); } catch (invalidmessageexception ime) { throw ime; } return res; }","classification":"NONSATD","isFinished":true,"code_context_2":"} } else { \/\/ insert\/update the key logger.info(clientport + \"> trying to insert\/update record\"); try {","code_context_10":"logger.info(clientport + \"> key does not exist - marked for deletion!\"); putstat = statustype.delete_error; } } catch (exception e) { logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error; } } else { \/\/ insert\/update the key logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update;","code_context_20":"if (cache != null) { cache.remove(key); } file file = new file(storagedirectory + key); file.delete(); logger.info(clientport + \"> \" + key + \" successfully pruned\"); } }; clientrequests.get(key).startpruning(prunedelete); } else { logger.info(clientport + \"> key does not exist - marked for deletion!\"); putstat = statustype.delete_error; } } catch (exception e) { logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error; } } else { \/\/ insert\/update the key logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close();","repo":"CAPIndustries\/capDB"}
{"id":20999,"comment_id":8,"comment":"\/\/ inserting a new key","code":"@override public kvmessage putkv(final int clientport, final string key, final string value) throws invalidmessageexception { logger.info(clientport + \"> put for key=\" + key + \" value=\" + value); kvmessage res; statustype putstat; \/\/ todo: cleanup the clientrequests after the requests are completed clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() { @override public void run() { logger.info(clientport + \"> starting pruning thread\"); do { \/\/ logger.debug(\"prune waiting\"); } while (!clientrequests.get(key).isempty()); clientrequests.remove(key); if (cache != null) { cache.remove(key); } file file = new file(storagedirectory + key); file.delete(); logger.info(clientport + \"> \" + key + \" successfully pruned\"); } }; clientrequests.get(key).startpruning(prunedelete); } else { logger.info(clientport + \"> key does not exist - marked for deletion!\"); putstat = statustype.delete_error; } } catch (exception e) { logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error; } } else { \/\/ insert\/update the key logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close(); \/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000); } catch (exception e) { logger.error(e); exceptionlogger(e); putstat = statustype.put_error; } } \/\/ remove the top item from the list for this key removetopqueue(key); logger.info(clientport + \"> !!!!===removing from queue===!!!!\"); try { res = new kvmessage(key, value, putstat); } catch (invalidmessageexception ime) { throw ime; } return res; }","classification":"NONSATD","isFinished":true,"code_context_2":"try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success;","code_context_10":"logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error; } } else { \/\/ insert\/update the key logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false);","code_context_20":"file.delete(); logger.info(clientport + \"> \" + key + \" successfully pruned\"); } }; clientrequests.get(key).startpruning(prunedelete); } else { logger.info(clientport + \"> key does not exist - marked for deletion!\"); putstat = statustype.delete_error; } } catch (exception e) { logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error; } } else { \/\/ insert\/update the key logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close(); \/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000); } catch (exception e) { logger.error(e);","repo":"CAPIndustries\/capDB"}
{"id":20999,"comment_id":9,"comment":"\/\/ updating a key","code":"@override public kvmessage putkv(final int clientport, final string key, final string value) throws invalidmessageexception { logger.info(clientport + \"> put for key=\" + key + \" value=\" + value); kvmessage res; statustype putstat; \/\/ todo: cleanup the clientrequests after the requests are completed clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() { @override public void run() { logger.info(clientport + \"> starting pruning thread\"); do { \/\/ logger.debug(\"prune waiting\"); } while (!clientrequests.get(key).isempty()); clientrequests.remove(key); if (cache != null) { cache.remove(key); } file file = new file(storagedirectory + key); file.delete(); logger.info(clientport + \"> \" + key + \" successfully pruned\"); } }; clientrequests.get(key).startpruning(prunedelete); } else { logger.info(clientport + \"> key does not exist - marked for deletion!\"); putstat = statustype.delete_error; } } catch (exception e) { logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error; } } else { \/\/ insert\/update the key logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close(); \/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000); } catch (exception e) { logger.error(e); exceptionlogger(e); putstat = statustype.put_error; } } \/\/ remove the top item from the list for this key removetopqueue(key); logger.info(clientport + \"> !!!!===removing from queue===!!!!\"); try { res = new kvmessage(key, value, putstat); } catch (invalidmessageexception ime) { throw ime; } return res; }","classification":"NONSATD","isFinished":true,"code_context_2":"putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update;","code_context_10":"} } else { \/\/ insert\/update the key logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key);","code_context_20":"clientrequests.get(key).startpruning(prunedelete); } else { logger.info(clientport + \"> key does not exist - marked for deletion!\"); putstat = statustype.delete_error; } } catch (exception e) { logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error; } } else { \/\/ insert\/update the key logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close(); \/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000); } catch (exception e) { logger.error(e); exceptionlogger(e); putstat = statustype.put_error; } }","repo":"CAPIndustries\/capDB"}
{"id":20999,"comment_id":10,"comment":"\/\/ stop the deletion","code":"@override public kvmessage putkv(final int clientport, final string key, final string value) throws invalidmessageexception { logger.info(clientport + \"> put for key=\" + key + \" value=\" + value); kvmessage res; statustype putstat; \/\/ todo: cleanup the clientrequests after the requests are completed clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() { @override public void run() { logger.info(clientport + \"> starting pruning thread\"); do { \/\/ logger.debug(\"prune waiting\"); } while (!clientrequests.get(key).isempty()); clientrequests.remove(key); if (cache != null) { cache.remove(key); } file file = new file(storagedirectory + key); file.delete(); logger.info(clientport + \"> \" + key + \" successfully pruned\"); } }; clientrequests.get(key).startpruning(prunedelete); } else { logger.info(clientport + \"> key does not exist - marked for deletion!\"); putstat = statustype.delete_error; } } catch (exception e) { logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error; } } else { \/\/ insert\/update the key logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close(); \/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000); } catch (exception e) { logger.error(e); exceptionlogger(e); putstat = statustype.put_error; } } \/\/ remove the top item from the list for this key removetopqueue(key); logger.info(clientport + \"> !!!!===removing from queue===!!!!\"); try { res = new kvmessage(key, value, putstat); } catch (invalidmessageexception ime) { throw ime; } return res; }","classification":"NONSATD","isFinished":true,"code_context_2":"putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false);","code_context_10":"try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close(); \/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000);","code_context_20":"} } catch (exception e) { logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error; } } else { \/\/ insert\/update the key logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close(); \/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000); } catch (exception e) { logger.error(e); exceptionlogger(e); putstat = statustype.put_error; } } \/\/ remove the top item from the list for this key removetopqueue(key); logger.info(clientport + \"> !!!!===removing from queue===!!!!\"); try {","repo":"CAPIndustries\/capDB"}
{"id":20999,"comment_id":11,"comment":"\/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000);","code":"@override public kvmessage putkv(final int clientport, final string key, final string value) throws invalidmessageexception { logger.info(clientport + \"> put for key=\" + key + \" value=\" + value); kvmessage res; statustype putstat; \/\/ todo: cleanup the clientrequests after the requests are completed clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() { @override public void run() { logger.info(clientport + \"> starting pruning thread\"); do { \/\/ logger.debug(\"prune waiting\"); } while (!clientrequests.get(key).isempty()); clientrequests.remove(key); if (cache != null) { cache.remove(key); } file file = new file(storagedirectory + key); file.delete(); logger.info(clientport + \"> \" + key + \" successfully pruned\"); } }; clientrequests.get(key).startpruning(prunedelete); } else { logger.info(clientport + \"> key does not exist - marked for deletion!\"); putstat = statustype.delete_error; } } catch (exception e) { logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error; } } else { \/\/ insert\/update the key logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close(); \/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000); } catch (exception e) { logger.error(e); exceptionlogger(e); putstat = statustype.put_error; } } \/\/ remove the top item from the list for this key removetopqueue(key); logger.info(clientport + \"> !!!!===removing from queue===!!!!\"); try { res = new kvmessage(key, value, putstat); } catch (invalidmessageexception ime) { throw ime; } return res; }","classification":"NONSATD","isFinished":true,"code_context_2":"mywriter.write(value); mywriter.close(); \/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000); } catch (exception e) { logger.error(e);","code_context_10":"if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close(); \/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000); } catch (exception e) { logger.error(e); exceptionlogger(e); putstat = statustype.put_error; } } \/\/ remove the top item from the list for this key removetopqueue(key); logger.info(clientport + \"> !!!!===removing from queue===!!!!\"); try {","code_context_20":"logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close(); \/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000); } catch (exception e) { logger.error(e); exceptionlogger(e); putstat = statustype.put_error; } } \/\/ remove the top item from the list for this key removetopqueue(key); logger.info(clientport + \"> !!!!===removing from queue===!!!!\"); try { res = new kvmessage(key, value, putstat); } catch (invalidmessageexception ime) { throw ime; } return res; }","repo":"CAPIndustries\/capDB"}
{"id":20999,"comment_id":12,"comment":"\/\/ remove the top item from the list for this key","code":"@override public kvmessage putkv(final int clientport, final string key, final string value) throws invalidmessageexception { logger.info(clientport + \"> put for key=\" + key + \" value=\" + value); kvmessage res; statustype putstat; \/\/ todo: cleanup the clientrequests after the requests are completed clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; \/\/ add thread to back of list for this key - add is thread safe int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } \/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() { @override public void run() { logger.info(clientport + \"> starting pruning thread\"); do { \/\/ logger.debug(\"prune waiting\"); } while (!clientrequests.get(key).isempty()); clientrequests.remove(key); if (cache != null) { cache.remove(key); } file file = new file(storagedirectory + key); file.delete(); logger.info(clientport + \"> \" + key + \" successfully pruned\"); } }; clientrequests.get(key).startpruning(prunedelete); } else { logger.info(clientport + \"> key does not exist - marked for deletion!\"); putstat = statustype.delete_error; } } catch (exception e) { logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error; } } else { \/\/ insert\/update the key logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { \/\/ inserting a new key logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { \/\/ updating a key logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { \/\/ stop the deletion clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close(); \/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000); } catch (exception e) { logger.error(e); exceptionlogger(e); putstat = statustype.put_error; } } \/\/ remove the top item from the list for this key removetopqueue(key); logger.info(clientport + \"> !!!!===removing from queue===!!!!\"); try { res = new kvmessage(key, value, putstat); } catch (invalidmessageexception ime) { throw ime; } return res; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\");","code_context_10":"try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() { @override public void run() { logger.info(clientport + \"> starting pruning thread\");","code_context_20":"\/\/ work while (clientrequests.get(key).peek()[0] != clientport) ; \/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads); logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { \/\/ delete the key logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { \/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() { @override public void run() { logger.info(clientport + \"> starting pruning thread\"); do { \/\/ logger.debug(\"prune waiting\"); } while (!clientrequests.get(key).isempty()); clientrequests.remove(key); if (cache != null) { cache.remove(key); } file file = new file(storagedirectory + key); file.delete(); logger.info(clientport + \"> \" + key + \" successfully pruned\");","repo":"CAPIndustries\/capDB"}
{"id":21001,"comment_id":0,"comment":"\/** * @param args contains the program's input args (here for signature purposes) *\/","code":"\/** * @param args contains the program's input args (here for signature purposes) *\/ public static void main(string[] args) { try { if (args.length != 6) { logger.error(\"error! invalid number of arguments!\"); logger.error(\"usage: server <name> <port> <zookeeper port> <ecs ip> <isloadreplica> <parentname>!\"); system.exit(1); } else { string name = args[0]; int port = integer.parseint(args[1]); int zkport = integer.parseint(args[2]); string ecsip = args[3]; boolean isloadreplica = boolean.parseboolean(args[4]); string parentname = args[5]; simpledateformat fmt = new simpledateformat(\"yyyy-mm-dd-hh-mm-ss\"); new logsetup(\"logs\/\" + name + \"_\" + fmt.format(new date()) + \".log\", level.all, true); \/\/ no need to use the run method here since the contructor is supposed to \/\/ start the server on its own \/\/ todo: allow passing additional arguments from the command line: new kvserver(start_cache_size, start_cache_strategy, name, port, zkport, ecsip, isloadreplica, parentname); } } catch (ioexception e) { system.out.println(\"error! unable to initialize logger!\"); e.printstacktrace(); system.exit(1); } catch (numberformatexception nfe) { system.out.println(\"error! invalid argument <port>! not a number!\"); system.out.println(\"usage: server <port>!\"); system.exit(1); } }","classification":"NONSATD","isFinished":true,"code_context_2":"public static void main(string[] args) { try { if (args.length != 6) { logger.error(\"error! invalid number of arguments!\"); logger.error(\"usage: server <name> <port> <zookeeper port> <ecs ip> <isloadreplica> <parentname>!\"); system.exit(1); } else { string name = args[0]; int port = integer.parseint(args[1]); int zkport = integer.parseint(args[2]); string ecsip = args[3]; boolean isloadreplica = boolean.parseboolean(args[4]); string parentname = args[5]; simpledateformat fmt = new simpledateformat(\"yyyy-mm-dd-hh-mm-ss\"); new logsetup(\"logs\/\" + name + \"_\" + fmt.format(new date()) + \".log\", level.all, true); \/\/ no need to use the run method here since the contructor is supposed to \/\/ start the server on its own \/\/ todo: allow passing additional arguments from the command line: new kvserver(start_cache_size, start_cache_strategy, name, port, zkport, ecsip, isloadreplica, parentname); } } catch (ioexception e) { system.out.println(\"error! unable to initialize logger!\"); e.printstacktrace(); system.exit(1); } catch (numberformatexception nfe) { system.out.println(\"error! invalid argument <port>! not a number!\"); system.out.println(\"usage: server <port>!\"); system.exit(1); } }","code_context_10":"public static void main(string[] args) { try { if (args.length != 6) { logger.error(\"error! invalid number of arguments!\"); logger.error(\"usage: server <name> <port> <zookeeper port> <ecs ip> <isloadreplica> <parentname>!\"); system.exit(1); } else { string name = args[0]; int port = integer.parseint(args[1]); int zkport = integer.parseint(args[2]); string ecsip = args[3]; boolean isloadreplica = boolean.parseboolean(args[4]); string parentname = args[5]; simpledateformat fmt = new simpledateformat(\"yyyy-mm-dd-hh-mm-ss\"); new logsetup(\"logs\/\" + name + \"_\" + fmt.format(new date()) + \".log\", level.all, true); \/\/ no need to use the run method here since the contructor is supposed to \/\/ start the server on its own \/\/ todo: allow passing additional arguments from the command line: new kvserver(start_cache_size, start_cache_strategy, name, port, zkport, ecsip, isloadreplica, parentname); } } catch (ioexception e) { system.out.println(\"error! unable to initialize logger!\"); e.printstacktrace(); system.exit(1); } catch (numberformatexception nfe) { system.out.println(\"error! invalid argument <port>! not a number!\"); system.out.println(\"usage: server <port>!\"); system.exit(1); } }","code_context_20":"public static void main(string[] args) { try { if (args.length != 6) { logger.error(\"error! invalid number of arguments!\"); logger.error(\"usage: server <name> <port> <zookeeper port> <ecs ip> <isloadreplica> <parentname>!\"); system.exit(1); } else { string name = args[0]; int port = integer.parseint(args[1]); int zkport = integer.parseint(args[2]); string ecsip = args[3]; boolean isloadreplica = boolean.parseboolean(args[4]); string parentname = args[5]; simpledateformat fmt = new simpledateformat(\"yyyy-mm-dd-hh-mm-ss\"); new logsetup(\"logs\/\" + name + \"_\" + fmt.format(new date()) + \".log\", level.all, true); \/\/ no need to use the run method here since the contructor is supposed to \/\/ start the server on its own \/\/ todo: allow passing additional arguments from the command line: new kvserver(start_cache_size, start_cache_strategy, name, port, zkport, ecsip, isloadreplica, parentname); } } catch (ioexception e) { system.out.println(\"error! unable to initialize logger!\"); e.printstacktrace(); system.exit(1); } catch (numberformatexception nfe) { system.out.println(\"error! invalid argument <port>! not a number!\"); system.out.println(\"usage: server <port>!\"); system.exit(1); } }","repo":"CAPIndustries\/capDB"}
{"id":21001,"comment_id":1,"comment":"\/\/ no need to use the run method here since the contructor is supposed to \/\/ start the server on its own \/\/ todo: allow passing additional arguments from the command line:","code":"public static void main(string[] args) { try { if (args.length != 6) { logger.error(\"error! invalid number of arguments!\"); logger.error(\"usage: server <name> <port> <zookeeper port> <ecs ip> <isloadreplica> <parentname>!\"); system.exit(1); } else { string name = args[0]; int port = integer.parseint(args[1]); int zkport = integer.parseint(args[2]); string ecsip = args[3]; boolean isloadreplica = boolean.parseboolean(args[4]); string parentname = args[5]; simpledateformat fmt = new simpledateformat(\"yyyy-mm-dd-hh-mm-ss\"); new logsetup(\"logs\/\" + name + \"_\" + fmt.format(new date()) + \".log\", level.all, true); \/\/ no need to use the run method here since the contructor is supposed to \/\/ start the server on its own \/\/ todo: allow passing additional arguments from the command line: new kvserver(start_cache_size, start_cache_strategy, name, port, zkport, ecsip, isloadreplica, parentname); } } catch (ioexception e) { system.out.println(\"error! unable to initialize logger!\"); e.printstacktrace(); system.exit(1); } catch (numberformatexception nfe) { system.out.println(\"error! invalid argument <port>! not a number!\"); system.out.println(\"usage: server <port>!\"); system.exit(1); } }","classification":"DESIGN","isFinished":true,"code_context_2":"simpledateformat fmt = new simpledateformat(\"yyyy-mm-dd-hh-mm-ss\"); new logsetup(\"logs\/\" + name + \"_\" + fmt.format(new date()) + \".log\", level.all, true); \/\/ no need to use the run method here since the contructor is supposed to \/\/ start the server on its own \/\/ todo: allow passing additional arguments from the command line: new kvserver(start_cache_size, start_cache_strategy, name, port, zkport, ecsip, isloadreplica, parentname); }","code_context_10":"system.exit(1); } else { string name = args[0]; int port = integer.parseint(args[1]); int zkport = integer.parseint(args[2]); string ecsip = args[3]; boolean isloadreplica = boolean.parseboolean(args[4]); string parentname = args[5]; simpledateformat fmt = new simpledateformat(\"yyyy-mm-dd-hh-mm-ss\"); new logsetup(\"logs\/\" + name + \"_\" + fmt.format(new date()) + \".log\", level.all, true); \/\/ no need to use the run method here since the contructor is supposed to \/\/ start the server on its own \/\/ todo: allow passing additional arguments from the command line: new kvserver(start_cache_size, start_cache_strategy, name, port, zkport, ecsip, isloadreplica, parentname); } } catch (ioexception e) { system.out.println(\"error! unable to initialize logger!\"); e.printstacktrace(); system.exit(1); } catch (numberformatexception nfe) { system.out.println(\"error! invalid argument <port>! not a number!\"); system.out.println(\"usage: server <port>!\"); system.exit(1);","code_context_20":"public static void main(string[] args) { try { if (args.length != 6) { logger.error(\"error! invalid number of arguments!\"); logger.error(\"usage: server <name> <port> <zookeeper port> <ecs ip> <isloadreplica> <parentname>!\"); system.exit(1); } else { string name = args[0]; int port = integer.parseint(args[1]); int zkport = integer.parseint(args[2]); string ecsip = args[3]; boolean isloadreplica = boolean.parseboolean(args[4]); string parentname = args[5]; simpledateformat fmt = new simpledateformat(\"yyyy-mm-dd-hh-mm-ss\"); new logsetup(\"logs\/\" + name + \"_\" + fmt.format(new date()) + \".log\", level.all, true); \/\/ no need to use the run method here since the contructor is supposed to \/\/ start the server on its own \/\/ todo: allow passing additional arguments from the command line: new kvserver(start_cache_size, start_cache_strategy, name, port, zkport, ecsip, isloadreplica, parentname); } } catch (ioexception e) { system.out.println(\"error! unable to initialize logger!\"); e.printstacktrace(); system.exit(1); } catch (numberformatexception nfe) { system.out.println(\"error! invalid argument <port>! not a number!\"); system.out.println(\"usage: server <port>!\"); system.exit(1); } }","repo":"CAPIndustries\/capDB"}
{"id":21046,"comment_id":0,"comment":"\/\/ inflate the layout for this fragment","code":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { \/\/ inflate the layout for this fragment llview = (linearlayout)inflater.inflate(r.layout.fragment_layers, container, false); llview.findviewbyid(r.id.btnaddstrokelayer).setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { layer newlayer = new strokepl(); createlayer(((idd<id>)mtree).getid(), newlayer); } }); llview.findviewbyid(r.id.btnaddgrouplayer).setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { layer newlayer = new grouplayer(); createlayer(((idd<id>)mtree).getid(), newlayer); } }); llview.findviewbyid(r.id.btnaddotherlayer).setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { \/\/todo this will need to change, for settings, etc. alertdialog.builder builder = new alertdialog.builder(getactivity()); list<class> classes = new arraylist<class>(); try { classes = classscanner.getconcretedescendants(getcontext(), layer.class, null); } catch (nosuchmethodexception e) { e.printstacktrace(); } catch (ioexception e) { e.printstacktrace(); } catch (classnotfoundexception e) { e.printstacktrace(); } classes.remove(uacanvas.class); arraylist<string> classnames = new arraylist<string>(); for (class<?> clazz : classes) { classnames.add(clazz.getname()); } string[] layertypes = new string[]{}; layertypes = classnames.toarray(layertypes); final list<class> fclasses = classes; builder.settitle(\"pick a layer type\") .setitems(layertypes, new dialoginterface.onclicklistener() { public void onclick(dialoginterface dialog, int which) { try { layer newlayer = (layer)fclasses.get(which).newinstance(); createlayer(((idd<id>)mtree).getid(), newlayer); } catch (java.lang.instantiationexception e) { e.printstacktrace(); showtoast(\"error creating layer:\\n\" + e.getmessage()); } catch (illegalaccessexception e) { e.printstacktrace(); showtoast(\"error creating layer:\\n\" + e.getmessage()); } } }); builder.show(); } }); updateview(); return llview; }","classification":"NONSATD","isFinished":true,"code_context_2":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { \/\/ inflate the layout for this fragment llview = (linearlayout)inflater.inflate(r.layout.fragment_layers, container, false); llview.findviewbyid(r.id.btnaddstrokelayer).setonclicklistener(new view.onclicklistener() {","code_context_10":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { \/\/ inflate the layout for this fragment llview = (linearlayout)inflater.inflate(r.layout.fragment_layers, container, false); llview.findviewbyid(r.id.btnaddstrokelayer).setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { layer newlayer = new strokepl(); createlayer(((idd<id>)mtree).getid(), newlayer); } }); llview.findviewbyid(r.id.btnaddgrouplayer).setonclicklistener(new view.onclicklistener() { @override","code_context_20":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { \/\/ inflate the layout for this fragment llview = (linearlayout)inflater.inflate(r.layout.fragment_layers, container, false); llview.findviewbyid(r.id.btnaddstrokelayer).setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { layer newlayer = new strokepl(); createlayer(((idd<id>)mtree).getid(), newlayer); } }); llview.findviewbyid(r.id.btnaddgrouplayer).setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { layer newlayer = new grouplayer(); createlayer(((idd<id>)mtree).getid(), newlayer); } }); llview.findviewbyid(r.id.btnaddotherlayer).setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { \/\/todo this will need to change, for settings, etc. alertdialog.builder builder = new alertdialog.builder(getactivity());","repo":"Erhannis\/UnstableArt"}
{"id":21046,"comment_id":1,"comment":"\/\/todo this will need to change, for settings, etc.","code":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { \/\/ inflate the layout for this fragment llview = (linearlayout)inflater.inflate(r.layout.fragment_layers, container, false); llview.findviewbyid(r.id.btnaddstrokelayer).setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { layer newlayer = new strokepl(); createlayer(((idd<id>)mtree).getid(), newlayer); } }); llview.findviewbyid(r.id.btnaddgrouplayer).setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { layer newlayer = new grouplayer(); createlayer(((idd<id>)mtree).getid(), newlayer); } }); llview.findviewbyid(r.id.btnaddotherlayer).setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { \/\/todo this will need to change, for settings, etc. alertdialog.builder builder = new alertdialog.builder(getactivity()); list<class> classes = new arraylist<class>(); try { classes = classscanner.getconcretedescendants(getcontext(), layer.class, null); } catch (nosuchmethodexception e) { e.printstacktrace(); } catch (ioexception e) { e.printstacktrace(); } catch (classnotfoundexception e) { e.printstacktrace(); } classes.remove(uacanvas.class); arraylist<string> classnames = new arraylist<string>(); for (class<?> clazz : classes) { classnames.add(clazz.getname()); } string[] layertypes = new string[]{}; layertypes = classnames.toarray(layertypes); final list<class> fclasses = classes; builder.settitle(\"pick a layer type\") .setitems(layertypes, new dialoginterface.onclicklistener() { public void onclick(dialoginterface dialog, int which) { try { layer newlayer = (layer)fclasses.get(which).newinstance(); createlayer(((idd<id>)mtree).getid(), newlayer); } catch (java.lang.instantiationexception e) { e.printstacktrace(); showtoast(\"error creating layer:\\n\" + e.getmessage()); } catch (illegalaccessexception e) { e.printstacktrace(); showtoast(\"error creating layer:\\n\" + e.getmessage()); } } }); builder.show(); } }); updateview(); return llview; }","classification":"DESIGN","isFinished":true,"code_context_2":"@override public void onclick(view v) { \/\/todo this will need to change, for settings, etc. alertdialog.builder builder = new alertdialog.builder(getactivity()); list<class> classes = new arraylist<class>();","code_context_10":"llview.findviewbyid(r.id.btnaddgrouplayer).setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { layer newlayer = new grouplayer(); createlayer(((idd<id>)mtree).getid(), newlayer); } }); llview.findviewbyid(r.id.btnaddotherlayer).setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { \/\/todo this will need to change, for settings, etc. alertdialog.builder builder = new alertdialog.builder(getactivity()); list<class> classes = new arraylist<class>(); try { classes = classscanner.getconcretedescendants(getcontext(), layer.class, null); } catch (nosuchmethodexception e) { e.printstacktrace(); } catch (ioexception e) { e.printstacktrace(); } catch (classnotfoundexception e) { e.printstacktrace();","code_context_20":"public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { \/\/ inflate the layout for this fragment llview = (linearlayout)inflater.inflate(r.layout.fragment_layers, container, false); llview.findviewbyid(r.id.btnaddstrokelayer).setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { layer newlayer = new strokepl(); createlayer(((idd<id>)mtree).getid(), newlayer); } }); llview.findviewbyid(r.id.btnaddgrouplayer).setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { layer newlayer = new grouplayer(); createlayer(((idd<id>)mtree).getid(), newlayer); } }); llview.findviewbyid(r.id.btnaddotherlayer).setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { \/\/todo this will need to change, for settings, etc. alertdialog.builder builder = new alertdialog.builder(getactivity()); list<class> classes = new arraylist<class>(); try { classes = classscanner.getconcretedescendants(getcontext(), layer.class, null); } catch (nosuchmethodexception e) { e.printstacktrace(); } catch (ioexception e) { e.printstacktrace(); } catch (classnotfoundexception e) { e.printstacktrace(); } classes.remove(uacanvas.class); arraylist<string> classnames = new arraylist<string>(); for (class<?> clazz : classes) { classnames.add(clazz.getname()); } string[] layertypes = new string[]{}; layertypes = classnames.toarray(layertypes); final list<class> fclasses = classes; builder.settitle(\"pick a layer type\")","repo":"Erhannis\/UnstableArt"}
{"id":21397,"comment_id":0,"comment":"\/\/ component.setimportenabled(false);","code":"private mxgraphcomponent creategraphcomponent(mxgraph graph) { mxgraphcomponent component = new mxgraphcomponent(graph); component.setautoextend(true); component.setantialias(true); component.settextantialias(true); component.settooltips(true); \/\/ component.setimportenabled(false); component.setfoldingenabled(true); component.setconnectable(false); component.setdragenabled(false); \/\/ component.setkeepselectionvisibleonzoom(true); \/\/ component.getviewport().setbackground(color.white); \/\/todo setup return component; }","classification":"NONSATD","isFinished":true,"code_context_2":"component.settextantialias(true); component.settooltips(true); \/\/ component.setimportenabled(false); component.setfoldingenabled(true); component.setconnectable(false);","code_context_10":"private mxgraphcomponent creategraphcomponent(mxgraph graph) { mxgraphcomponent component = new mxgraphcomponent(graph); component.setautoextend(true); component.setantialias(true); component.settextantialias(true); component.settooltips(true); \/\/ component.setimportenabled(false); component.setfoldingenabled(true); component.setconnectable(false); component.setdragenabled(false); \/\/ component.setkeepselectionvisibleonzoom(true); \/\/ component.getviewport().setbackground(color.white); \/\/todo setup return component; }","code_context_20":"private mxgraphcomponent creategraphcomponent(mxgraph graph) { mxgraphcomponent component = new mxgraphcomponent(graph); component.setautoextend(true); component.setantialias(true); component.settextantialias(true); component.settooltips(true); \/\/ component.setimportenabled(false); component.setfoldingenabled(true); component.setconnectable(false); component.setdragenabled(false); \/\/ component.setkeepselectionvisibleonzoom(true); \/\/ component.getviewport().setbackground(color.white); \/\/todo setup return component; }","repo":"ICARUS-tooling\/icarus2-modeling-framework"}
{"id":21397,"comment_id":1,"comment":"\/\/ component.setkeepselectionvisibleonzoom(true); \/\/ component.getviewport().setbackground(color.white); \/\/todo setup","code":"private mxgraphcomponent creategraphcomponent(mxgraph graph) { mxgraphcomponent component = new mxgraphcomponent(graph); component.setautoextend(true); component.setantialias(true); component.settextantialias(true); component.settooltips(true); \/\/ component.setimportenabled(false); component.setfoldingenabled(true); component.setconnectable(false); component.setdragenabled(false); \/\/ component.setkeepselectionvisibleonzoom(true); \/\/ component.getviewport().setbackground(color.white); \/\/todo setup return component; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"component.setconnectable(false); component.setdragenabled(false); \/\/ component.setkeepselectionvisibleonzoom(true); \/\/ component.getviewport().setbackground(color.white); \/\/todo setup return component; }","code_context_10":"private mxgraphcomponent creategraphcomponent(mxgraph graph) { mxgraphcomponent component = new mxgraphcomponent(graph); component.setautoextend(true); component.setantialias(true); component.settextantialias(true); component.settooltips(true); \/\/ component.setimportenabled(false); component.setfoldingenabled(true); component.setconnectable(false); component.setdragenabled(false); \/\/ component.setkeepselectionvisibleonzoom(true); \/\/ component.getviewport().setbackground(color.white); \/\/todo setup return component; }","code_context_20":"private mxgraphcomponent creategraphcomponent(mxgraph graph) { mxgraphcomponent component = new mxgraphcomponent(graph); component.setautoextend(true); component.setantialias(true); component.settextantialias(true); component.settooltips(true); \/\/ component.setimportenabled(false); component.setfoldingenabled(true); component.setconnectable(false); component.setdragenabled(false); \/\/ component.setkeepselectionvisibleonzoom(true); \/\/ component.getviewport().setbackground(color.white); \/\/todo setup return component; }","repo":"ICARUS-tooling\/icarus2-modeling-framework"}
{"id":13266,"comment_id":0,"comment":"\/\/ todo: put safe grabbing of age here","code":"public int getage() { \/\/ todo: put safe grabbing of age here return 0; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"public int getage() { \/\/ todo: put safe grabbing of age here return 0; }","code_context_10":"public int getage() { \/\/ todo: put safe grabbing of age here return 0; }","code_context_20":"public int getage() { \/\/ todo: put safe grabbing of age here return 0; }","repo":"210118-java-enterprise\/demos"}
{"id":13267,"comment_id":0,"comment":"\/\/ todo rework when new instance name is ready","code":"@instancename public string getcaption() { \/\/ todo rework when new instance name is ready string pattern =\/* appcontext.getproperty(\"cuba.user.namepattern\"); if (stringutils.isblank(pattern)) { pattern =*\/ \"{1} [{0}]\"; \/*}*\/ messageformat fmt = new messageformat(pattern); return stringutils.trimtoempty(fmt.format(new object[]{ stringutils.trimtoempty(username), stringutils.trimtoempty(name) })); }","classification":"DESIGN","isFinished":true,"code_context_2":"@instancename public string getcaption() { \/\/ todo rework when new instance name is ready string pattern =\/* appcontext.getproperty(\"cuba.user.namepattern\"); if (stringutils.isblank(pattern)) {","code_context_10":"@instancename public string getcaption() { \/\/ todo rework when new instance name is ready string pattern =\/* appcontext.getproperty(\"cuba.user.namepattern\"); if (stringutils.isblank(pattern)) { pattern =*\/ \"{1} [{0}]\"; \/*}*\/ messageformat fmt = new messageformat(pattern); return stringutils.trimtoempty(fmt.format(new object[]{ stringutils.trimtoempty(username), stringutils.trimtoempty(name) })); }","code_context_20":"@instancename public string getcaption() { \/\/ todo rework when new instance name is ready string pattern =\/* appcontext.getproperty(\"cuba.user.namepattern\"); if (stringutils.isblank(pattern)) { pattern =*\/ \"{1} [{0}]\"; \/*}*\/ messageformat fmt = new messageformat(pattern); return stringutils.trimtoempty(fmt.format(new object[]{ stringutils.trimtoempty(username), stringutils.trimtoempty(name) })); }","repo":"Haulmont\/jmix-old"}
{"id":13267,"comment_id":1,"comment":"\/* appcontext.getproperty(\"cuba.user.namepattern\"); if (stringutils.isblank(pattern)) { pattern =*\/","code":"@instancename public string getcaption() { \/\/ todo rework when new instance name is ready string pattern =\/* appcontext.getproperty(\"cuba.user.namepattern\"); if (stringutils.isblank(pattern)) { pattern =*\/ \"{1} [{0}]\"; \/*}*\/ messageformat fmt = new messageformat(pattern); return stringutils.trimtoempty(fmt.format(new object[]{ stringutils.trimtoempty(username), stringutils.trimtoempty(name) })); }","classification":"NONSATD","isFinished":true,"code_context_2":"public string getcaption() { \/\/ todo rework when new instance name is ready string pattern =\/* appcontext.getproperty(\"cuba.user.namepattern\"); if (stringutils.isblank(pattern)) { pattern =*\/ \"{1} [{0}]\"; \/*}*\/ messageformat fmt = new messageformat(pattern);","code_context_10":"@instancename public string getcaption() { \/\/ todo rework when new instance name is ready string pattern =\/* appcontext.getproperty(\"cuba.user.namepattern\"); if (stringutils.isblank(pattern)) { pattern =*\/ \"{1} [{0}]\"; \/*}*\/ messageformat fmt = new messageformat(pattern); return stringutils.trimtoempty(fmt.format(new object[]{ stringutils.trimtoempty(username), stringutils.trimtoempty(name) })); }","code_context_20":"@instancename public string getcaption() { \/\/ todo rework when new instance name is ready string pattern =\/* appcontext.getproperty(\"cuba.user.namepattern\"); if (stringutils.isblank(pattern)) { pattern =*\/ \"{1} [{0}]\"; \/*}*\/ messageformat fmt = new messageformat(pattern); return stringutils.trimtoempty(fmt.format(new object[]{ stringutils.trimtoempty(username), stringutils.trimtoempty(name) })); }","repo":"Haulmont\/jmix-old"}
{"id":13267,"comment_id":2,"comment":"\/*}*\/","code":"@instancename public string getcaption() { \/\/ todo rework when new instance name is ready string pattern =\/* appcontext.getproperty(\"cuba.user.namepattern\"); if (stringutils.isblank(pattern)) { pattern =*\/ \"{1} [{0}]\"; \/*}*\/ messageformat fmt = new messageformat(pattern); return stringutils.trimtoempty(fmt.format(new object[]{ stringutils.trimtoempty(username), stringutils.trimtoempty(name) })); }","classification":"NONSATD","isFinished":true,"code_context_2":"if (stringutils.isblank(pattern)) { pattern =*\/ \"{1} [{0}]\"; \/*}*\/ messageformat fmt = new messageformat(pattern); return stringutils.trimtoempty(fmt.format(new object[]{","code_context_10":"@instancename public string getcaption() { \/\/ todo rework when new instance name is ready string pattern =\/* appcontext.getproperty(\"cuba.user.namepattern\"); if (stringutils.isblank(pattern)) { pattern =*\/ \"{1} [{0}]\"; \/*}*\/ messageformat fmt = new messageformat(pattern); return stringutils.trimtoempty(fmt.format(new object[]{ stringutils.trimtoempty(username), stringutils.trimtoempty(name) })); }","code_context_20":"@instancename public string getcaption() { \/\/ todo rework when new instance name is ready string pattern =\/* appcontext.getproperty(\"cuba.user.namepattern\"); if (stringutils.isblank(pattern)) { pattern =*\/ \"{1} [{0}]\"; \/*}*\/ messageformat fmt = new messageformat(pattern); return stringutils.trimtoempty(fmt.format(new object[]{ stringutils.trimtoempty(username), stringutils.trimtoempty(name) })); }","repo":"Haulmont\/jmix-old"}
{"id":13309,"comment_id":0,"comment":"\/\/ the relevance (of each results element) to the search terms.","code":"private solrquery createquery(string querystring, int startpage, int pagesize, boolean usedismax) { solrquery query = new solrquery(querystring); query.settimeallowed(querytimeout); query.setincludescore(true); \/\/ the relevance (of each results element) to the search terms. query.sethighlight(false); if (usedismax) { query.set(\"deftype\", \"dismax\"); } \/\/todo: put the \"options\" from the \"queryfield\" picklist into a config file. \/\/this list matches the \"options\" from the \"queryfield\" picklist on unformattedsearch.ftl, \/\/without the \"date\" fields. query.setstart(startpage * pagesize); \/\/ which results element to return first in this batch. query.setrows(pagesize); \/\/ the number of results elements to return. \/\/ request only fields that we need to display query.setfields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\", \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\", \"subject\", \"expression_of_concern\", \"retraction\"); query.addfacetfield(\"subject_facet\"); query.addfacetfield(\"author_facet\"); query.addfacetfield(\"editor_facet\"); query.addfacetfield(\"article_type_facet\"); query.addfacetfield(\"affiliate_facet\"); query.set(\"facet.method\", \"fc\"); query.setfacetlimit(max_facet_size); query.setfacetmincount(min_facet_count); \/\/ add a filter to ensure that solr never returns partial documents query.addfilterquery(createfilterfulldocuments()); return query; }","classification":"NONSATD","isFinished":true,"code_context_2":"solrquery query = new solrquery(querystring); query.settimeallowed(querytimeout); query.setincludescore(true); \/\/ the relevance (of each results element) to the search terms. query.sethighlight(false); if (usedismax) {","code_context_10":"private solrquery createquery(string querystring, int startpage, int pagesize, boolean usedismax) { solrquery query = new solrquery(querystring); query.settimeallowed(querytimeout); query.setincludescore(true); \/\/ the relevance (of each results element) to the search terms. query.sethighlight(false); if (usedismax) { query.set(\"deftype\", \"dismax\"); } \/\/todo: put the \"options\" from the \"queryfield\" picklist into a config file. \/\/this list matches the \"options\" from the \"queryfield\" picklist on unformattedsearch.ftl, \/\/without the \"date\" fields. query.setstart(startpage * pagesize); \/\/ which results element to return first in this batch. query.setrows(pagesize); \/\/ the number of results elements to return. \/\/ request only fields that we need to display","code_context_20":"private solrquery createquery(string querystring, int startpage, int pagesize, boolean usedismax) { solrquery query = new solrquery(querystring); query.settimeallowed(querytimeout); query.setincludescore(true); \/\/ the relevance (of each results element) to the search terms. query.sethighlight(false); if (usedismax) { query.set(\"deftype\", \"dismax\"); } \/\/todo: put the \"options\" from the \"queryfield\" picklist into a config file. \/\/this list matches the \"options\" from the \"queryfield\" picklist on unformattedsearch.ftl, \/\/without the \"date\" fields. query.setstart(startpage * pagesize); \/\/ which results element to return first in this batch. query.setrows(pagesize); \/\/ the number of results elements to return. \/\/ request only fields that we need to display query.setfields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\", \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\", \"subject\", \"expression_of_concern\", \"retraction\"); query.addfacetfield(\"subject_facet\"); query.addfacetfield(\"author_facet\"); query.addfacetfield(\"editor_facet\"); query.addfacetfield(\"article_type_facet\"); query.addfacetfield(\"affiliate_facet\"); query.set(\"facet.method\", \"fc\"); query.setfacetlimit(max_facet_size);","repo":"AndrewGuthua\/JournalSystem"}
{"id":13309,"comment_id":1,"comment":"\/\/todo: put the \"options\" from the \"queryfield\" picklist into a config file. \/\/this list matches the \"options\" from the \"queryfield\" picklist on unformattedsearch.ftl, \/\/without the \"date\" fields.","code":"private solrquery createquery(string querystring, int startpage, int pagesize, boolean usedismax) { solrquery query = new solrquery(querystring); query.settimeallowed(querytimeout); query.setincludescore(true); \/\/ the relevance (of each results element) to the search terms. query.sethighlight(false); if (usedismax) { query.set(\"deftype\", \"dismax\"); } \/\/todo: put the \"options\" from the \"queryfield\" picklist into a config file. \/\/this list matches the \"options\" from the \"queryfield\" picklist on unformattedsearch.ftl, \/\/without the \"date\" fields. query.setstart(startpage * pagesize); \/\/ which results element to return first in this batch. query.setrows(pagesize); \/\/ the number of results elements to return. \/\/ request only fields that we need to display query.setfields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\", \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\", \"subject\", \"expression_of_concern\", \"retraction\"); query.addfacetfield(\"subject_facet\"); query.addfacetfield(\"author_facet\"); query.addfacetfield(\"editor_facet\"); query.addfacetfield(\"article_type_facet\"); query.addfacetfield(\"affiliate_facet\"); query.set(\"facet.method\", \"fc\"); query.setfacetlimit(max_facet_size); query.setfacetmincount(min_facet_count); \/\/ add a filter to ensure that solr never returns partial documents query.addfilterquery(createfilterfulldocuments()); return query; }","classification":"DESIGN","isFinished":true,"code_context_2":"query.set(\"deftype\", \"dismax\"); } \/\/todo: put the \"options\" from the \"queryfield\" picklist into a config file. \/\/this list matches the \"options\" from the \"queryfield\" picklist on unformattedsearch.ftl, \/\/without the \"date\" fields. query.setstart(startpage * pagesize); \/\/ which results element to return first in this batch. query.setrows(pagesize); \/\/ the number of results elements to return.","code_context_10":"private solrquery createquery(string querystring, int startpage, int pagesize, boolean usedismax) { solrquery query = new solrquery(querystring); query.settimeallowed(querytimeout); query.setincludescore(true); \/\/ the relevance (of each results element) to the search terms. query.sethighlight(false); if (usedismax) { query.set(\"deftype\", \"dismax\"); } \/\/todo: put the \"options\" from the \"queryfield\" picklist into a config file. \/\/this list matches the \"options\" from the \"queryfield\" picklist on unformattedsearch.ftl, \/\/without the \"date\" fields. query.setstart(startpage * pagesize); \/\/ which results element to return first in this batch. query.setrows(pagesize); \/\/ the number of results elements to return. \/\/ request only fields that we need to display query.setfields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\", \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\", \"subject\", \"expression_of_concern\", \"retraction\"); query.addfacetfield(\"subject_facet\"); query.addfacetfield(\"author_facet\"); query.addfacetfield(\"editor_facet\"); query.addfacetfield(\"article_type_facet\");","code_context_20":"private solrquery createquery(string querystring, int startpage, int pagesize, boolean usedismax) { solrquery query = new solrquery(querystring); query.settimeallowed(querytimeout); query.setincludescore(true); \/\/ the relevance (of each results element) to the search terms. query.sethighlight(false); if (usedismax) { query.set(\"deftype\", \"dismax\"); } \/\/todo: put the \"options\" from the \"queryfield\" picklist into a config file. \/\/this list matches the \"options\" from the \"queryfield\" picklist on unformattedsearch.ftl, \/\/without the \"date\" fields. query.setstart(startpage * pagesize); \/\/ which results element to return first in this batch. query.setrows(pagesize); \/\/ the number of results elements to return. \/\/ request only fields that we need to display query.setfields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\", \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\", \"subject\", \"expression_of_concern\", \"retraction\"); query.addfacetfield(\"subject_facet\"); query.addfacetfield(\"author_facet\"); query.addfacetfield(\"editor_facet\"); query.addfacetfield(\"article_type_facet\"); query.addfacetfield(\"affiliate_facet\"); query.set(\"facet.method\", \"fc\"); query.setfacetlimit(max_facet_size); query.setfacetmincount(min_facet_count); \/\/ add a filter to ensure that solr never returns partial documents query.addfilterquery(createfilterfulldocuments()); return query; }","repo":"AndrewGuthua\/JournalSystem"}
{"id":13309,"comment_id":2,"comment":"\/\/ which results element to return first in this batch.","code":"private solrquery createquery(string querystring, int startpage, int pagesize, boolean usedismax) { solrquery query = new solrquery(querystring); query.settimeallowed(querytimeout); query.setincludescore(true); \/\/ the relevance (of each results element) to the search terms. query.sethighlight(false); if (usedismax) { query.set(\"deftype\", \"dismax\"); } \/\/todo: put the \"options\" from the \"queryfield\" picklist into a config file. \/\/this list matches the \"options\" from the \"queryfield\" picklist on unformattedsearch.ftl, \/\/without the \"date\" fields. query.setstart(startpage * pagesize); \/\/ which results element to return first in this batch. query.setrows(pagesize); \/\/ the number of results elements to return. \/\/ request only fields that we need to display query.setfields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\", \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\", \"subject\", \"expression_of_concern\", \"retraction\"); query.addfacetfield(\"subject_facet\"); query.addfacetfield(\"author_facet\"); query.addfacetfield(\"editor_facet\"); query.addfacetfield(\"article_type_facet\"); query.addfacetfield(\"affiliate_facet\"); query.set(\"facet.method\", \"fc\"); query.setfacetlimit(max_facet_size); query.setfacetmincount(min_facet_count); \/\/ add a filter to ensure that solr never returns partial documents query.addfilterquery(createfilterfulldocuments()); return query; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/this list matches the \"options\" from the \"queryfield\" picklist on unformattedsearch.ftl, \/\/without the \"date\" fields. query.setstart(startpage * pagesize); \/\/ which results element to return first in this batch. query.setrows(pagesize); \/\/ the number of results elements to return. \/\/ request only fields that we need to display","code_context_10":"solrquery query = new solrquery(querystring); query.settimeallowed(querytimeout); query.setincludescore(true); \/\/ the relevance (of each results element) to the search terms. query.sethighlight(false); if (usedismax) { query.set(\"deftype\", \"dismax\"); } \/\/todo: put the \"options\" from the \"queryfield\" picklist into a config file. \/\/this list matches the \"options\" from the \"queryfield\" picklist on unformattedsearch.ftl, \/\/without the \"date\" fields. query.setstart(startpage * pagesize); \/\/ which results element to return first in this batch. query.setrows(pagesize); \/\/ the number of results elements to return. \/\/ request only fields that we need to display query.setfields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\", \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\", \"subject\", \"expression_of_concern\", \"retraction\"); query.addfacetfield(\"subject_facet\"); query.addfacetfield(\"author_facet\"); query.addfacetfield(\"editor_facet\"); query.addfacetfield(\"article_type_facet\"); query.addfacetfield(\"affiliate_facet\");","code_context_20":"private solrquery createquery(string querystring, int startpage, int pagesize, boolean usedismax) { solrquery query = new solrquery(querystring); query.settimeallowed(querytimeout); query.setincludescore(true); \/\/ the relevance (of each results element) to the search terms. query.sethighlight(false); if (usedismax) { query.set(\"deftype\", \"dismax\"); } \/\/todo: put the \"options\" from the \"queryfield\" picklist into a config file. \/\/this list matches the \"options\" from the \"queryfield\" picklist on unformattedsearch.ftl, \/\/without the \"date\" fields. query.setstart(startpage * pagesize); \/\/ which results element to return first in this batch. query.setrows(pagesize); \/\/ the number of results elements to return. \/\/ request only fields that we need to display query.setfields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\", \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\", \"subject\", \"expression_of_concern\", \"retraction\"); query.addfacetfield(\"subject_facet\"); query.addfacetfield(\"author_facet\"); query.addfacetfield(\"editor_facet\"); query.addfacetfield(\"article_type_facet\"); query.addfacetfield(\"affiliate_facet\"); query.set(\"facet.method\", \"fc\"); query.setfacetlimit(max_facet_size); query.setfacetmincount(min_facet_count); \/\/ add a filter to ensure that solr never returns partial documents query.addfilterquery(createfilterfulldocuments()); return query; }","repo":"AndrewGuthua\/JournalSystem"}
{"id":13309,"comment_id":3,"comment":"\/\/ the number of results elements to return.","code":"private solrquery createquery(string querystring, int startpage, int pagesize, boolean usedismax) { solrquery query = new solrquery(querystring); query.settimeallowed(querytimeout); query.setincludescore(true); \/\/ the relevance (of each results element) to the search terms. query.sethighlight(false); if (usedismax) { query.set(\"deftype\", \"dismax\"); } \/\/todo: put the \"options\" from the \"queryfield\" picklist into a config file. \/\/this list matches the \"options\" from the \"queryfield\" picklist on unformattedsearch.ftl, \/\/without the \"date\" fields. query.setstart(startpage * pagesize); \/\/ which results element to return first in this batch. query.setrows(pagesize); \/\/ the number of results elements to return. \/\/ request only fields that we need to display query.setfields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\", \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\", \"subject\", \"expression_of_concern\", \"retraction\"); query.addfacetfield(\"subject_facet\"); query.addfacetfield(\"author_facet\"); query.addfacetfield(\"editor_facet\"); query.addfacetfield(\"article_type_facet\"); query.addfacetfield(\"affiliate_facet\"); query.set(\"facet.method\", \"fc\"); query.setfacetlimit(max_facet_size); query.setfacetmincount(min_facet_count); \/\/ add a filter to ensure that solr never returns partial documents query.addfilterquery(createfilterfulldocuments()); return query; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/without the \"date\" fields. query.setstart(startpage * pagesize); \/\/ which results element to return first in this batch. query.setrows(pagesize); \/\/ the number of results elements to return. \/\/ request only fields that we need to display query.setfields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\",","code_context_10":"query.settimeallowed(querytimeout); query.setincludescore(true); \/\/ the relevance (of each results element) to the search terms. query.sethighlight(false); if (usedismax) { query.set(\"deftype\", \"dismax\"); } \/\/todo: put the \"options\" from the \"queryfield\" picklist into a config file. \/\/this list matches the \"options\" from the \"queryfield\" picklist on unformattedsearch.ftl, \/\/without the \"date\" fields. query.setstart(startpage * pagesize); \/\/ which results element to return first in this batch. query.setrows(pagesize); \/\/ the number of results elements to return. \/\/ request only fields that we need to display query.setfields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\", \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\", \"subject\", \"expression_of_concern\", \"retraction\"); query.addfacetfield(\"subject_facet\"); query.addfacetfield(\"author_facet\"); query.addfacetfield(\"editor_facet\"); query.addfacetfield(\"article_type_facet\"); query.addfacetfield(\"affiliate_facet\"); query.set(\"facet.method\", \"fc\");","code_context_20":"private solrquery createquery(string querystring, int startpage, int pagesize, boolean usedismax) { solrquery query = new solrquery(querystring); query.settimeallowed(querytimeout); query.setincludescore(true); \/\/ the relevance (of each results element) to the search terms. query.sethighlight(false); if (usedismax) { query.set(\"deftype\", \"dismax\"); } \/\/todo: put the \"options\" from the \"queryfield\" picklist into a config file. \/\/this list matches the \"options\" from the \"queryfield\" picklist on unformattedsearch.ftl, \/\/without the \"date\" fields. query.setstart(startpage * pagesize); \/\/ which results element to return first in this batch. query.setrows(pagesize); \/\/ the number of results elements to return. \/\/ request only fields that we need to display query.setfields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\", \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\", \"subject\", \"expression_of_concern\", \"retraction\"); query.addfacetfield(\"subject_facet\"); query.addfacetfield(\"author_facet\"); query.addfacetfield(\"editor_facet\"); query.addfacetfield(\"article_type_facet\"); query.addfacetfield(\"affiliate_facet\"); query.set(\"facet.method\", \"fc\"); query.setfacetlimit(max_facet_size); query.setfacetmincount(min_facet_count); \/\/ add a filter to ensure that solr never returns partial documents query.addfilterquery(createfilterfulldocuments()); return query; }","repo":"AndrewGuthua\/JournalSystem"}
{"id":13309,"comment_id":4,"comment":"\/\/ request only fields that we need to display","code":"private solrquery createquery(string querystring, int startpage, int pagesize, boolean usedismax) { solrquery query = new solrquery(querystring); query.settimeallowed(querytimeout); query.setincludescore(true); \/\/ the relevance (of each results element) to the search terms. query.sethighlight(false); if (usedismax) { query.set(\"deftype\", \"dismax\"); } \/\/todo: put the \"options\" from the \"queryfield\" picklist into a config file. \/\/this list matches the \"options\" from the \"queryfield\" picklist on unformattedsearch.ftl, \/\/without the \"date\" fields. query.setstart(startpage * pagesize); \/\/ which results element to return first in this batch. query.setrows(pagesize); \/\/ the number of results elements to return. \/\/ request only fields that we need to display query.setfields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\", \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\", \"subject\", \"expression_of_concern\", \"retraction\"); query.addfacetfield(\"subject_facet\"); query.addfacetfield(\"author_facet\"); query.addfacetfield(\"editor_facet\"); query.addfacetfield(\"article_type_facet\"); query.addfacetfield(\"affiliate_facet\"); query.set(\"facet.method\", \"fc\"); query.setfacetlimit(max_facet_size); query.setfacetmincount(min_facet_count); \/\/ add a filter to ensure that solr never returns partial documents query.addfilterquery(createfilterfulldocuments()); return query; }","classification":"NONSATD","isFinished":true,"code_context_2":"query.setstart(startpage * pagesize); \/\/ which results element to return first in this batch. query.setrows(pagesize); \/\/ the number of results elements to return. \/\/ request only fields that we need to display query.setfields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\", \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\",","code_context_10":"query.setincludescore(true); \/\/ the relevance (of each results element) to the search terms. query.sethighlight(false); if (usedismax) { query.set(\"deftype\", \"dismax\"); } \/\/todo: put the \"options\" from the \"queryfield\" picklist into a config file. \/\/this list matches the \"options\" from the \"queryfield\" picklist on unformattedsearch.ftl, \/\/without the \"date\" fields. query.setstart(startpage * pagesize); \/\/ which results element to return first in this batch. query.setrows(pagesize); \/\/ the number of results elements to return. \/\/ request only fields that we need to display query.setfields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\", \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\", \"subject\", \"expression_of_concern\", \"retraction\"); query.addfacetfield(\"subject_facet\"); query.addfacetfield(\"author_facet\"); query.addfacetfield(\"editor_facet\"); query.addfacetfield(\"article_type_facet\"); query.addfacetfield(\"affiliate_facet\"); query.set(\"facet.method\", \"fc\"); query.setfacetlimit(max_facet_size);","code_context_20":"private solrquery createquery(string querystring, int startpage, int pagesize, boolean usedismax) { solrquery query = new solrquery(querystring); query.settimeallowed(querytimeout); query.setincludescore(true); \/\/ the relevance (of each results element) to the search terms. query.sethighlight(false); if (usedismax) { query.set(\"deftype\", \"dismax\"); } \/\/todo: put the \"options\" from the \"queryfield\" picklist into a config file. \/\/this list matches the \"options\" from the \"queryfield\" picklist on unformattedsearch.ftl, \/\/without the \"date\" fields. query.setstart(startpage * pagesize); \/\/ which results element to return first in this batch. query.setrows(pagesize); \/\/ the number of results elements to return. \/\/ request only fields that we need to display query.setfields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\", \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\", \"subject\", \"expression_of_concern\", \"retraction\"); query.addfacetfield(\"subject_facet\"); query.addfacetfield(\"author_facet\"); query.addfacetfield(\"editor_facet\"); query.addfacetfield(\"article_type_facet\"); query.addfacetfield(\"affiliate_facet\"); query.set(\"facet.method\", \"fc\"); query.setfacetlimit(max_facet_size); query.setfacetmincount(min_facet_count); \/\/ add a filter to ensure that solr never returns partial documents query.addfilterquery(createfilterfulldocuments()); return query; }","repo":"AndrewGuthua\/JournalSystem"}
{"id":13309,"comment_id":5,"comment":"\/\/ add a filter to ensure that solr never returns partial documents","code":"private solrquery createquery(string querystring, int startpage, int pagesize, boolean usedismax) { solrquery query = new solrquery(querystring); query.settimeallowed(querytimeout); query.setincludescore(true); \/\/ the relevance (of each results element) to the search terms. query.sethighlight(false); if (usedismax) { query.set(\"deftype\", \"dismax\"); } \/\/todo: put the \"options\" from the \"queryfield\" picklist into a config file. \/\/this list matches the \"options\" from the \"queryfield\" picklist on unformattedsearch.ftl, \/\/without the \"date\" fields. query.setstart(startpage * pagesize); \/\/ which results element to return first in this batch. query.setrows(pagesize); \/\/ the number of results elements to return. \/\/ request only fields that we need to display query.setfields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\", \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\", \"subject\", \"expression_of_concern\", \"retraction\"); query.addfacetfield(\"subject_facet\"); query.addfacetfield(\"author_facet\"); query.addfacetfield(\"editor_facet\"); query.addfacetfield(\"article_type_facet\"); query.addfacetfield(\"affiliate_facet\"); query.set(\"facet.method\", \"fc\"); query.setfacetlimit(max_facet_size); query.setfacetmincount(min_facet_count); \/\/ add a filter to ensure that solr never returns partial documents query.addfilterquery(createfilterfulldocuments()); return query; }","classification":"NONSATD","isFinished":true,"code_context_2":"query.setfacetlimit(max_facet_size); query.setfacetmincount(min_facet_count); \/\/ add a filter to ensure that solr never returns partial documents query.addfilterquery(createfilterfulldocuments()); return query;","code_context_10":"\"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\", \"subject\", \"expression_of_concern\", \"retraction\"); query.addfacetfield(\"subject_facet\"); query.addfacetfield(\"author_facet\"); query.addfacetfield(\"editor_facet\"); query.addfacetfield(\"article_type_facet\"); query.addfacetfield(\"affiliate_facet\"); query.set(\"facet.method\", \"fc\"); query.setfacetlimit(max_facet_size); query.setfacetmincount(min_facet_count); \/\/ add a filter to ensure that solr never returns partial documents query.addfilterquery(createfilterfulldocuments()); return query; }","code_context_20":"if (usedismax) { query.set(\"deftype\", \"dismax\"); } \/\/todo: put the \"options\" from the \"queryfield\" picklist into a config file. \/\/this list matches the \"options\" from the \"queryfield\" picklist on unformattedsearch.ftl, \/\/without the \"date\" fields. query.setstart(startpage * pagesize); \/\/ which results element to return first in this batch. query.setrows(pagesize); \/\/ the number of results elements to return. \/\/ request only fields that we need to display query.setfields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\", \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\", \"subject\", \"expression_of_concern\", \"retraction\"); query.addfacetfield(\"subject_facet\"); query.addfacetfield(\"author_facet\"); query.addfacetfield(\"editor_facet\"); query.addfacetfield(\"article_type_facet\"); query.addfacetfield(\"affiliate_facet\"); query.set(\"facet.method\", \"fc\"); query.setfacetlimit(max_facet_size); query.setfacetmincount(min_facet_count); \/\/ add a filter to ensure that solr never returns partial documents query.addfilterquery(createfilterfulldocuments()); return query; }","repo":"AndrewGuthua\/JournalSystem"}
{"id":13361,"comment_id":0,"comment":"\/\/todo consider mulitdimensional arrays","code":"private string gettypestring(string _stypename, typeclass _atypeclass, boolean _basheadersourcecode){ string stypestring = \"\"; switch (_atypeclass.getvalue()){ case typeclass.boolean_value: stypestring = m_xlanguagesourcecodegenerator.getbooleantypedescription(); break; case typeclass.byte_value: stypestring = m_xlanguagesourcecodegenerator.getbytetypedescription(); break; case typeclass.char_value: stypestring = m_xlanguagesourcecodegenerator.getchartypedescription(); break; case typeclass.double_value: stypestring = m_xlanguagesourcecodegenerator.getdoubletypedescription(); break; case typeclass.float_value: stypestring = m_xlanguagesourcecodegenerator.getfloattypedescription(); break; case typeclass.hyper_value: stypestring = m_xlanguagesourcecodegenerator.gethypertypedescription(); break; case typeclass.long_value: stypestring = m_xlanguagesourcecodegenerator.getlongtypedescription(); break; case typeclass.short_value: stypestring = m_xlanguagesourcecodegenerator.getshorttypedescription(); break; case typeclass.string_value: stypestring = m_xlanguagesourcecodegenerator.getstringtypedescription(_basheadersourcecode); break; case typeclass.unsigned_hyper_value: stypestring = m_xlanguagesourcecodegenerator.getunsignedhypertypedescription(); break; case typeclass.unsigned_long_value: stypestring = m_xlanguagesourcecodegenerator.getunsignedlongtypedescription(); break; case typeclass.unsigned_short_value: stypestring = m_xlanguagesourcecodegenerator.getdoubletypedescription(); break; case typeclass.sequence_value: \/\/todo consider mulitdimensional arrays xtypedescription xtypedescription = introspector.getintrospector().getreferencedtype(_stypename); if (xtypedescription != null){ stypestring = gettypestring(xtypedescription.getname(), xtypedescription.gettypeclass(), _basheadersourcecode); } break; case typeclass.any_value: stypestring = m_xlanguagesourcecodegenerator.getanytypedescription(_basheadersourcecode); break; case typeclass.type_value: stypestring = m_xlanguagesourcecodegenerator.getobjecttypedescription(\"com.sun.star.uno.type\", _basheadersourcecode); break; case typeclass.enum_value: case typeclass.struct_value: case typeclass.interface_attribute_value: case typeclass.interface_method_value: case typeclass.interface_value: case typeclass.property_value: stypestring = m_xlanguagesourcecodegenerator.getobjecttypedescription(_stypename, _basheadersourcecode); break; default: } return stypestring; }","classification":"DESIGN","isFinished":true,"code_context_2":"break; case typeclass.sequence_value: \/\/todo consider mulitdimensional arrays xtypedescription xtypedescription = introspector.getintrospector().getreferencedtype(_stypename); if (xtypedescription != null){","code_context_10":"case typeclass.unsigned_hyper_value: stypestring = m_xlanguagesourcecodegenerator.getunsignedhypertypedescription(); break; case typeclass.unsigned_long_value: stypestring = m_xlanguagesourcecodegenerator.getunsignedlongtypedescription(); break; case typeclass.unsigned_short_value: stypestring = m_xlanguagesourcecodegenerator.getdoubletypedescription(); break; case typeclass.sequence_value: \/\/todo consider mulitdimensional arrays xtypedescription xtypedescription = introspector.getintrospector().getreferencedtype(_stypename); if (xtypedescription != null){ stypestring = gettypestring(xtypedescription.getname(), xtypedescription.gettypeclass(), _basheadersourcecode); } break; case typeclass.any_value: stypestring = m_xlanguagesourcecodegenerator.getanytypedescription(_basheadersourcecode); break; case typeclass.type_value: stypestring = m_xlanguagesourcecodegenerator.getobjecttypedescription(\"com.sun.star.uno.type\", _basheadersourcecode);","code_context_20":"break; case typeclass.long_value: stypestring = m_xlanguagesourcecodegenerator.getlongtypedescription(); break; case typeclass.short_value: stypestring = m_xlanguagesourcecodegenerator.getshorttypedescription(); break; case typeclass.string_value: stypestring = m_xlanguagesourcecodegenerator.getstringtypedescription(_basheadersourcecode); break; case typeclass.unsigned_hyper_value: stypestring = m_xlanguagesourcecodegenerator.getunsignedhypertypedescription(); break; case typeclass.unsigned_long_value: stypestring = m_xlanguagesourcecodegenerator.getunsignedlongtypedescription(); break; case typeclass.unsigned_short_value: stypestring = m_xlanguagesourcecodegenerator.getdoubletypedescription(); break; case typeclass.sequence_value: \/\/todo consider mulitdimensional arrays xtypedescription xtypedescription = introspector.getintrospector().getreferencedtype(_stypename); if (xtypedescription != null){ stypestring = gettypestring(xtypedescription.getname(), xtypedescription.gettypeclass(), _basheadersourcecode); } break; case typeclass.any_value: stypestring = m_xlanguagesourcecodegenerator.getanytypedescription(_basheadersourcecode); break; case typeclass.type_value: stypestring = m_xlanguagesourcecodegenerator.getobjecttypedescription(\"com.sun.star.uno.type\", _basheadersourcecode); break; case typeclass.enum_value: case typeclass.struct_value: case typeclass.interface_attribute_value: case typeclass.interface_method_value: case typeclass.interface_value: case typeclass.property_value: stypestring = m_xlanguagesourcecodegenerator.getobjecttypedescription(_stypename, _basheadersourcecode); break; default:","repo":"Grosskopf\/openoffice"}
{"id":13362,"comment_id":0,"comment":"\/\/todo consider mulitdimensional arrays","code":"private string getcentralvariablestemname(typeclass _atypeclass){ string scentralvariablestemname = \"\"; int ntypeclass = _atypeclass.getvalue(); switch(ntypeclass){ case typeclass.sequence_value: \/\/todo consider mulitdimensional arrays xtypedescription xtypedescription = introspector.getintrospector().getreferencedtype(gettypename()); if (xtypedescription != null){ scentralvariablestemname = getcentralvariablestemname(xtypedescription.gettypeclass()); } break; case typeclass.type_value: scentralvariablestemname = svariablename; break; case typeclass.struct_value: scentralvariablestemname = introspector.getshortclassname(gettypename()); break; case typeclass.interface_attribute_value: case typeclass.interface_method_value: case typeclass.interface_value: case typeclass.property_value: string sshortclassname = m_ointrospector.getshortclassname(gettypename()); scentralvariablestemname = getvariablenameforunoobject(sshortclassname); default: scentralvariablestemname = svariablename; } return scentralvariablestemname; }","classification":"DESIGN","isFinished":true,"code_context_2":"switch(ntypeclass){ case typeclass.sequence_value: \/\/todo consider mulitdimensional arrays xtypedescription xtypedescription = introspector.getintrospector().getreferencedtype(gettypename()); if (xtypedescription != null){","code_context_10":"private string getcentralvariablestemname(typeclass _atypeclass){ string scentralvariablestemname = \"\"; int ntypeclass = _atypeclass.getvalue(); switch(ntypeclass){ case typeclass.sequence_value: \/\/todo consider mulitdimensional arrays xtypedescription xtypedescription = introspector.getintrospector().getreferencedtype(gettypename()); if (xtypedescription != null){ scentralvariablestemname = getcentralvariablestemname(xtypedescription.gettypeclass()); } break; case typeclass.type_value: scentralvariablestemname = svariablename; break; case typeclass.struct_value: scentralvariablestemname = introspector.getshortclassname(gettypename());","code_context_20":"private string getcentralvariablestemname(typeclass _atypeclass){ string scentralvariablestemname = \"\"; int ntypeclass = _atypeclass.getvalue(); switch(ntypeclass){ case typeclass.sequence_value: \/\/todo consider mulitdimensional arrays xtypedescription xtypedescription = introspector.getintrospector().getreferencedtype(gettypename()); if (xtypedescription != null){ scentralvariablestemname = getcentralvariablestemname(xtypedescription.gettypeclass()); } break; case typeclass.type_value: scentralvariablestemname = svariablename; break; case typeclass.struct_value: scentralvariablestemname = introspector.getshortclassname(gettypename()); break; case typeclass.interface_attribute_value: case typeclass.interface_method_value: case typeclass.interface_value: case typeclass.property_value: string sshortclassname = m_ointrospector.getshortclassname(gettypename()); scentralvariablestemname = getvariablenameforunoobject(sshortclassname); default: scentralvariablestemname = svariablename; }","repo":"Grosskopf\/openoffice"}
{"id":13363,"comment_id":0,"comment":"\/\/todo consider mulitdimensional arrays","code":"public string getvariablestemname(typeclass _atypeclass){ int ntypeclass = _atypeclass.getvalue(); switch(ntypeclass){ case typeclass.boolean_value: svariablestemname = \"b\" + m_scentralvariablestemname; break; case typeclass.double_value: case typeclass.float_value: svariablestemname = \"f\" + m_scentralvariablestemname; break; case typeclass.byte_value: case typeclass.hyper_value: case typeclass.long_value: case typeclass.unsigned_hyper_value: case typeclass.unsigned_long_value: case typeclass.unsigned_short_value: case typeclass.short_value: svariablestemname = \"n\" + m_scentralvariablestemname; break; case typeclass.char_value: case typeclass.string_value: svariablestemname = \"s\" + m_scentralvariablestemname; break; case typeclass.sequence_value: \/\/todo consider mulitdimensional arrays xtypedescription xtypedescription = introspector.getintrospector().getreferencedtype(gettypename()); if (xtypedescription != null){ svariablestemname = getvariablestemname(xtypedescription.gettypeclass()); } break; case typeclass.type_value: svariablestemname = \"a\" + m_scentralvariablestemname; break; case typeclass.any_value: svariablestemname = \"o\" + m_scentralvariablestemname; break; case typeclass.struct_value: case typeclass.enum_value: svariablestemname = \"a\" + m_scentralvariablestemname; break; case typeclass.interface_attribute_value: case typeclass.interface_method_value: case typeclass.interface_value: case typeclass.property_value: string sshortclassname = m_ointrospector.getshortclassname(gettypename()); svariablestemname = getvariablenameforunoobject(sshortclassname); default: } return svariablestemname; }","classification":"DESIGN","isFinished":true,"code_context_2":"break; case typeclass.sequence_value: \/\/todo consider mulitdimensional arrays xtypedescription xtypedescription = introspector.getintrospector().getreferencedtype(gettypename()); if (xtypedescription != null){","code_context_10":"case typeclass.unsigned_long_value: case typeclass.unsigned_short_value: case typeclass.short_value: svariablestemname = \"n\" + m_scentralvariablestemname; break; case typeclass.char_value: case typeclass.string_value: svariablestemname = \"s\" + m_scentralvariablestemname; break; case typeclass.sequence_value: \/\/todo consider mulitdimensional arrays xtypedescription xtypedescription = introspector.getintrospector().getreferencedtype(gettypename()); if (xtypedescription != null){ svariablestemname = getvariablestemname(xtypedescription.gettypeclass()); } break; case typeclass.type_value: svariablestemname = \"a\" + m_scentralvariablestemname; break; case typeclass.any_value: svariablestemname = \"o\" + m_scentralvariablestemname;","code_context_20":"svariablestemname = \"b\" + m_scentralvariablestemname; break; case typeclass.double_value: case typeclass.float_value: svariablestemname = \"f\" + m_scentralvariablestemname; break; case typeclass.byte_value: case typeclass.hyper_value: case typeclass.long_value: case typeclass.unsigned_hyper_value: case typeclass.unsigned_long_value: case typeclass.unsigned_short_value: case typeclass.short_value: svariablestemname = \"n\" + m_scentralvariablestemname; break; case typeclass.char_value: case typeclass.string_value: svariablestemname = \"s\" + m_scentralvariablestemname; break; case typeclass.sequence_value: \/\/todo consider mulitdimensional arrays xtypedescription xtypedescription = introspector.getintrospector().getreferencedtype(gettypename()); if (xtypedescription != null){ svariablestemname = getvariablestemname(xtypedescription.gettypeclass()); } break; case typeclass.type_value: svariablestemname = \"a\" + m_scentralvariablestemname; break; case typeclass.any_value: svariablestemname = \"o\" + m_scentralvariablestemname; break; case typeclass.struct_value: case typeclass.enum_value: svariablestemname = \"a\" + m_scentralvariablestemname; break; case typeclass.interface_attribute_value: case typeclass.interface_method_value: case typeclass.interface_value: case typeclass.property_value: string sshortclassname = m_ointrospector.getshortclassname(gettypename());","repo":"Grosskopf\/openoffice"}
{"id":29971,"comment_id":0,"comment":"\/** * get the status (tag) values from the break rule(s) that determined the most * recently returned break position. the values appear in the rule source * within brackets, {123}, for example. the default status value for rules * that do not explicitly provide one is zero. * <p> * todo: not supported for dictionary based break iterator. * * @param fillinarray an array to be filled in with the status values. * @return the number of rule status values from rules that determined * the most recent boundary returned by the break iterator. * in the event that the array is too small, the return value * is the total number of status values that were available, * not the reduced number that were actually returned. * @draft icu 3.0 * @provisional this api might change or be removed in a future release. *\/","code":"\/** * get the status (tag) values from the break rule(s) that determined the most * recently returned break position. the values appear in the rule source * within brackets, {123}, for example. the default status value for rules * that do not explicitly provide one is zero. * <p> * todo: not supported for dictionary based break iterator. * * @param fillinarray an array to be filled in with the status values. * @return the number of rule status values from rules that determined * the most recent boundary returned by the break iterator. * in the event that the array is too small, the return value * is the total number of status values that were available, * not the reduced number that were actually returned. * @draft icu 3.0 * @provisional this api might change or be removed in a future release. *\/ public int getrulestatusvec(int[] fillinarray) { if (fillinarray != null && fillinarray.length>=1) { fillinarray[0] = 0; } return 1; }","classification":"DESIGN","isFinished":true,"code_context_2":"public int getrulestatusvec(int[] fillinarray) { if (fillinarray != null && fillinarray.length>=1) { fillinarray[0] = 0; } return 1; }","code_context_10":"public int getrulestatusvec(int[] fillinarray) { if (fillinarray != null && fillinarray.length>=1) { fillinarray[0] = 0; } return 1; }","code_context_20":"public int getrulestatusvec(int[] fillinarray) { if (fillinarray != null && fillinarray.length>=1) { fillinarray[0] = 0; } return 1; }","repo":"HughP\/quickdic-dictionary"}
{"id":30000,"comment_id":0,"comment":"\/\/ system.out.println(line);","code":"public void go() throws exception { bufferedreader br = new bufferedreader(new filereader(\"verilog\\\\out.log\")); string line; pattern p = pattern.compile(\".+jag rd ref=. ob=1 blt=. gpu=. \\\\$(......).*\"); long lineno = 0; int xmin[] = new int[3]; int xmax[] = new int[3]; int ymin[] = new int[3]; int ymax[] = new int[3]; long slino[] = new long[3]; long elino[] = new long[3]; for(int k = 0; k < 3; k++) { xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; } while( (line = br.readline()) != null) { lineno++; if (lineno >= 10l * 1000l * 1000l) break; matcher m = p.matcher(line); if (m.matches()) { \/\/ system.out.println(line); int addr = integer.parseint(m.group(1), 16); int index = -1; boolean wtf = false; if (addr == 0xeb40) { \/\/ olp \/\/ system.out.print(\".\"); for(int k = 0; k < 3; k++) { if (slino[k] != 0) { \/\/wtf = (ymin[k] != ymax[k]); system.out.format(\"%-9d %-9d s%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), xmin[k], ymin[k], xmax[k], ymax[k], (wtf ? \"wtf\" : \"\")); } xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; slino[k] = 0; elino[k] = 0; } system.out.println(); } \/*if (wtf) break;*\/ if (addr >= screen1 && addr < screen1 + screensize) { index = 0; addr -= screen1; } else if (addr >= screen2 && addr < screen2 + screensize) { index = 1; addr -= screen2; } else if (addr >= screen3 && addr < screen3 + screensize) { index = 2; addr -= screen3; } if (index < 0) continue; \/\/ system.out.format(\"%06x %04x\\n\", addr, val); int y = (addr >> 1) \/ width; int x = (addr >> 1) % width; \/\/ system.out.format(\"%d (%d,%d)\\n\", index, x, y); if (slino[index] == 0) slino[index] = lineno; elino[index] = lineno; if (xmin[index] > x) xmin[index] = x; if (xmax[index] < x) xmax[index] = x; if (ymin[index] > y) ymin[index] = y; if (ymax[index] < y) ymax[index] = y; } } br.close(); }","classification":"NONSATD","isFinished":true,"code_context_2":"matcher m = p.matcher(line); if (m.matches()) { \/\/ system.out.println(line); int addr = integer.parseint(m.group(1), 16); int index = -1;","code_context_10":"for(int k = 0; k < 3; k++) { xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; } while( (line = br.readline()) != null) { lineno++; if (lineno >= 10l * 1000l * 1000l) break; matcher m = p.matcher(line); if (m.matches()) { \/\/ system.out.println(line); int addr = integer.parseint(m.group(1), 16); int index = -1; boolean wtf = false; if (addr == 0xeb40) { \/\/ olp \/\/ system.out.print(\".\"); for(int k = 0; k < 3; k++) { if (slino[k] != 0) { \/\/wtf = (ymin[k] != ymax[k]); system.out.format(\"%-9d %-9d s%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), xmin[k], ymin[k], xmax[k], ymax[k],","code_context_20":"bufferedreader br = new bufferedreader(new filereader(\"verilog\\\\out.log\")); string line; pattern p = pattern.compile(\".+jag rd ref=. ob=1 blt=. gpu=. \\\\$(......).*\"); long lineno = 0; int xmin[] = new int[3]; int xmax[] = new int[3]; int ymin[] = new int[3]; int ymax[] = new int[3]; long slino[] = new long[3]; long elino[] = new long[3]; for(int k = 0; k < 3; k++) { xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; } while( (line = br.readline()) != null) { lineno++; if (lineno >= 10l * 1000l * 1000l) break; matcher m = p.matcher(line); if (m.matches()) { \/\/ system.out.println(line); int addr = integer.parseint(m.group(1), 16); int index = -1; boolean wtf = false; if (addr == 0xeb40) { \/\/ olp \/\/ system.out.print(\".\"); for(int k = 0; k < 3; k++) { if (slino[k] != 0) { \/\/wtf = (ymin[k] != ymax[k]); system.out.format(\"%-9d %-9d s%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), xmin[k], ymin[k], xmax[k], ymax[k], (wtf ? \"wtf\" : \"\")); } xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; slino[k] = 0; elino[k] = 0; } system.out.println(); } \/*if (wtf)","repo":"ElectronAsh\/jag_sim"}
{"id":30000,"comment_id":1,"comment":"\/\/ olp \/\/ system.out.print(\".\");","code":"public void go() throws exception { bufferedreader br = new bufferedreader(new filereader(\"verilog\\\\out.log\")); string line; pattern p = pattern.compile(\".+jag rd ref=. ob=1 blt=. gpu=. \\\\$(......).*\"); long lineno = 0; int xmin[] = new int[3]; int xmax[] = new int[3]; int ymin[] = new int[3]; int ymax[] = new int[3]; long slino[] = new long[3]; long elino[] = new long[3]; for(int k = 0; k < 3; k++) { xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; } while( (line = br.readline()) != null) { lineno++; if (lineno >= 10l * 1000l * 1000l) break; matcher m = p.matcher(line); if (m.matches()) { \/\/ system.out.println(line); int addr = integer.parseint(m.group(1), 16); int index = -1; boolean wtf = false; if (addr == 0xeb40) { \/\/ olp \/\/ system.out.print(\".\"); for(int k = 0; k < 3; k++) { if (slino[k] != 0) { \/\/wtf = (ymin[k] != ymax[k]); system.out.format(\"%-9d %-9d s%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), xmin[k], ymin[k], xmax[k], ymax[k], (wtf ? \"wtf\" : \"\")); } xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; slino[k] = 0; elino[k] = 0; } system.out.println(); } \/*if (wtf) break;*\/ if (addr >= screen1 && addr < screen1 + screensize) { index = 0; addr -= screen1; } else if (addr >= screen2 && addr < screen2 + screensize) { index = 1; addr -= screen2; } else if (addr >= screen3 && addr < screen3 + screensize) { index = 2; addr -= screen3; } if (index < 0) continue; \/\/ system.out.format(\"%06x %04x\\n\", addr, val); int y = (addr >> 1) \/ width; int x = (addr >> 1) % width; \/\/ system.out.format(\"%d (%d,%d)\\n\", index, x, y); if (slino[index] == 0) slino[index] = lineno; elino[index] = lineno; if (xmin[index] > x) xmin[index] = x; if (xmax[index] < x) xmax[index] = x; if (ymin[index] > y) ymin[index] = y; if (ymax[index] < y) ymax[index] = y; } } br.close(); }","classification":"NONSATD","isFinished":true,"code_context_2":"boolean wtf = false; if (addr == 0xeb40) { \/\/ olp \/\/ system.out.print(\".\"); for(int k = 0; k < 3; k++) { if (slino[k] != 0) {","code_context_10":"lineno++; if (lineno >= 10l * 1000l * 1000l) break; matcher m = p.matcher(line); if (m.matches()) { \/\/ system.out.println(line); int addr = integer.parseint(m.group(1), 16); int index = -1; boolean wtf = false; if (addr == 0xeb40) { \/\/ olp \/\/ system.out.print(\".\"); for(int k = 0; k < 3; k++) { if (slino[k] != 0) { \/\/wtf = (ymin[k] != ymax[k]); system.out.format(\"%-9d %-9d s%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), xmin[k], ymin[k], xmax[k], ymax[k], (wtf ? \"wtf\" : \"\")); } xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; slino[k] = 0; elino[k] = 0;","code_context_20":"int xmax[] = new int[3]; int ymin[] = new int[3]; int ymax[] = new int[3]; long slino[] = new long[3]; long elino[] = new long[3]; for(int k = 0; k < 3; k++) { xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; } while( (line = br.readline()) != null) { lineno++; if (lineno >= 10l * 1000l * 1000l) break; matcher m = p.matcher(line); if (m.matches()) { \/\/ system.out.println(line); int addr = integer.parseint(m.group(1), 16); int index = -1; boolean wtf = false; if (addr == 0xeb40) { \/\/ olp \/\/ system.out.print(\".\"); for(int k = 0; k < 3; k++) { if (slino[k] != 0) { \/\/wtf = (ymin[k] != ymax[k]); system.out.format(\"%-9d %-9d s%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), xmin[k], ymin[k], xmax[k], ymax[k], (wtf ? \"wtf\" : \"\")); } xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; slino[k] = 0; elino[k] = 0; } system.out.println(); } \/*if (wtf) break;*\/ if (addr >= screen1 && addr < screen1 + screensize) { index = 0; addr -= screen1; } else if (addr >= screen2 && addr < screen2 + screensize) {","repo":"ElectronAsh\/jag_sim"}
{"id":30000,"comment_id":2,"comment":"\/\/wtf = (ymin[k] != ymax[k]);","code":"public void go() throws exception { bufferedreader br = new bufferedreader(new filereader(\"verilog\\\\out.log\")); string line; pattern p = pattern.compile(\".+jag rd ref=. ob=1 blt=. gpu=. \\\\$(......).*\"); long lineno = 0; int xmin[] = new int[3]; int xmax[] = new int[3]; int ymin[] = new int[3]; int ymax[] = new int[3]; long slino[] = new long[3]; long elino[] = new long[3]; for(int k = 0; k < 3; k++) { xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; } while( (line = br.readline()) != null) { lineno++; if (lineno >= 10l * 1000l * 1000l) break; matcher m = p.matcher(line); if (m.matches()) { \/\/ system.out.println(line); int addr = integer.parseint(m.group(1), 16); int index = -1; boolean wtf = false; if (addr == 0xeb40) { \/\/ olp \/\/ system.out.print(\".\"); for(int k = 0; k < 3; k++) { if (slino[k] != 0) { \/\/wtf = (ymin[k] != ymax[k]); system.out.format(\"%-9d %-9d s%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), xmin[k], ymin[k], xmax[k], ymax[k], (wtf ? \"wtf\" : \"\")); } xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; slino[k] = 0; elino[k] = 0; } system.out.println(); } \/*if (wtf) break;*\/ if (addr >= screen1 && addr < screen1 + screensize) { index = 0; addr -= screen1; } else if (addr >= screen2 && addr < screen2 + screensize) { index = 1; addr -= screen2; } else if (addr >= screen3 && addr < screen3 + screensize) { index = 2; addr -= screen3; } if (index < 0) continue; \/\/ system.out.format(\"%06x %04x\\n\", addr, val); int y = (addr >> 1) \/ width; int x = (addr >> 1) % width; \/\/ system.out.format(\"%d (%d,%d)\\n\", index, x, y); if (slino[index] == 0) slino[index] = lineno; elino[index] = lineno; if (xmin[index] > x) xmin[index] = x; if (xmax[index] < x) xmax[index] = x; if (ymin[index] > y) ymin[index] = y; if (ymax[index] < y) ymax[index] = y; } } br.close(); }","classification":"NONSATD","isFinished":true,"code_context_2":"for(int k = 0; k < 3; k++) { if (slino[k] != 0) { \/\/wtf = (ymin[k] != ymax[k]); system.out.format(\"%-9d %-9d s%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), xmin[k], ymin[k], xmax[k], ymax[k], (wtf ? \"wtf\" : \"\"));","code_context_10":"if (m.matches()) { \/\/ system.out.println(line); int addr = integer.parseint(m.group(1), 16); int index = -1; boolean wtf = false; if (addr == 0xeb40) { \/\/ olp \/\/ system.out.print(\".\"); for(int k = 0; k < 3; k++) { if (slino[k] != 0) { \/\/wtf = (ymin[k] != ymax[k]); system.out.format(\"%-9d %-9d s%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), xmin[k], ymin[k], xmax[k], ymax[k], (wtf ? \"wtf\" : \"\")); } xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; slino[k] = 0; elino[k] = 0; } system.out.println(); }","code_context_20":"long elino[] = new long[3]; for(int k = 0; k < 3; k++) { xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; } while( (line = br.readline()) != null) { lineno++; if (lineno >= 10l * 1000l * 1000l) break; matcher m = p.matcher(line); if (m.matches()) { \/\/ system.out.println(line); int addr = integer.parseint(m.group(1), 16); int index = -1; boolean wtf = false; if (addr == 0xeb40) { \/\/ olp \/\/ system.out.print(\".\"); for(int k = 0; k < 3; k++) { if (slino[k] != 0) { \/\/wtf = (ymin[k] != ymax[k]); system.out.format(\"%-9d %-9d s%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), xmin[k], ymin[k], xmax[k], ymax[k], (wtf ? \"wtf\" : \"\")); } xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; slino[k] = 0; elino[k] = 0; } system.out.println(); } \/*if (wtf) break;*\/ if (addr >= screen1 && addr < screen1 + screensize) { index = 0; addr -= screen1; } else if (addr >= screen2 && addr < screen2 + screensize) { index = 1; addr -= screen2; }","repo":"ElectronAsh\/jag_sim"}
{"id":30000,"comment_id":3,"comment":"\/*if (wtf) break;*\/","code":"public void go() throws exception { bufferedreader br = new bufferedreader(new filereader(\"verilog\\\\out.log\")); string line; pattern p = pattern.compile(\".+jag rd ref=. ob=1 blt=. gpu=. \\\\$(......).*\"); long lineno = 0; int xmin[] = new int[3]; int xmax[] = new int[3]; int ymin[] = new int[3]; int ymax[] = new int[3]; long slino[] = new long[3]; long elino[] = new long[3]; for(int k = 0; k < 3; k++) { xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; } while( (line = br.readline()) != null) { lineno++; if (lineno >= 10l * 1000l * 1000l) break; matcher m = p.matcher(line); if (m.matches()) { \/\/ system.out.println(line); int addr = integer.parseint(m.group(1), 16); int index = -1; boolean wtf = false; if (addr == 0xeb40) { \/\/ olp \/\/ system.out.print(\".\"); for(int k = 0; k < 3; k++) { if (slino[k] != 0) { \/\/wtf = (ymin[k] != ymax[k]); system.out.format(\"%-9d %-9d s%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), xmin[k], ymin[k], xmax[k], ymax[k], (wtf ? \"wtf\" : \"\")); } xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; slino[k] = 0; elino[k] = 0; } system.out.println(); } \/*if (wtf) break;*\/ if (addr >= screen1 && addr < screen1 + screensize) { index = 0; addr -= screen1; } else if (addr >= screen2 && addr < screen2 + screensize) { index = 1; addr -= screen2; } else if (addr >= screen3 && addr < screen3 + screensize) { index = 2; addr -= screen3; } if (index < 0) continue; \/\/ system.out.format(\"%06x %04x\\n\", addr, val); int y = (addr >> 1) \/ width; int x = (addr >> 1) % width; \/\/ system.out.format(\"%d (%d,%d)\\n\", index, x, y); if (slino[index] == 0) slino[index] = lineno; elino[index] = lineno; if (xmin[index] > x) xmin[index] = x; if (xmax[index] < x) xmax[index] = x; if (ymin[index] > y) ymin[index] = y; if (ymax[index] < y) ymax[index] = y; } } br.close(); }","classification":"NONSATD","isFinished":true,"code_context_2":"system.out.println(); } \/*if (wtf) break;*\/ if (addr >= screen1 && addr < screen1 + screensize) { index = 0;","code_context_10":"system.out.format(\"%-9d %-9d s%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), xmin[k], ymin[k], xmax[k], ymax[k], (wtf ? \"wtf\" : \"\")); } xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; slino[k] = 0; elino[k] = 0; } system.out.println(); } \/*if (wtf) break;*\/ if (addr >= screen1 && addr < screen1 + screensize) { index = 0; addr -= screen1; } else if (addr >= screen2 && addr < screen2 + screensize) { index = 1; addr -= screen2; } else if (addr >= screen3 && addr < screen3 + screensize) { index = 2;","code_context_20":"\/\/ system.out.println(line); int addr = integer.parseint(m.group(1), 16); int index = -1; boolean wtf = false; if (addr == 0xeb40) { \/\/ olp \/\/ system.out.print(\".\"); for(int k = 0; k < 3; k++) { if (slino[k] != 0) { \/\/wtf = (ymin[k] != ymax[k]); system.out.format(\"%-9d %-9d s%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), xmin[k], ymin[k], xmax[k], ymax[k], (wtf ? \"wtf\" : \"\")); } xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; slino[k] = 0; elino[k] = 0; } system.out.println(); } \/*if (wtf) break;*\/ if (addr >= screen1 && addr < screen1 + screensize) { index = 0; addr -= screen1; } else if (addr >= screen2 && addr < screen2 + screensize) { index = 1; addr -= screen2; } else if (addr >= screen3 && addr < screen3 + screensize) { index = 2; addr -= screen3; } if (index < 0) continue; \/\/ system.out.format(\"%06x %04x\\n\", addr, val); int y = (addr >> 1) \/ width; int x = (addr >> 1) % width; \/\/ system.out.format(\"%d (%d,%d)\\n\", index, x, y); if (slino[index] == 0) slino[index] = lineno;","repo":"ElectronAsh\/jag_sim"}
{"id":30000,"comment_id":4,"comment":"\/\/ system.out.format(\"%06x %04x\\n\", addr, val);","code":"public void go() throws exception { bufferedreader br = new bufferedreader(new filereader(\"verilog\\\\out.log\")); string line; pattern p = pattern.compile(\".+jag rd ref=. ob=1 blt=. gpu=. \\\\$(......).*\"); long lineno = 0; int xmin[] = new int[3]; int xmax[] = new int[3]; int ymin[] = new int[3]; int ymax[] = new int[3]; long slino[] = new long[3]; long elino[] = new long[3]; for(int k = 0; k < 3; k++) { xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; } while( (line = br.readline()) != null) { lineno++; if (lineno >= 10l * 1000l * 1000l) break; matcher m = p.matcher(line); if (m.matches()) { \/\/ system.out.println(line); int addr = integer.parseint(m.group(1), 16); int index = -1; boolean wtf = false; if (addr == 0xeb40) { \/\/ olp \/\/ system.out.print(\".\"); for(int k = 0; k < 3; k++) { if (slino[k] != 0) { \/\/wtf = (ymin[k] != ymax[k]); system.out.format(\"%-9d %-9d s%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), xmin[k], ymin[k], xmax[k], ymax[k], (wtf ? \"wtf\" : \"\")); } xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; slino[k] = 0; elino[k] = 0; } system.out.println(); } \/*if (wtf) break;*\/ if (addr >= screen1 && addr < screen1 + screensize) { index = 0; addr -= screen1; } else if (addr >= screen2 && addr < screen2 + screensize) { index = 1; addr -= screen2; } else if (addr >= screen3 && addr < screen3 + screensize) { index = 2; addr -= screen3; } if (index < 0) continue; \/\/ system.out.format(\"%06x %04x\\n\", addr, val); int y = (addr >> 1) \/ width; int x = (addr >> 1) % width; \/\/ system.out.format(\"%d (%d,%d)\\n\", index, x, y); if (slino[index] == 0) slino[index] = lineno; elino[index] = lineno; if (xmin[index] > x) xmin[index] = x; if (xmax[index] < x) xmax[index] = x; if (ymin[index] > y) ymin[index] = y; if (ymax[index] < y) ymax[index] = y; } } br.close(); }","classification":"NONSATD","isFinished":true,"code_context_2":"if (index < 0) continue; \/\/ system.out.format(\"%06x %04x\\n\", addr, val); int y = (addr >> 1) \/ width; int x = (addr >> 1) % width;","code_context_10":"else if (addr >= screen2 && addr < screen2 + screensize) { index = 1; addr -= screen2; } else if (addr >= screen3 && addr < screen3 + screensize) { index = 2; addr -= screen3; } if (index < 0) continue; \/\/ system.out.format(\"%06x %04x\\n\", addr, val); int y = (addr >> 1) \/ width; int x = (addr >> 1) % width; \/\/ system.out.format(\"%d (%d,%d)\\n\", index, x, y); if (slino[index] == 0) slino[index] = lineno; elino[index] = lineno; if (xmin[index] > x) xmin[index] = x; if (xmax[index] < x) xmax[index] = x;","code_context_20":"elino[k] = 0; } system.out.println(); } \/*if (wtf) break;*\/ if (addr >= screen1 && addr < screen1 + screensize) { index = 0; addr -= screen1; } else if (addr >= screen2 && addr < screen2 + screensize) { index = 1; addr -= screen2; } else if (addr >= screen3 && addr < screen3 + screensize) { index = 2; addr -= screen3; } if (index < 0) continue; \/\/ system.out.format(\"%06x %04x\\n\", addr, val); int y = (addr >> 1) \/ width; int x = (addr >> 1) % width; \/\/ system.out.format(\"%d (%d,%d)\\n\", index, x, y); if (slino[index] == 0) slino[index] = lineno; elino[index] = lineno; if (xmin[index] > x) xmin[index] = x; if (xmax[index] < x) xmax[index] = x; if (ymin[index] > y) ymin[index] = y; if (ymax[index] < y) ymax[index] = y; } } br.close(); }","repo":"ElectronAsh\/jag_sim"}
{"id":30000,"comment_id":5,"comment":"\/\/ system.out.format(\"%d (%d,%d)\\n\", index, x, y);","code":"public void go() throws exception { bufferedreader br = new bufferedreader(new filereader(\"verilog\\\\out.log\")); string line; pattern p = pattern.compile(\".+jag rd ref=. ob=1 blt=. gpu=. \\\\$(......).*\"); long lineno = 0; int xmin[] = new int[3]; int xmax[] = new int[3]; int ymin[] = new int[3]; int ymax[] = new int[3]; long slino[] = new long[3]; long elino[] = new long[3]; for(int k = 0; k < 3; k++) { xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; } while( (line = br.readline()) != null) { lineno++; if (lineno >= 10l * 1000l * 1000l) break; matcher m = p.matcher(line); if (m.matches()) { \/\/ system.out.println(line); int addr = integer.parseint(m.group(1), 16); int index = -1; boolean wtf = false; if (addr == 0xeb40) { \/\/ olp \/\/ system.out.print(\".\"); for(int k = 0; k < 3; k++) { if (slino[k] != 0) { \/\/wtf = (ymin[k] != ymax[k]); system.out.format(\"%-9d %-9d s%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), xmin[k], ymin[k], xmax[k], ymax[k], (wtf ? \"wtf\" : \"\")); } xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; slino[k] = 0; elino[k] = 0; } system.out.println(); } \/*if (wtf) break;*\/ if (addr >= screen1 && addr < screen1 + screensize) { index = 0; addr -= screen1; } else if (addr >= screen2 && addr < screen2 + screensize) { index = 1; addr -= screen2; } else if (addr >= screen3 && addr < screen3 + screensize) { index = 2; addr -= screen3; } if (index < 0) continue; \/\/ system.out.format(\"%06x %04x\\n\", addr, val); int y = (addr >> 1) \/ width; int x = (addr >> 1) % width; \/\/ system.out.format(\"%d (%d,%d)\\n\", index, x, y); if (slino[index] == 0) slino[index] = lineno; elino[index] = lineno; if (xmin[index] > x) xmin[index] = x; if (xmax[index] < x) xmax[index] = x; if (ymin[index] > y) ymin[index] = y; if (ymax[index] < y) ymax[index] = y; } } br.close(); }","classification":"NONSATD","isFinished":true,"code_context_2":"int y = (addr >> 1) \/ width; int x = (addr >> 1) % width; \/\/ system.out.format(\"%d (%d,%d)\\n\", index, x, y); if (slino[index] == 0) slino[index] = lineno;","code_context_10":"} else if (addr >= screen3 && addr < screen3 + screensize) { index = 2; addr -= screen3; } if (index < 0) continue; \/\/ system.out.format(\"%06x %04x\\n\", addr, val); int y = (addr >> 1) \/ width; int x = (addr >> 1) % width; \/\/ system.out.format(\"%d (%d,%d)\\n\", index, x, y); if (slino[index] == 0) slino[index] = lineno; elino[index] = lineno; if (xmin[index] > x) xmin[index] = x; if (xmax[index] < x) xmax[index] = x; if (ymin[index] > y) ymin[index] = y; if (ymax[index] < y)","code_context_20":"} \/*if (wtf) break;*\/ if (addr >= screen1 && addr < screen1 + screensize) { index = 0; addr -= screen1; } else if (addr >= screen2 && addr < screen2 + screensize) { index = 1; addr -= screen2; } else if (addr >= screen3 && addr < screen3 + screensize) { index = 2; addr -= screen3; } if (index < 0) continue; \/\/ system.out.format(\"%06x %04x\\n\", addr, val); int y = (addr >> 1) \/ width; int x = (addr >> 1) % width; \/\/ system.out.format(\"%d (%d,%d)\\n\", index, x, y); if (slino[index] == 0) slino[index] = lineno; elino[index] = lineno; if (xmin[index] > x) xmin[index] = x; if (xmax[index] < x) xmax[index] = x; if (ymin[index] > y) ymin[index] = y; if (ymax[index] < y) ymax[index] = y; } } br.close(); }","repo":"ElectronAsh\/jag_sim"}
{"id":21824,"comment_id":0,"comment":"\/\/ @todo: replace with stringbuilder","code":"private void downloadmedia(mediafileinfo fileinfo) { if (fileinfo == null) { return; } int mediaid = fileinfo.getid(); getdelegate(fileinfo.gettype()).ondownloadmedia(fileinfo) .thenacceptasync((result) -> { \/\/ @todo: replace with stringbuilder if (result != null && result.issuccessful()) { logger.info(\"downloading of media id=\" + mediaid + \" succeeded.\"); asynctask.execute(() -> { \/\/ result contains the local file uri if successful mediafiledao.setlocaluri(mediaid, result.unwrap()); }); } else { logger.warn(\"downloading of media id=\" + mediaid + \" failed.\"); if (result.geterrortype() == actionresult.network_error) { logger.warn(\"due to network error.\"); } else { logger.warn(\"due to unknown error.\"); } } }).exceptionally((e) -> { logger.error(\"downloading of media id=\" + mediaid + \" failed spectacularly:\"); e.printstacktrace(); return null; }); }","classification":"DESIGN","isFinished":true,"code_context_2":"getdelegate(fileinfo.gettype()).ondownloadmedia(fileinfo) .thenacceptasync((result) -> { \/\/ @todo: replace with stringbuilder if (result != null && result.issuccessful()) { logger.info(\"downloading of media id=\" + mediaid + \" succeeded.\");","code_context_10":"private void downloadmedia(mediafileinfo fileinfo) { if (fileinfo == null) { return; } int mediaid = fileinfo.getid(); getdelegate(fileinfo.gettype()).ondownloadmedia(fileinfo) .thenacceptasync((result) -> { \/\/ @todo: replace with stringbuilder if (result != null && result.issuccessful()) { logger.info(\"downloading of media id=\" + mediaid + \" succeeded.\"); asynctask.execute(() -> { \/\/ result contains the local file uri if successful mediafiledao.setlocaluri(mediaid, result.unwrap()); }); } else { logger.warn(\"downloading of media id=\" + mediaid + \" failed.\"); if (result.geterrortype() == actionresult.network_error) { logger.warn(\"due to network error.\");","code_context_20":"private void downloadmedia(mediafileinfo fileinfo) { if (fileinfo == null) { return; } int mediaid = fileinfo.getid(); getdelegate(fileinfo.gettype()).ondownloadmedia(fileinfo) .thenacceptasync((result) -> { \/\/ @todo: replace with stringbuilder if (result != null && result.issuccessful()) { logger.info(\"downloading of media id=\" + mediaid + \" succeeded.\"); asynctask.execute(() -> { \/\/ result contains the local file uri if successful mediafiledao.setlocaluri(mediaid, result.unwrap()); }); } else { logger.warn(\"downloading of media id=\" + mediaid + \" failed.\"); if (result.geterrortype() == actionresult.network_error) { logger.warn(\"due to network error.\"); } else { logger.warn(\"due to unknown error.\"); } } }).exceptionally((e) -> { logger.error(\"downloading of media id=\" + mediaid + \" failed spectacularly:\"); e.printstacktrace(); return null; }); }","repo":"COMP30022-Russia\/Russia_Client"}
{"id":21824,"comment_id":1,"comment":"\/\/ result contains the local file uri if successful","code":"private void downloadmedia(mediafileinfo fileinfo) { if (fileinfo == null) { return; } int mediaid = fileinfo.getid(); getdelegate(fileinfo.gettype()).ondownloadmedia(fileinfo) .thenacceptasync((result) -> { \/\/ @todo: replace with stringbuilder if (result != null && result.issuccessful()) { logger.info(\"downloading of media id=\" + mediaid + \" succeeded.\"); asynctask.execute(() -> { \/\/ result contains the local file uri if successful mediafiledao.setlocaluri(mediaid, result.unwrap()); }); } else { logger.warn(\"downloading of media id=\" + mediaid + \" failed.\"); if (result.geterrortype() == actionresult.network_error) { logger.warn(\"due to network error.\"); } else { logger.warn(\"due to unknown error.\"); } } }).exceptionally((e) -> { logger.error(\"downloading of media id=\" + mediaid + \" failed spectacularly:\"); e.printstacktrace(); return null; }); }","classification":"NONSATD","isFinished":true,"code_context_2":"logger.info(\"downloading of media id=\" + mediaid + \" succeeded.\"); asynctask.execute(() -> { \/\/ result contains the local file uri if successful mediafiledao.setlocaluri(mediaid, result.unwrap()); });","code_context_10":"if (fileinfo == null) { return; } int mediaid = fileinfo.getid(); getdelegate(fileinfo.gettype()).ondownloadmedia(fileinfo) .thenacceptasync((result) -> { \/\/ @todo: replace with stringbuilder if (result != null && result.issuccessful()) { logger.info(\"downloading of media id=\" + mediaid + \" succeeded.\"); asynctask.execute(() -> { \/\/ result contains the local file uri if successful mediafiledao.setlocaluri(mediaid, result.unwrap()); }); } else { logger.warn(\"downloading of media id=\" + mediaid + \" failed.\"); if (result.geterrortype() == actionresult.network_error) { logger.warn(\"due to network error.\"); } else { logger.warn(\"due to unknown error.\"); } }","code_context_20":"private void downloadmedia(mediafileinfo fileinfo) { if (fileinfo == null) { return; } int mediaid = fileinfo.getid(); getdelegate(fileinfo.gettype()).ondownloadmedia(fileinfo) .thenacceptasync((result) -> { \/\/ @todo: replace with stringbuilder if (result != null && result.issuccessful()) { logger.info(\"downloading of media id=\" + mediaid + \" succeeded.\"); asynctask.execute(() -> { \/\/ result contains the local file uri if successful mediafiledao.setlocaluri(mediaid, result.unwrap()); }); } else { logger.warn(\"downloading of media id=\" + mediaid + \" failed.\"); if (result.geterrortype() == actionresult.network_error) { logger.warn(\"due to network error.\"); } else { logger.warn(\"due to unknown error.\"); } } }).exceptionally((e) -> { logger.error(\"downloading of media id=\" + mediaid + \" failed spectacularly:\"); e.printstacktrace(); return null; }); }","repo":"COMP30022-Russia\/Russia_Client"}
{"id":21825,"comment_id":0,"comment":"\/\/ @todo: replace with stringbuilder","code":"private completablefuture<void> uploadmedia(mediafileinfo fileinfo) { if (fileinfo == null) { return completablefuture.completedfuture(null); } int mediaid = fileinfo.getid(); return getdelegate(fileinfo.gettype()).onuploadmedia(fileinfo) .thenacceptasync((result) -> { \/\/ @todo: replace with stringbuilder if (result != null && result.issuccessful()) { logger.info(\"uploading of media id=\" + mediaid + \" succeeded.\"); asynctask.execute(() -> { mediafiledao.insertorupdate(fileinfo); mediafiledao.setremoteavailable(mediaid); }); } else { logger.warn(\"uploading of media id=\" + mediaid + \" failed.\"); if (result.geterrortype() == actionresult.network_error) { logger.warn(\"due to network error.\"); } else { logger.warn(\"due to unknown error.\"); } } }).exceptionally((e) -> { logger.error(\"uploading of media id=\" + mediaid + \" failed spectacularly:\"); e.printstacktrace(); return null; }); }","classification":"DESIGN","isFinished":true,"code_context_2":"return getdelegate(fileinfo.gettype()).onuploadmedia(fileinfo) .thenacceptasync((result) -> { \/\/ @todo: replace with stringbuilder if (result != null && result.issuccessful()) { logger.info(\"uploading of media id=\" + mediaid + \" succeeded.\");","code_context_10":"private completablefuture<void> uploadmedia(mediafileinfo fileinfo) { if (fileinfo == null) { return completablefuture.completedfuture(null); } int mediaid = fileinfo.getid(); return getdelegate(fileinfo.gettype()).onuploadmedia(fileinfo) .thenacceptasync((result) -> { \/\/ @todo: replace with stringbuilder if (result != null && result.issuccessful()) { logger.info(\"uploading of media id=\" + mediaid + \" succeeded.\"); asynctask.execute(() -> { mediafiledao.insertorupdate(fileinfo); mediafiledao.setremoteavailable(mediaid); }); } else { logger.warn(\"uploading of media id=\" + mediaid + \" failed.\"); if (result.geterrortype() == actionresult.network_error) { logger.warn(\"due to network error.\");","code_context_20":"private completablefuture<void> uploadmedia(mediafileinfo fileinfo) { if (fileinfo == null) { return completablefuture.completedfuture(null); } int mediaid = fileinfo.getid(); return getdelegate(fileinfo.gettype()).onuploadmedia(fileinfo) .thenacceptasync((result) -> { \/\/ @todo: replace with stringbuilder if (result != null && result.issuccessful()) { logger.info(\"uploading of media id=\" + mediaid + \" succeeded.\"); asynctask.execute(() -> { mediafiledao.insertorupdate(fileinfo); mediafiledao.setremoteavailable(mediaid); }); } else { logger.warn(\"uploading of media id=\" + mediaid + \" failed.\"); if (result.geterrortype() == actionresult.network_error) { logger.warn(\"due to network error.\"); } else { logger.warn(\"due to unknown error.\"); } } }).exceptionally((e) -> { logger.error(\"uploading of media id=\" + mediaid + \" failed spectacularly:\"); e.printstacktrace(); return null; }); }","repo":"COMP30022-Russia\/Russia_Client"}
{"id":13695,"comment_id":0,"comment":"\/\/ create config for trajectory \/*trajectoryconfig config = new trajectoryconfig(constants.maxmecspeed,constants.maxmecacceleration) \/\/ add kinematics to ensure max speed is actually obeyed .setkinematics(mecdrivetrain.getmeckinetimatics()); \/\/ an example trajectory to follow. all units in meters. trajectory exampletrajectory = trajectorygenerator.generatetrajectory( \/\/ start at the origin facing the +x direction new pose2d(0, 0, new rotation2d(0)), \/\/ pass through these two interior waypoints, making an 's' curve path list.of(new translation2d(1, 1), new translation2d(2, -1)), \/\/ end 3 meters straight ahead of where we started, facing forward new pose2d(3, 0, new rotation2d(0)), config);*\/","code":"public static command getmeccontrollercommand(pathplannertrajectory pptrajectory, mecdrivetrain mecdrivetrain) { \/\/ create config for trajectory \/*trajectoryconfig config = new trajectoryconfig(constants.maxmecspeed,constants.maxmecacceleration) \/\/ add kinematics to ensure max speed is actually obeyed .setkinematics(mecdrivetrain.getmeckinetimatics()); \/\/ an example trajectory to follow. all units in meters. trajectory exampletrajectory = trajectorygenerator.generatetrajectory( \/\/ start at the origin facing the +x direction new pose2d(0, 0, new rotation2d(0)), \/\/ pass through these two interior waypoints, making an 's' curve path list.of(new translation2d(1, 1), new translation2d(2, -1)), \/\/ end 3 meters straight ahead of where we started, facing forward new pose2d(3, 0, new rotation2d(0)), config);*\/ profiledpidcontroller thetacontroller = new profiledpidcontroller(constants.kpmecthetacontroller, 0., 0., new constraints(constants.maxmecrotationvelocity, constants.maxmecrotationaccel)); thetacontroller.enablecontinuousinput(-math.pi, math.pi); thetacontroller.reset(robotstate.getposeestimate().getrotation().getradians()); \/\/mecdrivetrain.setpose(pptrajectory.getinitialpose()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory, robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages mecdrivetrain ); \/\/pathplannerstate initialstate = pptrajectory.getinitialstate(); \/*return new instantcommand(() -> mecdrivetrain.setpose(new pose2d(initialstate.posemeters.gettranslation(), initialstate.holonomicrotation))) .andthen(mecanumcontrollercommand); \/\/.andthen(mecdrivetrain::stopdrive);*\/ return mecanumcontrollercommand; }","classification":"NONSATD","isFinished":true,"code_context_2":"public static command getmeccontrollercommand(pathplannertrajectory pptrajectory, mecdrivetrain mecdrivetrain) { \/\/ create config for trajectory \/*trajectoryconfig config = new trajectoryconfig(constants.maxmecspeed,constants.maxmecacceleration) \/\/ add kinematics to ensure max speed is actually obeyed .setkinematics(mecdrivetrain.getmeckinetimatics()); \/\/ an example trajectory to follow. all units in meters. trajectory exampletrajectory = trajectorygenerator.generatetrajectory( \/\/ start at the origin facing the +x direction new pose2d(0, 0, new rotation2d(0)), \/\/ pass through these two interior waypoints, making an 's' curve path list.of(new translation2d(1, 1), new translation2d(2, -1)), \/\/ end 3 meters straight ahead of where we started, facing forward new pose2d(3, 0, new rotation2d(0)), config);*\/ profiledpidcontroller thetacontroller = new profiledpidcontroller(constants.kpmecthetacontroller, 0., 0., new constraints(constants.maxmecrotationvelocity, constants.maxmecrotationaccel));","code_context_10":"public static command getmeccontrollercommand(pathplannertrajectory pptrajectory, mecdrivetrain mecdrivetrain) { \/\/ create config for trajectory \/*trajectoryconfig config = new trajectoryconfig(constants.maxmecspeed,constants.maxmecacceleration) \/\/ add kinematics to ensure max speed is actually obeyed .setkinematics(mecdrivetrain.getmeckinetimatics()); \/\/ an example trajectory to follow. all units in meters. trajectory exampletrajectory = trajectorygenerator.generatetrajectory( \/\/ start at the origin facing the +x direction new pose2d(0, 0, new rotation2d(0)), \/\/ pass through these two interior waypoints, making an 's' curve path list.of(new translation2d(1, 1), new translation2d(2, -1)), \/\/ end 3 meters straight ahead of where we started, facing forward new pose2d(3, 0, new rotation2d(0)), config);*\/ profiledpidcontroller thetacontroller = new profiledpidcontroller(constants.kpmecthetacontroller, 0., 0., new constraints(constants.maxmecrotationvelocity, constants.maxmecrotationaccel)); thetacontroller.enablecontinuousinput(-math.pi, math.pi); thetacontroller.reset(robotstate.getposeestimate().getrotation().getradians()); \/\/mecdrivetrain.setpose(pptrajectory.getinitialpose()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory, robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method","code_context_20":"public static command getmeccontrollercommand(pathplannertrajectory pptrajectory, mecdrivetrain mecdrivetrain) { \/\/ create config for trajectory \/*trajectoryconfig config = new trajectoryconfig(constants.maxmecspeed,constants.maxmecacceleration) \/\/ add kinematics to ensure max speed is actually obeyed .setkinematics(mecdrivetrain.getmeckinetimatics()); \/\/ an example trajectory to follow. all units in meters. trajectory exampletrajectory = trajectorygenerator.generatetrajectory( \/\/ start at the origin facing the +x direction new pose2d(0, 0, new rotation2d(0)), \/\/ pass through these two interior waypoints, making an 's' curve path list.of(new translation2d(1, 1), new translation2d(2, -1)), \/\/ end 3 meters straight ahead of where we started, facing forward new pose2d(3, 0, new rotation2d(0)), config);*\/ profiledpidcontroller thetacontroller = new profiledpidcontroller(constants.kpmecthetacontroller, 0., 0., new constraints(constants.maxmecrotationvelocity, constants.maxmecrotationaccel)); thetacontroller.enablecontinuousinput(-math.pi, math.pi); thetacontroller.reset(robotstate.getposeestimate().getrotation().getradians()); \/\/mecdrivetrain.setpose(pptrajectory.getinitialpose()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory, robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0),","repo":"FRC6302\/2022Bot1"}
{"id":13695,"comment_id":1,"comment":"\/\/mecdrivetrain.setpose(pptrajectory.getinitialpose());","code":"public static command getmeccontrollercommand(pathplannertrajectory pptrajectory, mecdrivetrain mecdrivetrain) { \/\/ create config for trajectory \/*trajectoryconfig config = new trajectoryconfig(constants.maxmecspeed,constants.maxmecacceleration) \/\/ add kinematics to ensure max speed is actually obeyed .setkinematics(mecdrivetrain.getmeckinetimatics()); \/\/ an example trajectory to follow. all units in meters. trajectory exampletrajectory = trajectorygenerator.generatetrajectory( \/\/ start at the origin facing the +x direction new pose2d(0, 0, new rotation2d(0)), \/\/ pass through these two interior waypoints, making an 's' curve path list.of(new translation2d(1, 1), new translation2d(2, -1)), \/\/ end 3 meters straight ahead of where we started, facing forward new pose2d(3, 0, new rotation2d(0)), config);*\/ profiledpidcontroller thetacontroller = new profiledpidcontroller(constants.kpmecthetacontroller, 0., 0., new constraints(constants.maxmecrotationvelocity, constants.maxmecrotationaccel)); thetacontroller.enablecontinuousinput(-math.pi, math.pi); thetacontroller.reset(robotstate.getposeestimate().getrotation().getradians()); \/\/mecdrivetrain.setpose(pptrajectory.getinitialpose()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory, robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages mecdrivetrain ); \/\/pathplannerstate initialstate = pptrajectory.getinitialstate(); \/*return new instantcommand(() -> mecdrivetrain.setpose(new pose2d(initialstate.posemeters.gettranslation(), initialstate.holonomicrotation))) .andthen(mecanumcontrollercommand); \/\/.andthen(mecdrivetrain::stopdrive);*\/ return mecanumcontrollercommand; }","classification":"NONSATD","isFinished":true,"code_context_2":"thetacontroller.enablecontinuousinput(-math.pi, math.pi); thetacontroller.reset(robotstate.getposeestimate().getrotation().getradians()); \/\/mecdrivetrain.setpose(pptrajectory.getinitialpose()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory,","code_context_10":"new pose2d(0, 0, new rotation2d(0)), \/\/ pass through these two interior waypoints, making an 's' curve path list.of(new translation2d(1, 1), new translation2d(2, -1)), \/\/ end 3 meters straight ahead of where we started, facing forward new pose2d(3, 0, new rotation2d(0)), config);*\/ profiledpidcontroller thetacontroller = new profiledpidcontroller(constants.kpmecthetacontroller, 0., 0., new constraints(constants.maxmecrotationvelocity, constants.maxmecrotationaccel)); thetacontroller.enablecontinuousinput(-math.pi, math.pi); thetacontroller.reset(robotstate.getposeestimate().getrotation().getradians()); \/\/mecdrivetrain.setpose(pptrajectory.getinitialpose()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory, robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0),","code_context_20":"public static command getmeccontrollercommand(pathplannertrajectory pptrajectory, mecdrivetrain mecdrivetrain) { \/\/ create config for trajectory \/*trajectoryconfig config = new trajectoryconfig(constants.maxmecspeed,constants.maxmecacceleration) \/\/ add kinematics to ensure max speed is actually obeyed .setkinematics(mecdrivetrain.getmeckinetimatics()); \/\/ an example trajectory to follow. all units in meters. trajectory exampletrajectory = trajectorygenerator.generatetrajectory( \/\/ start at the origin facing the +x direction new pose2d(0, 0, new rotation2d(0)), \/\/ pass through these two interior waypoints, making an 's' curve path list.of(new translation2d(1, 1), new translation2d(2, -1)), \/\/ end 3 meters straight ahead of where we started, facing forward new pose2d(3, 0, new rotation2d(0)), config);*\/ profiledpidcontroller thetacontroller = new profiledpidcontroller(constants.kpmecthetacontroller, 0., 0., new constraints(constants.maxmecrotationvelocity, constants.maxmecrotationaccel)); thetacontroller.enablecontinuousinput(-math.pi, math.pi); thetacontroller.reset(robotstate.getposeestimate().getrotation().getradians()); \/\/mecdrivetrain.setpose(pptrajectory.getinitialpose()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory, robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages","repo":"FRC6302\/2022Bot1"}
{"id":13695,"comment_id":2,"comment":"\/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(),","code":"public static command getmeccontrollercommand(pathplannertrajectory pptrajectory, mecdrivetrain mecdrivetrain) { \/\/ create config for trajectory \/*trajectoryconfig config = new trajectoryconfig(constants.maxmecspeed,constants.maxmecacceleration) \/\/ add kinematics to ensure max speed is actually obeyed .setkinematics(mecdrivetrain.getmeckinetimatics()); \/\/ an example trajectory to follow. all units in meters. trajectory exampletrajectory = trajectorygenerator.generatetrajectory( \/\/ start at the origin facing the +x direction new pose2d(0, 0, new rotation2d(0)), \/\/ pass through these two interior waypoints, making an 's' curve path list.of(new translation2d(1, 1), new translation2d(2, -1)), \/\/ end 3 meters straight ahead of where we started, facing forward new pose2d(3, 0, new rotation2d(0)), config);*\/ profiledpidcontroller thetacontroller = new profiledpidcontroller(constants.kpmecthetacontroller, 0., 0., new constraints(constants.maxmecrotationvelocity, constants.maxmecrotationaccel)); thetacontroller.enablecontinuousinput(-math.pi, math.pi); thetacontroller.reset(robotstate.getposeestimate().getrotation().getradians()); \/\/mecdrivetrain.setpose(pptrajectory.getinitialpose()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory, robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages mecdrivetrain ); \/\/pathplannerstate initialstate = pptrajectory.getinitialstate(); \/*return new instantcommand(() -> mecdrivetrain.setpose(new pose2d(initialstate.posemeters.gettranslation(), initialstate.holonomicrotation))) .andthen(mecanumcontrollercommand); \/\/.andthen(mecdrivetrain::stopdrive);*\/ return mecanumcontrollercommand; }","classification":"DESIGN","isFinished":true,"code_context_2":"pptrajectory, robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers","code_context_10":"new pose2d(3, 0, new rotation2d(0)), config);*\/ profiledpidcontroller thetacontroller = new profiledpidcontroller(constants.kpmecthetacontroller, 0., 0., new constraints(constants.maxmecrotationvelocity, constants.maxmecrotationaccel)); thetacontroller.enablecontinuousinput(-math.pi, math.pi); thetacontroller.reset(robotstate.getposeestimate().getrotation().getradians()); \/\/mecdrivetrain.setpose(pptrajectory.getinitialpose()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory, robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0),","code_context_20":"\/\/ add kinematics to ensure max speed is actually obeyed .setkinematics(mecdrivetrain.getmeckinetimatics()); \/\/ an example trajectory to follow. all units in meters. trajectory exampletrajectory = trajectorygenerator.generatetrajectory( \/\/ start at the origin facing the +x direction new pose2d(0, 0, new rotation2d(0)), \/\/ pass through these two interior waypoints, making an 's' curve path list.of(new translation2d(1, 1), new translation2d(2, -1)), \/\/ end 3 meters straight ahead of where we started, facing forward new pose2d(3, 0, new rotation2d(0)), config);*\/ profiledpidcontroller thetacontroller = new profiledpidcontroller(constants.kpmecthetacontroller, 0., 0., new constraints(constants.maxmecrotationvelocity, constants.maxmecrotationaccel)); thetacontroller.enablecontinuousinput(-math.pi, math.pi); thetacontroller.reset(robotstate.getposeestimate().getrotation().getradians()); \/\/mecdrivetrain.setpose(pptrajectory.getinitialpose()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory, robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages mecdrivetrain ); \/\/pathplannerstate initialstate = pptrajectory.getinitialstate(); \/*return new instantcommand(() -> mecdrivetrain.setpose(new pose2d(initialstate.posemeters.gettranslation(), initialstate.holonomicrotation))) .andthen(mecanumcontrollercommand);","repo":"FRC6302\/2022Bot1"}
{"id":13695,"comment_id":3,"comment":"\/\/ position contollers","code":"public static command getmeccontrollercommand(pathplannertrajectory pptrajectory, mecdrivetrain mecdrivetrain) { \/\/ create config for trajectory \/*trajectoryconfig config = new trajectoryconfig(constants.maxmecspeed,constants.maxmecacceleration) \/\/ add kinematics to ensure max speed is actually obeyed .setkinematics(mecdrivetrain.getmeckinetimatics()); \/\/ an example trajectory to follow. all units in meters. trajectory exampletrajectory = trajectorygenerator.generatetrajectory( \/\/ start at the origin facing the +x direction new pose2d(0, 0, new rotation2d(0)), \/\/ pass through these two interior waypoints, making an 's' curve path list.of(new translation2d(1, 1), new translation2d(2, -1)), \/\/ end 3 meters straight ahead of where we started, facing forward new pose2d(3, 0, new rotation2d(0)), config);*\/ profiledpidcontroller thetacontroller = new profiledpidcontroller(constants.kpmecthetacontroller, 0., 0., new constraints(constants.maxmecrotationvelocity, constants.maxmecrotationaccel)); thetacontroller.enablecontinuousinput(-math.pi, math.pi); thetacontroller.reset(robotstate.getposeestimate().getrotation().getradians()); \/\/mecdrivetrain.setpose(pptrajectory.getinitialpose()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory, robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages mecdrivetrain ); \/\/pathplannerstate initialstate = pptrajectory.getinitialstate(); \/*return new instantcommand(() -> mecdrivetrain.setpose(new pose2d(initialstate.posemeters.gettranslation(), initialstate.holonomicrotation))) .andthen(mecanumcontrollercommand); \/\/.andthen(mecdrivetrain::stopdrive);*\/ return mecanumcontrollercommand; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0),","code_context_10":"thetacontroller.enablecontinuousinput(-math.pi, math.pi); thetacontroller.reset(robotstate.getposeestimate().getrotation().getradians()); \/\/mecdrivetrain.setpose(pptrajectory.getinitialpose()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory, robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/","code_context_20":"trajectorygenerator.generatetrajectory( \/\/ start at the origin facing the +x direction new pose2d(0, 0, new rotation2d(0)), \/\/ pass through these two interior waypoints, making an 's' curve path list.of(new translation2d(1, 1), new translation2d(2, -1)), \/\/ end 3 meters straight ahead of where we started, facing forward new pose2d(3, 0, new rotation2d(0)), config);*\/ profiledpidcontroller thetacontroller = new profiledpidcontroller(constants.kpmecthetacontroller, 0., 0., new constraints(constants.maxmecrotationvelocity, constants.maxmecrotationaccel)); thetacontroller.enablecontinuousinput(-math.pi, math.pi); thetacontroller.reset(robotstate.getposeestimate().getrotation().getradians()); \/\/mecdrivetrain.setpose(pptrajectory.getinitialpose()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory, robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages mecdrivetrain ); \/\/pathplannerstate initialstate = pptrajectory.getinitialstate(); \/*return new instantcommand(() -> mecdrivetrain.setpose(new pose2d(initialstate.posemeters.gettranslation(), initialstate.holonomicrotation))) .andthen(mecanumcontrollercommand); \/\/.andthen(mecdrivetrain::stopdrive);*\/ return mecanumcontrollercommand;","repo":"FRC6302\/2022Bot1"}
{"id":13695,"comment_id":4,"comment":"\/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/","code":"public static command getmeccontrollercommand(pathplannertrajectory pptrajectory, mecdrivetrain mecdrivetrain) { \/\/ create config for trajectory \/*trajectoryconfig config = new trajectoryconfig(constants.maxmecspeed,constants.maxmecacceleration) \/\/ add kinematics to ensure max speed is actually obeyed .setkinematics(mecdrivetrain.getmeckinetimatics()); \/\/ an example trajectory to follow. all units in meters. trajectory exampletrajectory = trajectorygenerator.generatetrajectory( \/\/ start at the origin facing the +x direction new pose2d(0, 0, new rotation2d(0)), \/\/ pass through these two interior waypoints, making an 's' curve path list.of(new translation2d(1, 1), new translation2d(2, -1)), \/\/ end 3 meters straight ahead of where we started, facing forward new pose2d(3, 0, new rotation2d(0)), config);*\/ profiledpidcontroller thetacontroller = new profiledpidcontroller(constants.kpmecthetacontroller, 0., 0., new constraints(constants.maxmecrotationvelocity, constants.maxmecrotationaccel)); thetacontroller.enablecontinuousinput(-math.pi, math.pi); thetacontroller.reset(robotstate.getposeestimate().getrotation().getradians()); \/\/mecdrivetrain.setpose(pptrajectory.getinitialpose()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory, robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages mecdrivetrain ); \/\/pathplannerstate initialstate = pptrajectory.getinitialstate(); \/*return new instantcommand(() -> mecdrivetrain.setpose(new pose2d(initialstate.posemeters.gettranslation(), initialstate.holonomicrotation))) .andthen(mecanumcontrollercommand); \/\/.andthen(mecdrivetrain::stopdrive);*\/ return mecanumcontrollercommand; }","classification":"NONSATD","isFinished":true,"code_context_2":"new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages","code_context_10":"pptrajectory, robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages mecdrivetrain ); \/\/pathplannerstate initialstate = pptrajectory.getinitialstate(); \/*return new instantcommand(() -> mecdrivetrain.setpose(new pose2d(initialstate.posemeters.gettranslation(), initialstate.holonomicrotation))) .andthen(mecanumcontrollercommand); \/\/.andthen(mecdrivetrain::stopdrive);*\/ return mecanumcontrollercommand;","code_context_20":"list.of(new translation2d(1, 1), new translation2d(2, -1)), \/\/ end 3 meters straight ahead of where we started, facing forward new pose2d(3, 0, new rotation2d(0)), config);*\/ profiledpidcontroller thetacontroller = new profiledpidcontroller(constants.kpmecthetacontroller, 0., 0., new constraints(constants.maxmecrotationvelocity, constants.maxmecrotationaccel)); thetacontroller.enablecontinuousinput(-math.pi, math.pi); thetacontroller.reset(robotstate.getposeestimate().getrotation().getradians()); \/\/mecdrivetrain.setpose(pptrajectory.getinitialpose()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory, robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages mecdrivetrain ); \/\/pathplannerstate initialstate = pptrajectory.getinitialstate(); \/*return new instantcommand(() -> mecdrivetrain.setpose(new pose2d(initialstate.posemeters.gettranslation(), initialstate.holonomicrotation))) .andthen(mecanumcontrollercommand); \/\/.andthen(mecdrivetrain::stopdrive);*\/ return mecanumcontrollercommand; }","repo":"FRC6302\/2022Bot1"}
{"id":13695,"comment_id":5,"comment":"\/\/mecdrivetrain::getcurrentwheelspeeds,","code":"public static command getmeccontrollercommand(pathplannertrajectory pptrajectory, mecdrivetrain mecdrivetrain) { \/\/ create config for trajectory \/*trajectoryconfig config = new trajectoryconfig(constants.maxmecspeed,constants.maxmecacceleration) \/\/ add kinematics to ensure max speed is actually obeyed .setkinematics(mecdrivetrain.getmeckinetimatics()); \/\/ an example trajectory to follow. all units in meters. trajectory exampletrajectory = trajectorygenerator.generatetrajectory( \/\/ start at the origin facing the +x direction new pose2d(0, 0, new rotation2d(0)), \/\/ pass through these two interior waypoints, making an 's' curve path list.of(new translation2d(1, 1), new translation2d(2, -1)), \/\/ end 3 meters straight ahead of where we started, facing forward new pose2d(3, 0, new rotation2d(0)), config);*\/ profiledpidcontroller thetacontroller = new profiledpidcontroller(constants.kpmecthetacontroller, 0., 0., new constraints(constants.maxmecrotationvelocity, constants.maxmecrotationaccel)); thetacontroller.enablecontinuousinput(-math.pi, math.pi); thetacontroller.reset(robotstate.getposeestimate().getrotation().getradians()); \/\/mecdrivetrain.setpose(pptrajectory.getinitialpose()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory, robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages mecdrivetrain ); \/\/pathplannerstate initialstate = pptrajectory.getinitialstate(); \/*return new instantcommand(() -> mecdrivetrain.setpose(new pose2d(initialstate.posemeters.gettranslation(), initialstate.holonomicrotation))) .andthen(mecanumcontrollercommand); \/\/.andthen(mecdrivetrain::stopdrive);*\/ return mecanumcontrollercommand; }","classification":"NONSATD","isFinished":true,"code_context_2":"new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages mecdrivetrain","code_context_10":"new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages mecdrivetrain ); \/\/pathplannerstate initialstate = pptrajectory.getinitialstate(); \/*return new instantcommand(() -> mecdrivetrain.setpose(new pose2d(initialstate.posemeters.gettranslation(), initialstate.holonomicrotation))) .andthen(mecanumcontrollercommand); \/\/.andthen(mecdrivetrain::stopdrive);*\/ return mecanumcontrollercommand; }","code_context_20":"thetacontroller.reset(robotstate.getposeestimate().getrotation().getradians()); \/\/mecdrivetrain.setpose(pptrajectory.getinitialpose()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory, robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages mecdrivetrain ); \/\/pathplannerstate initialstate = pptrajectory.getinitialstate(); \/*return new instantcommand(() -> mecdrivetrain.setpose(new pose2d(initialstate.posemeters.gettranslation(), initialstate.holonomicrotation))) .andthen(mecanumcontrollercommand); \/\/.andthen(mecdrivetrain::stopdrive);*\/ return mecanumcontrollercommand; }","repo":"FRC6302\/2022Bot1"}
{"id":13695,"comment_id":6,"comment":"\/\/ consumer for the output motor voltages","code":"public static command getmeccontrollercommand(pathplannertrajectory pptrajectory, mecdrivetrain mecdrivetrain) { \/\/ create config for trajectory \/*trajectoryconfig config = new trajectoryconfig(constants.maxmecspeed,constants.maxmecacceleration) \/\/ add kinematics to ensure max speed is actually obeyed .setkinematics(mecdrivetrain.getmeckinetimatics()); \/\/ an example trajectory to follow. all units in meters. trajectory exampletrajectory = trajectorygenerator.generatetrajectory( \/\/ start at the origin facing the +x direction new pose2d(0, 0, new rotation2d(0)), \/\/ pass through these two interior waypoints, making an 's' curve path list.of(new translation2d(1, 1), new translation2d(2, -1)), \/\/ end 3 meters straight ahead of where we started, facing forward new pose2d(3, 0, new rotation2d(0)), config);*\/ profiledpidcontroller thetacontroller = new profiledpidcontroller(constants.kpmecthetacontroller, 0., 0., new constraints(constants.maxmecrotationvelocity, constants.maxmecrotationaccel)); thetacontroller.enablecontinuousinput(-math.pi, math.pi); thetacontroller.reset(robotstate.getposeestimate().getrotation().getradians()); \/\/mecdrivetrain.setpose(pptrajectory.getinitialpose()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory, robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages mecdrivetrain ); \/\/pathplannerstate initialstate = pptrajectory.getinitialstate(); \/*return new instantcommand(() -> mecdrivetrain.setpose(new pose2d(initialstate.posemeters.gettranslation(), initialstate.holonomicrotation))) .andthen(mecanumcontrollercommand); \/\/.andthen(mecdrivetrain::stopdrive);*\/ return mecanumcontrollercommand; }","classification":"NONSATD","isFinished":true,"code_context_2":"new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages mecdrivetrain );","code_context_10":"new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages mecdrivetrain ); \/\/pathplannerstate initialstate = pptrajectory.getinitialstate(); \/*return new instantcommand(() -> mecdrivetrain.setpose(new pose2d(initialstate.posemeters.gettranslation(), initialstate.holonomicrotation))) .andthen(mecanumcontrollercommand); \/\/.andthen(mecdrivetrain::stopdrive);*\/ return mecanumcontrollercommand; }","code_context_20":"\/\/mecdrivetrain.setpose(pptrajectory.getinitialpose()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory, robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages mecdrivetrain ); \/\/pathplannerstate initialstate = pptrajectory.getinitialstate(); \/*return new instantcommand(() -> mecdrivetrain.setpose(new pose2d(initialstate.posemeters.gettranslation(), initialstate.holonomicrotation))) .andthen(mecanumcontrollercommand); \/\/.andthen(mecdrivetrain::stopdrive);*\/ return mecanumcontrollercommand; }","repo":"FRC6302\/2022Bot1"}
{"id":13695,"comment_id":7,"comment":"\/\/pathplannerstate initialstate = pptrajectory.getinitialstate(); \/*return new instantcommand(() -> mecdrivetrain.setpose(new pose2d(initialstate.posemeters.gettranslation(), initialstate.holonomicrotation))) .andthen(mecanumcontrollercommand); \/\/.andthen(mecdrivetrain::stopdrive);*\/","code":"public static command getmeccontrollercommand(pathplannertrajectory pptrajectory, mecdrivetrain mecdrivetrain) { \/\/ create config for trajectory \/*trajectoryconfig config = new trajectoryconfig(constants.maxmecspeed,constants.maxmecacceleration) \/\/ add kinematics to ensure max speed is actually obeyed .setkinematics(mecdrivetrain.getmeckinetimatics()); \/\/ an example trajectory to follow. all units in meters. trajectory exampletrajectory = trajectorygenerator.generatetrajectory( \/\/ start at the origin facing the +x direction new pose2d(0, 0, new rotation2d(0)), \/\/ pass through these two interior waypoints, making an 's' curve path list.of(new translation2d(1, 1), new translation2d(2, -1)), \/\/ end 3 meters straight ahead of where we started, facing forward new pose2d(3, 0, new rotation2d(0)), config);*\/ profiledpidcontroller thetacontroller = new profiledpidcontroller(constants.kpmecthetacontroller, 0., 0., new constraints(constants.maxmecrotationvelocity, constants.maxmecrotationaccel)); thetacontroller.enablecontinuousinput(-math.pi, math.pi); thetacontroller.reset(robotstate.getposeestimate().getrotation().getradians()); \/\/mecdrivetrain.setpose(pptrajectory.getinitialpose()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory, robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages mecdrivetrain ); \/\/pathplannerstate initialstate = pptrajectory.getinitialstate(); \/*return new instantcommand(() -> mecdrivetrain.setpose(new pose2d(initialstate.posemeters.gettranslation(), initialstate.holonomicrotation))) .andthen(mecanumcontrollercommand); \/\/.andthen(mecdrivetrain::stopdrive);*\/ return mecanumcontrollercommand; }","classification":"NONSATD","isFinished":true,"code_context_2":"mecdrivetrain ); \/\/pathplannerstate initialstate = pptrajectory.getinitialstate(); \/*return new instantcommand(() -> mecdrivetrain.setpose(new pose2d(initialstate.posemeters.gettranslation(), initialstate.holonomicrotation))) .andthen(mecanumcontrollercommand); \/\/.andthen(mecdrivetrain::stopdrive);*\/ return mecanumcontrollercommand; }","code_context_10":"\/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages mecdrivetrain ); \/\/pathplannerstate initialstate = pptrajectory.getinitialstate(); \/*return new instantcommand(() -> mecdrivetrain.setpose(new pose2d(initialstate.posemeters.gettranslation(), initialstate.holonomicrotation))) .andthen(mecanumcontrollercommand); \/\/.andthen(mecdrivetrain::stopdrive);*\/ return mecanumcontrollercommand; }","code_context_20":"robotstate::getposeestimate, \/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(), robotstate.getmeckinematics(), \/\/ position contollers new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, \/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/ \/\/mecdrivetrain::getcurrentwheelspeeds, mecdrivetrain::setspeeds, \/\/ consumer for the output motor voltages mecdrivetrain ); \/\/pathplannerstate initialstate = pptrajectory.getinitialstate(); \/*return new instantcommand(() -> mecdrivetrain.setpose(new pose2d(initialstate.posemeters.gettranslation(), initialstate.holonomicrotation))) .andthen(mecanumcontrollercommand); \/\/.andthen(mecdrivetrain::stopdrive);*\/ return mecanumcontrollercommand; }","repo":"FRC6302\/2022Bot1"}
{"id":14329,"comment_id":0,"comment":"\/* alliance info *\/","code":"public void importalliancesscoring(hashmap<matchgeneral, matchdetailrelicjson> scores){ file alliancefile = new file(config.scoring_dir + file.separator + \"alliances.txt\"); if (alliancefile.exists()) { try { bufferedreader reader = new bufferedreader(new filereader(alliancefile)); string line; alliances = new alliance[4]; while ((line = reader.readline()) != null) { \/* alliance info *\/ string[] allianceinfo = line.split(\"\\\\|\"); int division = integer.parseint(allianceinfo[0]); int alliancenumber = integer.parseint(allianceinfo[1]); int[] alliancenumbers = {integer.parseint(allianceinfo[3]), integer.parseint(allianceinfo[4]), integer.parseint(allianceinfo[5])}; alliances[alliancenumber-1] = new alliance(division, alliancenumber, alliancenumbers); } reader.close(); \/* todo - make upload alliances so we can uncomment this controller.btnuploadalliances.setdisable(false);*\/ updatealliancelabels(scores); toalogger.log(level.info, \"alliance import successful.\"); } catch (exception e) { e.printstacktrace(); controller.senderror(\"could not open file. \" + e.getlocalizedmessage()); } } else { controller.senderror(\"could not locate alliances.txt from the scoring system. did you generate an elimination bracket?\"); } }","classification":"NONSATD","isFinished":true,"code_context_2":"alliances = new alliance[4]; while ((line = reader.readline()) != null) { \/* alliance info *\/ string[] allianceinfo = line.split(\"\\\\|\"); int division = integer.parseint(allianceinfo[0]);","code_context_10":"public void importalliancesscoring(hashmap<matchgeneral, matchdetailrelicjson> scores){ file alliancefile = new file(config.scoring_dir + file.separator + \"alliances.txt\"); if (alliancefile.exists()) { try { bufferedreader reader = new bufferedreader(new filereader(alliancefile)); string line; alliances = new alliance[4]; while ((line = reader.readline()) != null) { \/* alliance info *\/ string[] allianceinfo = line.split(\"\\\\|\"); int division = integer.parseint(allianceinfo[0]); int alliancenumber = integer.parseint(allianceinfo[1]); int[] alliancenumbers = {integer.parseint(allianceinfo[3]), integer.parseint(allianceinfo[4]), integer.parseint(allianceinfo[5])}; alliances[alliancenumber-1] = new alliance(division, alliancenumber, alliancenumbers); } reader.close(); \/* todo - make upload alliances so we can uncomment this controller.btnuploadalliances.setdisable(false);*\/ updatealliancelabels(scores);","code_context_20":"public void importalliancesscoring(hashmap<matchgeneral, matchdetailrelicjson> scores){ file alliancefile = new file(config.scoring_dir + file.separator + \"alliances.txt\"); if (alliancefile.exists()) { try { bufferedreader reader = new bufferedreader(new filereader(alliancefile)); string line; alliances = new alliance[4]; while ((line = reader.readline()) != null) { \/* alliance info *\/ string[] allianceinfo = line.split(\"\\\\|\"); int division = integer.parseint(allianceinfo[0]); int alliancenumber = integer.parseint(allianceinfo[1]); int[] alliancenumbers = {integer.parseint(allianceinfo[3]), integer.parseint(allianceinfo[4]), integer.parseint(allianceinfo[5])}; alliances[alliancenumber-1] = new alliance(division, alliancenumber, alliancenumbers); } reader.close(); \/* todo - make upload alliances so we can uncomment this controller.btnuploadalliances.setdisable(false);*\/ updatealliancelabels(scores); toalogger.log(level.info, \"alliance import successful.\"); } catch (exception e) { e.printstacktrace(); controller.senderror(\"could not open file. \" + e.getlocalizedmessage()); } } else { controller.senderror(\"could not locate alliances.txt from the scoring system. did you generate an elimination bracket?\"); } }","repo":"Agardner329\/TOA-DataSync"}
{"id":14329,"comment_id":1,"comment":"\/* todo - make upload alliances so we can uncomment this controller.btnuploadalliances.setdisable(false);*\/","code":"public void importalliancesscoring(hashmap<matchgeneral, matchdetailrelicjson> scores){ file alliancefile = new file(config.scoring_dir + file.separator + \"alliances.txt\"); if (alliancefile.exists()) { try { bufferedreader reader = new bufferedreader(new filereader(alliancefile)); string line; alliances = new alliance[4]; while ((line = reader.readline()) != null) { \/* alliance info *\/ string[] allianceinfo = line.split(\"\\\\|\"); int division = integer.parseint(allianceinfo[0]); int alliancenumber = integer.parseint(allianceinfo[1]); int[] alliancenumbers = {integer.parseint(allianceinfo[3]), integer.parseint(allianceinfo[4]), integer.parseint(allianceinfo[5])}; alliances[alliancenumber-1] = new alliance(division, alliancenumber, alliancenumbers); } reader.close(); \/* todo - make upload alliances so we can uncomment this controller.btnuploadalliances.setdisable(false);*\/ updatealliancelabels(scores); toalogger.log(level.info, \"alliance import successful.\"); } catch (exception e) { e.printstacktrace(); controller.senderror(\"could not open file. \" + e.getlocalizedmessage()); } } else { controller.senderror(\"could not locate alliances.txt from the scoring system. did you generate an elimination bracket?\"); } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"} reader.close(); \/* todo - make upload alliances so we can uncomment this controller.btnuploadalliances.setdisable(false);*\/ updatealliancelabels(scores); toalogger.log(level.info, \"alliance import successful.\");","code_context_10":"alliances = new alliance[4]; while ((line = reader.readline()) != null) { \/* alliance info *\/ string[] allianceinfo = line.split(\"\\\\|\"); int division = integer.parseint(allianceinfo[0]); int alliancenumber = integer.parseint(allianceinfo[1]); int[] alliancenumbers = {integer.parseint(allianceinfo[3]), integer.parseint(allianceinfo[4]), integer.parseint(allianceinfo[5])}; alliances[alliancenumber-1] = new alliance(division, alliancenumber, alliancenumbers); } reader.close(); \/* todo - make upload alliances so we can uncomment this controller.btnuploadalliances.setdisable(false);*\/ updatealliancelabels(scores); toalogger.log(level.info, \"alliance import successful.\"); } catch (exception e) { e.printstacktrace(); controller.senderror(\"could not open file. \" + e.getlocalizedmessage()); } } else { controller.senderror(\"could not locate alliances.txt from the scoring system. did you generate an elimination bracket?\"); } }","code_context_20":"public void importalliancesscoring(hashmap<matchgeneral, matchdetailrelicjson> scores){ file alliancefile = new file(config.scoring_dir + file.separator + \"alliances.txt\"); if (alliancefile.exists()) { try { bufferedreader reader = new bufferedreader(new filereader(alliancefile)); string line; alliances = new alliance[4]; while ((line = reader.readline()) != null) { \/* alliance info *\/ string[] allianceinfo = line.split(\"\\\\|\"); int division = integer.parseint(allianceinfo[0]); int alliancenumber = integer.parseint(allianceinfo[1]); int[] alliancenumbers = {integer.parseint(allianceinfo[3]), integer.parseint(allianceinfo[4]), integer.parseint(allianceinfo[5])}; alliances[alliancenumber-1] = new alliance(division, alliancenumber, alliancenumbers); } reader.close(); \/* todo - make upload alliances so we can uncomment this controller.btnuploadalliances.setdisable(false);*\/ updatealliancelabels(scores); toalogger.log(level.info, \"alliance import successful.\"); } catch (exception e) { e.printstacktrace(); controller.senderror(\"could not open file. \" + e.getlocalizedmessage()); } } else { controller.senderror(\"could not locate alliances.txt from the scoring system. did you generate an elimination bracket?\"); } }","repo":"Agardner329\/TOA-DataSync"}
{"id":14380,"comment_id":0,"comment":"\/** * * todo figure out how to test this * * @throws exception *\/","code":"\/** * * todo figure out how to test this * * @throws exception *\/ public void testemit() throws exception { eh.on(\"ok\", new eventemitter.listener() { @override public void onevent(object data) { string ss = (string) data; if (ss == \"ok\") log.d(tag, \"pass@\" + ss); else log.d(tag, \"fail@\" + ss); } }); eh.on(\"no\", new eventemitter.listener() { @override public void onevent(object data) { string ss = (string) data; if (ss == \"no\") log.d(tag, \"pass@\" + ss); else log.d(tag, \"fail@\" + ss); } }); eh.emit(\"ok\"); eh.emit(\"ok\", \"ok\"); eh.emit(\"ok\", \"no\"); eh.emit(\"no\"); eh.emit(\"no\", \"no\"); eh.emit(\"no\", \"ok\"); eh.emit(\"unknown\"); eh.emit(\"unknown\", \"ok\"); eh.emit(\"unknown\", \"no\"); fail(); \/\/ fixme these tests are not correct }","classification":"TEST","isFinished":true,"code_context_2":"public void testemit() throws exception { eh.on(\"ok\", new eventemitter.listener() { @override public void onevent(object data) { string ss = (string) data; if (ss == \"ok\") log.d(tag, \"pass@\" + ss); else log.d(tag, \"fail@\" + ss); } }); eh.on(\"no\", new eventemitter.listener() { @override public void onevent(object data) { string ss = (string) data; if (ss == \"no\") log.d(tag, \"pass@\" + ss); else log.d(tag, \"fail@\" + ss); } }); eh.emit(\"ok\"); eh.emit(\"ok\", \"ok\"); eh.emit(\"ok\", \"no\"); eh.emit(\"no\"); eh.emit(\"no\", \"no\"); eh.emit(\"no\", \"ok\"); eh.emit(\"unknown\"); eh.emit(\"unknown\", \"ok\"); eh.emit(\"unknown\", \"no\"); fail(); \/\/ fixme these tests are not correct }","code_context_10":"public void testemit() throws exception { eh.on(\"ok\", new eventemitter.listener() { @override public void onevent(object data) { string ss = (string) data; if (ss == \"ok\") log.d(tag, \"pass@\" + ss); else log.d(tag, \"fail@\" + ss); } }); eh.on(\"no\", new eventemitter.listener() { @override public void onevent(object data) { string ss = (string) data; if (ss == \"no\") log.d(tag, \"pass@\" + ss); else log.d(tag, \"fail@\" + ss); } }); eh.emit(\"ok\"); eh.emit(\"ok\", \"ok\"); eh.emit(\"ok\", \"no\"); eh.emit(\"no\"); eh.emit(\"no\", \"no\"); eh.emit(\"no\", \"ok\"); eh.emit(\"unknown\"); eh.emit(\"unknown\", \"ok\"); eh.emit(\"unknown\", \"no\"); fail(); \/\/ fixme these tests are not correct }","code_context_20":"public void testemit() throws exception { eh.on(\"ok\", new eventemitter.listener() { @override public void onevent(object data) { string ss = (string) data; if (ss == \"ok\") log.d(tag, \"pass@\" + ss); else log.d(tag, \"fail@\" + ss); } }); eh.on(\"no\", new eventemitter.listener() { @override public void onevent(object data) { string ss = (string) data; if (ss == \"no\") log.d(tag, \"pass@\" + ss); else log.d(tag, \"fail@\" + ss); } }); eh.emit(\"ok\"); eh.emit(\"ok\", \"ok\"); eh.emit(\"ok\", \"no\"); eh.emit(\"no\"); eh.emit(\"no\", \"no\"); eh.emit(\"no\", \"ok\"); eh.emit(\"unknown\"); eh.emit(\"unknown\", \"ok\"); eh.emit(\"unknown\", \"no\"); fail(); \/\/ fixme these tests are not correct }","repo":"InstantWebP2P\/node-android"}
{"id":14380,"comment_id":1,"comment":"\/\/ fixme these tests are not correct","code":"public void testemit() throws exception { eh.on(\"ok\", new eventemitter.listener() { @override public void onevent(object data) { string ss = (string) data; if (ss == \"ok\") log.d(tag, \"pass@\" + ss); else log.d(tag, \"fail@\" + ss); } }); eh.on(\"no\", new eventemitter.listener() { @override public void onevent(object data) { string ss = (string) data; if (ss == \"no\") log.d(tag, \"pass@\" + ss); else log.d(tag, \"fail@\" + ss); } }); eh.emit(\"ok\"); eh.emit(\"ok\", \"ok\"); eh.emit(\"ok\", \"no\"); eh.emit(\"no\"); eh.emit(\"no\", \"no\"); eh.emit(\"no\", \"ok\"); eh.emit(\"unknown\"); eh.emit(\"unknown\", \"ok\"); eh.emit(\"unknown\", \"no\"); fail(); \/\/ fixme these tests are not correct }","classification":"TEST","isFinished":true,"code_context_2":"eh.emit(\"unknown\", \"ok\"); eh.emit(\"unknown\", \"no\"); fail(); \/\/ fixme these tests are not correct }","code_context_10":"}); eh.emit(\"ok\"); eh.emit(\"ok\", \"ok\"); eh.emit(\"ok\", \"no\"); eh.emit(\"no\"); eh.emit(\"no\", \"no\"); eh.emit(\"no\", \"ok\"); eh.emit(\"unknown\"); eh.emit(\"unknown\", \"ok\"); eh.emit(\"unknown\", \"no\"); fail(); \/\/ fixme these tests are not correct }","code_context_20":"}); eh.on(\"no\", new eventemitter.listener() { @override public void onevent(object data) { string ss = (string) data; if (ss == \"no\") log.d(tag, \"pass@\" + ss); else log.d(tag, \"fail@\" + ss); } }); eh.emit(\"ok\"); eh.emit(\"ok\", \"ok\"); eh.emit(\"ok\", \"no\"); eh.emit(\"no\"); eh.emit(\"no\", \"no\"); eh.emit(\"no\", \"ok\"); eh.emit(\"unknown\"); eh.emit(\"unknown\", \"ok\"); eh.emit(\"unknown\", \"no\"); fail(); \/\/ fixme these tests are not correct }","repo":"InstantWebP2P\/node-android"}
{"id":14566,"comment_id":0,"comment":"\/\/ todo consider showing actual source code instead of just types and names","code":"\/\/ todo consider showing actual source code instead of just types and names private void resolvedetail(completionitem item, completiondata data, tree tree) { if (tree instanceof methodtree) { var method = (methodtree) tree; var parameters = new stringjoiner(\", \"); for (var p : method.getparameters()) { parameters.add(p.gettype() + \" \" + p.getname()); } item.detail = method.getreturntype() + \" \" + method.getname() + \"(\" + parameters + \")\"; if (!method.getthrows().isempty()) { var exceptions = new stringjoiner(\", \"); for (var e : method.getthrows()) { exceptions.add(e.tostring()); } item.detail += \" throws \" + exceptions; } if (data.plusoverloads != 0) { item.detail += \" (+\" + data.plusoverloads + \" overloads)\"; } } }","classification":"DESIGN","isFinished":true,"code_context_2":"private void resolvedetail(completionitem item, completiondata data, tree tree) { if (tree instanceof methodtree) { var method = (methodtree) tree; var parameters = new stringjoiner(\", \"); for (var p : method.getparameters()) { parameters.add(p.gettype() + \" \" + p.getname()); } item.detail = method.getreturntype() + \" \" + method.getname() + \"(\" + parameters + \")\"; if (!method.getthrows().isempty()) { var exceptions = new stringjoiner(\", \"); for (var e : method.getthrows()) { exceptions.add(e.tostring()); } item.detail += \" throws \" + exceptions; } if (data.plusoverloads != 0) { item.detail += \" (+\" + data.plusoverloads + \" overloads)\"; } } }","code_context_10":"private void resolvedetail(completionitem item, completiondata data, tree tree) { if (tree instanceof methodtree) { var method = (methodtree) tree; var parameters = new stringjoiner(\", \"); for (var p : method.getparameters()) { parameters.add(p.gettype() + \" \" + p.getname()); } item.detail = method.getreturntype() + \" \" + method.getname() + \"(\" + parameters + \")\"; if (!method.getthrows().isempty()) { var exceptions = new stringjoiner(\", \"); for (var e : method.getthrows()) { exceptions.add(e.tostring()); } item.detail += \" throws \" + exceptions; } if (data.plusoverloads != 0) { item.detail += \" (+\" + data.plusoverloads + \" overloads)\"; } } }","code_context_20":"private void resolvedetail(completionitem item, completiondata data, tree tree) { if (tree instanceof methodtree) { var method = (methodtree) tree; var parameters = new stringjoiner(\", \"); for (var p : method.getparameters()) { parameters.add(p.gettype() + \" \" + p.getname()); } item.detail = method.getreturntype() + \" \" + method.getname() + \"(\" + parameters + \")\"; if (!method.getthrows().isempty()) { var exceptions = new stringjoiner(\", \"); for (var e : method.getthrows()) { exceptions.add(e.tostring()); } item.detail += \" throws \" + exceptions; } if (data.plusoverloads != 0) { item.detail += \" (+\" + data.plusoverloads + \" overloads)\"; } } }","repo":"80952556400\/java-language-server"}
{"id":30960,"comment_id":0,"comment":"\/\/ todo: fix to compare provided eventdate and reproductivestate with data from fna","code":"public void validatefloweringtime(string scientificname, string eventdate, string reproductivestate, string country, string kingdom, string latitude, string longitude) { hashmap<string, string> initialvalues = new hashmap<string, string>(); initialvalues.put(\"eventdate\", eventdate); initialvalues.put(\"scientificname\", scientificname); initialvalues.put(\"reproductive\", reproductivestate); initialvalues.put(\"country\", country); initialvalues.put(\"kingdom\", kingdom); initialvalues.put(\"latitude\", latitude); initialvalues.put(\"longitude\", longitude); initdate(new curationstep(\"validate collecting event date: check dwc:eventdate against reproductive state. \", initialvalues)); \/\/ todo: fix to compare provided eventdate and reproductivestate with data from fna vector<string> months = new vector<string>(); vector<string> foundfloweringtime = null; if(authoritativefloweringtimemap != null && authoritativefloweringtimemap.containskey(scientificname.tolowercase())){ foundfloweringtime = authoritativefloweringtimemap.get(scientificname.tolowercase()); } if(foundfloweringtime == null){ setcurationstatus(curationcomment.unable_determine_validity); addtocomment(\"can't find the flowering time of the \"+scientificname+\" in the current available phenology data from fna.\"); correctedfloweringtime = null; }else{ if(months==null || !months.containsall(foundfloweringtime) || !foundfloweringtime.containsall(months) ){ setcurationstatus(curationcomment.unable_curated); addtocomment(\"provided event date and flowering state is inconsistent with known flowering times for species according to fna.\"); }else{ setcurationstatus(curationcomment.correct); addtocomment(\"the event date and flowering state is consistent with authoritative data from fna\"); correctedfloweringtime = months; } } }","classification":"DESIGN","isFinished":true,"code_context_2":"initialvalues.put(\"longitude\", longitude); initdate(new curationstep(\"validate collecting event date: check dwc:eventdate against reproductive state. \", initialvalues)); \/\/ todo: fix to compare provided eventdate and reproductivestate with data from fna vector<string> months = new vector<string>(); vector<string> foundfloweringtime = null;","code_context_10":"public void validatefloweringtime(string scientificname, string eventdate, string reproductivestate, string country, string kingdom, string latitude, string longitude) { hashmap<string, string> initialvalues = new hashmap<string, string>(); initialvalues.put(\"eventdate\", eventdate); initialvalues.put(\"scientificname\", scientificname); initialvalues.put(\"reproductive\", reproductivestate); initialvalues.put(\"country\", country); initialvalues.put(\"kingdom\", kingdom); initialvalues.put(\"latitude\", latitude); initialvalues.put(\"longitude\", longitude); initdate(new curationstep(\"validate collecting event date: check dwc:eventdate against reproductive state. \", initialvalues)); \/\/ todo: fix to compare provided eventdate and reproductivestate with data from fna vector<string> months = new vector<string>(); vector<string> foundfloweringtime = null; if(authoritativefloweringtimemap != null && authoritativefloweringtimemap.containskey(scientificname.tolowercase())){ foundfloweringtime = authoritativefloweringtimemap.get(scientificname.tolowercase()); } if(foundfloweringtime == null){ setcurationstatus(curationcomment.unable_determine_validity); addtocomment(\"can't find the flowering time of the \"+scientificname+\" in the current available phenology data from fna.\"); correctedfloweringtime = null; }else{","code_context_20":"public void validatefloweringtime(string scientificname, string eventdate, string reproductivestate, string country, string kingdom, string latitude, string longitude) { hashmap<string, string> initialvalues = new hashmap<string, string>(); initialvalues.put(\"eventdate\", eventdate); initialvalues.put(\"scientificname\", scientificname); initialvalues.put(\"reproductive\", reproductivestate); initialvalues.put(\"country\", country); initialvalues.put(\"kingdom\", kingdom); initialvalues.put(\"latitude\", latitude); initialvalues.put(\"longitude\", longitude); initdate(new curationstep(\"validate collecting event date: check dwc:eventdate against reproductive state. \", initialvalues)); \/\/ todo: fix to compare provided eventdate and reproductivestate with data from fna vector<string> months = new vector<string>(); vector<string> foundfloweringtime = null; if(authoritativefloweringtimemap != null && authoritativefloweringtimemap.containskey(scientificname.tolowercase())){ foundfloweringtime = authoritativefloweringtimemap.get(scientificname.tolowercase()); } if(foundfloweringtime == null){ setcurationstatus(curationcomment.unable_determine_validity); addtocomment(\"can't find the flowering time of the \"+scientificname+\" in the current available phenology data from fna.\"); correctedfloweringtime = null; }else{ if(months==null || !months.containsall(foundfloweringtime) || !foundfloweringtime.containsall(months) ){ setcurationstatus(curationcomment.unable_curated); addtocomment(\"provided event date and flowering state is inconsistent with known flowering times for species according to fna.\"); }else{ setcurationstatus(curationcomment.correct); addtocomment(\"the event date and flowering state is consistent with authoritative data from fna\"); correctedfloweringtime = months; } } }","repo":"FilteredPush\/FP-KurationServices"}
{"id":22911,"comment_id":0,"comment":"\/\/ look for the raw contact if specified.","code":"private void pickrawcontactdelta() { if (log.isloggable(tag, log.verbose)) { log.v(tag, \"parse: \" + mrawcontactdeltas.size() + \" rawcontactdelta(s)\"); } for (int j = 0; j < mrawcontactdeltas.size(); j++) { final rawcontactdelta rawcontactdelta = mrawcontactdeltas.get(j); if (log.isloggable(tag, log.verbose)) { log.v(tag, \"parse: \" + j + \" rawcontactdelta\" + rawcontactdelta); } if (rawcontactdelta == null || !rawcontactdelta.isvisible()) continue; final accounttype accounttype = rawcontactdelta.getaccounttype(maccounttypemanager); if (accounttype == null) continue; if (mrawcontactidtodisplayalone > 0) { \/\/ look for the raw contact if specified. if (rawcontactdelta.getrawcontactid().equals(mrawcontactidtodisplayalone)) { mcurrentrawcontactdelta = rawcontactdelta; return; } } else if (mprimaryaccount != null && mprimaryaccount.equals(rawcontactdelta.getaccountwithdataset())) { \/\/ otherwise try to find the one that matches the default. mcurrentrawcontactdelta = rawcontactdelta; return; } else if (accounttype.arecontactswritable()){ \/\/ todo: find better raw contact delta \/\/ just select an arbitrary writable contact. mcurrentrawcontactdelta = rawcontactdelta; } } }","classification":"NONSATD","isFinished":true,"code_context_2":"if (accounttype == null) continue; if (mrawcontactidtodisplayalone > 0) { \/\/ look for the raw contact if specified. if (rawcontactdelta.getrawcontactid().equals(mrawcontactidtodisplayalone)) { mcurrentrawcontactdelta = rawcontactdelta;","code_context_10":"} for (int j = 0; j < mrawcontactdeltas.size(); j++) { final rawcontactdelta rawcontactdelta = mrawcontactdeltas.get(j); if (log.isloggable(tag, log.verbose)) { log.v(tag, \"parse: \" + j + \" rawcontactdelta\" + rawcontactdelta); } if (rawcontactdelta == null || !rawcontactdelta.isvisible()) continue; final accounttype accounttype = rawcontactdelta.getaccounttype(maccounttypemanager); if (accounttype == null) continue; if (mrawcontactidtodisplayalone > 0) { \/\/ look for the raw contact if specified. if (rawcontactdelta.getrawcontactid().equals(mrawcontactidtodisplayalone)) { mcurrentrawcontactdelta = rawcontactdelta; return; } } else if (mprimaryaccount != null && mprimaryaccount.equals(rawcontactdelta.getaccountwithdataset())) { \/\/ otherwise try to find the one that matches the default. mcurrentrawcontactdelta = rawcontactdelta; return; } else if (accounttype.arecontactswritable()){","code_context_20":"private void pickrawcontactdelta() { if (log.isloggable(tag, log.verbose)) { log.v(tag, \"parse: \" + mrawcontactdeltas.size() + \" rawcontactdelta(s)\"); } for (int j = 0; j < mrawcontactdeltas.size(); j++) { final rawcontactdelta rawcontactdelta = mrawcontactdeltas.get(j); if (log.isloggable(tag, log.verbose)) { log.v(tag, \"parse: \" + j + \" rawcontactdelta\" + rawcontactdelta); } if (rawcontactdelta == null || !rawcontactdelta.isvisible()) continue; final accounttype accounttype = rawcontactdelta.getaccounttype(maccounttypemanager); if (accounttype == null) continue; if (mrawcontactidtodisplayalone > 0) { \/\/ look for the raw contact if specified. if (rawcontactdelta.getrawcontactid().equals(mrawcontactidtodisplayalone)) { mcurrentrawcontactdelta = rawcontactdelta; return; } } else if (mprimaryaccount != null && mprimaryaccount.equals(rawcontactdelta.getaccountwithdataset())) { \/\/ otherwise try to find the one that matches the default. mcurrentrawcontactdelta = rawcontactdelta; return; } else if (accounttype.arecontactswritable()){ \/\/ todo: find better raw contact delta \/\/ just select an arbitrary writable contact. mcurrentrawcontactdelta = rawcontactdelta; } } }","repo":"BrahmaOS\/brahmaos-packages-apps-Contacts"}
{"id":22911,"comment_id":1,"comment":"\/\/ otherwise try to find the one that matches the default.","code":"private void pickrawcontactdelta() { if (log.isloggable(tag, log.verbose)) { log.v(tag, \"parse: \" + mrawcontactdeltas.size() + \" rawcontactdelta(s)\"); } for (int j = 0; j < mrawcontactdeltas.size(); j++) { final rawcontactdelta rawcontactdelta = mrawcontactdeltas.get(j); if (log.isloggable(tag, log.verbose)) { log.v(tag, \"parse: \" + j + \" rawcontactdelta\" + rawcontactdelta); } if (rawcontactdelta == null || !rawcontactdelta.isvisible()) continue; final accounttype accounttype = rawcontactdelta.getaccounttype(maccounttypemanager); if (accounttype == null) continue; if (mrawcontactidtodisplayalone > 0) { \/\/ look for the raw contact if specified. if (rawcontactdelta.getrawcontactid().equals(mrawcontactidtodisplayalone)) { mcurrentrawcontactdelta = rawcontactdelta; return; } } else if (mprimaryaccount != null && mprimaryaccount.equals(rawcontactdelta.getaccountwithdataset())) { \/\/ otherwise try to find the one that matches the default. mcurrentrawcontactdelta = rawcontactdelta; return; } else if (accounttype.arecontactswritable()){ \/\/ todo: find better raw contact delta \/\/ just select an arbitrary writable contact. mcurrentrawcontactdelta = rawcontactdelta; } } }","classification":"NONSATD","isFinished":true,"code_context_2":"} else if (mprimaryaccount != null && mprimaryaccount.equals(rawcontactdelta.getaccountwithdataset())) { \/\/ otherwise try to find the one that matches the default. mcurrentrawcontactdelta = rawcontactdelta; return;","code_context_10":"final accounttype accounttype = rawcontactdelta.getaccounttype(maccounttypemanager); if (accounttype == null) continue; if (mrawcontactidtodisplayalone > 0) { \/\/ look for the raw contact if specified. if (rawcontactdelta.getrawcontactid().equals(mrawcontactidtodisplayalone)) { mcurrentrawcontactdelta = rawcontactdelta; return; } } else if (mprimaryaccount != null && mprimaryaccount.equals(rawcontactdelta.getaccountwithdataset())) { \/\/ otherwise try to find the one that matches the default. mcurrentrawcontactdelta = rawcontactdelta; return; } else if (accounttype.arecontactswritable()){ \/\/ todo: find better raw contact delta \/\/ just select an arbitrary writable contact. mcurrentrawcontactdelta = rawcontactdelta; } } }","code_context_20":"private void pickrawcontactdelta() { if (log.isloggable(tag, log.verbose)) { log.v(tag, \"parse: \" + mrawcontactdeltas.size() + \" rawcontactdelta(s)\"); } for (int j = 0; j < mrawcontactdeltas.size(); j++) { final rawcontactdelta rawcontactdelta = mrawcontactdeltas.get(j); if (log.isloggable(tag, log.verbose)) { log.v(tag, \"parse: \" + j + \" rawcontactdelta\" + rawcontactdelta); } if (rawcontactdelta == null || !rawcontactdelta.isvisible()) continue; final accounttype accounttype = rawcontactdelta.getaccounttype(maccounttypemanager); if (accounttype == null) continue; if (mrawcontactidtodisplayalone > 0) { \/\/ look for the raw contact if specified. if (rawcontactdelta.getrawcontactid().equals(mrawcontactidtodisplayalone)) { mcurrentrawcontactdelta = rawcontactdelta; return; } } else if (mprimaryaccount != null && mprimaryaccount.equals(rawcontactdelta.getaccountwithdataset())) { \/\/ otherwise try to find the one that matches the default. mcurrentrawcontactdelta = rawcontactdelta; return; } else if (accounttype.arecontactswritable()){ \/\/ todo: find better raw contact delta \/\/ just select an arbitrary writable contact. mcurrentrawcontactdelta = rawcontactdelta; } } }","repo":"BrahmaOS\/brahmaos-packages-apps-Contacts"}
{"id":22911,"comment_id":2,"comment":"\/\/ todo: find better raw contact delta \/\/ just select an arbitrary writable contact.","code":"private void pickrawcontactdelta() { if (log.isloggable(tag, log.verbose)) { log.v(tag, \"parse: \" + mrawcontactdeltas.size() + \" rawcontactdelta(s)\"); } for (int j = 0; j < mrawcontactdeltas.size(); j++) { final rawcontactdelta rawcontactdelta = mrawcontactdeltas.get(j); if (log.isloggable(tag, log.verbose)) { log.v(tag, \"parse: \" + j + \" rawcontactdelta\" + rawcontactdelta); } if (rawcontactdelta == null || !rawcontactdelta.isvisible()) continue; final accounttype accounttype = rawcontactdelta.getaccounttype(maccounttypemanager); if (accounttype == null) continue; if (mrawcontactidtodisplayalone > 0) { \/\/ look for the raw contact if specified. if (rawcontactdelta.getrawcontactid().equals(mrawcontactidtodisplayalone)) { mcurrentrawcontactdelta = rawcontactdelta; return; } } else if (mprimaryaccount != null && mprimaryaccount.equals(rawcontactdelta.getaccountwithdataset())) { \/\/ otherwise try to find the one that matches the default. mcurrentrawcontactdelta = rawcontactdelta; return; } else if (accounttype.arecontactswritable()){ \/\/ todo: find better raw contact delta \/\/ just select an arbitrary writable contact. mcurrentrawcontactdelta = rawcontactdelta; } } }","classification":"DESIGN","isFinished":true,"code_context_2":"return; } else if (accounttype.arecontactswritable()){ \/\/ todo: find better raw contact delta \/\/ just select an arbitrary writable contact. mcurrentrawcontactdelta = rawcontactdelta; }","code_context_10":"if (rawcontactdelta.getrawcontactid().equals(mrawcontactidtodisplayalone)) { mcurrentrawcontactdelta = rawcontactdelta; return; } } else if (mprimaryaccount != null && mprimaryaccount.equals(rawcontactdelta.getaccountwithdataset())) { \/\/ otherwise try to find the one that matches the default. mcurrentrawcontactdelta = rawcontactdelta; return; } else if (accounttype.arecontactswritable()){ \/\/ todo: find better raw contact delta \/\/ just select an arbitrary writable contact. mcurrentrawcontactdelta = rawcontactdelta; } } }","code_context_20":"for (int j = 0; j < mrawcontactdeltas.size(); j++) { final rawcontactdelta rawcontactdelta = mrawcontactdeltas.get(j); if (log.isloggable(tag, log.verbose)) { log.v(tag, \"parse: \" + j + \" rawcontactdelta\" + rawcontactdelta); } if (rawcontactdelta == null || !rawcontactdelta.isvisible()) continue; final accounttype accounttype = rawcontactdelta.getaccounttype(maccounttypemanager); if (accounttype == null) continue; if (mrawcontactidtodisplayalone > 0) { \/\/ look for the raw contact if specified. if (rawcontactdelta.getrawcontactid().equals(mrawcontactidtodisplayalone)) { mcurrentrawcontactdelta = rawcontactdelta; return; } } else if (mprimaryaccount != null && mprimaryaccount.equals(rawcontactdelta.getaccountwithdataset())) { \/\/ otherwise try to find the one that matches the default. mcurrentrawcontactdelta = rawcontactdelta; return; } else if (accounttype.arecontactswritable()){ \/\/ todo: find better raw contact delta \/\/ just select an arbitrary writable contact. mcurrentrawcontactdelta = rawcontactdelta; } } }","repo":"BrahmaOS\/brahmaos-packages-apps-Contacts"}
{"id":22966,"comment_id":0,"comment":"\/\/ fixme: maybe skip writing the som at 0 iterations (0 mod x == 0 ...)","code":"@override public void interruptionoccurred(int currentiteration, int numiterations) { \/\/ fixme: maybe skip writing the som at 0 iterations (0 mod x == 0 ...) string filename = fileproperties.nameprefix(false) + \"_\" + currentiteration; try { somlibmapoutputter.writeweightvectorfile(growingsom.this, fileproperties.outputdirectory(), filename, true, \"$current_iteration=\" + currentiteration, \"$num_iterations=\" + numiterations); } catch (ioexception e) { logger.getlogger(\"at.tuwien.ifs.somtoolbox\").severe( \"could not open or write to output file \" + filename + \": \" + e.getmessage()); } }","classification":"DEFECT","isFinished":true,"code_context_2":"@override public void interruptionoccurred(int currentiteration, int numiterations) { \/\/ fixme: maybe skip writing the som at 0 iterations (0 mod x == 0 ...) string filename = fileproperties.nameprefix(false) + \"_\" + currentiteration; try {","code_context_10":"@override public void interruptionoccurred(int currentiteration, int numiterations) { \/\/ fixme: maybe skip writing the som at 0 iterations (0 mod x == 0 ...) string filename = fileproperties.nameprefix(false) + \"_\" + currentiteration; try { somlibmapoutputter.writeweightvectorfile(growingsom.this, fileproperties.outputdirectory(), filename, true, \"$current_iteration=\" + currentiteration, \"$num_iterations=\" + numiterations); } catch (ioexception e) { logger.getlogger(\"at.tuwien.ifs.somtoolbox\").severe( \"could not open or write to output file \" + filename + \": \" + e.getmessage()); } }","code_context_20":"@override public void interruptionoccurred(int currentiteration, int numiterations) { \/\/ fixme: maybe skip writing the som at 0 iterations (0 mod x == 0 ...) string filename = fileproperties.nameprefix(false) + \"_\" + currentiteration; try { somlibmapoutputter.writeweightvectorfile(growingsom.this, fileproperties.outputdirectory(), filename, true, \"$current_iteration=\" + currentiteration, \"$num_iterations=\" + numiterations); } catch (ioexception e) { logger.getlogger(\"at.tuwien.ifs.somtoolbox\").severe( \"could not open or write to output file \" + filename + \": \" + e.getmessage()); } }","repo":"ChrisPrein\/TUW_SelfOrganizingSystems_WS2021"}
{"id":23001,"comment_id":0,"comment":"\/** * generates structures in given cube. * * @param world the world that the structure is generated in * @param cube the block buffer to be filled with blocks (cube) * @param cubepos position of the cube to generate structures in *\/","code":"\/** * generates structures in given cube. * * @param world the world that the structure is generated in * @param cube the block buffer to be filled with blocks (cube) * @param cubepos position of the cube to generate structures in *\/ public void generate(icubicworld world, icubeprimer cube, cubepos cubepos) { \/\/todo: maybe skip some of this stuff if the cube is empty? (would need to use hints) int radius = this.range; this.world = world; this.rand.setseed(world.getseed()); \/\/used to randomize contribution of each coordinate to the cube seed \/\/without these swapping x\/y\/z coordinates would result in the same seed \/\/so structures would generate symmetrically long randx = this.rand.nextlong(); long randy = this.rand.nextlong(); long randz = this.rand.nextlong(); int cubex = cubepos.getx(); int cubey = cubepos.gety(); int cubez = cubepos.getz(); \/\/x\/y\/zorigin is location of the structure \"center\", and cubex\/y\/z is the currently generated cube for (int xorigin = cubex - radius; xorigin <= cubex + radius; ++xorigin) { for (int yorigin = cubey - radius; yorigin <= cubey + radius; ++yorigin) { for (int zorigin = cubez - radius; zorigin <= cubez + radius; ++zorigin) { long randx_mul = xorigin*randx; long randy_mul = yorigin*randy; long randz_mul = zorigin*randz; this.rand.setseed(randx_mul ^ randy_mul ^ randz_mul ^ world.getseed()); this.generate(world, cube, xorigin, yorigin, zorigin, cubepos); } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"public void generate(icubicworld world, icubeprimer cube, cubepos cubepos) { \/\/todo: maybe skip some of this stuff if the cube is empty? (would need to use hints) int radius = this.range; this.world = world; this.rand.setseed(world.getseed()); \/\/used to randomize contribution of each coordinate to the cube seed \/\/without these swapping x\/y\/z coordinates would result in the same seed \/\/so structures would generate symmetrically long randx = this.rand.nextlong(); long randy = this.rand.nextlong(); long randz = this.rand.nextlong(); int cubex = cubepos.getx(); int cubey = cubepos.gety(); int cubez = cubepos.getz(); \/\/x\/y\/zorigin is location of the structure \"center\", and cubex\/y\/z is the currently generated cube for (int xorigin = cubex - radius; xorigin <= cubex + radius; ++xorigin) { for (int yorigin = cubey - radius; yorigin <= cubey + radius; ++yorigin) { for (int zorigin = cubez - radius; zorigin <= cubez + radius; ++zorigin) { long randx_mul = xorigin*randx; long randy_mul = yorigin*randy; long randz_mul = zorigin*randz; this.rand.setseed(randx_mul ^ randy_mul ^ randz_mul ^ world.getseed()); this.generate(world, cube, xorigin, yorigin, zorigin, cubepos); } } } }","code_context_10":"public void generate(icubicworld world, icubeprimer cube, cubepos cubepos) { \/\/todo: maybe skip some of this stuff if the cube is empty? (would need to use hints) int radius = this.range; this.world = world; this.rand.setseed(world.getseed()); \/\/used to randomize contribution of each coordinate to the cube seed \/\/without these swapping x\/y\/z coordinates would result in the same seed \/\/so structures would generate symmetrically long randx = this.rand.nextlong(); long randy = this.rand.nextlong(); long randz = this.rand.nextlong(); int cubex = cubepos.getx(); int cubey = cubepos.gety(); int cubez = cubepos.getz(); \/\/x\/y\/zorigin is location of the structure \"center\", and cubex\/y\/z is the currently generated cube for (int xorigin = cubex - radius; xorigin <= cubex + radius; ++xorigin) { for (int yorigin = cubey - radius; yorigin <= cubey + radius; ++yorigin) { for (int zorigin = cubez - radius; zorigin <= cubez + radius; ++zorigin) { long randx_mul = xorigin*randx; long randy_mul = yorigin*randy; long randz_mul = zorigin*randz; this.rand.setseed(randx_mul ^ randy_mul ^ randz_mul ^ world.getseed()); this.generate(world, cube, xorigin, yorigin, zorigin, cubepos); } } } }","code_context_20":"public void generate(icubicworld world, icubeprimer cube, cubepos cubepos) { \/\/todo: maybe skip some of this stuff if the cube is empty? (would need to use hints) int radius = this.range; this.world = world; this.rand.setseed(world.getseed()); \/\/used to randomize contribution of each coordinate to the cube seed \/\/without these swapping x\/y\/z coordinates would result in the same seed \/\/so structures would generate symmetrically long randx = this.rand.nextlong(); long randy = this.rand.nextlong(); long randz = this.rand.nextlong(); int cubex = cubepos.getx(); int cubey = cubepos.gety(); int cubez = cubepos.getz(); \/\/x\/y\/zorigin is location of the structure \"center\", and cubex\/y\/z is the currently generated cube for (int xorigin = cubex - radius; xorigin <= cubex + radius; ++xorigin) { for (int yorigin = cubey - radius; yorigin <= cubey + radius; ++yorigin) { for (int zorigin = cubez - radius; zorigin <= cubez + radius; ++zorigin) { long randx_mul = xorigin*randx; long randy_mul = yorigin*randy; long randz_mul = zorigin*randz; this.rand.setseed(randx_mul ^ randy_mul ^ randz_mul ^ world.getseed()); this.generate(world, cube, xorigin, yorigin, zorigin, cubepos); } } } }","repo":"Cyclonit\/CubicChunks"}
{"id":23001,"comment_id":1,"comment":"\/\/todo: maybe skip some of this stuff if the cube is empty? (would need to use hints)","code":"public void generate(icubicworld world, icubeprimer cube, cubepos cubepos) { \/\/todo: maybe skip some of this stuff if the cube is empty? (would need to use hints) int radius = this.range; this.world = world; this.rand.setseed(world.getseed()); \/\/used to randomize contribution of each coordinate to the cube seed \/\/without these swapping x\/y\/z coordinates would result in the same seed \/\/so structures would generate symmetrically long randx = this.rand.nextlong(); long randy = this.rand.nextlong(); long randz = this.rand.nextlong(); int cubex = cubepos.getx(); int cubey = cubepos.gety(); int cubez = cubepos.getz(); \/\/x\/y\/zorigin is location of the structure \"center\", and cubex\/y\/z is the currently generated cube for (int xorigin = cubex - radius; xorigin <= cubex + radius; ++xorigin) { for (int yorigin = cubey - radius; yorigin <= cubey + radius; ++yorigin) { for (int zorigin = cubez - radius; zorigin <= cubez + radius; ++zorigin) { long randx_mul = xorigin*randx; long randy_mul = yorigin*randy; long randz_mul = zorigin*randz; this.rand.setseed(randx_mul ^ randy_mul ^ randz_mul ^ world.getseed()); this.generate(world, cube, xorigin, yorigin, zorigin, cubepos); } } } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"public void generate(icubicworld world, icubeprimer cube, cubepos cubepos) { \/\/todo: maybe skip some of this stuff if the cube is empty? (would need to use hints) int radius = this.range; this.world = world;","code_context_10":"public void generate(icubicworld world, icubeprimer cube, cubepos cubepos) { \/\/todo: maybe skip some of this stuff if the cube is empty? (would need to use hints) int radius = this.range; this.world = world; this.rand.setseed(world.getseed()); \/\/used to randomize contribution of each coordinate to the cube seed \/\/without these swapping x\/y\/z coordinates would result in the same seed \/\/so structures would generate symmetrically long randx = this.rand.nextlong(); long randy = this.rand.nextlong(); long randz = this.rand.nextlong(); int cubex = cubepos.getx();","code_context_20":"public void generate(icubicworld world, icubeprimer cube, cubepos cubepos) { \/\/todo: maybe skip some of this stuff if the cube is empty? (would need to use hints) int radius = this.range; this.world = world; this.rand.setseed(world.getseed()); \/\/used to randomize contribution of each coordinate to the cube seed \/\/without these swapping x\/y\/z coordinates would result in the same seed \/\/so structures would generate symmetrically long randx = this.rand.nextlong(); long randy = this.rand.nextlong(); long randz = this.rand.nextlong(); int cubex = cubepos.getx(); int cubey = cubepos.gety(); int cubez = cubepos.getz(); \/\/x\/y\/zorigin is location of the structure \"center\", and cubex\/y\/z is the currently generated cube for (int xorigin = cubex - radius; xorigin <= cubex + radius; ++xorigin) { for (int yorigin = cubey - radius; yorigin <= cubey + radius; ++yorigin) { for (int zorigin = cubez - radius; zorigin <= cubez + radius; ++zorigin) { long randx_mul = xorigin*randx; long randy_mul = yorigin*randy; long randz_mul = zorigin*randz; this.rand.setseed(randx_mul ^ randy_mul ^ randz_mul ^ world.getseed());","repo":"Cyclonit\/CubicChunks"}
{"id":23001,"comment_id":2,"comment":"\/\/used to randomize contribution of each coordinate to the cube seed \/\/without these swapping x\/y\/z coordinates would result in the same seed \/\/so structures would generate symmetrically","code":"public void generate(icubicworld world, icubeprimer cube, cubepos cubepos) { \/\/todo: maybe skip some of this stuff if the cube is empty? (would need to use hints) int radius = this.range; this.world = world; this.rand.setseed(world.getseed()); \/\/used to randomize contribution of each coordinate to the cube seed \/\/without these swapping x\/y\/z coordinates would result in the same seed \/\/so structures would generate symmetrically long randx = this.rand.nextlong(); long randy = this.rand.nextlong(); long randz = this.rand.nextlong(); int cubex = cubepos.getx(); int cubey = cubepos.gety(); int cubez = cubepos.getz(); \/\/x\/y\/zorigin is location of the structure \"center\", and cubex\/y\/z is the currently generated cube for (int xorigin = cubex - radius; xorigin <= cubex + radius; ++xorigin) { for (int yorigin = cubey - radius; yorigin <= cubey + radius; ++yorigin) { for (int zorigin = cubez - radius; zorigin <= cubez + radius; ++zorigin) { long randx_mul = xorigin*randx; long randy_mul = yorigin*randy; long randz_mul = zorigin*randz; this.rand.setseed(randx_mul ^ randy_mul ^ randz_mul ^ world.getseed()); this.generate(world, cube, xorigin, yorigin, zorigin, cubepos); } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"this.world = world; this.rand.setseed(world.getseed()); \/\/used to randomize contribution of each coordinate to the cube seed \/\/without these swapping x\/y\/z coordinates would result in the same seed \/\/so structures would generate symmetrically long randx = this.rand.nextlong(); long randy = this.rand.nextlong();","code_context_10":"public void generate(icubicworld world, icubeprimer cube, cubepos cubepos) { \/\/todo: maybe skip some of this stuff if the cube is empty? (would need to use hints) int radius = this.range; this.world = world; this.rand.setseed(world.getseed()); \/\/used to randomize contribution of each coordinate to the cube seed \/\/without these swapping x\/y\/z coordinates would result in the same seed \/\/so structures would generate symmetrically long randx = this.rand.nextlong(); long randy = this.rand.nextlong(); long randz = this.rand.nextlong(); int cubex = cubepos.getx(); int cubey = cubepos.gety(); int cubez = cubepos.getz(); \/\/x\/y\/zorigin is location of the structure \"center\", and cubex\/y\/z is the currently generated cube for (int xorigin = cubex - radius; xorigin <= cubex + radius; ++xorigin) { for (int yorigin = cubey - radius; yorigin <= cubey + radius; ++yorigin) { for (int zorigin = cubez - radius; zorigin <= cubez + radius; ++zorigin) {","code_context_20":"public void generate(icubicworld world, icubeprimer cube, cubepos cubepos) { \/\/todo: maybe skip some of this stuff if the cube is empty? (would need to use hints) int radius = this.range; this.world = world; this.rand.setseed(world.getseed()); \/\/used to randomize contribution of each coordinate to the cube seed \/\/without these swapping x\/y\/z coordinates would result in the same seed \/\/so structures would generate symmetrically long randx = this.rand.nextlong(); long randy = this.rand.nextlong(); long randz = this.rand.nextlong(); int cubex = cubepos.getx(); int cubey = cubepos.gety(); int cubez = cubepos.getz(); \/\/x\/y\/zorigin is location of the structure \"center\", and cubex\/y\/z is the currently generated cube for (int xorigin = cubex - radius; xorigin <= cubex + radius; ++xorigin) { for (int yorigin = cubey - radius; yorigin <= cubey + radius; ++yorigin) { for (int zorigin = cubez - radius; zorigin <= cubez + radius; ++zorigin) { long randx_mul = xorigin*randx; long randy_mul = yorigin*randy; long randz_mul = zorigin*randz; this.rand.setseed(randx_mul ^ randy_mul ^ randz_mul ^ world.getseed()); this.generate(world, cube, xorigin, yorigin, zorigin, cubepos); } } } }","repo":"Cyclonit\/CubicChunks"}
{"id":23001,"comment_id":3,"comment":"\/\/x\/y\/zorigin is location of the structure \"center\", and cubex\/y\/z is the currently generated cube","code":"public void generate(icubicworld world, icubeprimer cube, cubepos cubepos) { \/\/todo: maybe skip some of this stuff if the cube is empty? (would need to use hints) int radius = this.range; this.world = world; this.rand.setseed(world.getseed()); \/\/used to randomize contribution of each coordinate to the cube seed \/\/without these swapping x\/y\/z coordinates would result in the same seed \/\/so structures would generate symmetrically long randx = this.rand.nextlong(); long randy = this.rand.nextlong(); long randz = this.rand.nextlong(); int cubex = cubepos.getx(); int cubey = cubepos.gety(); int cubez = cubepos.getz(); \/\/x\/y\/zorigin is location of the structure \"center\", and cubex\/y\/z is the currently generated cube for (int xorigin = cubex - radius; xorigin <= cubex + radius; ++xorigin) { for (int yorigin = cubey - radius; yorigin <= cubey + radius; ++yorigin) { for (int zorigin = cubez - radius; zorigin <= cubez + radius; ++zorigin) { long randx_mul = xorigin*randx; long randy_mul = yorigin*randy; long randz_mul = zorigin*randz; this.rand.setseed(randx_mul ^ randy_mul ^ randz_mul ^ world.getseed()); this.generate(world, cube, xorigin, yorigin, zorigin, cubepos); } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"int cubey = cubepos.gety(); int cubez = cubepos.getz(); \/\/x\/y\/zorigin is location of the structure \"center\", and cubex\/y\/z is the currently generated cube for (int xorigin = cubex - radius; xorigin <= cubex + radius; ++xorigin) { for (int yorigin = cubey - radius; yorigin <= cubey + radius; ++yorigin) {","code_context_10":"this.rand.setseed(world.getseed()); \/\/used to randomize contribution of each coordinate to the cube seed \/\/without these swapping x\/y\/z coordinates would result in the same seed \/\/so structures would generate symmetrically long randx = this.rand.nextlong(); long randy = this.rand.nextlong(); long randz = this.rand.nextlong(); int cubex = cubepos.getx(); int cubey = cubepos.gety(); int cubez = cubepos.getz(); \/\/x\/y\/zorigin is location of the structure \"center\", and cubex\/y\/z is the currently generated cube for (int xorigin = cubex - radius; xorigin <= cubex + radius; ++xorigin) { for (int yorigin = cubey - radius; yorigin <= cubey + radius; ++yorigin) { for (int zorigin = cubez - radius; zorigin <= cubez + radius; ++zorigin) { long randx_mul = xorigin*randx; long randy_mul = yorigin*randy; long randz_mul = zorigin*randz; this.rand.setseed(randx_mul ^ randy_mul ^ randz_mul ^ world.getseed()); this.generate(world, cube, xorigin, yorigin, zorigin, cubepos); } }","code_context_20":"public void generate(icubicworld world, icubeprimer cube, cubepos cubepos) { \/\/todo: maybe skip some of this stuff if the cube is empty? (would need to use hints) int radius = this.range; this.world = world; this.rand.setseed(world.getseed()); \/\/used to randomize contribution of each coordinate to the cube seed \/\/without these swapping x\/y\/z coordinates would result in the same seed \/\/so structures would generate symmetrically long randx = this.rand.nextlong(); long randy = this.rand.nextlong(); long randz = this.rand.nextlong(); int cubex = cubepos.getx(); int cubey = cubepos.gety(); int cubez = cubepos.getz(); \/\/x\/y\/zorigin is location of the structure \"center\", and cubex\/y\/z is the currently generated cube for (int xorigin = cubex - radius; xorigin <= cubex + radius; ++xorigin) { for (int yorigin = cubey - radius; yorigin <= cubey + radius; ++yorigin) { for (int zorigin = cubez - radius; zorigin <= cubez + radius; ++zorigin) { long randx_mul = xorigin*randx; long randy_mul = yorigin*randy; long randz_mul = zorigin*randz; this.rand.setseed(randx_mul ^ randy_mul ^ randz_mul ^ world.getseed()); this.generate(world, cube, xorigin, yorigin, zorigin, cubepos); } } } }","repo":"Cyclonit\/CubicChunks"}
{"id":31498,"comment_id":0,"comment":"\/** * test of getentereddate method, of class gov.nih.nci.camod.domain.availability. *\/","code":"\/** * test of getentereddate method, of class gov.nih.nci.camod.domain.availability. *\/ public void testgetentereddate() { system.out.println(\"testgetentereddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","classification":"NONSATD","isFinished":true,"code_context_2":"public void testgetentereddate() { system.out.println(\"testgetentereddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_10":"public void testgetentereddate() { system.out.println(\"testgetentereddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_20":"public void testgetentereddate() { system.out.println(\"testgetentereddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod"}
{"id":31498,"comment_id":1,"comment":"\/\/ todo add your test code below by replacing the default call to fail.","code":"public void testgetentereddate() { system.out.println(\"testgetentereddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","classification":"TEST","isFinished":true,"code_context_2":"public void testgetentereddate() { system.out.println(\"testgetentereddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_10":"public void testgetentereddate() { system.out.println(\"testgetentereddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_20":"public void testgetentereddate() { system.out.println(\"testgetentereddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod"}
{"id":31499,"comment_id":0,"comment":"\/** * test of setentereddate method, of class gov.nih.nci.camod.domain.availability. *\/","code":"\/** * test of setentereddate method, of class gov.nih.nci.camod.domain.availability. *\/ public void testsetentereddate() { system.out.println(\"testsetentereddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","classification":"NONSATD","isFinished":true,"code_context_2":"public void testsetentereddate() { system.out.println(\"testsetentereddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_10":"public void testsetentereddate() { system.out.println(\"testsetentereddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_20":"public void testsetentereddate() { system.out.println(\"testsetentereddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod"}
{"id":31499,"comment_id":1,"comment":"\/\/ todo add your test code below by replacing the default call to fail.","code":"public void testsetentereddate() { system.out.println(\"testsetentereddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","classification":"TEST","isFinished":true,"code_context_2":"public void testsetentereddate() { system.out.println(\"testsetentereddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_10":"public void testsetentereddate() { system.out.println(\"testsetentereddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_20":"public void testsetentereddate() { system.out.println(\"testsetentereddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod"}
{"id":31500,"comment_id":0,"comment":"\/** * test of getmodifieddate method, of class gov.nih.nci.camod.domain.availability. *\/","code":"\/** * test of getmodifieddate method, of class gov.nih.nci.camod.domain.availability. *\/ public void testgetmodifieddate() { system.out.println(\"testgetmodifieddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","classification":"NONSATD","isFinished":true,"code_context_2":"public void testgetmodifieddate() { system.out.println(\"testgetmodifieddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_10":"public void testgetmodifieddate() { system.out.println(\"testgetmodifieddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_20":"public void testgetmodifieddate() { system.out.println(\"testgetmodifieddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod"}
{"id":31500,"comment_id":1,"comment":"\/\/ todo add your test code below by replacing the default call to fail.","code":"public void testgetmodifieddate() { system.out.println(\"testgetmodifieddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","classification":"TEST","isFinished":true,"code_context_2":"public void testgetmodifieddate() { system.out.println(\"testgetmodifieddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_10":"public void testgetmodifieddate() { system.out.println(\"testgetmodifieddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_20":"public void testgetmodifieddate() { system.out.println(\"testgetmodifieddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod"}
{"id":31501,"comment_id":0,"comment":"\/** * test of setmodifieddate method, of class gov.nih.nci.camod.domain.availability. *\/","code":"\/** * test of setmodifieddate method, of class gov.nih.nci.camod.domain.availability. *\/ public void testsetmodifieddate() { system.out.println(\"testsetmodifieddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","classification":"NONSATD","isFinished":true,"code_context_2":"public void testsetmodifieddate() { system.out.println(\"testsetmodifieddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_10":"public void testsetmodifieddate() { system.out.println(\"testsetmodifieddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_20":"public void testsetmodifieddate() { system.out.println(\"testsetmodifieddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod"}
{"id":31501,"comment_id":1,"comment":"\/\/ todo add your test code below by replacing the default call to fail.","code":"public void testsetmodifieddate() { system.out.println(\"testsetmodifieddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"public void testsetmodifieddate() { system.out.println(\"testsetmodifieddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_10":"public void testsetmodifieddate() { system.out.println(\"testsetmodifieddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_20":"public void testsetmodifieddate() { system.out.println(\"testsetmodifieddate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod"}
{"id":31502,"comment_id":0,"comment":"\/** * test of getreleasedate method, of class gov.nih.nci.camod.domain.availability. *\/","code":"\/** * test of getreleasedate method, of class gov.nih.nci.camod.domain.availability. *\/ public void testgetreleasedate() { system.out.println(\"testgetreleasedate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","classification":"NONSATD","isFinished":true,"code_context_2":"public void testgetreleasedate() { system.out.println(\"testgetreleasedate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_10":"public void testgetreleasedate() { system.out.println(\"testgetreleasedate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_20":"public void testgetreleasedate() { system.out.println(\"testgetreleasedate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod"}
{"id":31502,"comment_id":1,"comment":"\/\/ todo add your test code below by replacing the default call to fail.","code":"public void testgetreleasedate() { system.out.println(\"testgetreleasedate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","classification":"TEST","isFinished":true,"code_context_2":"public void testgetreleasedate() { system.out.println(\"testgetreleasedate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_10":"public void testgetreleasedate() { system.out.println(\"testgetreleasedate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_20":"public void testgetreleasedate() { system.out.println(\"testgetreleasedate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod"}
{"id":31503,"comment_id":0,"comment":"\/** * test of setreleasedate method, of class gov.nih.nci.camod.domain.availability. *\/","code":"\/** * test of setreleasedate method, of class gov.nih.nci.camod.domain.availability. *\/ public void testsetreleasedate() { system.out.println(\"testsetreleasedate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","classification":"NONSATD","isFinished":true,"code_context_2":"public void testsetreleasedate() { system.out.println(\"testsetreleasedate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_10":"public void testsetreleasedate() { system.out.println(\"testsetreleasedate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_20":"public void testsetreleasedate() { system.out.println(\"testsetreleasedate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod"}
{"id":31503,"comment_id":1,"comment":"\/\/ todo add your test code below by replacing the default call to fail.","code":"public void testsetreleasedate() { system.out.println(\"testsetreleasedate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","classification":"TEST","isFinished":true,"code_context_2":"public void testsetreleasedate() { system.out.println(\"testsetreleasedate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_10":"public void testsetreleasedate() { system.out.println(\"testsetreleasedate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_20":"public void testsetreleasedate() { system.out.println(\"testsetreleasedate\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod"}
{"id":31504,"comment_id":0,"comment":"\/** * test of getvisibleto method, of class gov.nih.nci.camod.domain.availability. *\/","code":"\/** * test of getvisibleto method, of class gov.nih.nci.camod.domain.availability. *\/ public void testgetvisibleto() { system.out.println(\"testgetvisibleto\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","classification":"NONSATD","isFinished":true,"code_context_2":"public void testgetvisibleto() { system.out.println(\"testgetvisibleto\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_10":"public void testgetvisibleto() { system.out.println(\"testgetvisibleto\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_20":"public void testgetvisibleto() { system.out.println(\"testgetvisibleto\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod"}
{"id":31504,"comment_id":1,"comment":"\/\/ todo add your test code below by replacing the default call to fail.","code":"public void testgetvisibleto() { system.out.println(\"testgetvisibleto\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","classification":"TEST","isFinished":true,"code_context_2":"public void testgetvisibleto() { system.out.println(\"testgetvisibleto\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_10":"public void testgetvisibleto() { system.out.println(\"testgetvisibleto\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_20":"public void testgetvisibleto() { system.out.println(\"testgetvisibleto\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod"}
{"id":31505,"comment_id":0,"comment":"\/** * test of setvisibleto method, of class gov.nih.nci.camod.domain.availability. *\/","code":"\/** * test of setvisibleto method, of class gov.nih.nci.camod.domain.availability. *\/ public void testsetvisibleto() { system.out.println(\"testsetvisibleto\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","classification":"NONSATD","isFinished":true,"code_context_2":"public void testsetvisibleto() { system.out.println(\"testsetvisibleto\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_10":"public void testsetvisibleto() { system.out.println(\"testsetvisibleto\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_20":"public void testsetvisibleto() { system.out.println(\"testsetvisibleto\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod"}
{"id":31505,"comment_id":1,"comment":"\/\/ todo add your test code below by replacing the default call to fail.","code":"public void testsetvisibleto() { system.out.println(\"testsetvisibleto\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","classification":"TEST","isFinished":true,"code_context_2":"public void testsetvisibleto() { system.out.println(\"testsetvisibleto\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_10":"public void testsetvisibleto() { system.out.println(\"testsetvisibleto\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_20":"public void testsetvisibleto() { system.out.println(\"testsetvisibleto\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod"}
{"id":31506,"comment_id":0,"comment":"\/** * test of tostring method, of class gov.nih.nci.camod.domain.availability. *\/","code":"\/** * test of tostring method, of class gov.nih.nci.camod.domain.availability. *\/ public void testtostring() { system.out.println(\"testtostring\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","classification":"NONSATD","isFinished":true,"code_context_2":"public void testtostring() { system.out.println(\"testtostring\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_10":"public void testtostring() { system.out.println(\"testtostring\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_20":"public void testtostring() { system.out.println(\"testtostring\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod"}
{"id":31506,"comment_id":1,"comment":"\/\/ todo add your test code below by replacing the default call to fail.","code":"public void testtostring() { system.out.println(\"testtostring\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","classification":"TEST","isFinished":true,"code_context_2":"public void testtostring() { system.out.println(\"testtostring\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_10":"public void testtostring() { system.out.println(\"testtostring\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_20":"public void testtostring() { system.out.println(\"testtostring\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod"}
{"id":31507,"comment_id":0,"comment":"\/** * test of equals method, of class gov.nih.nci.camod.domain.availability. *\/","code":"\/** * test of equals method, of class gov.nih.nci.camod.domain.availability. *\/ public void testequals() { system.out.println(\"testequals\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","classification":"NONSATD","isFinished":true,"code_context_2":"public void testequals() { system.out.println(\"testequals\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_10":"public void testequals() { system.out.println(\"testequals\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_20":"public void testequals() { system.out.println(\"testequals\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod"}
{"id":31507,"comment_id":1,"comment":"\/\/ todo add your test code below by replacing the default call to fail.","code":"public void testequals() { system.out.println(\"testequals\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","classification":"TEST","isFinished":true,"code_context_2":"public void testequals() { system.out.println(\"testequals\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_10":"public void testequals() { system.out.println(\"testequals\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","code_context_20":"public void testequals() { system.out.println(\"testequals\"); \/\/ todo add your test code below by replacing the default call to fail. fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod"}
{"id":15312,"comment_id":0,"comment":"\/\/todo: file was choosen;","code":"private void initmenuitems() { menuitemfileopen.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { var filechooser = new filechooser(); var selected = filechooser.showopendialog(null); if (selected != null) { \/\/todo: file was choosen; ifmlengine.loadstory(selected); } } }); menuitemfilerestart.setdisable(true); menuitemfilerestart.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { \/\/todo: ask you are sure ? ifmlengine.restart(); } }); menuitemfilesave.setdisable(true); menuitemfileload.setdisable(true); menuitemfileexit.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { \/\/todo: add question: you are really want to exit. platform.exit(); } }); menuitemlibrarycatalog.setdisable(true); menuitemlibraryimport.setdisable(true); menuitemsettingscheat.setdisable(true); menuitemsettingssettings.setdisable(true); }","classification":"NONSATD","isFinished":true,"code_context_2":"var selected = filechooser.showopendialog(null); if (selected != null) { \/\/todo: file was choosen; ifmlengine.loadstory(selected); }","code_context_10":"private void initmenuitems() { menuitemfileopen.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { var filechooser = new filechooser(); var selected = filechooser.showopendialog(null); if (selected != null) { \/\/todo: file was choosen; ifmlengine.loadstory(selected); } } }); menuitemfilerestart.setdisable(true); menuitemfilerestart.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { \/\/todo: ask you are sure ? ifmlengine.restart();","code_context_20":"private void initmenuitems() { menuitemfileopen.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { var filechooser = new filechooser(); var selected = filechooser.showopendialog(null); if (selected != null) { \/\/todo: file was choosen; ifmlengine.loadstory(selected); } } }); menuitemfilerestart.setdisable(true); menuitemfilerestart.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { \/\/todo: ask you are sure ? ifmlengine.restart(); } }); menuitemfilesave.setdisable(true); menuitemfileload.setdisable(true); menuitemfileexit.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { \/\/todo: add question: you are really want to exit. platform.exit(); }","repo":"IFML2\/ifml-player"}
{"id":15312,"comment_id":1,"comment":"\/\/todo: ask you are sure ?","code":"private void initmenuitems() { menuitemfileopen.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { var filechooser = new filechooser(); var selected = filechooser.showopendialog(null); if (selected != null) { \/\/todo: file was choosen; ifmlengine.loadstory(selected); } } }); menuitemfilerestart.setdisable(true); menuitemfilerestart.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { \/\/todo: ask you are sure ? ifmlengine.restart(); } }); menuitemfilesave.setdisable(true); menuitemfileload.setdisable(true); menuitemfileexit.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { \/\/todo: add question: you are really want to exit. platform.exit(); } }); menuitemlibrarycatalog.setdisable(true); menuitemlibraryimport.setdisable(true); menuitemsettingscheat.setdisable(true); menuitemsettingssettings.setdisable(true); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"@override public void handle(actionevent event) { \/\/todo: ask you are sure ? ifmlengine.restart(); }","code_context_10":"if (selected != null) { \/\/todo: file was choosen; ifmlengine.loadstory(selected); } } }); menuitemfilerestart.setdisable(true); menuitemfilerestart.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { \/\/todo: ask you are sure ? ifmlengine.restart(); } }); menuitemfilesave.setdisable(true); menuitemfileload.setdisable(true); menuitemfileexit.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { \/\/todo: add question: you are really want to exit. platform.exit();","code_context_20":"private void initmenuitems() { menuitemfileopen.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { var filechooser = new filechooser(); var selected = filechooser.showopendialog(null); if (selected != null) { \/\/todo: file was choosen; ifmlengine.loadstory(selected); } } }); menuitemfilerestart.setdisable(true); menuitemfilerestart.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { \/\/todo: ask you are sure ? ifmlengine.restart(); } }); menuitemfilesave.setdisable(true); menuitemfileload.setdisable(true); menuitemfileexit.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { \/\/todo: add question: you are really want to exit. platform.exit(); } }); menuitemlibrarycatalog.setdisable(true); menuitemlibraryimport.setdisable(true); menuitemsettingscheat.setdisable(true); menuitemsettingssettings.setdisable(true); }","repo":"IFML2\/ifml-player"}
{"id":15312,"comment_id":2,"comment":"\/\/todo: add question: you are really want to exit.","code":"private void initmenuitems() { menuitemfileopen.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { var filechooser = new filechooser(); var selected = filechooser.showopendialog(null); if (selected != null) { \/\/todo: file was choosen; ifmlengine.loadstory(selected); } } }); menuitemfilerestart.setdisable(true); menuitemfilerestart.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { \/\/todo: ask you are sure ? ifmlengine.restart(); } }); menuitemfilesave.setdisable(true); menuitemfileload.setdisable(true); menuitemfileexit.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { \/\/todo: add question: you are really want to exit. platform.exit(); } }); menuitemlibrarycatalog.setdisable(true); menuitemlibraryimport.setdisable(true); menuitemsettingscheat.setdisable(true); menuitemsettingssettings.setdisable(true); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"@override public void handle(actionevent event) { \/\/todo: add question: you are really want to exit. platform.exit(); }","code_context_10":"public void handle(actionevent event) { \/\/todo: ask you are sure ? ifmlengine.restart(); } }); menuitemfilesave.setdisable(true); menuitemfileload.setdisable(true); menuitemfileexit.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { \/\/todo: add question: you are really want to exit. platform.exit(); } }); menuitemlibrarycatalog.setdisable(true); menuitemlibraryimport.setdisable(true); menuitemsettingscheat.setdisable(true); menuitemsettingssettings.setdisable(true); }","code_context_20":"var selected = filechooser.showopendialog(null); if (selected != null) { \/\/todo: file was choosen; ifmlengine.loadstory(selected); } } }); menuitemfilerestart.setdisable(true); menuitemfilerestart.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { \/\/todo: ask you are sure ? ifmlengine.restart(); } }); menuitemfilesave.setdisable(true); menuitemfileload.setdisable(true); menuitemfileexit.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { \/\/todo: add question: you are really want to exit. platform.exit(); } }); menuitemlibrarycatalog.setdisable(true); menuitemlibraryimport.setdisable(true); menuitemsettingscheat.setdisable(true); menuitemsettingssettings.setdisable(true); }","repo":"IFML2\/ifml-player"}
{"id":15473,"comment_id":0,"comment":"\/\/ ensure directories exist","code":"private static path resolve(path parent, string path) { \/\/ ensure directories exist file directory = parent.tofile(); if (!directory.exists() && !directory.mkdirs()) { \/\/ failed to create directories... should probably let this crash scalinghealth.logger.error(\"failed to create config directory '{}'. this won't end well...\", directory.getabsolutepath()); } return parent.resolve(path); }","classification":"NONSATD","isFinished":true,"code_context_2":"private static path resolve(path parent, string path) { \/\/ ensure directories exist file directory = parent.tofile(); if (!directory.exists() && !directory.mkdirs()) {","code_context_10":"private static path resolve(path parent, string path) { \/\/ ensure directories exist file directory = parent.tofile(); if (!directory.exists() && !directory.mkdirs()) { \/\/ failed to create directories... should probably let this crash scalinghealth.logger.error(\"failed to create config directory '{}'. this won't end well...\", directory.getabsolutepath()); } return parent.resolve(path); }","code_context_20":"private static path resolve(path parent, string path) { \/\/ ensure directories exist file directory = parent.tofile(); if (!directory.exists() && !directory.mkdirs()) { \/\/ failed to create directories... should probably let this crash scalinghealth.logger.error(\"failed to create config directory '{}'. this won't end well...\", directory.getabsolutepath()); } return parent.resolve(path); }","repo":"Cyborgmas\/ScalingHealth"}
{"id":15473,"comment_id":1,"comment":"\/\/ failed to create directories... should probably let this crash","code":"private static path resolve(path parent, string path) { \/\/ ensure directories exist file directory = parent.tofile(); if (!directory.exists() && !directory.mkdirs()) { \/\/ failed to create directories... should probably let this crash scalinghealth.logger.error(\"failed to create config directory '{}'. this won't end well...\", directory.getabsolutepath()); } return parent.resolve(path); }","classification":"DEFECT","isFinished":true,"code_context_2":"file directory = parent.tofile(); if (!directory.exists() && !directory.mkdirs()) { \/\/ failed to create directories... should probably let this crash scalinghealth.logger.error(\"failed to create config directory '{}'. this won't end well...\", directory.getabsolutepath());","code_context_10":"private static path resolve(path parent, string path) { \/\/ ensure directories exist file directory = parent.tofile(); if (!directory.exists() && !directory.mkdirs()) { \/\/ failed to create directories... should probably let this crash scalinghealth.logger.error(\"failed to create config directory '{}'. this won't end well...\", directory.getabsolutepath()); } return parent.resolve(path); }","code_context_20":"private static path resolve(path parent, string path) { \/\/ ensure directories exist file directory = parent.tofile(); if (!directory.exists() && !directory.mkdirs()) { \/\/ failed to create directories... should probably let this crash scalinghealth.logger.error(\"failed to create config directory '{}'. this won't end well...\", directory.getabsolutepath()); } return parent.resolve(path); }","repo":"Cyborgmas\/ScalingHealth"}
{"id":15483,"comment_id":0,"comment":"\/\/ todo: set working dir","code":"\/\/ todo: set working dir private static object invokeannotation(class<?> clazz, object[] trees) throws instantiationexception, illegalaccessexception, invocationtargetexception { constructor<?> ctor = clazz.getdeclaredconstructors()[0]; ctor.setaccessible(true); object instance = ctor.newinstance(); method method = null; method[] declaredmethods = clazz.getdeclaredmethods(); for (method m : declaredmethods) { if (m.getname().equals(\"apply\")) method = m; } assert method != null: \"method 'apply' not found in annotation class\"; method.setaccessible(true); object result; try { result = method.invoke(instance, trees); } catch (invocationtargetexception e) { \/\/ we can't even pass exceptions without re-wraping them since classes on the invoking side are incompatible \/\/ also flatten to avoid getting nested ites runtimeexception exception = new runtimeexception(e.gettargetexception().tostring()); exception.setstacktrace(e.getstacktrace()); throw exception; } return result; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"private static object invokeannotation(class<?> clazz, object[] trees) throws instantiationexception, illegalaccessexception, invocationtargetexception { constructor<?> ctor = clazz.getdeclaredconstructors()[0]; ctor.setaccessible(true); object instance = ctor.newinstance(); method method = null; method[] declaredmethods = clazz.getdeclaredmethods(); for (method m : declaredmethods) { if (m.getname().equals(\"apply\")) method = m; } assert method != null: \"method 'apply' not found in annotation class\"; method.setaccessible(true); object result; try { result = method.invoke(instance, trees); } catch (invocationtargetexception e) { \/\/ we can't even pass exceptions without re-wraping them since classes on the invoking side are incompatible \/\/ also flatten to avoid getting nested ites runtimeexception exception = new runtimeexception(e.gettargetexception().tostring()); exception.setstacktrace(e.getstacktrace()); throw exception; } return result; }","code_context_10":"private static object invokeannotation(class<?> clazz, object[] trees) throws instantiationexception, illegalaccessexception, invocationtargetexception { constructor<?> ctor = clazz.getdeclaredconstructors()[0]; ctor.setaccessible(true); object instance = ctor.newinstance(); method method = null; method[] declaredmethods = clazz.getdeclaredmethods(); for (method m : declaredmethods) { if (m.getname().equals(\"apply\")) method = m; } assert method != null: \"method 'apply' not found in annotation class\"; method.setaccessible(true); object result; try { result = method.invoke(instance, trees); } catch (invocationtargetexception e) { \/\/ we can't even pass exceptions without re-wraping them since classes on the invoking side are incompatible \/\/ also flatten to avoid getting nested ites runtimeexception exception = new runtimeexception(e.gettargetexception().tostring()); exception.setstacktrace(e.getstacktrace()); throw exception; } return result; }","code_context_20":"private static object invokeannotation(class<?> clazz, object[] trees) throws instantiationexception, illegalaccessexception, invocationtargetexception { constructor<?> ctor = clazz.getdeclaredconstructors()[0]; ctor.setaccessible(true); object instance = ctor.newinstance(); method method = null; method[] declaredmethods = clazz.getdeclaredmethods(); for (method m : declaredmethods) { if (m.getname().equals(\"apply\")) method = m; } assert method != null: \"method 'apply' not found in annotation class\"; method.setaccessible(true); object result; try { result = method.invoke(instance, trees); } catch (invocationtargetexception e) { \/\/ we can't even pass exceptions without re-wraping them since classes on the invoking side are incompatible \/\/ also flatten to avoid getting nested ites runtimeexception exception = new runtimeexception(e.gettargetexception().tostring()); exception.setstacktrace(e.getstacktrace()); throw exception; } return result; }","repo":"FogInTheFrog\/intellij-scala"}
{"id":15483,"comment_id":1,"comment":"\/\/ we can't even pass exceptions without re-wraping them since classes on the invoking side are incompatible \/\/ also flatten to avoid getting nested ites","code":"private static object invokeannotation(class<?> clazz, object[] trees) throws instantiationexception, illegalaccessexception, invocationtargetexception { constructor<?> ctor = clazz.getdeclaredconstructors()[0]; ctor.setaccessible(true); object instance = ctor.newinstance(); method method = null; method[] declaredmethods = clazz.getdeclaredmethods(); for (method m : declaredmethods) { if (m.getname().equals(\"apply\")) method = m; } assert method != null: \"method 'apply' not found in annotation class\"; method.setaccessible(true); object result; try { result = method.invoke(instance, trees); } catch (invocationtargetexception e) { \/\/ we can't even pass exceptions without re-wraping them since classes on the invoking side are incompatible \/\/ also flatten to avoid getting nested ites runtimeexception exception = new runtimeexception(e.gettargetexception().tostring()); exception.setstacktrace(e.getstacktrace()); throw exception; } return result; }","classification":"NONSATD","isFinished":true,"code_context_2":"result = method.invoke(instance, trees); } catch (invocationtargetexception e) { \/\/ we can't even pass exceptions without re-wraping them since classes on the invoking side are incompatible \/\/ also flatten to avoid getting nested ites runtimeexception exception = new runtimeexception(e.gettargetexception().tostring()); exception.setstacktrace(e.getstacktrace());","code_context_10":"method[] declaredmethods = clazz.getdeclaredmethods(); for (method m : declaredmethods) { if (m.getname().equals(\"apply\")) method = m; } assert method != null: \"method 'apply' not found in annotation class\"; method.setaccessible(true); object result; try { result = method.invoke(instance, trees); } catch (invocationtargetexception e) { \/\/ we can't even pass exceptions without re-wraping them since classes on the invoking side are incompatible \/\/ also flatten to avoid getting nested ites runtimeexception exception = new runtimeexception(e.gettargetexception().tostring()); exception.setstacktrace(e.getstacktrace()); throw exception; } return result; }","code_context_20":"private static object invokeannotation(class<?> clazz, object[] trees) throws instantiationexception, illegalaccessexception, invocationtargetexception { constructor<?> ctor = clazz.getdeclaredconstructors()[0]; ctor.setaccessible(true); object instance = ctor.newinstance(); method method = null; method[] declaredmethods = clazz.getdeclaredmethods(); for (method m : declaredmethods) { if (m.getname().equals(\"apply\")) method = m; } assert method != null: \"method 'apply' not found in annotation class\"; method.setaccessible(true); object result; try { result = method.invoke(instance, trees); } catch (invocationtargetexception e) { \/\/ we can't even pass exceptions without re-wraping them since classes on the invoking side are incompatible \/\/ also flatten to avoid getting nested ites runtimeexception exception = new runtimeexception(e.gettargetexception().tostring()); exception.setstacktrace(e.getstacktrace()); throw exception; } return result; }","repo":"FogInTheFrog\/intellij-scala"}
{"id":23785,"comment_id":0,"comment":"\/\/ todo insert preface","code":"private static void replaceparagraphwithpreface(final context context, final xwpfparagraph paragraph) { try (final cursorhelper cursorhelper = context.newcursorhelper(paragraph)) { \/\/ todo insert preface } finally { context.getdocument().removebodyelement(context.getdocument().getposofparagraph(paragraph)); } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"private static void replaceparagraphwithpreface(final context context, final xwpfparagraph paragraph) { try (final cursorhelper cursorhelper = context.newcursorhelper(paragraph)) { \/\/ todo insert preface } finally { context.getdocument().removebodyelement(context.getdocument().getposofparagraph(paragraph));","code_context_10":"private static void replaceparagraphwithpreface(final context context, final xwpfparagraph paragraph) { try (final cursorhelper cursorhelper = context.newcursorhelper(paragraph)) { \/\/ todo insert preface } finally { context.getdocument().removebodyelement(context.getdocument().getposofparagraph(paragraph)); } }","code_context_20":"private static void replaceparagraphwithpreface(final context context, final xwpfparagraph paragraph) { try (final cursorhelper cursorhelper = context.newcursorhelper(paragraph)) { \/\/ todo insert preface } finally { context.getdocument().removebodyelement(context.getdocument().getposofparagraph(paragraph)); } }","repo":"FIT-Mobility\/dimo-tool-suite"}
{"id":15634,"comment_id":0,"comment":"\/* * when 'node' has been created under 'parent' (by the sessioncontext user) this will send a * notification to foreign servers. this call returns immediately and delegates the actuall * proccessing to a daemon thread. * * for concurrency reasons, note that we pass in the nodeid to this method rather than the node even * if we do have the node, because we want to make sure there's no concurrent access. * * important: this method only sends notifications to users who are in the 'acl' which means these * can only be users already imported into the system, however this is ok, because we will have * called savementionstonodeacl() right before calling this method so the 'acl' should completely * contain all the mentions that exist in the text of the message. * * todo-0: we should probably extract out of this method the actual construction of the 'message' * itself and then pass the message in as a parameter, and we'd be passing in without setting the * 'cc + to' properties on the message and then the message would have those added inside here * insead of building the entire message from scratch. *\/","code":"\/* * when 'node' has been created under 'parent' (by the sessioncontext user) this will send a * notification to foreign servers. this call returns immediately and delegates the actuall * proccessing to a daemon thread. * * for concurrency reasons, note that we pass in the nodeid to this method rather than the node even * if we do have the node, because we want to make sure there's no concurrent access. * * important: this method only sends notifications to users who are in the 'acl' which means these * can only be users already imported into the system, however this is ok, because we will have * called savementionstonodeacl() right before calling this method so the 'acl' should completely * contain all the mentions that exist in the text of the message. * * todo-0: we should probably extract out of this method the actual construction of the 'message' * itself and then pass the message in as a parameter, and we'd be passing in without setting the * 'cc + to' properties on the message and then the message would have those added inside here * insead of building the entire message from scratch. *\/ public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","classification":"DESIGN","isFinished":true,"code_context_2":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","code_context_10":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","code_context_20":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","repo":"Clay-Ferguson\/Quantizr"}
{"id":15634,"comment_id":1,"comment":"\/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is.","code":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","classification":"NONSATD","isFinished":true,"code_context_2":"try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null;","code_context_10":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else {","code_context_20":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames'","repo":"Clay-Ferguson\/Quantizr"}
{"id":15634,"comment_id":2,"comment":"\/\/ tousernames will hold all usernames in the acl list (both local and foreign user names)","code":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","classification":"NONSATD","isFinished":true,"code_context_2":"string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true;","code_context_10":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) {","code_context_20":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } }","repo":"Clay-Ferguson\/Quantizr"}
{"id":15634,"comment_id":3,"comment":"\/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/","code":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","classification":"NONSATD","isFinished":true,"code_context_2":"} else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) {","code_context_10":"aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } }","code_context_20":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) {","repo":"Clay-Ferguson\/Quantizr"}
{"id":15634,"comment_id":4,"comment":"\/\/ get username off this node and add to 'tousernames'","code":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","classification":"NONSATD","isFinished":true,"code_context_2":"} else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user));","code_context_10":"} else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser);","code_context_20":"\/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save","repo":"Clay-Ferguson\/Quantizr"}
{"id":15634,"comment_id":5,"comment":"\/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s());","code":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","classification":"NONSATD","isFinished":true,"code_context_2":"} } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser);","code_context_10":"} else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else {","code_context_20":"if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else {","repo":"Clay-Ferguson\/Quantizr"}
{"id":15634,"comment_id":6,"comment":"\/\/ construct the update-type wrapper around teh person object, and send","code":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","classification":"NONSATD","isFinished":true,"code_context_2":"apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message));","code_context_10":"} } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage);","code_context_20":"for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>();","repo":"Clay-Ferguson\/Quantizr"}
{"id":15634,"comment_id":7,"comment":"\/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?)","code":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","classification":"DESIGN","isFinished":true,"code_context_2":"log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc);","code_context_10":"string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); }","code_context_20":"subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them","repo":"Clay-Ferguson\/Quantizr"}
{"id":15634,"comment_id":8,"comment":"\/\/ else send out as a note.","code":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","classification":"NONSATD","isFinished":true,"code_context_2":"apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype,","code_context_10":"log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) {","code_context_20":"} \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above.","repo":"Clay-Ferguson\/Quantizr"}
{"id":15634,"comment_id":9,"comment":"\/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually","code":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","classification":"NONSATD","isFinished":true,"code_context_2":"} } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here","code_context_10":"zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof);","code_context_20":"apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e);","repo":"Clay-Ferguson\/Quantizr"}
{"id":15634,"comment_id":10,"comment":"\/\/ when posting a public message we send out to all unique sharedinboxes here","code":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>();","code_context_10":"} \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue","code_context_20":"message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } });","repo":"Clay-Ferguson\/Quantizr"}
{"id":15634,"comment_id":11,"comment":"\/\/ loads only foreign user's inboxes into the two sets.","code":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","classification":"NONSATD","isFinished":true,"code_context_2":"if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them","code_context_10":"message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes);","code_context_20":"\/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","repo":"Clay-Ferguson\/Quantizr"}
{"id":15634,"comment_id":12,"comment":"\/\/ merge both sets of inboxes into allinboxes and send to them","code":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes);","code_context_10":"} } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/","code_context_20":"\/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","repo":"Clay-Ferguson\/Quantizr"}
{"id":15634,"comment_id":13,"comment":"\/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above.","code":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","classification":"NONSATD","isFinished":true,"code_context_2":"aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes);","code_context_10":"\/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","code_context_20":"} \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","repo":"Clay-Ferguson\/Quantizr"}
{"id":15634,"comment_id":14,"comment":"\/\/","code":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); \/\/ get username off this node and add to 'tousernames' if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } \/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s()); string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { \/\/ construct the update-type wrapper around teh person object, and send message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { \/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?) if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } \/\/ else send out as a note. else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } \/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually hashset<string> userinboxes = new hashset<>(); \/\/ when posting a public message we send out to all unique sharedinboxes here if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); \/\/ loads only foreign user's inboxes into the two sets. getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); \/\/ merge both sets of inboxes into allinboxes and send to them hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } \/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above. if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } \/\/ catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","classification":"NONSATD","isFinished":true,"code_context_2":"try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null;","code_context_10":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false;","code_context_20":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); \/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is. string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); \/\/ tousernames will hold all usernames in the acl list (both local and foreign user names) hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { \/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/ for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid);","repo":"Clay-Ferguson\/Quantizr"}
{"id":15732,"comment_id":0,"comment":"\/\/ todo how to react to failure status of dcevstatus of cablecheckreq? \/* * todo we need a timeout mechanism here so that a response can be sent within 2s * the dcevsestatus should be generated according to already available values * (if evseprocessing == ongoing, maybe because of evse_isolationmonitoringactive, * within a certain timeout, then the status must be different) *\/","code":"@override public reactiontoincomingmessage processincomingmessage(object message) { if (isincomingmessagevalid(message, cablecheckreqtype.class, cablecheckres)) { v2gmessage v2gmessagereq = (v2gmessage) message; cablecheckreqtype cablecheckreq = (cablecheckreqtype) v2gmessagereq.getbody().getbodyelement().getvalue(); \/\/ todo how to react to failure status of dcevstatus of cablecheckreq? \/* * todo we need a timeout mechanism here so that a response can be sent within 2s * the dcevsestatus should be generated according to already available values * (if evseprocessing == ongoing, maybe because of evse_isolationmonitoringactive, * within a certain timeout, then the status must be different) *\/ setevseprocessingfinished(true); if (isevseprocessingfinished()) { cablecheckres.setevseprocessing(evseprocessingtype.finished); cablecheckres.setdcevsestatus( ((idcevsecontroller) getcommsessioncontext().getdcevsecontroller()).getdcevsestatus(evsenotificationtype.none) ); return getsendmessage(cablecheckres, v2gmessages.pre_charge_req); } else { cablecheckres.setevseprocessing(evseprocessingtype.ongoing); return getsendmessage(cablecheckres, v2gmessages.cable_check_req); } } else { setmandatoryfieldsforfailedres(); } return getsendmessage(cablecheckres, v2gmessages.none); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"cablecheckreqtype cablecheckreq = (cablecheckreqtype) v2gmessagereq.getbody().getbodyelement().getvalue(); \/\/ todo how to react to failure status of dcevstatus of cablecheckreq? \/* * todo we need a timeout mechanism here so that a response can be sent within 2s * the dcevsestatus should be generated according to already available values * (if evseprocessing == ongoing, maybe because of evse_isolationmonitoringactive, * within a certain timeout, then the status must be different) *\/ setevseprocessingfinished(true); if (isevseprocessingfinished()) {","code_context_10":"@override public reactiontoincomingmessage processincomingmessage(object message) { if (isincomingmessagevalid(message, cablecheckreqtype.class, cablecheckres)) { v2gmessage v2gmessagereq = (v2gmessage) message; cablecheckreqtype cablecheckreq = (cablecheckreqtype) v2gmessagereq.getbody().getbodyelement().getvalue(); \/\/ todo how to react to failure status of dcevstatus of cablecheckreq? \/* * todo we need a timeout mechanism here so that a response can be sent within 2s * the dcevsestatus should be generated according to already available values * (if evseprocessing == ongoing, maybe because of evse_isolationmonitoringactive, * within a certain timeout, then the status must be different) *\/ setevseprocessingfinished(true); if (isevseprocessingfinished()) { cablecheckres.setevseprocessing(evseprocessingtype.finished); cablecheckres.setdcevsestatus( ((idcevsecontroller) getcommsessioncontext().getdcevsecontroller()).getdcevsestatus(evsenotificationtype.none) ); return getsendmessage(cablecheckres, v2gmessages.pre_charge_req); } else { cablecheckres.setevseprocessing(evseprocessingtype.ongoing); return getsendmessage(cablecheckres, v2gmessages.cable_check_req);","code_context_20":"@override public reactiontoincomingmessage processincomingmessage(object message) { if (isincomingmessagevalid(message, cablecheckreqtype.class, cablecheckres)) { v2gmessage v2gmessagereq = (v2gmessage) message; cablecheckreqtype cablecheckreq = (cablecheckreqtype) v2gmessagereq.getbody().getbodyelement().getvalue(); \/\/ todo how to react to failure status of dcevstatus of cablecheckreq? \/* * todo we need a timeout mechanism here so that a response can be sent within 2s * the dcevsestatus should be generated according to already available values * (if evseprocessing == ongoing, maybe because of evse_isolationmonitoringactive, * within a certain timeout, then the status must be different) *\/ setevseprocessingfinished(true); if (isevseprocessingfinished()) { cablecheckres.setevseprocessing(evseprocessingtype.finished); cablecheckres.setdcevsestatus( ((idcevsecontroller) getcommsessioncontext().getdcevsecontroller()).getdcevsestatus(evsenotificationtype.none) ); return getsendmessage(cablecheckres, v2gmessages.pre_charge_req); } else { cablecheckres.setevseprocessing(evseprocessingtype.ongoing); return getsendmessage(cablecheckres, v2gmessages.cable_check_req); } } else { setmandatoryfieldsforfailedres(); } return getsendmessage(cablecheckres, v2gmessages.none); }","repo":"I2SE\/RISE-V2G"}
{"id":15882,"comment_id":0,"comment":"\/** * starts this service to perform action foo with the given parameters. if * the service is already performing a task this action will be queued. * * @see intentservice *\/ \/\/ todo: customize helper method","code":"\/** * starts this service to perform action foo with the given parameters. if * the service is already performing a task this action will be queued. * * @see intentservice *\/ \/\/ todo: customize helper method public static void startactionfoo(context context, string param1, string param2) { intent intent = new intent(context, myintentservice.class); intent.setaction(action_foo); intent.putextra(extra_param1, param1); intent.putextra(extra_param2, param2); context.startservice(intent); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"public static void startactionfoo(context context, string param1, string param2) { intent intent = new intent(context, myintentservice.class); intent.setaction(action_foo); intent.putextra(extra_param1, param1); intent.putextra(extra_param2, param2); context.startservice(intent); }","code_context_10":"public static void startactionfoo(context context, string param1, string param2) { intent intent = new intent(context, myintentservice.class); intent.setaction(action_foo); intent.putextra(extra_param1, param1); intent.putextra(extra_param2, param2); context.startservice(intent); }","code_context_20":"public static void startactionfoo(context context, string param1, string param2) { intent intent = new intent(context, myintentservice.class); intent.setaction(action_foo); intent.putextra(extra_param1, param1); intent.putextra(extra_param2, param2); context.startservice(intent); }","repo":"CasterIO\/Bootstrap"}
{"id":15883,"comment_id":0,"comment":"\/** * starts this service to perform action baz with the given parameters. if * the service is already performing a task this action will be queued. * * @see intentservice *\/ \/\/ todo: customize helper method","code":"\/** * starts this service to perform action baz with the given parameters. if * the service is already performing a task this action will be queued. * * @see intentservice *\/ \/\/ todo: customize helper method public static void startactionbaz(context context, string param1, string param2) { intent intent = new intent(context, myintentservice.class); intent.setaction(action_baz); intent.putextra(extra_param1, param1); intent.putextra(extra_param2, param2); context.startservice(intent); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"public static void startactionbaz(context context, string param1, string param2) { intent intent = new intent(context, myintentservice.class); intent.setaction(action_baz); intent.putextra(extra_param1, param1); intent.putextra(extra_param2, param2); context.startservice(intent); }","code_context_10":"public static void startactionbaz(context context, string param1, string param2) { intent intent = new intent(context, myintentservice.class); intent.setaction(action_baz); intent.putextra(extra_param1, param1); intent.putextra(extra_param2, param2); context.startservice(intent); }","code_context_20":"public static void startactionbaz(context context, string param1, string param2) { intent intent = new intent(context, myintentservice.class); intent.setaction(action_baz); intent.putextra(extra_param1, param1); intent.putextra(extra_param2, param2); context.startservice(intent); }","repo":"CasterIO\/Bootstrap"}
{"id":24133,"comment_id":0,"comment":"\/\/ todo incorporate evolution!","code":"\/\/ todo incorporate evolution! public string deresolve(eu.hyvar.feature.hyfeatureattribute element, eu.hyvar.context.contextvalidity.hyattributevalidityformula container, ereference reference) { return hyfeatureresolverutil.deresolvefeatureattribute(element, new date()); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"public string deresolve(eu.hyvar.feature.hyfeatureattribute element, eu.hyvar.context.contextvalidity.hyattributevalidityformula container, ereference reference) { return hyfeatureresolverutil.deresolvefeatureattribute(element, new date()); }","code_context_10":"public string deresolve(eu.hyvar.feature.hyfeatureattribute element, eu.hyvar.context.contextvalidity.hyattributevalidityformula container, ereference reference) { return hyfeatureresolverutil.deresolvefeatureattribute(element, new date()); }","code_context_20":"public string deresolve(eu.hyvar.feature.hyfeatureattribute element, eu.hyvar.context.contextvalidity.hyattributevalidityformula container, ereference reference) { return hyfeatureresolverutil.deresolvefeatureattribute(element, new date()); }","repo":"DarwinSPL\/DarwinSPL"}
{"id":15951,"comment_id":0,"comment":"\/* * todo: at a production level, accept an enum of species with predefined * groups, and map with corresponding options * * todo: cleaner way of adding titles and ids *\/","code":"\/* * todo: at a production level, accept an enum of species with predefined * groups, and map with corresponding options * * todo: cleaner way of adding titles and ids *\/ public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); \/* * add treatment expressionstagegroup *\/ expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3); treatmentexpressionstagegroup.setgroupnumericalid(3); list<expressionstage> treatmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ larva stages for (int i = 82; i <= 90; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 0; i <= 10; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } treatmentexpressionstagegroup.setexpressionstagelist(treatmentexpressionstagelist); expressionstagegrouplist.add(treatmentexpressionstagegroup); \/* * add cell-line expressionstagegroup *\/ expressionstagegroup celllineexpressionstagegroup = new expressionstagegroup(); celllineexpressionstagegroup.setgrouptitle(\"cell-line\"); celllineexpressionstagegroup.setgroupid(\"group\" + 4); celllineexpressionstagegroup.setgroupnumericalid(4); list<expressionstage> celllineexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 98; i <= 103; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 68; i <= 74; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 91; i <= 96; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 45; i <= 46; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 30; i <= 31; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } celllineexpressionstagelist.add(allexpressionstages.get(55)); \/\/ todo: add the others celllineexpressionstagegroup.setexpressionstagelist(celllineexpressionstagelist); expressionstagegrouplist.add(celllineexpressionstagegroup); expressionstageoptions.setexpressionstagegrouplist(expressionstagegrouplist); return expressionstageoptions; }","classification":"DESIGN","isFinished":true,"code_context_2":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); \/* * add treatment expressionstagegroup *\/ expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3); treatmentexpressionstagegroup.setgroupnumericalid(3); list<expressionstage> treatmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ larva stages for (int i = 82; i <= 90; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 0; i <= 10; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } treatmentexpressionstagegroup.setexpressionstagelist(treatmentexpressionstagelist); expressionstagegrouplist.add(treatmentexpressionstagegroup); \/* * add cell-line expressionstagegroup *\/ expressionstagegroup celllineexpressionstagegroup = new expressionstagegroup(); celllineexpressionstagegroup.setgrouptitle(\"cell-line\"); celllineexpressionstagegroup.setgroupid(\"group\" + 4); celllineexpressionstagegroup.setgroupnumericalid(4); list<expressionstage> celllineexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 98; i <= 103; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 68; i <= 74; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 91; i <= 96; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 45; i <= 46; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 30; i <= 31; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } celllineexpressionstagelist.add(allexpressionstages.get(55)); \/\/ todo: add the others celllineexpressionstagegroup.setexpressionstagelist(celllineexpressionstagelist); expressionstagegrouplist.add(celllineexpressionstagegroup); expressionstageoptions.setexpressionstagegrouplist(expressionstagegrouplist); return expressionstageoptions; }","code_context_10":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); \/* * add treatment expressionstagegroup *\/ expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3); treatmentexpressionstagegroup.setgroupnumericalid(3); list<expressionstage> treatmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ larva stages for (int i = 82; i <= 90; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 0; i <= 10; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } treatmentexpressionstagegroup.setexpressionstagelist(treatmentexpressionstagelist); expressionstagegrouplist.add(treatmentexpressionstagegroup); \/* * add cell-line expressionstagegroup *\/ expressionstagegroup celllineexpressionstagegroup = new expressionstagegroup(); celllineexpressionstagegroup.setgrouptitle(\"cell-line\"); celllineexpressionstagegroup.setgroupid(\"group\" + 4); celllineexpressionstagegroup.setgroupnumericalid(4); list<expressionstage> celllineexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 98; i <= 103; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 68; i <= 74; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 91; i <= 96; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 45; i <= 46; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 30; i <= 31; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } celllineexpressionstagelist.add(allexpressionstages.get(55)); \/\/ todo: add the others celllineexpressionstagegroup.setexpressionstagelist(celllineexpressionstagelist); expressionstagegrouplist.add(celllineexpressionstagegroup); expressionstageoptions.setexpressionstagegrouplist(expressionstagegrouplist); return expressionstageoptions; }","code_context_20":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); \/* * add treatment expressionstagegroup *\/ expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3); treatmentexpressionstagegroup.setgroupnumericalid(3); list<expressionstage> treatmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ larva stages for (int i = 82; i <= 90; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 0; i <= 10; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } treatmentexpressionstagegroup.setexpressionstagelist(treatmentexpressionstagelist); expressionstagegrouplist.add(treatmentexpressionstagegroup); \/* * add cell-line expressionstagegroup *\/ expressionstagegroup celllineexpressionstagegroup = new expressionstagegroup(); celllineexpressionstagegroup.setgrouptitle(\"cell-line\"); celllineexpressionstagegroup.setgroupid(\"group\" + 4); celllineexpressionstagegroup.setgroupnumericalid(4); list<expressionstage> celllineexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 98; i <= 103; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 68; i <= 74; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 91; i <= 96; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 45; i <= 46; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 30; i <= 31; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } celllineexpressionstagelist.add(allexpressionstages.get(55)); \/\/ todo: add the others celllineexpressionstagegroup.setexpressionstagelist(celllineexpressionstagelist); expressionstagegrouplist.add(celllineexpressionstagegroup); expressionstageoptions.setexpressionstagegrouplist(expressionstagegrouplist); return expressionstageoptions; }","repo":"CodingBash\/fly-transcription-webapp"}
{"id":15951,"comment_id":1,"comment":"\/\/ add expressionstagelist to returned object","code":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); \/* * add treatment expressionstagegroup *\/ expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3); treatmentexpressionstagegroup.setgroupnumericalid(3); list<expressionstage> treatmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ larva stages for (int i = 82; i <= 90; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 0; i <= 10; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } treatmentexpressionstagegroup.setexpressionstagelist(treatmentexpressionstagelist); expressionstagegrouplist.add(treatmentexpressionstagegroup); \/* * add cell-line expressionstagegroup *\/ expressionstagegroup celllineexpressionstagegroup = new expressionstagegroup(); celllineexpressionstagegroup.setgrouptitle(\"cell-line\"); celllineexpressionstagegroup.setgroupid(\"group\" + 4); celllineexpressionstagegroup.setgroupnumericalid(4); list<expressionstage> celllineexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 98; i <= 103; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 68; i <= 74; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 91; i <= 96; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 45; i <= 46; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 30; i <= 31; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } celllineexpressionstagelist.add(allexpressionstages.get(55)); \/\/ todo: add the others celllineexpressionstagegroup.setexpressionstagelist(celllineexpressionstagelist); expressionstagegrouplist.add(celllineexpressionstagegroup); expressionstageoptions.setexpressionstagegrouplist(expressionstagegrouplist); return expressionstageoptions; }","classification":"NONSATD","isFinished":true,"code_context_2":"idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/*","code_context_10":"list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages","code_context_20":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\");","repo":"CodingBash\/fly-transcription-webapp"}
{"id":15951,"comment_id":2,"comment":"\/* * add embryogenesis expressionstagegroup *\/","code":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); \/* * add treatment expressionstagegroup *\/ expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3); treatmentexpressionstagegroup.setgroupnumericalid(3); list<expressionstage> treatmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ larva stages for (int i = 82; i <= 90; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 0; i <= 10; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } treatmentexpressionstagegroup.setexpressionstagelist(treatmentexpressionstagelist); expressionstagegrouplist.add(treatmentexpressionstagegroup); \/* * add cell-line expressionstagegroup *\/ expressionstagegroup celllineexpressionstagegroup = new expressionstagegroup(); celllineexpressionstagegroup.setgrouptitle(\"cell-line\"); celllineexpressionstagegroup.setgroupid(\"group\" + 4); celllineexpressionstagegroup.setgroupnumericalid(4); list<expressionstage> celllineexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 98; i <= 103; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 68; i <= 74; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 91; i <= 96; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 45; i <= 46; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 30; i <= 31; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } celllineexpressionstagelist.add(allexpressionstages.get(55)); \/\/ todo: add the others celllineexpressionstagegroup.setexpressionstagelist(celllineexpressionstagelist); expressionstagegrouplist.add(celllineexpressionstagegroup); expressionstageoptions.setexpressionstagegrouplist(expressionstagegrouplist); return expressionstageoptions; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\");","code_context_10":"for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist);","code_context_20":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages","repo":"CodingBash\/fly-transcription-webapp"}
{"id":15951,"comment_id":3,"comment":"\/\/ add embryo stages","code":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); \/* * add treatment expressionstagegroup *\/ expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3); treatmentexpressionstagegroup.setgroupnumericalid(3); list<expressionstage> treatmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ larva stages for (int i = 82; i <= 90; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 0; i <= 10; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } treatmentexpressionstagegroup.setexpressionstagelist(treatmentexpressionstagelist); expressionstagegrouplist.add(treatmentexpressionstagegroup); \/* * add cell-line expressionstagegroup *\/ expressionstagegroup celllineexpressionstagegroup = new expressionstagegroup(); celllineexpressionstagegroup.setgrouptitle(\"cell-line\"); celllineexpressionstagegroup.setgroupid(\"group\" + 4); celllineexpressionstagegroup.setgroupnumericalid(4); list<expressionstage> celllineexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 98; i <= 103; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 68; i <= 74; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 91; i <= 96; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 45; i <= 46; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 30; i <= 31; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } celllineexpressionstagelist.add(allexpressionstages.get(55)); \/\/ todo: add the others celllineexpressionstagegroup.setexpressionstagelist(celllineexpressionstagelist); expressionstagegrouplist.add(celllineexpressionstagegroup); expressionstageoptions.setexpressionstagegrouplist(expressionstagegrouplist); return expressionstageoptions; }","classification":"NONSATD","isFinished":true,"code_context_2":"embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i));","code_context_10":"\/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\");","code_context_20":"list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i));","repo":"CodingBash\/fly-transcription-webapp"}
{"id":15951,"comment_id":4,"comment":"\/* * add development expressionstagegroup *\/","code":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); \/* * add treatment expressionstagegroup *\/ expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3); treatmentexpressionstagegroup.setgroupnumericalid(3); list<expressionstage> treatmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ larva stages for (int i = 82; i <= 90; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 0; i <= 10; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } treatmentexpressionstagegroup.setexpressionstagelist(treatmentexpressionstagelist); expressionstagegrouplist.add(treatmentexpressionstagegroup); \/* * add cell-line expressionstagegroup *\/ expressionstagegroup celllineexpressionstagegroup = new expressionstagegroup(); celllineexpressionstagegroup.setgrouptitle(\"cell-line\"); celllineexpressionstagegroup.setgroupid(\"group\" + 4); celllineexpressionstagegroup.setgroupnumericalid(4); list<expressionstage> celllineexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 98; i <= 103; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 68; i <= 74; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 91; i <= 96; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 45; i <= 46; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 30; i <= 31; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } celllineexpressionstagelist.add(allexpressionstages.get(55)); \/\/ todo: add the others celllineexpressionstagegroup.setexpressionstagelist(celllineexpressionstagelist); expressionstagegrouplist.add(celllineexpressionstagegroup); expressionstageoptions.setexpressionstagegrouplist(expressionstagegrouplist); return expressionstageoptions; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\");","code_context_10":"for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist);","code_context_20":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages","repo":"CodingBash\/fly-transcription-webapp"}
{"id":15951,"comment_id":5,"comment":"\/\/ add embryo stages","code":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); \/* * add treatment expressionstagegroup *\/ expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3); treatmentexpressionstagegroup.setgroupnumericalid(3); list<expressionstage> treatmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ larva stages for (int i = 82; i <= 90; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 0; i <= 10; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } treatmentexpressionstagegroup.setexpressionstagelist(treatmentexpressionstagelist); expressionstagegrouplist.add(treatmentexpressionstagegroup); \/* * add cell-line expressionstagegroup *\/ expressionstagegroup celllineexpressionstagegroup = new expressionstagegroup(); celllineexpressionstagegroup.setgrouptitle(\"cell-line\"); celllineexpressionstagegroup.setgroupid(\"group\" + 4); celllineexpressionstagegroup.setgroupnumericalid(4); list<expressionstage> celllineexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 98; i <= 103; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 68; i <= 74; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 91; i <= 96; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 45; i <= 46; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 30; i <= 31; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } celllineexpressionstagelist.add(allexpressionstages.get(55)); \/\/ todo: add the others celllineexpressionstagegroup.setexpressionstagelist(celllineexpressionstagelist); expressionstagegrouplist.add(celllineexpressionstagegroup); expressionstageoptions.setexpressionstagegrouplist(expressionstagegrouplist); return expressionstageoptions; }","classification":"NONSATD","isFinished":true,"code_context_2":"embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i));","code_context_10":"\/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\");","code_context_20":"list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i));","repo":"CodingBash\/fly-transcription-webapp"}
{"id":15951,"comment_id":6,"comment":"\/\/ larva stages","code":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); \/* * add treatment expressionstagegroup *\/ expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3); treatmentexpressionstagegroup.setgroupnumericalid(3); list<expressionstage> treatmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ larva stages for (int i = 82; i <= 90; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 0; i <= 10; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } treatmentexpressionstagegroup.setexpressionstagelist(treatmentexpressionstagelist); expressionstagegrouplist.add(treatmentexpressionstagegroup); \/* * add cell-line expressionstagegroup *\/ expressionstagegroup celllineexpressionstagegroup = new expressionstagegroup(); celllineexpressionstagegroup.setgrouptitle(\"cell-line\"); celllineexpressionstagegroup.setgroupid(\"group\" + 4); celllineexpressionstagegroup.setgroupnumericalid(4); list<expressionstage> celllineexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 98; i <= 103; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 68; i <= 74; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 91; i <= 96; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 45; i <= 46; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 30; i <= 31; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } celllineexpressionstagelist.add(allexpressionstages.get(55)); \/\/ todo: add the others celllineexpressionstagegroup.setexpressionstagelist(celllineexpressionstagelist); expressionstagegrouplist.add(celllineexpressionstagegroup); expressionstageoptions.setexpressionstagegrouplist(expressionstagegrouplist); return expressionstageoptions; }","classification":"NONSATD","isFinished":true,"code_context_2":"developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i));","code_context_10":"*\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); }","code_context_20":"embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\");","repo":"CodingBash\/fly-transcription-webapp"}
{"id":15951,"comment_id":7,"comment":"\/\/ todo: add the others","code":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); \/* * add treatment expressionstagegroup *\/ expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3); treatmentexpressionstagegroup.setgroupnumericalid(3); list<expressionstage> treatmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ larva stages for (int i = 82; i <= 90; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 0; i <= 10; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } treatmentexpressionstagegroup.setexpressionstagelist(treatmentexpressionstagelist); expressionstagegrouplist.add(treatmentexpressionstagegroup); \/* * add cell-line expressionstagegroup *\/ expressionstagegroup celllineexpressionstagegroup = new expressionstagegroup(); celllineexpressionstagegroup.setgrouptitle(\"cell-line\"); celllineexpressionstagegroup.setgroupid(\"group\" + 4); celllineexpressionstagegroup.setgroupnumericalid(4); list<expressionstage> celllineexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 98; i <= 103; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 68; i <= 74; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 91; i <= 96; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 45; i <= 46; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 30; i <= 31; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } celllineexpressionstagelist.add(allexpressionstages.get(55)); \/\/ todo: add the others celllineexpressionstagegroup.setexpressionstagelist(celllineexpressionstagelist); expressionstagegrouplist.add(celllineexpressionstagegroup); expressionstageoptions.setexpressionstagegrouplist(expressionstagegrouplist); return expressionstageoptions; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44));","code_context_10":"for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2);","code_context_20":"expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) {","repo":"CodingBash\/fly-transcription-webapp"}
{"id":15951,"comment_id":8,"comment":"\/* * add tissue expressionstagegroup *\/","code":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); \/* * add treatment expressionstagegroup *\/ expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3); treatmentexpressionstagegroup.setgroupnumericalid(3); list<expressionstage> treatmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ larva stages for (int i = 82; i <= 90; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 0; i <= 10; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } treatmentexpressionstagegroup.setexpressionstagelist(treatmentexpressionstagelist); expressionstagegrouplist.add(treatmentexpressionstagegroup); \/* * add cell-line expressionstagegroup *\/ expressionstagegroup celllineexpressionstagegroup = new expressionstagegroup(); celllineexpressionstagegroup.setgrouptitle(\"cell-line\"); celllineexpressionstagegroup.setgroupid(\"group\" + 4); celllineexpressionstagegroup.setgroupnumericalid(4); list<expressionstage> celllineexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 98; i <= 103; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 68; i <= 74; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 91; i <= 96; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 45; i <= 46; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 30; i <= 31; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } celllineexpressionstagelist.add(allexpressionstages.get(55)); \/\/ todo: add the others celllineexpressionstagegroup.setexpressionstagelist(celllineexpressionstagelist); expressionstagegrouplist.add(celllineexpressionstagegroup); expressionstageoptions.setexpressionstagegrouplist(expressionstagegrouplist); return expressionstageoptions; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\");","code_context_10":"for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist);","code_context_20":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages","repo":"CodingBash\/fly-transcription-webapp"}
{"id":15951,"comment_id":9,"comment":"\/\/ a mate stages","code":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); \/* * add treatment expressionstagegroup *\/ expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3); treatmentexpressionstagegroup.setgroupnumericalid(3); list<expressionstage> treatmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ larva stages for (int i = 82; i <= 90; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 0; i <= 10; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } treatmentexpressionstagegroup.setexpressionstagelist(treatmentexpressionstagelist); expressionstagegrouplist.add(treatmentexpressionstagegroup); \/* * add cell-line expressionstagegroup *\/ expressionstagegroup celllineexpressionstagegroup = new expressionstagegroup(); celllineexpressionstagegroup.setgrouptitle(\"cell-line\"); celllineexpressionstagegroup.setgroupid(\"group\" + 4); celllineexpressionstagegroup.setgroupnumericalid(4); list<expressionstage> celllineexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 98; i <= 103; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 68; i <= 74; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 91; i <= 96; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 45; i <= 46; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 30; i <= 31; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } celllineexpressionstagelist.add(allexpressionstages.get(55)); \/\/ todo: add the others celllineexpressionstagegroup.setexpressionstagelist(celllineexpressionstagelist); expressionstagegrouplist.add(celllineexpressionstagegroup); expressionstageoptions.setexpressionstagegrouplist(expressionstagegrouplist); return expressionstageoptions; }","classification":"NONSATD","isFinished":true,"code_context_2":"tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i));","code_context_10":"developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) {","code_context_20":"developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); \/* * add treatment expressionstagegroup *\/ expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3);","repo":"CodingBash\/fly-transcription-webapp"}
{"id":15951,"comment_id":10,"comment":"\/* * add treatment expressionstagegroup *\/","code":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); \/* * add treatment expressionstagegroup *\/ expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3); treatmentexpressionstagegroup.setgroupnumericalid(3); list<expressionstage> treatmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ larva stages for (int i = 82; i <= 90; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 0; i <= 10; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } treatmentexpressionstagegroup.setexpressionstagelist(treatmentexpressionstagelist); expressionstagegrouplist.add(treatmentexpressionstagegroup); \/* * add cell-line expressionstagegroup *\/ expressionstagegroup celllineexpressionstagegroup = new expressionstagegroup(); celllineexpressionstagegroup.setgrouptitle(\"cell-line\"); celllineexpressionstagegroup.setgroupid(\"group\" + 4); celllineexpressionstagegroup.setgroupnumericalid(4); list<expressionstage> celllineexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 98; i <= 103; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 68; i <= 74; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 91; i <= 96; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 45; i <= 46; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 30; i <= 31; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } celllineexpressionstagelist.add(allexpressionstages.get(55)); \/\/ todo: add the others celllineexpressionstagegroup.setexpressionstagelist(celllineexpressionstagelist); expressionstagegrouplist.add(celllineexpressionstagegroup); expressionstageoptions.setexpressionstagegrouplist(expressionstagegrouplist); return expressionstageoptions; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\");","code_context_10":"for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist);","code_context_20":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages","repo":"CodingBash\/fly-transcription-webapp"}
{"id":15951,"comment_id":11,"comment":"\/\/ larva stages","code":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); \/* * add treatment expressionstagegroup *\/ expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3); treatmentexpressionstagegroup.setgroupnumericalid(3); list<expressionstage> treatmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ larva stages for (int i = 82; i <= 90; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 0; i <= 10; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } treatmentexpressionstagegroup.setexpressionstagelist(treatmentexpressionstagelist); expressionstagegrouplist.add(treatmentexpressionstagegroup); \/* * add cell-line expressionstagegroup *\/ expressionstagegroup celllineexpressionstagegroup = new expressionstagegroup(); celllineexpressionstagegroup.setgrouptitle(\"cell-line\"); celllineexpressionstagegroup.setgroupid(\"group\" + 4); celllineexpressionstagegroup.setgroupnumericalid(4); list<expressionstage> celllineexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 98; i <= 103; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 68; i <= 74; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 91; i <= 96; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 45; i <= 46; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 30; i <= 31; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } celllineexpressionstagelist.add(allexpressionstages.get(55)); \/\/ todo: add the others celllineexpressionstagegroup.setexpressionstagelist(celllineexpressionstagelist); expressionstagegrouplist.add(celllineexpressionstagegroup); expressionstageoptions.setexpressionstagegrouplist(expressionstagegrouplist); return expressionstageoptions; }","classification":"NONSATD","isFinished":true,"code_context_2":"developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i));","code_context_10":"*\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); }","code_context_20":"embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\");","repo":"CodingBash\/fly-transcription-webapp"}
{"id":15951,"comment_id":12,"comment":"\/* * add cell-line expressionstagegroup *\/","code":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); \/* * add treatment expressionstagegroup *\/ expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3); treatmentexpressionstagegroup.setgroupnumericalid(3); list<expressionstage> treatmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ larva stages for (int i = 82; i <= 90; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 0; i <= 10; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } treatmentexpressionstagegroup.setexpressionstagelist(treatmentexpressionstagelist); expressionstagegrouplist.add(treatmentexpressionstagegroup); \/* * add cell-line expressionstagegroup *\/ expressionstagegroup celllineexpressionstagegroup = new expressionstagegroup(); celllineexpressionstagegroup.setgrouptitle(\"cell-line\"); celllineexpressionstagegroup.setgroupid(\"group\" + 4); celllineexpressionstagegroup.setgroupnumericalid(4); list<expressionstage> celllineexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 98; i <= 103; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 68; i <= 74; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 91; i <= 96; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 45; i <= 46; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 30; i <= 31; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } celllineexpressionstagelist.add(allexpressionstages.get(55)); \/\/ todo: add the others celllineexpressionstagegroup.setexpressionstagelist(celllineexpressionstagelist); expressionstagegrouplist.add(celllineexpressionstagegroup); expressionstageoptions.setexpressionstagegrouplist(expressionstagegrouplist); return expressionstageoptions; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\");","code_context_10":"for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist);","code_context_20":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages","repo":"CodingBash\/fly-transcription-webapp"}
{"id":15951,"comment_id":13,"comment":"\/\/ add embryo stages","code":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); \/* * add treatment expressionstagegroup *\/ expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3); treatmentexpressionstagegroup.setgroupnumericalid(3); list<expressionstage> treatmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ larva stages for (int i = 82; i <= 90; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 0; i <= 10; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } treatmentexpressionstagegroup.setexpressionstagelist(treatmentexpressionstagelist); expressionstagegrouplist.add(treatmentexpressionstagegroup); \/* * add cell-line expressionstagegroup *\/ expressionstagegroup celllineexpressionstagegroup = new expressionstagegroup(); celllineexpressionstagegroup.setgrouptitle(\"cell-line\"); celllineexpressionstagegroup.setgroupid(\"group\" + 4); celllineexpressionstagegroup.setgroupnumericalid(4); list<expressionstage> celllineexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 98; i <= 103; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 68; i <= 74; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 91; i <= 96; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 45; i <= 46; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 30; i <= 31; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } celllineexpressionstagelist.add(allexpressionstages.get(55)); \/\/ todo: add the others celllineexpressionstagegroup.setexpressionstagelist(celllineexpressionstagelist); expressionstagegrouplist.add(celllineexpressionstagegroup); expressionstageoptions.setexpressionstagegrouplist(expressionstagegrouplist); return expressionstageoptions; }","classification":"NONSATD","isFinished":true,"code_context_2":"embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i));","code_context_10":"\/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\");","code_context_20":"list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i));","repo":"CodingBash\/fly-transcription-webapp"}
{"id":15951,"comment_id":14,"comment":"\/\/ larva stages","code":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); \/* * add treatment expressionstagegroup *\/ expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3); treatmentexpressionstagegroup.setgroupnumericalid(3); list<expressionstage> treatmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ larva stages for (int i = 82; i <= 90; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 0; i <= 10; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } treatmentexpressionstagegroup.setexpressionstagelist(treatmentexpressionstagelist); expressionstagegrouplist.add(treatmentexpressionstagegroup); \/* * add cell-line expressionstagegroup *\/ expressionstagegroup celllineexpressionstagegroup = new expressionstagegroup(); celllineexpressionstagegroup.setgrouptitle(\"cell-line\"); celllineexpressionstagegroup.setgroupid(\"group\" + 4); celllineexpressionstagegroup.setgroupnumericalid(4); list<expressionstage> celllineexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 98; i <= 103; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 68; i <= 74; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 91; i <= 96; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 45; i <= 46; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 30; i <= 31; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } celllineexpressionstagelist.add(allexpressionstages.get(55)); \/\/ todo: add the others celllineexpressionstagegroup.setexpressionstagelist(celllineexpressionstagelist); expressionstagegrouplist.add(celllineexpressionstagegroup); expressionstageoptions.setexpressionstagegrouplist(expressionstagegrouplist); return expressionstageoptions; }","classification":"NONSATD","isFinished":true,"code_context_2":"developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i));","code_context_10":"*\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); }","code_context_20":"embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\");","repo":"CodingBash\/fly-transcription-webapp"}
{"id":15951,"comment_id":15,"comment":"\/\/ todo: add the others","code":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } \/\/ add expressionstagelist to returned object expressionstageoptions.setexpressionstagelist(allexpressionstages); \/* * add embryogenesis expressionstagegroup *\/ expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); \/* * add development expressionstagegroup *\/ expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); \/* * add treatment expressionstagegroup *\/ expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3); treatmentexpressionstagegroup.setgroupnumericalid(3); list<expressionstage> treatmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ larva stages for (int i = 82; i <= 90; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 0; i <= 10; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } treatmentexpressionstagegroup.setexpressionstagelist(treatmentexpressionstagelist); expressionstagegrouplist.add(treatmentexpressionstagegroup); \/* * add cell-line expressionstagegroup *\/ expressionstagegroup celllineexpressionstagegroup = new expressionstagegroup(); celllineexpressionstagegroup.setgrouptitle(\"cell-line\"); celllineexpressionstagegroup.setgroupid(\"group\" + 4); celllineexpressionstagegroup.setgroupnumericalid(4); list<expressionstage> celllineexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 98; i <= 103; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 68; i <= 74; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 91; i <= 96; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 45; i <= 46; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 30; i <= 31; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } celllineexpressionstagelist.add(allexpressionstages.get(55)); \/\/ todo: add the others celllineexpressionstagegroup.setexpressionstagelist(celllineexpressionstagelist); expressionstagegrouplist.add(celllineexpressionstagegroup); expressionstageoptions.setexpressionstagegrouplist(expressionstagegrouplist); return expressionstageoptions; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44));","code_context_10":"for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2);","code_context_20":"expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); \/\/ add embryo stages for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ larva stages for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } \/\/ todo: add the others developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); \/* * add tissue expressionstagegroup *\/ expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); \/\/ a mate stages for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) {","repo":"CodingBash\/fly-transcription-webapp"}
{"id":7837,"comment_id":0,"comment":"\/\/ todo: support apng animated images?","code":"public image loadimageanim(string filename, int frames) { image image = new image(); int framescount = 1; if (support_fileformat_gif) { if (rcore.isfileextension(filename, \".gif\")) { byte[] filedata = null; try{ bufferedimage tmpimg = imageio.read(new file(filename)); bytearrayoutputstream os = new bytearrayoutputstream(); imageio.write(tmpimg, rcore.getfileextension(filename).substring(1), os); filedata = os.tobytearray(); } catch (ioexception exception) { exception.printstacktrace(); } if (filedata != null) { try (memorystack stack = memorystack.stackpush()) { intbuffer widthbuffer = stack.mallocint(1); intbuffer heightbuffer = stack.mallocint(1); intbuffer compbuffer = stack.mallocint(1); pointerbuffer delaysbuffer = null; intbuffer framesbuffer = stack.mallocint(1); framesbuffer.put(framescount).flip(); bytebuffer filedatabuffer = memoryutil.memalloc(filedata.length); filedatabuffer.put(filedata).flip(); bytebuffer imgbuffer = stbimage.stbi_load_gif_from_memory(filedatabuffer, delaysbuffer, widthbuffer, heightbuffer, framesbuffer, compbuffer, 4); image.width = widthbuffer.get(); image.height = heightbuffer.get(); image.mipmaps = 1; image.format = rl_pixelformat_uncompressed_r8g8b8a8; if (imgbuffer != null) { byte[] bytes = new byte[imgbuffer.capacity()]; for (int i = 0; i < bytes.length; i++) { bytes[i] = imgbuffer.get(); } image.setdata(bytes); } filedata = null; } } } } else{ image = loadimage(filename); } \/\/ todo: support apng animated images? frames = framescount; return image; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"image = loadimage(filename); } \/\/ todo: support apng animated images? frames = framescount; return image;","code_context_10":"image.setdata(bytes); } filedata = null; } } } } else{ image = loadimage(filename); } \/\/ todo: support apng animated images? frames = framescount; return image; }","code_context_20":"widthbuffer, heightbuffer, framesbuffer, compbuffer, 4); image.width = widthbuffer.get(); image.height = heightbuffer.get(); image.mipmaps = 1; image.format = rl_pixelformat_uncompressed_r8g8b8a8; if (imgbuffer != null) { byte[] bytes = new byte[imgbuffer.capacity()]; for (int i = 0; i < bytes.length; i++) { bytes[i] = imgbuffer.get(); } image.setdata(bytes); } filedata = null; } } } } else{ image = loadimage(filename); } \/\/ todo: support apng animated images? frames = framescount; return image; }","repo":"CreedVI\/Raylib-J"}
{"id":7893,"comment_id":0,"comment":"\/** we are going to try to construct a bwevent object from a vevent. this * may represent a new event or an update to a pre-existing event. in any * case, the vevent probably has insufficient information to completely * reconstitute the event object so we'll get the uid first and retrieve * the event if it exists. * * <p>to put it another way we're doing a diff then update. * * <p>if it doesn't exist, we'll first fill in the appropriate fields, * (non-public, creator, created etc) then for both cases update the * remaining fields from the vevent. * * <p>recurring events present some challenges. if there is no recurrence * id the vevent represents the master entity which defines the recurrence * rules. if a recurrence id is present then the vevent represents a * recurrence instance override and we should not attempt to retrieve the * actual object but the referenced instance. * * <p>also, note that we sorted the components first so we get the master * before any instances. * * <p>if dtstart, rrule, exrule have changed (also rdate, exdate?) then any * existing overrides are unusable. we should delete all overrides and replace * with new ones. * * <p>for an update we have to keep track of which fields were present in * the vevent and set all absent fields to null in the bwevent. * * @param cb icalcallback object * @param cal needed so we can retrieve the event. * @param ical icalendar we are converting into. we check its events for * overrides. * @param val vevent object * @param mergeattendees true if we should only update our own attendee. * @return response with status and eventinfo object representing new entry or updated entry *\/","code":"\/** we are going to try to construct a bwevent object from a vevent. this * may represent a new event or an update to a pre-existing event. in any * case, the vevent probably has insufficient information to completely * reconstitute the event object so we'll get the uid first and retrieve * the event if it exists. * * <p>to put it another way we're doing a diff then update. * * <p>if it doesn't exist, we'll first fill in the appropriate fields, * (non-public, creator, created etc) then for both cases update the * remaining fields from the vevent. * * <p>recurring events present some challenges. if there is no recurrence * id the vevent represents the master entity which defines the recurrence * rules. if a recurrence id is present then the vevent represents a * recurrence instance override and we should not attempt to retrieve the * actual object but the referenced instance. * * <p>also, note that we sorted the components first so we get the master * before any instances. * * <p>if dtstart, rrule, exrule have changed (also rdate, exdate?) then any * existing overrides are unusable. we should delete all overrides and replace * with new ones. * * <p>for an update we have to keep track of which fields were present in * the vevent and set all absent fields to null in the bwevent. * * @param cb icalcallback object * @param cal needed so we can retrieve the event. * @param ical icalendar we are converting into. we check its events for * overrides. * @param val vevent object * @param mergeattendees true if we should only update our own attendee. * @return response with status and eventinfo object representing new entry or updated entry *\/ public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","code_context_10":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","code_context_20":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":1,"comment":"\/\/ we'll need this later.","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); }","code_context_10":"} string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties();","code_context_20":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent;","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":2,"comment":"\/\/ empty component","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); }","code_context_10":"colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) {","code_context_20":"} final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true;","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":3,"comment":"\/\/ get the guid from the component","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid);","code_context_10":"entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/","code_context_20":"entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp);","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":4,"comment":"\/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"DEFECT","isFinished":true,"code_context_2":"} if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); }","code_context_10":"val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp);","code_context_20":"entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":5,"comment":"\/* see if we have a recurrence id *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null;","code_context_10":"if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\");","code_context_20":"} else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override,","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":6,"comment":"\/* xxx what do i do with it? *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"DESIGN","isFinished":true,"code_context_2":"ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); }","code_context_10":"} \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). *","code_context_20":"final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":7,"comment":"\/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart);","code_context_10":"ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus","code_context_20":"*\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg);","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":8,"comment":"\/* we need this in a couple of places *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"* that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/*","code_context_10":"* annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart;","code_context_20":"eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true);","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":9,"comment":"\/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation.","code_context_10":"val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone.","code_context_20":"entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent();","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":10,"comment":"\/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event.","code_context_10":"e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) &&","code_context_20":"dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp);","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":11,"comment":"\/\/ see if we have a new master event. if so create a proxy to this event.","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"*\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) {","code_context_10":"} if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) &&","code_context_20":"} else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities();","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":12,"comment":"\/\/ dorecur - wrong again","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\");","code_context_10":"logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\");","code_context_20":"evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei);","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":13,"comment":"\/\/ we just retrieved it's master","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true);","code_context_10":"} if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master","code_context_20":"return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\";","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":14,"comment":"\/\/ this should never have an rid for cancel of entire event.","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else {","code_context_10":"} if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus","code_context_20":"\"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) {","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":15,"comment":"\/\/ presumably sent an update for the entire event. no longer suppressed master","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); }","code_context_10":"\/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\";","code_context_20":"} if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime,","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":16,"comment":"\/* manufacture a master for the instance *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent();","code_context_10":"evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate));","code_context_20":"} else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null);","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":17,"comment":"\/\/ xxx this seems bogus","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"DEFECT","isFinished":true,"code_context_2":"masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\";","code_context_10":"*\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg);","code_context_20":"* if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":18,"comment":"\/\/ base dtstart on the recurrence id.","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) {","code_context_10":"evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid()));","code_context_20":"masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid);","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":19,"comment":"\/\/ e.addrdate(ridobj);","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue());","code_context_10":"mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) {","code_context_20":"final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid();","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":20,"comment":"\/\/ xxx spurious???","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"DEFECT","isFinished":true,"code_context_2":"if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) {","code_context_10":"return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due);","code_context_20":"e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) {","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":21,"comment":"\/\/debug(\"ical prop \" + prop.getclass().getname());","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) {","code_context_10":"dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); }","code_context_20":"if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":22,"comment":"\/* ------------------- accept response -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) {","code_context_10":"} if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee:","code_context_20":"\/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} }","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":23,"comment":"\/* ------------------- attachment -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break;","code_context_10":"chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) {","code_context_20":"pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":24,"comment":"\/* ------------------- attendee -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) {","code_context_10":"string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop;","code_context_20":"if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":25,"comment":"\/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/}","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop;","code_context_10":"\/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees","code_context_20":"chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true;","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":26,"comment":"\/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else {","code_context_10":"\/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; }","code_context_20":"\/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } }","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":27,"comment":"\/\/ use the value we currently have","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) {","code_context_10":"} else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee","code_context_20":"return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval);","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":28,"comment":"\/\/ an added attendee","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr);","code_context_10":"\/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval);","code_context_20":"} else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories();","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":29,"comment":"\/* ------------------- categories -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories();","code_context_10":"break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd);","code_context_20":"} if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else {","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":30,"comment":"\/* got some categories *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) {","code_context_10":"ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); }","code_context_20":"att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } }","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":31,"comment":"\/* ------------------- class -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval);","code_context_10":"cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed:","code_context_20":"continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) {","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":32,"comment":"\/* ------------------- comment -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval));","code_context_10":"} } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept:","code_context_20":"return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); }","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":33,"comment":"\/* ------------------- completed -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval);","code_context_10":"if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/","code_context_20":"cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop);","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":34,"comment":"\/* ------------------- concept -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue();","code_context_10":"chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break;","code_context_20":"} break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) {","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":35,"comment":"\/* got a concept *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\",","code_context_10":"\/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop);","code_context_20":"if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity();","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":36,"comment":"\/* ------------------- contact -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop);","code_context_10":"final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); }","code_context_20":"break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) {","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":37,"comment":"\/* ------------------- created -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval);","code_context_10":"contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break;","code_context_20":"final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break;","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":38,"comment":"\/* ------------------- description -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval);","code_context_10":"} chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval);","code_context_20":"} } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break;","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":39,"comment":"\/* ------------------- dtend -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp:","code_context_10":"ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/","code_context_20":"cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule:","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":40,"comment":"\/* ------------------- dtstamp -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break;","code_context_10":"case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/","code_context_20":"contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break;","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":41,"comment":"\/* ------------------- dtstart -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due:","code_context_10":"} break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi,","code_context_20":"case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods();","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":42,"comment":"\/* -------------------- due ------------------------ *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case due: \/* -------------------- due ------------------------ *\/ break; case duration:","code_context_10":"\/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule:","code_context_20":"ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) {","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":43,"comment":"\/* ------------------- duration -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate:","code_context_10":"\/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break;","code_context_20":"case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy;","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":44,"comment":"\/* ------------------- exdate -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop));","code_context_10":"case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop;","code_context_20":"ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) {","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":45,"comment":"\/* ------------------- exrule -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break;","code_context_10":"break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy;","code_context_20":"break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) {","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":46,"comment":"\/* ------------------- freebusy -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods();","code_context_10":"case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative;","code_context_20":"break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" +","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":47,"comment":"\/* ------------------- geo -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(),","code_context_10":"par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) {","code_context_20":"} else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) {","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":48,"comment":"\/* ------------------- lastmodified -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval);","code_context_10":"case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems.","code_context_20":"\"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr);","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":49,"comment":"\/* ------------------- location -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop);","code_context_10":"ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null;","code_context_20":"fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); }","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":50,"comment":"\/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"DEFECT","isFinished":true,"code_context_2":"\/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null;","code_context_10":"break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) {","code_context_20":"ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation();","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":51,"comment":"\/\/ chgtbl - this only shows that it's a different location object","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) {","code_context_10":"} } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } }","code_context_20":"bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone();","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":52,"comment":"\/\/ see if the value is changed","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue();","code_context_10":"loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/","code_context_20":"addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) {","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":53,"comment":"\/* ------------------- organizer -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer();","code_context_10":"\/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) {","code_context_20":"loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) {","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":54,"comment":"\/* ------------------- percentcomplete -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) {","code_context_10":"} if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval);","code_context_20":"break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner:","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":55,"comment":"\/* ------------------- poll mode -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) {","code_context_10":"} break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval);","code_context_20":"evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority:","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":56,"comment":"\/* ------------------- poll properties ---------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) {","code_context_10":"} break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival);","code_context_20":"} else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate:","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":57,"comment":"\/* ------------------- poll winner -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) {","code_context_10":"} break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival);","code_context_20":"integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":58,"comment":"\/* ------------------- priority -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) {","code_context_10":"} break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break;","code_context_20":"sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\");","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":59,"comment":"\/* ------------------- rdate -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop));","code_context_10":"} break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop;","code_context_20":"sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); }","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":60,"comment":"\/* ------------------- recurrenceid -------------------- *\/ \/\/ done above","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to:","code_context_10":"if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); }","code_context_20":"case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs);","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":61,"comment":"\/* ------------------- relatedto -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto();","code_context_10":"case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto);","code_context_20":"ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":62,"comment":"\/* ------------------- requeststatus -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop);","code_context_10":"\"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop);","code_context_20":"break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval);","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":63,"comment":"\/* ------------------- resources -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) {","code_context_10":"ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } }","code_context_20":"\/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq);","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":64,"comment":"\/* got some resources *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) {","code_context_10":"case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/","code_context_20":"final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break;","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":65,"comment":"\/* ------------------- rrule -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break;","code_context_10":"\/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break;","code_context_20":"case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval);","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":66,"comment":"\/* ------------------- sequence -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) {","code_context_10":"s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval);","code_context_20":"chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":67,"comment":"\/* ------------------- status -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval);","code_context_10":"break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break;","code_context_20":"for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval);","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":68,"comment":"\/* ------------------- summary -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval);","code_context_10":"ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()),","code_context_20":"break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid:","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":69,"comment":"\/* ------------------- transp -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency(","code_context_10":"ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu);","code_context_20":"\/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) {","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":70,"comment":"\/* ------------------- uid -------------------- *\/ \/* we did this above *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url:","code_context_10":"pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname();","code_context_20":"if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break;","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":71,"comment":"\/* ------------------- url -------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval);","code_context_10":"if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) {","code_context_20":"case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) {","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":72,"comment":"\/* ------------------------- x-property --------------------------- *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) {","code_context_10":"\/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) {","code_context_20":"pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) {","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":73,"comment":"\/* see if this is an x-category that can be converted to a real category *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop,","code_context_10":"if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi +","code_context_20":"pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else {","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":74,"comment":"\/* =================== process sub-components =============== *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) {","code_context_10":"pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent();","code_context_20":"} } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) {","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":75,"comment":"\/* fix up timestamps. *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) {","code_context_10":"pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } }","code_context_20":"chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear();","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":76,"comment":"\/\/ created cannot be null now","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod());","code_context_10":"if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null);","code_context_20":"if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters.","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":77,"comment":"\/* remove any recipients and originator *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear();","code_context_10":"chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) {","code_context_20":"logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } }","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":78,"comment":"\/* save a text copy of the entire event as an x-property *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/","code_context_10":"chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value);","code_context_20":"chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false);","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":79,"comment":"\/* remove potentially large values *\/","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"\/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) {","code_context_10":"processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode()));","code_context_20":"ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) {","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":80,"comment":"\/\/ don't store the entire attachment - we just need the parameters.","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value);","code_context_10":"ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring()));","code_context_20":"\/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp);","repo":"Bedework\/bw-calendar-convert"}
{"id":7893,"comment_id":81,"comment":"\/\/ just return notfound as this event is on its override list","code":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { \/\/ we'll need this later. atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { \/\/ empty component return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } \/\/ get the guid from the component string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { \/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/ return response.notok(resp, failed, calfacadeexception.noguid); } \/* see if we have a recurrence id *\/ bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { \/* xxx what do i do with it? *\/ logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; \/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/ \/* we need this in a couple of places *\/ final dtstart dtstart = pl.getproperty(property.dtstart); \/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/ \/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/ if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to this event. masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { \/\/ dorecur - wrong again return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { \/\/ we just retrieved it's master masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { \/\/ this should never have an rid for cancel of entire event. evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { \/\/ presumably sent an update for the entire event. no longer suppressed master evinfo.getevent().setsuppressed(false); } } else if (rid != null) { \/* manufacture a master for the instance *\/ masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); \/\/ xxx this seems bogus final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; \/\/ base dtstart on the recurrence id. final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); \/\/ e.addrdate(ridobj); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); \/\/ xxx spurious??? } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); \/\/debug(\"ical prop \" + prop.getclass().getname()); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: \/* ------------------- accept response -------------------- *\/ string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: \/* ------------------- attachment -------------------- *\/ chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: \/* ------------------- attendee -------------------- *\/ if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } \/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/} } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { \/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/ chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { \/\/ use the value we currently have boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { \/\/ an added attendee final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: \/* ------------------- categories -------------------- *\/ final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { \/* got some categories *\/ for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: \/* ------------------- class -------------------- *\/ if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: \/* ------------------- comment -------------------- *\/ chg.addvalue(pi, new bwstring(null, pval)); break; case completed: \/* ------------------- completed -------------------- *\/ if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: \/* ------------------- concept -------------------- *\/ final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { \/* got a concept *\/ chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: \/* ------------------- contact -------------------- *\/ final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: \/* ------------------- created -------------------- *\/ if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: \/* ------------------- description -------------------- *\/ if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: \/* ------------------- dtend -------------------- *\/ break; case dtstamp: \/* ------------------- dtstamp -------------------- *\/ ev.setdtstamp(pval); break; case dtstart: \/* ------------------- dtstart -------------------- *\/ break; case due: \/* -------------------- due ------------------------ *\/ break; case duration: \/* ------------------- duration -------------------- *\/ break; case exdate: \/* ------------------- exdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: \/* ------------------- exrule -------------------- *\/ chg.addvalue(pi, pval); break; case freebusy: \/* ------------------- freebusy -------------------- *\/ final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: \/* ------------------- geo -------------------- *\/ final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: \/* ------------------- lastmodified -------------------- *\/ if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: \/* ------------------- location -------------------- *\/ bwlocation loc = null; \/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/ lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { \/\/ chgtbl - this only shows that it's a different location object ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { \/\/ see if the value is changed final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: \/* ------------------- organizer -------------------- *\/ final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: \/* ------------------- percentcomplete -------------------- *\/ integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: \/* ------------------- poll mode -------------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: \/* ------------------- poll properties ---------------- *\/ sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: \/* ------------------- poll winner -------------------- *\/ ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: \/* ------------------- priority -------------------- *\/ ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: \/* ------------------- rdate -------------------- *\/ chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: \/* ------------------- recurrenceid -------------------- *\/ \/\/ done above break; case related_to: \/* ------------------- relatedto -------------------- *\/ final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: \/* ------------------- requeststatus -------------------- *\/ final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: \/* ------------------- resources -------------------- *\/ final textlist rl = ((resources)prop).getresources(); if (rl != null) { \/* got some resources *\/ lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: \/* ------------------- rrule -------------------- *\/ chg.addvalue(pi, pval); break; case sequence: \/* ------------------- sequence -------------------- *\/ final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: \/* ------------------- status -------------------- *\/ if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: \/* ------------------- summary -------------------- *\/ if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: \/* ------------------- transp -------------------- *\/ if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: \/* ------------------- uid -------------------- *\/ \/* we did this above *\/ break; case url: \/* ------------------- url -------------------- *\/ if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: \/* ------------------------- x-property --------------------------- *\/ final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } \/* see if this is an x-category that can be converted to a real category *\/ final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } \/* =================== process sub-components =============== *\/ final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } \/* fix up timestamps. *\/ if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { \/\/ created cannot be null now ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); \/* remove any recipients and originator *\/ if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { \/* save a text copy of the entire event as an x-property *\/ final component valcopy = val.copy(); \/* remove potentially large values *\/ final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); }","code_context_10":"null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); }","code_context_20":"final attach attachp = valcopy.getproperty(property.attach); \/\/ don't store the entire attachment - we just need the parameters. if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { \/\/ just return notfound as this event is on its override list return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","repo":"Bedework\/bw-calendar-convert"}
{"id":7967,"comment_id":0,"comment":"\/\/ fixme uncomment when overrides can be handled \/\/ @outschema(\"wdk.users.get-by-id\")","code":"@get @produces(mediatype.application_json) \/\/ fixme uncomment when overrides can be handled \/\/ @outschema(\"wdk.users.get-by-id\") public jsonobject getbyid(@queryparam(\"includepreferences\") boolean includepreferences) throws wdkmodelexception { userbundle userbundle = getuserbundle(access.public); list<userpropertyname> propdefs = getwdkmodel().getmodelconfig() .getaccountdb().getuserpropertynames(); return formatuser(userbundle.gettargetuser(), userbundle.issessionuser(), getflag(includepreferences), propdefs); }","classification":"DESIGN","isFinished":true,"code_context_2":"@get @produces(mediatype.application_json) \/\/ fixme uncomment when overrides can be handled \/\/ @outschema(\"wdk.users.get-by-id\") public jsonobject getbyid(@queryparam(\"includepreferences\") boolean includepreferences) throws wdkmodelexception { userbundle userbundle = getuserbundle(access.public);","code_context_10":"@get @produces(mediatype.application_json) \/\/ fixme uncomment when overrides can be handled \/\/ @outschema(\"wdk.users.get-by-id\") public jsonobject getbyid(@queryparam(\"includepreferences\") boolean includepreferences) throws wdkmodelexception { userbundle userbundle = getuserbundle(access.public); list<userpropertyname> propdefs = getwdkmodel().getmodelconfig() .getaccountdb().getuserpropertynames(); return formatuser(userbundle.gettargetuser(), userbundle.issessionuser(), getflag(includepreferences), propdefs); }","code_context_20":"@get @produces(mediatype.application_json) \/\/ fixme uncomment when overrides can be handled \/\/ @outschema(\"wdk.users.get-by-id\") public jsonobject getbyid(@queryparam(\"includepreferences\") boolean includepreferences) throws wdkmodelexception { userbundle userbundle = getuserbundle(access.public); list<userpropertyname> propdefs = getwdkmodel().getmodelconfig() .getaccountdb().getuserpropertynames(); return formatuser(userbundle.gettargetuser(), userbundle.issessionuser(), getflag(includepreferences), propdefs); }","repo":"EuPathDB-Infra\/WDK"}
{"id":24418,"comment_id":0,"comment":"\/\/it is actually a gas tank","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability));","code_context_10":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; }","code_context_20":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":1,"comment":"\/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) {","code_context_10":"fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate);","code_context_20":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error }","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":2,"comment":"\/\/insert gas into dropper","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return;","code_context_10":"ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal);","code_context_20":"itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) {","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":3,"comment":"\/\/we are able to fit at least some of the gas from our tank into the item","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) {","code_context_10":"} if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper","code_context_20":"\/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) {","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":4,"comment":"\/\/if we were able to actually extract it from our tank, then insert it into the item","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error","code_context_10":"return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return;","code_context_20":"if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":5,"comment":"\/\/todo: print warning\/error","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"\/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer);","code_context_10":"gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal);","code_context_20":"if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer);","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":6,"comment":"\/\/extract gas from dropper","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"} } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas","code_context_10":"\/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) {","code_context_20":"} if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); }","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":7,"comment":"\/\/if the dropper has fluid or the tank interacting with is already full of gas","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"} else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; }","code_context_10":"if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) {","code_context_20":"if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) {","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":8,"comment":"\/\/if we were able to actually extract it from the item, then insert it into our gas tank","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error","code_context_10":"if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } }","code_context_20":"gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) {","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":9,"comment":"\/\/todo: print warning\/error","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"\/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer);","code_context_10":"gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal);","code_context_20":"if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer);","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":10,"comment":"\/\/dump the tank","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"} } } else if (button == 2) { \/\/dump the tank gastank.setempty(); }","code_context_10":"if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks","code_context_20":"} } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) {","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":11,"comment":"\/\/it is actually an infusion tank","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"} } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point","code_context_10":"\/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; }","code_context_20":"return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty();","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":12,"comment":"\/\/todo: implement at some point","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"\/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } }","code_context_10":"((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability));","code_context_20":"gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack));","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":13,"comment":"\/\/todo: handle other chemical tanks like maybe infusion tanks","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"} } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank;","code_context_10":"} else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) {","code_context_20":"if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return;","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":14,"comment":"\/\/dump the tank","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"} } } else if (button == 2) { \/\/dump the tank gastank.setempty(); }","code_context_10":"if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks","code_context_20":"} } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) {","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":15,"comment":"\/\/if something went wrong and we don't have a fluid handler on our tank, then fail","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; }","code_context_10":"igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) {","code_context_20":"} \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount();","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":16,"comment":"\/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; }","code_context_10":"if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return;","code_context_20":"return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":17,"comment":"\/\/if something went wrong and we don't have a fluid tank fail","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; }","code_context_10":"return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount();","code_context_20":"if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); }","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":18,"comment":"\/\/insert fluid into dropper","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return;","code_context_10":"if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual);","code_context_20":"} if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) {","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":19,"comment":"\/\/we are able to fit at least some of the fluid from our tank into the item","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) {","code_context_10":"} if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper","code_context_20":"ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":20,"comment":"\/\/if we were able to actually extract it from our tank, then insert it into the item","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error","code_context_10":"return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return;","code_context_20":"if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":21,"comment":"\/\/todo: print warning\/error","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"\/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer);","code_context_10":"gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal);","code_context_20":"if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer);","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":22,"comment":"\/\/extract fluid from dropper","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"} } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return;","code_context_10":"\/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank","code_context_20":"} if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":23,"comment":"\/\/if we were able to actually extract it from the item, then insert it into our gas tank","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"NONSATD","isFinished":true,"code_context_2":"gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error","code_context_10":"if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } }","code_context_20":"gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) {","repo":"Chiefwright\/Mekanism"}
{"id":24418,"comment_id":24,"comment":"\/\/todo: print warning\/error","code":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { \/\/it is actually a gas tank ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { \/\/dump the tank gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { \/\/it is actually an infusion tank ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; \/\/todo: implement at some point } } \/\/todo: handle other chemical tanks like maybe infusion tanks } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { \/\/dump the tank fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { \/\/if something went wrong and we don't have a fluid handler on our tank, then fail return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { \/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { \/\/if something went wrong and we don't have a fluid tank fail return; } if (button == 0) { \/\/insert fluid into dropper if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the fluid from our tank into the item fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract fluid from dropper if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"\/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer);","code_context_10":"gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal);","code_context_20":"if (gashandleritem.getgastankcount() > 0) { \/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { \/\/insert gas into dropper if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { \/\/we are able to fit at least some of the gas from our tank into the item gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from our tank, then insert it into the item if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { \/\/extract gas from dropper if (!storedfluid.isempty() || gastank.getneeded() == 0) { \/\/if the dropper has fluid or the tank interacting with is already full of gas return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { \/\/if we were able to actually extract it from the item, then insert it into our gas tank if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { \/\/todo: print warning\/error } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer);","repo":"Chiefwright\/Mekanism"}

{"id":24673,"comment_id":0,"comment":"\/** * checks if the provided zone is an option for the client to connect to. * any zone provided must have previously been created by zonemanagement. * * @param tenantid the tenantid of the connecting envoy. * @param zone the zone provided in the envoysummary. * @throws illegalargumentexception if the zone is not found. *\/","code":"\/** * checks if the provided zone is an option for the client to connect to. * any zone provided must have previously been created by zonemanagement. * * @param tenantid the tenantid of the connecting envoy. * @param zone the zone provided in the envoysummary. * @throws illegalargumentexception if the zone is not found. *\/ private void validatezoneavailable(string tenantid, string zone) throws illegalargumentexception { list<zonedto> zones; try { zones = zoneapi.getavailablezones(tenantid); } catch (resourceaccessexception e) { \/\/ need to do something here to handle things more gracefully. throw new runtimeexception(\"unable to validate zones.\", e); } boolean found = zones.stream().anymatch(z -> z.getname().equals(zone)); log.debug(\"found {} zones for tenant\", zoneapi.getavailablezones(tenantid).size()); if (!found) throw new illegalargumentexception(\"provided zone does not exist: \" + zone); }","classification":"NONSATD","isFinished":true,"code_context_2":"private void validatezoneavailable(string tenantid, string zone) throws illegalargumentexception { list<zonedto> zones; try { zones = zoneapi.getavailablezones(tenantid); } catch (resourceaccessexception e) { \/\/ need to do something here to handle things more gracefully. throw new runtimeexception(\"unable to validate zones.\", e); } boolean found = zones.stream().anymatch(z -> z.getname().equals(zone)); log.debug(\"found {} zones for tenant\", zoneapi.getavailablezones(tenantid).size()); if (!found) throw new illegalargumentexception(\"provided zone does not exist: \" + zone); }","code_context_10":"private void validatezoneavailable(string tenantid, string zone) throws illegalargumentexception { list<zonedto> zones; try { zones = zoneapi.getavailablezones(tenantid); } catch (resourceaccessexception e) { \/\/ need to do something here to handle things more gracefully. throw new runtimeexception(\"unable to validate zones.\", e); } boolean found = zones.stream().anymatch(z -> z.getname().equals(zone)); log.debug(\"found {} zones for tenant\", zoneapi.getavailablezones(tenantid).size()); if (!found) throw new illegalargumentexception(\"provided zone does not exist: \" + zone); }","code_context_20":"private void validatezoneavailable(string tenantid, string zone) throws illegalargumentexception { list<zonedto> zones; try { zones = zoneapi.getavailablezones(tenantid); } catch (resourceaccessexception e) { \/\/ need to do something here to handle things more gracefully. throw new runtimeexception(\"unable to validate zones.\", e); } boolean found = zones.stream().anymatch(z -> z.getname().equals(zone)); log.debug(\"found {} zones for tenant\", zoneapi.getavailablezones(tenantid).size()); if (!found) throw new illegalargumentexception(\"provided zone does not exist: \" + zone); }","repo":"racker\/salus-telemetry-ambassador"}
{"id":24673,"comment_id":1,"comment":"\/\/ need to do something here to handle things more gracefully.","code":"private void validatezoneavailable(string tenantid, string zone) throws illegalargumentexception { list<zonedto> zones; try { zones = zoneapi.getavailablezones(tenantid); } catch (resourceaccessexception e) { \/\/ need to do something here to handle things more gracefully. throw new runtimeexception(\"unable to validate zones.\", e); } boolean found = zones.stream().anymatch(z -> z.getname().equals(zone)); log.debug(\"found {} zones for tenant\", zoneapi.getavailablezones(tenantid).size()); if (!found) throw new illegalargumentexception(\"provided zone does not exist: \" + zone); }","classification":"DESIGN","isFinished":true,"code_context_2":"zones = zoneapi.getavailablezones(tenantid); } catch (resourceaccessexception e) { \/\/ need to do something here to handle things more gracefully. throw new runtimeexception(\"unable to validate zones.\", e); }","code_context_10":"private void validatezoneavailable(string tenantid, string zone) throws illegalargumentexception { list<zonedto> zones; try { zones = zoneapi.getavailablezones(tenantid); } catch (resourceaccessexception e) { \/\/ need to do something here to handle things more gracefully. throw new runtimeexception(\"unable to validate zones.\", e); } boolean found = zones.stream().anymatch(z -> z.getname().equals(zone)); log.debug(\"found {} zones for tenant\", zoneapi.getavailablezones(tenantid).size()); if (!found) throw new illegalargumentexception(\"provided zone does not exist: \" + zone); }","code_context_20":"private void validatezoneavailable(string tenantid, string zone) throws illegalargumentexception { list<zonedto> zones; try { zones = zoneapi.getavailablezones(tenantid); } catch (resourceaccessexception e) { \/\/ need to do something here to handle things more gracefully. throw new runtimeexception(\"unable to validate zones.\", e); } boolean found = zones.stream().anymatch(z -> z.getname().equals(zone)); log.debug(\"found {} zones for tenant\", zoneapi.getavailablezones(tenantid).size()); if (!found) throw new illegalargumentexception(\"provided zone does not exist: \" + zone); }","repo":"racker\/salus-telemetry-ambassador"}
{"id":16532,"comment_id":0,"comment":"\/** * return the id of the block that the spawn is happening on. *\/","code":"\/** * return the id of the block that the spawn is happening on. *\/ public string getblockid() { final blockentity be = serverworld.getblockentity(this.blockpos); \/\/ fixme do we need to check at y+1? return string.valueof(registry.block_entity_type.getid(be.gettype())); }","classification":"NONSATD","isFinished":true,"code_context_2":"public string getblockid() { final blockentity be = serverworld.getblockentity(this.blockpos); \/\/ fixme do we need to check at y+1? return string.valueof(registry.block_entity_type.getid(be.gettype())); }","code_context_10":"public string getblockid() { final blockentity be = serverworld.getblockentity(this.blockpos); \/\/ fixme do we need to check at y+1? return string.valueof(registry.block_entity_type.getid(be.gettype())); }","code_context_20":"public string getblockid() { final blockentity be = serverworld.getblockentity(this.blockpos); \/\/ fixme do we need to check at y+1? return string.valueof(registry.block_entity_type.getid(be.gettype())); }","repo":"pcal43\/mob-filter"}
{"id":16532,"comment_id":1,"comment":"\/\/ fixme do we need to check at y+1?","code":"public string getblockid() { final blockentity be = serverworld.getblockentity(this.blockpos); \/\/ fixme do we need to check at y+1? return string.valueof(registry.block_entity_type.getid(be.gettype())); }","classification":"DEFECT","isFinished":true,"code_context_2":"public string getblockid() { final blockentity be = serverworld.getblockentity(this.blockpos); \/\/ fixme do we need to check at y+1? return string.valueof(registry.block_entity_type.getid(be.gettype())); }","code_context_10":"public string getblockid() { final blockentity be = serverworld.getblockentity(this.blockpos); \/\/ fixme do we need to check at y+1? return string.valueof(registry.block_entity_type.getid(be.gettype())); }","code_context_20":"public string getblockid() { final blockentity be = serverworld.getblockentity(this.blockpos); \/\/ fixme do we need to check at y+1? return string.valueof(registry.block_entity_type.getid(be.gettype())); }","repo":"pcal43\/mob-filter"}
{"id":24727,"comment_id":0,"comment":"\/\/ todo: not sure what to do about this now that we have base and absolute path.","code":"\/\/ todo: not sure what to do about this now that we have base and absolute path. @override public list<devicestorageroot> getsecondarydevicestorageroots() { arraylist<devicestorageroot> secondarystorageroot = new arraylist<>(1); if (secondarystoragepath != null) { secondarystorageroot.add(new devicestorageroot(secondarystoragepath, secondarystoragepath, devicestorageroot.type.secondary)); } return secondarystorageroot; }","classification":"DESIGN","isFinished":true,"code_context_2":"@override public list<devicestorageroot> getsecondarydevicestorageroots() { arraylist<devicestorageroot> secondarystorageroot = new arraylist<>(1); if (secondarystoragepath != null) { secondarystorageroot.add(new devicestorageroot(secondarystoragepath, secondarystoragepath, devicestorageroot.type.secondary)); } return secondarystorageroot; }","code_context_10":"@override public list<devicestorageroot> getsecondarydevicestorageroots() { arraylist<devicestorageroot> secondarystorageroot = new arraylist<>(1); if (secondarystoragepath != null) { secondarystorageroot.add(new devicestorageroot(secondarystoragepath, secondarystoragepath, devicestorageroot.type.secondary)); } return secondarystorageroot; }","code_context_20":"@override public list<devicestorageroot> getsecondarydevicestorageroots() { arraylist<devicestorageroot> secondarystorageroot = new arraylist<>(1); if (secondarystoragepath != null) { secondarystorageroot.add(new devicestorageroot(secondarystoragepath, secondarystoragepath, devicestorageroot.type.secondary)); } return secondarystorageroot; }","repo":"novoda\/storage-path-finder"}
{"id":8431,"comment_id":0,"comment":"\/** getter * todo: write general description for this method *\/","code":"\/** getter * todo: write general description for this method *\/ @jsongetter(\"amount\") public int getamount ( ) { return this.amount; }","classification":"DOCUMENTATION","isFinished":true,"code_context_2":"@jsongetter(\"amount\") public int getamount ( ) { return this.amount; }","code_context_10":"@jsongetter(\"amount\") public int getamount ( ) { return this.amount; }","code_context_20":"@jsongetter(\"amount\") public int getamount ( ) { return this.amount; }","repo":"pagarme\/pagarme-core-api-java"}
{"id":8432,"comment_id":0,"comment":"\/** setter * todo: write general description for this method *\/","code":"\/** setter * todo: write general description for this method *\/ @jsonsetter(\"amount\") public void setamount (int value) { this.amount = value; }","classification":"DOCUMENTATION","isFinished":true,"code_context_2":"@jsonsetter(\"amount\") public void setamount (int value) { this.amount = value; }","code_context_10":"@jsonsetter(\"amount\") public void setamount (int value) { this.amount = value; }","code_context_20":"@jsonsetter(\"amount\") public void setamount (int value) { this.amount = value; }","repo":"pagarme\/pagarme-core-api-java"}
{"id":8433,"comment_id":0,"comment":"\/** getter * todo: write general description for this method *\/","code":"\/** getter * todo: write general description for this method *\/ @jsongetter(\"description\") public string getdescription ( ) { return this.description; }","classification":"DOCUMENTATION","isFinished":true,"code_context_2":"@jsongetter(\"description\") public string getdescription ( ) { return this.description; }","code_context_10":"@jsongetter(\"description\") public string getdescription ( ) { return this.description; }","code_context_20":"@jsongetter(\"description\") public string getdescription ( ) { return this.description; }","repo":"pagarme\/pagarme-core-api-java"}
{"id":8434,"comment_id":0,"comment":"\/** setter * todo: write general description for this method *\/","code":"\/** setter * todo: write general description for this method *\/ @jsonsetter(\"description\") public void setdescription (string value) { this.description = value; }","classification":"DOCUMENTATION","isFinished":true,"code_context_2":"@jsonsetter(\"description\") public void setdescription (string value) { this.description = value; }","code_context_10":"@jsonsetter(\"description\") public void setdescription (string value) { this.description = value; }","code_context_20":"@jsonsetter(\"description\") public void setdescription (string value) { this.description = value; }","repo":"pagarme\/pagarme-core-api-java"}
{"id":8435,"comment_id":0,"comment":"\/** getter * todo: write general description for this method *\/","code":"\/** getter * todo: write general description for this method *\/ @jsongetter(\"quantity\") public int getquantity ( ) { return this.quantity; }","classification":"DOCUMENTATION","isFinished":true,"code_context_2":"@jsongetter(\"quantity\") public int getquantity ( ) { return this.quantity; }","code_context_10":"@jsongetter(\"quantity\") public int getquantity ( ) { return this.quantity; }","code_context_20":"@jsongetter(\"quantity\") public int getquantity ( ) { return this.quantity; }","repo":"pagarme\/pagarme-core-api-java"}
{"id":8436,"comment_id":0,"comment":"\/** setter * todo: write general description for this method *\/","code":"\/** setter * todo: write general description for this method *\/ @jsonsetter(\"quantity\") public void setquantity (int value) { this.quantity = value; }","classification":"DOCUMENTATION","isFinished":true,"code_context_2":"@jsonsetter(\"quantity\") public void setquantity (int value) { this.quantity = value; }","code_context_10":"@jsonsetter(\"quantity\") public void setquantity (int value) { this.quantity = value; }","code_context_20":"@jsonsetter(\"quantity\") public void setquantity (int value) { this.quantity = value; }","repo":"pagarme\/pagarme-core-api-java"}
{"id":8437,"comment_id":0,"comment":"\/** getter * todo: write general description for this method *\/","code":"\/** getter * todo: write general description for this method *\/ @jsongetter(\"category\") public string getcategory ( ) { return this.category; }","classification":"DOCUMENTATION","isFinished":true,"code_context_2":"@jsongetter(\"category\") public string getcategory ( ) { return this.category; }","code_context_10":"@jsongetter(\"category\") public string getcategory ( ) { return this.category; }","code_context_20":"@jsongetter(\"category\") public string getcategory ( ) { return this.category; }","repo":"pagarme\/pagarme-core-api-java"}
{"id":8438,"comment_id":0,"comment":"\/** setter * todo: write general description for this method *\/","code":"\/** setter * todo: write general description for this method *\/ @jsonsetter(\"category\") public void setcategory (string value) { this.category = value; }","classification":"DOCUMENTATION","isFinished":true,"code_context_2":"@jsonsetter(\"category\") public void setcategory (string value) { this.category = value; }","code_context_10":"@jsonsetter(\"category\") public void setcategory (string value) { this.category = value; }","code_context_20":"@jsonsetter(\"category\") public void setcategory (string value) { this.category = value; }","repo":"pagarme\/pagarme-core-api-java"}
{"id":8485,"comment_id":0,"comment":"\/\/ not called","code":"\/\/ not called private void updatecartcount(int count){ if (txtitemcount != null) { txtitemcount.settext(string.valueof(count)); } }","classification":"DESIGN","isFinished":true,"code_context_2":"private void updatecartcount(int count){ if (txtitemcount != null) { txtitemcount.settext(string.valueof(count)); } }","code_context_10":"private void updatecartcount(int count){ if (txtitemcount != null) { txtitemcount.settext(string.valueof(count)); } }","code_context_20":"private void updatecartcount(int count){ if (txtitemcount != null) { txtitemcount.settext(string.valueof(count)); } }","repo":"nilesh14\/FMC"}
{"id":16767,"comment_id":0,"comment":"\/\/ iterate on the messages","code":"@override public runnable getconsumer(final kafkasynchronizedconsumerpool pool, final kafkastream<byte[], byte[]> stream) { return new runnable() { @override public void run() { consumeriterator<byte[],byte[]> iter = stream.iterator(); byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); \/\/ iterate on the messages tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); \/\/ todo(hbs): allow setting of writebuffersize try { while (iter.hasnext()) { \/\/ \/\/ since the cal to 'next' may block, we need to first \/\/ check that there is a message available \/\/ boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next(); counters.count(msg.partition(), msg.offset()); byte[] data = msg.message(); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_messages, sensision.empty_labels, 1); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_bytes, sensision.empty_labels, data.length); if (null != siphashkey) { data = cryptoutils.removemac(siphashkey, data); } \/\/ skip data whose mac was not verified successfully if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidmacs, sensision.empty_labels, 1); continue; } \/\/ unwrap data if need be if (null != aeskey) { data = cryptoutils.unwrap(aeskey, data); } \/\/ skip data that was not unwrapped successfuly if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidciphers, sensision.empty_labels, 1); continue; } \/\/ \/\/ extract kafkadatamessage \/\/ kafkadatamessage tmsg = new kafkadatamessage(); deserializer.deserialize(tmsg, data); switch(tmsg.gettype()) { case store: gtsencoder encoder = new gtsencoder(0l, null, tmsg.getdata()); encoder.setclassid(tmsg.getclassid()); encoder.setlabelsid(tmsg.getlabelsid()); frontend.dispatch(encoder); break; case delete: case archive: break; default: throw new runtimeexception(\"invalid message type.\"); } } else { \/\/ sleep a tiny while try { thread.sleep(1l); } catch (interruptedexception ie) { } } } } catch (throwable t) { t.printstacktrace(system.err); } finally { \/\/ set abort to true in case we exit the 'run' method pool.getabort().set(true); } } }; }","classification":"NONSATD","isFinished":true,"code_context_2":"byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); \/\/ iterate on the messages tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters();","code_context_10":"@override public runnable getconsumer(final kafkasynchronizedconsumerpool pool, final kafkastream<byte[], byte[]> stream) { return new runnable() { @override public void run() { consumeriterator<byte[],byte[]> iter = stream.iterator(); byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); \/\/ iterate on the messages tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); \/\/ todo(hbs): allow setting of writebuffersize try { while (iter.hasnext()) { \/\/ \/\/ since the cal to 'next' may block, we need to first \/\/ check that there is a message available \/\/ boolean nonempty = iter.nonempty();","code_context_20":"@override public runnable getconsumer(final kafkasynchronizedconsumerpool pool, final kafkastream<byte[], byte[]> stream) { return new runnable() { @override public void run() { consumeriterator<byte[],byte[]> iter = stream.iterator(); byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); \/\/ iterate on the messages tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); \/\/ todo(hbs): allow setting of writebuffersize try { while (iter.hasnext()) { \/\/ \/\/ since the cal to 'next' may block, we need to first \/\/ check that there is a message available \/\/ boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next(); counters.count(msg.partition(), msg.offset()); byte[] data = msg.message(); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_messages, sensision.empty_labels, 1); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_bytes, sensision.empty_labels, data.length); if (null != siphashkey) { data = cryptoutils.removemac(siphashkey, data); } \/\/ skip data whose mac was not verified successfully","repo":"randomboolean\/warp10-platform"}
{"id":16767,"comment_id":1,"comment":"\/\/ todo(hbs): allow setting of writebuffersize","code":"@override public runnable getconsumer(final kafkasynchronizedconsumerpool pool, final kafkastream<byte[], byte[]> stream) { return new runnable() { @override public void run() { consumeriterator<byte[],byte[]> iter = stream.iterator(); byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); \/\/ iterate on the messages tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); \/\/ todo(hbs): allow setting of writebuffersize try { while (iter.hasnext()) { \/\/ \/\/ since the cal to 'next' may block, we need to first \/\/ check that there is a message available \/\/ boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next(); counters.count(msg.partition(), msg.offset()); byte[] data = msg.message(); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_messages, sensision.empty_labels, 1); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_bytes, sensision.empty_labels, data.length); if (null != siphashkey) { data = cryptoutils.removemac(siphashkey, data); } \/\/ skip data whose mac was not verified successfully if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidmacs, sensision.empty_labels, 1); continue; } \/\/ unwrap data if need be if (null != aeskey) { data = cryptoutils.unwrap(aeskey, data); } \/\/ skip data that was not unwrapped successfuly if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidciphers, sensision.empty_labels, 1); continue; } \/\/ \/\/ extract kafkadatamessage \/\/ kafkadatamessage tmsg = new kafkadatamessage(); deserializer.deserialize(tmsg, data); switch(tmsg.gettype()) { case store: gtsencoder encoder = new gtsencoder(0l, null, tmsg.getdata()); encoder.setclassid(tmsg.getclassid()); encoder.setlabelsid(tmsg.getlabelsid()); frontend.dispatch(encoder); break; case delete: case archive: break; default: throw new runtimeexception(\"invalid message type.\"); } } else { \/\/ sleep a tiny while try { thread.sleep(1l); } catch (interruptedexception ie) { } } } } catch (throwable t) { t.printstacktrace(system.err); } finally { \/\/ set abort to true in case we exit the 'run' method pool.getabort().set(true); } } }; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); \/\/ todo(hbs): allow setting of writebuffersize try { while (iter.hasnext()) {","code_context_10":"public runnable getconsumer(final kafkasynchronizedconsumerpool pool, final kafkastream<byte[], byte[]> stream) { return new runnable() { @override public void run() { consumeriterator<byte[],byte[]> iter = stream.iterator(); byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); \/\/ iterate on the messages tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); \/\/ todo(hbs): allow setting of writebuffersize try { while (iter.hasnext()) { \/\/ \/\/ since the cal to 'next' may block, we need to first \/\/ check that there is a message available \/\/ boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next(); counters.count(msg.partition(), msg.offset());","code_context_20":"@override public runnable getconsumer(final kafkasynchronizedconsumerpool pool, final kafkastream<byte[], byte[]> stream) { return new runnable() { @override public void run() { consumeriterator<byte[],byte[]> iter = stream.iterator(); byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); \/\/ iterate on the messages tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); \/\/ todo(hbs): allow setting of writebuffersize try { while (iter.hasnext()) { \/\/ \/\/ since the cal to 'next' may block, we need to first \/\/ check that there is a message available \/\/ boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next(); counters.count(msg.partition(), msg.offset()); byte[] data = msg.message(); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_messages, sensision.empty_labels, 1); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_bytes, sensision.empty_labels, data.length); if (null != siphashkey) { data = cryptoutils.removemac(siphashkey, data); } \/\/ skip data whose mac was not verified successfully if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidmacs, sensision.empty_labels, 1); continue;","repo":"randomboolean\/warp10-platform"}
{"id":16767,"comment_id":2,"comment":"\/\/ \/\/ since the cal to 'next' may block, we need to first \/\/ check that there is a message available \/\/","code":"@override public runnable getconsumer(final kafkasynchronizedconsumerpool pool, final kafkastream<byte[], byte[]> stream) { return new runnable() { @override public void run() { consumeriterator<byte[],byte[]> iter = stream.iterator(); byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); \/\/ iterate on the messages tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); \/\/ todo(hbs): allow setting of writebuffersize try { while (iter.hasnext()) { \/\/ \/\/ since the cal to 'next' may block, we need to first \/\/ check that there is a message available \/\/ boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next(); counters.count(msg.partition(), msg.offset()); byte[] data = msg.message(); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_messages, sensision.empty_labels, 1); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_bytes, sensision.empty_labels, data.length); if (null != siphashkey) { data = cryptoutils.removemac(siphashkey, data); } \/\/ skip data whose mac was not verified successfully if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidmacs, sensision.empty_labels, 1); continue; } \/\/ unwrap data if need be if (null != aeskey) { data = cryptoutils.unwrap(aeskey, data); } \/\/ skip data that was not unwrapped successfuly if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidciphers, sensision.empty_labels, 1); continue; } \/\/ \/\/ extract kafkadatamessage \/\/ kafkadatamessage tmsg = new kafkadatamessage(); deserializer.deserialize(tmsg, data); switch(tmsg.gettype()) { case store: gtsencoder encoder = new gtsencoder(0l, null, tmsg.getdata()); encoder.setclassid(tmsg.getclassid()); encoder.setlabelsid(tmsg.getlabelsid()); frontend.dispatch(encoder); break; case delete: case archive: break; default: throw new runtimeexception(\"invalid message type.\"); } } else { \/\/ sleep a tiny while try { thread.sleep(1l); } catch (interruptedexception ie) { } } } } catch (throwable t) { t.printstacktrace(system.err); } finally { \/\/ set abort to true in case we exit the 'run' method pool.getabort().set(true); } } }; }","classification":"NONSATD","isFinished":true,"code_context_2":"byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); \/\/ iterate on the messages tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); \/\/ todo(hbs): allow setting of writebuffersize try { while (iter.hasnext()) {","code_context_10":"@override public runnable getconsumer(final kafkasynchronizedconsumerpool pool, final kafkastream<byte[], byte[]> stream) { return new runnable() { @override public void run() { consumeriterator<byte[],byte[]> iter = stream.iterator(); byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); \/\/ iterate on the messages tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); \/\/ todo(hbs): allow setting of writebuffersize try { while (iter.hasnext()) { \/\/ \/\/ since the cal to 'next' may block, we need to first \/\/ check that there is a message available \/\/ boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next(); counters.count(msg.partition(), msg.offset());","code_context_20":"@override public runnable getconsumer(final kafkasynchronizedconsumerpool pool, final kafkastream<byte[], byte[]> stream) { return new runnable() { @override public void run() { consumeriterator<byte[],byte[]> iter = stream.iterator(); byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); \/\/ iterate on the messages tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); \/\/ todo(hbs): allow setting of writebuffersize try { while (iter.hasnext()) { \/\/ \/\/ since the cal to 'next' may block, we need to first \/\/ check that there is a message available \/\/ boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next(); counters.count(msg.partition(), msg.offset()); byte[] data = msg.message(); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_messages, sensision.empty_labels, 1); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_bytes, sensision.empty_labels, data.length); if (null != siphashkey) { data = cryptoutils.removemac(siphashkey, data); } \/\/ skip data whose mac was not verified successfully if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidmacs, sensision.empty_labels, 1); continue;","repo":"randomboolean\/warp10-platform"}
{"id":16767,"comment_id":3,"comment":"\/\/ skip data whose mac was not verified successfully","code":"@override public runnable getconsumer(final kafkasynchronizedconsumerpool pool, final kafkastream<byte[], byte[]> stream) { return new runnable() { @override public void run() { consumeriterator<byte[],byte[]> iter = stream.iterator(); byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); \/\/ iterate on the messages tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); \/\/ todo(hbs): allow setting of writebuffersize try { while (iter.hasnext()) { \/\/ \/\/ since the cal to 'next' may block, we need to first \/\/ check that there is a message available \/\/ boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next(); counters.count(msg.partition(), msg.offset()); byte[] data = msg.message(); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_messages, sensision.empty_labels, 1); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_bytes, sensision.empty_labels, data.length); if (null != siphashkey) { data = cryptoutils.removemac(siphashkey, data); } \/\/ skip data whose mac was not verified successfully if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidmacs, sensision.empty_labels, 1); continue; } \/\/ unwrap data if need be if (null != aeskey) { data = cryptoutils.unwrap(aeskey, data); } \/\/ skip data that was not unwrapped successfuly if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidciphers, sensision.empty_labels, 1); continue; } \/\/ \/\/ extract kafkadatamessage \/\/ kafkadatamessage tmsg = new kafkadatamessage(); deserializer.deserialize(tmsg, data); switch(tmsg.gettype()) { case store: gtsencoder encoder = new gtsencoder(0l, null, tmsg.getdata()); encoder.setclassid(tmsg.getclassid()); encoder.setlabelsid(tmsg.getlabelsid()); frontend.dispatch(encoder); break; case delete: case archive: break; default: throw new runtimeexception(\"invalid message type.\"); } } else { \/\/ sleep a tiny while try { thread.sleep(1l); } catch (interruptedexception ie) { } } } } catch (throwable t) { t.printstacktrace(system.err); } finally { \/\/ set abort to true in case we exit the 'run' method pool.getabort().set(true); } } }; }","classification":"NONSATD","isFinished":true,"code_context_2":"data = cryptoutils.removemac(siphashkey, data); } \/\/ skip data whose mac was not verified successfully if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidmacs, sensision.empty_labels, 1);","code_context_10":"boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next(); counters.count(msg.partition(), msg.offset()); byte[] data = msg.message(); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_messages, sensision.empty_labels, 1); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_bytes, sensision.empty_labels, data.length); if (null != siphashkey) { data = cryptoutils.removemac(siphashkey, data); } \/\/ skip data whose mac was not verified successfully if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidmacs, sensision.empty_labels, 1); continue; } \/\/ unwrap data if need be if (null != aeskey) { data = cryptoutils.unwrap(aeskey, data); } \/\/ skip data that was not unwrapped successfuly if (null == data) {","code_context_20":"\/\/ iterate on the messages tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); \/\/ todo(hbs): allow setting of writebuffersize try { while (iter.hasnext()) { \/\/ \/\/ since the cal to 'next' may block, we need to first \/\/ check that there is a message available \/\/ boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next(); counters.count(msg.partition(), msg.offset()); byte[] data = msg.message(); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_messages, sensision.empty_labels, 1); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_bytes, sensision.empty_labels, data.length); if (null != siphashkey) { data = cryptoutils.removemac(siphashkey, data); } \/\/ skip data whose mac was not verified successfully if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidmacs, sensision.empty_labels, 1); continue; } \/\/ unwrap data if need be if (null != aeskey) { data = cryptoutils.unwrap(aeskey, data); } \/\/ skip data that was not unwrapped successfuly if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidciphers, sensision.empty_labels, 1); continue; } \/\/ \/\/ extract kafkadatamessage \/\/ kafkadatamessage tmsg = new kafkadatamessage(); deserializer.deserialize(tmsg, data); switch(tmsg.gettype()) { case store:","repo":"randomboolean\/warp10-platform"}
{"id":16767,"comment_id":4,"comment":"\/\/ unwrap data if need be","code":"@override public runnable getconsumer(final kafkasynchronizedconsumerpool pool, final kafkastream<byte[], byte[]> stream) { return new runnable() { @override public void run() { consumeriterator<byte[],byte[]> iter = stream.iterator(); byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); \/\/ iterate on the messages tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); \/\/ todo(hbs): allow setting of writebuffersize try { while (iter.hasnext()) { \/\/ \/\/ since the cal to 'next' may block, we need to first \/\/ check that there is a message available \/\/ boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next(); counters.count(msg.partition(), msg.offset()); byte[] data = msg.message(); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_messages, sensision.empty_labels, 1); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_bytes, sensision.empty_labels, data.length); if (null != siphashkey) { data = cryptoutils.removemac(siphashkey, data); } \/\/ skip data whose mac was not verified successfully if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidmacs, sensision.empty_labels, 1); continue; } \/\/ unwrap data if need be if (null != aeskey) { data = cryptoutils.unwrap(aeskey, data); } \/\/ skip data that was not unwrapped successfuly if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidciphers, sensision.empty_labels, 1); continue; } \/\/ \/\/ extract kafkadatamessage \/\/ kafkadatamessage tmsg = new kafkadatamessage(); deserializer.deserialize(tmsg, data); switch(tmsg.gettype()) { case store: gtsencoder encoder = new gtsencoder(0l, null, tmsg.getdata()); encoder.setclassid(tmsg.getclassid()); encoder.setlabelsid(tmsg.getlabelsid()); frontend.dispatch(encoder); break; case delete: case archive: break; default: throw new runtimeexception(\"invalid message type.\"); } } else { \/\/ sleep a tiny while try { thread.sleep(1l); } catch (interruptedexception ie) { } } } } catch (throwable t) { t.printstacktrace(system.err); } finally { \/\/ set abort to true in case we exit the 'run' method pool.getabort().set(true); } } }; }","classification":"NONSATD","isFinished":true,"code_context_2":"continue; } \/\/ unwrap data if need be if (null != aeskey) { data = cryptoutils.unwrap(aeskey, data);","code_context_10":"sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_messages, sensision.empty_labels, 1); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_bytes, sensision.empty_labels, data.length); if (null != siphashkey) { data = cryptoutils.removemac(siphashkey, data); } \/\/ skip data whose mac was not verified successfully if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidmacs, sensision.empty_labels, 1); continue; } \/\/ unwrap data if need be if (null != aeskey) { data = cryptoutils.unwrap(aeskey, data); } \/\/ skip data that was not unwrapped successfuly if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidciphers, sensision.empty_labels, 1); continue; } \/\/ \/\/ extract kafkadatamessage","code_context_20":"while (iter.hasnext()) { \/\/ \/\/ since the cal to 'next' may block, we need to first \/\/ check that there is a message available \/\/ boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next(); counters.count(msg.partition(), msg.offset()); byte[] data = msg.message(); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_messages, sensision.empty_labels, 1); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_bytes, sensision.empty_labels, data.length); if (null != siphashkey) { data = cryptoutils.removemac(siphashkey, data); } \/\/ skip data whose mac was not verified successfully if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidmacs, sensision.empty_labels, 1); continue; } \/\/ unwrap data if need be if (null != aeskey) { data = cryptoutils.unwrap(aeskey, data); } \/\/ skip data that was not unwrapped successfuly if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidciphers, sensision.empty_labels, 1); continue; } \/\/ \/\/ extract kafkadatamessage \/\/ kafkadatamessage tmsg = new kafkadatamessage(); deserializer.deserialize(tmsg, data); switch(tmsg.gettype()) { case store: gtsencoder encoder = new gtsencoder(0l, null, tmsg.getdata()); encoder.setclassid(tmsg.getclassid()); encoder.setlabelsid(tmsg.getlabelsid()); frontend.dispatch(encoder); break;","repo":"randomboolean\/warp10-platform"}
{"id":16767,"comment_id":5,"comment":"\/\/ skip data that was not unwrapped successfuly","code":"@override public runnable getconsumer(final kafkasynchronizedconsumerpool pool, final kafkastream<byte[], byte[]> stream) { return new runnable() { @override public void run() { consumeriterator<byte[],byte[]> iter = stream.iterator(); byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); \/\/ iterate on the messages tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); \/\/ todo(hbs): allow setting of writebuffersize try { while (iter.hasnext()) { \/\/ \/\/ since the cal to 'next' may block, we need to first \/\/ check that there is a message available \/\/ boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next(); counters.count(msg.partition(), msg.offset()); byte[] data = msg.message(); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_messages, sensision.empty_labels, 1); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_bytes, sensision.empty_labels, data.length); if (null != siphashkey) { data = cryptoutils.removemac(siphashkey, data); } \/\/ skip data whose mac was not verified successfully if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidmacs, sensision.empty_labels, 1); continue; } \/\/ unwrap data if need be if (null != aeskey) { data = cryptoutils.unwrap(aeskey, data); } \/\/ skip data that was not unwrapped successfuly if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidciphers, sensision.empty_labels, 1); continue; } \/\/ \/\/ extract kafkadatamessage \/\/ kafkadatamessage tmsg = new kafkadatamessage(); deserializer.deserialize(tmsg, data); switch(tmsg.gettype()) { case store: gtsencoder encoder = new gtsencoder(0l, null, tmsg.getdata()); encoder.setclassid(tmsg.getclassid()); encoder.setlabelsid(tmsg.getlabelsid()); frontend.dispatch(encoder); break; case delete: case archive: break; default: throw new runtimeexception(\"invalid message type.\"); } } else { \/\/ sleep a tiny while try { thread.sleep(1l); } catch (interruptedexception ie) { } } } } catch (throwable t) { t.printstacktrace(system.err); } finally { \/\/ set abort to true in case we exit the 'run' method pool.getabort().set(true); } } }; }","classification":"NONSATD","isFinished":true,"code_context_2":"data = cryptoutils.unwrap(aeskey, data); } \/\/ skip data that was not unwrapped successfuly if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidciphers, sensision.empty_labels, 1);","code_context_10":"} \/\/ skip data whose mac was not verified successfully if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidmacs, sensision.empty_labels, 1); continue; } \/\/ unwrap data if need be if (null != aeskey) { data = cryptoutils.unwrap(aeskey, data); } \/\/ skip data that was not unwrapped successfuly if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidciphers, sensision.empty_labels, 1); continue; } \/\/ \/\/ extract kafkadatamessage \/\/ kafkadatamessage tmsg = new kafkadatamessage(); deserializer.deserialize(tmsg, data); switch(tmsg.gettype()) {","code_context_20":"\/\/ boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next(); counters.count(msg.partition(), msg.offset()); byte[] data = msg.message(); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_messages, sensision.empty_labels, 1); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_bytes, sensision.empty_labels, data.length); if (null != siphashkey) { data = cryptoutils.removemac(siphashkey, data); } \/\/ skip data whose mac was not verified successfully if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidmacs, sensision.empty_labels, 1); continue; } \/\/ unwrap data if need be if (null != aeskey) { data = cryptoutils.unwrap(aeskey, data); } \/\/ skip data that was not unwrapped successfuly if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidciphers, sensision.empty_labels, 1); continue; } \/\/ \/\/ extract kafkadatamessage \/\/ kafkadatamessage tmsg = new kafkadatamessage(); deserializer.deserialize(tmsg, data); switch(tmsg.gettype()) { case store: gtsencoder encoder = new gtsencoder(0l, null, tmsg.getdata()); encoder.setclassid(tmsg.getclassid()); encoder.setlabelsid(tmsg.getlabelsid()); frontend.dispatch(encoder); break; case delete: case archive: break; default:","repo":"randomboolean\/warp10-platform"}
{"id":16767,"comment_id":6,"comment":"\/\/ \/\/ extract kafkadatamessage \/\/","code":"@override public runnable getconsumer(final kafkasynchronizedconsumerpool pool, final kafkastream<byte[], byte[]> stream) { return new runnable() { @override public void run() { consumeriterator<byte[],byte[]> iter = stream.iterator(); byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); \/\/ iterate on the messages tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); \/\/ todo(hbs): allow setting of writebuffersize try { while (iter.hasnext()) { \/\/ \/\/ since the cal to 'next' may block, we need to first \/\/ check that there is a message available \/\/ boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next(); counters.count(msg.partition(), msg.offset()); byte[] data = msg.message(); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_messages, sensision.empty_labels, 1); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_bytes, sensision.empty_labels, data.length); if (null != siphashkey) { data = cryptoutils.removemac(siphashkey, data); } \/\/ skip data whose mac was not verified successfully if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidmacs, sensision.empty_labels, 1); continue; } \/\/ unwrap data if need be if (null != aeskey) { data = cryptoutils.unwrap(aeskey, data); } \/\/ skip data that was not unwrapped successfuly if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidciphers, sensision.empty_labels, 1); continue; } \/\/ \/\/ extract kafkadatamessage \/\/ kafkadatamessage tmsg = new kafkadatamessage(); deserializer.deserialize(tmsg, data); switch(tmsg.gettype()) { case store: gtsencoder encoder = new gtsencoder(0l, null, tmsg.getdata()); encoder.setclassid(tmsg.getclassid()); encoder.setlabelsid(tmsg.getlabelsid()); frontend.dispatch(encoder); break; case delete: case archive: break; default: throw new runtimeexception(\"invalid message type.\"); } } else { \/\/ sleep a tiny while try { thread.sleep(1l); } catch (interruptedexception ie) { } } } } catch (throwable t) { t.printstacktrace(system.err); } finally { \/\/ set abort to true in case we exit the 'run' method pool.getabort().set(true); } } }; }","classification":"NONSATD","isFinished":true,"code_context_2":"byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); \/\/ iterate on the messages tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); \/\/ todo(hbs): allow setting of writebuffersize try {","code_context_10":"@override public runnable getconsumer(final kafkasynchronizedconsumerpool pool, final kafkastream<byte[], byte[]> stream) { return new runnable() { @override public void run() { consumeriterator<byte[],byte[]> iter = stream.iterator(); byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); \/\/ iterate on the messages tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); \/\/ todo(hbs): allow setting of writebuffersize try { while (iter.hasnext()) { \/\/ \/\/ since the cal to 'next' may block, we need to first \/\/ check that there is a message available \/\/ boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next();","code_context_20":"@override public runnable getconsumer(final kafkasynchronizedconsumerpool pool, final kafkastream<byte[], byte[]> stream) { return new runnable() { @override public void run() { consumeriterator<byte[],byte[]> iter = stream.iterator(); byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); \/\/ iterate on the messages tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); \/\/ todo(hbs): allow setting of writebuffersize try { while (iter.hasnext()) { \/\/ \/\/ since the cal to 'next' may block, we need to first \/\/ check that there is a message available \/\/ boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next(); counters.count(msg.partition(), msg.offset()); byte[] data = msg.message(); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_messages, sensision.empty_labels, 1); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_bytes, sensision.empty_labels, data.length); if (null != siphashkey) { data = cryptoutils.removemac(siphashkey, data); } \/\/ skip data whose mac was not verified successfully if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidmacs, sensision.empty_labels, 1);","repo":"randomboolean\/warp10-platform"}
{"id":16767,"comment_id":7,"comment":"\/\/ sleep a tiny while","code":"@override public runnable getconsumer(final kafkasynchronizedconsumerpool pool, final kafkastream<byte[], byte[]> stream) { return new runnable() { @override public void run() { consumeriterator<byte[],byte[]> iter = stream.iterator(); byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); \/\/ iterate on the messages tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); \/\/ todo(hbs): allow setting of writebuffersize try { while (iter.hasnext()) { \/\/ \/\/ since the cal to 'next' may block, we need to first \/\/ check that there is a message available \/\/ boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next(); counters.count(msg.partition(), msg.offset()); byte[] data = msg.message(); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_messages, sensision.empty_labels, 1); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_bytes, sensision.empty_labels, data.length); if (null != siphashkey) { data = cryptoutils.removemac(siphashkey, data); } \/\/ skip data whose mac was not verified successfully if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidmacs, sensision.empty_labels, 1); continue; } \/\/ unwrap data if need be if (null != aeskey) { data = cryptoutils.unwrap(aeskey, data); } \/\/ skip data that was not unwrapped successfuly if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidciphers, sensision.empty_labels, 1); continue; } \/\/ \/\/ extract kafkadatamessage \/\/ kafkadatamessage tmsg = new kafkadatamessage(); deserializer.deserialize(tmsg, data); switch(tmsg.gettype()) { case store: gtsencoder encoder = new gtsencoder(0l, null, tmsg.getdata()); encoder.setclassid(tmsg.getclassid()); encoder.setlabelsid(tmsg.getlabelsid()); frontend.dispatch(encoder); break; case delete: case archive: break; default: throw new runtimeexception(\"invalid message type.\"); } } else { \/\/ sleep a tiny while try { thread.sleep(1l); } catch (interruptedexception ie) { } } } } catch (throwable t) { t.printstacktrace(system.err); } finally { \/\/ set abort to true in case we exit the 'run' method pool.getabort().set(true); } } }; }","classification":"NONSATD","isFinished":true,"code_context_2":"} } else { \/\/ sleep a tiny while try { thread.sleep(1l);","code_context_10":"encoder.setlabelsid(tmsg.getlabelsid()); frontend.dispatch(encoder); break; case delete: case archive: break; default: throw new runtimeexception(\"invalid message type.\"); } } else { \/\/ sleep a tiny while try { thread.sleep(1l); } catch (interruptedexception ie) { } } } } catch (throwable t) { t.printstacktrace(system.err); } finally { \/\/ set abort to true in case we exit the 'run' method","code_context_20":"} \/\/ \/\/ extract kafkadatamessage \/\/ kafkadatamessage tmsg = new kafkadatamessage(); deserializer.deserialize(tmsg, data); switch(tmsg.gettype()) { case store: gtsencoder encoder = new gtsencoder(0l, null, tmsg.getdata()); encoder.setclassid(tmsg.getclassid()); encoder.setlabelsid(tmsg.getlabelsid()); frontend.dispatch(encoder); break; case delete: case archive: break; default: throw new runtimeexception(\"invalid message type.\"); } } else { \/\/ sleep a tiny while try { thread.sleep(1l); } catch (interruptedexception ie) { } } } } catch (throwable t) { t.printstacktrace(system.err); } finally { \/\/ set abort to true in case we exit the 'run' method pool.getabort().set(true); } } }; }","repo":"randomboolean\/warp10-platform"}
{"id":16767,"comment_id":8,"comment":"\/\/ set abort to true in case we exit the 'run' method","code":"@override public runnable getconsumer(final kafkasynchronizedconsumerpool pool, final kafkastream<byte[], byte[]> stream) { return new runnable() { @override public void run() { consumeriterator<byte[],byte[]> iter = stream.iterator(); byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); \/\/ iterate on the messages tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); \/\/ todo(hbs): allow setting of writebuffersize try { while (iter.hasnext()) { \/\/ \/\/ since the cal to 'next' may block, we need to first \/\/ check that there is a message available \/\/ boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next(); counters.count(msg.partition(), msg.offset()); byte[] data = msg.message(); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_messages, sensision.empty_labels, 1); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_bytes, sensision.empty_labels, data.length); if (null != siphashkey) { data = cryptoutils.removemac(siphashkey, data); } \/\/ skip data whose mac was not verified successfully if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidmacs, sensision.empty_labels, 1); continue; } \/\/ unwrap data if need be if (null != aeskey) { data = cryptoutils.unwrap(aeskey, data); } \/\/ skip data that was not unwrapped successfuly if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidciphers, sensision.empty_labels, 1); continue; } \/\/ \/\/ extract kafkadatamessage \/\/ kafkadatamessage tmsg = new kafkadatamessage(); deserializer.deserialize(tmsg, data); switch(tmsg.gettype()) { case store: gtsencoder encoder = new gtsencoder(0l, null, tmsg.getdata()); encoder.setclassid(tmsg.getclassid()); encoder.setlabelsid(tmsg.getlabelsid()); frontend.dispatch(encoder); break; case delete: case archive: break; default: throw new runtimeexception(\"invalid message type.\"); } } else { \/\/ sleep a tiny while try { thread.sleep(1l); } catch (interruptedexception ie) { } } } } catch (throwable t) { t.printstacktrace(system.err); } finally { \/\/ set abort to true in case we exit the 'run' method pool.getabort().set(true); } } }; }","classification":"NONSATD","isFinished":true,"code_context_2":"t.printstacktrace(system.err); } finally { \/\/ set abort to true in case we exit the 'run' method pool.getabort().set(true); }","code_context_10":"\/\/ sleep a tiny while try { thread.sleep(1l); } catch (interruptedexception ie) { } } } } catch (throwable t) { t.printstacktrace(system.err); } finally { \/\/ set abort to true in case we exit the 'run' method pool.getabort().set(true); } } }; }","code_context_20":"encoder.setlabelsid(tmsg.getlabelsid()); frontend.dispatch(encoder); break; case delete: case archive: break; default: throw new runtimeexception(\"invalid message type.\"); } } else { \/\/ sleep a tiny while try { thread.sleep(1l); } catch (interruptedexception ie) { } } } } catch (throwable t) { t.printstacktrace(system.err); } finally { \/\/ set abort to true in case we exit the 'run' method pool.getabort().set(true); } } }; }","repo":"randomboolean\/warp10-platform"}
{"id":432,"comment_id":0,"comment":"\/** {@inheritdoc} *\/","code":"\/** {@inheritdoc} *\/ protected void addsubtable(glyphsubtable subtable) { if (subtable instanceof glyphclasssubtable) { this.gct = (glyphclasssubtable) subtable; } else if (subtable instanceof attachmentpointsubtable) { \/\/ todo - not yet used \/\/ this.apt = (attachmentpointsubtable) subtable; } else if (subtable instanceof ligaturecaretsubtable) { \/\/ todo - not yet used \/\/ this.lct = (ligaturecaretsubtable) subtable; } else if (subtable instanceof markattachmentsubtable) { this.mat = (markattachmentsubtable) subtable; } else { throw new unsupportedoperationexception(\"unsupported glyph definition subtable type: \" + subtable); } }","classification":"NONSATD","isFinished":true,"code_context_2":"protected void addsubtable(glyphsubtable subtable) { if (subtable instanceof glyphclasssubtable) { this.gct = (glyphclasssubtable) subtable; } else if (subtable instanceof attachmentpointsubtable) { \/\/ todo - not yet used \/\/ this.apt = (attachmentpointsubtable) subtable; } else if (subtable instanceof ligaturecaretsubtable) { \/\/ todo - not yet used \/\/ this.lct = (ligaturecaretsubtable) subtable; } else if (subtable instanceof markattachmentsubtable) { this.mat = (markattachmentsubtable) subtable; } else { throw new unsupportedoperationexception(\"unsupported glyph definition subtable type: \" + subtable); } }","code_context_10":"protected void addsubtable(glyphsubtable subtable) { if (subtable instanceof glyphclasssubtable) { this.gct = (glyphclasssubtable) subtable; } else if (subtable instanceof attachmentpointsubtable) { \/\/ todo - not yet used \/\/ this.apt = (attachmentpointsubtable) subtable; } else if (subtable instanceof ligaturecaretsubtable) { \/\/ todo - not yet used \/\/ this.lct = (ligaturecaretsubtable) subtable; } else if (subtable instanceof markattachmentsubtable) { this.mat = (markattachmentsubtable) subtable; } else { throw new unsupportedoperationexception(\"unsupported glyph definition subtable type: \" + subtable); } }","code_context_20":"protected void addsubtable(glyphsubtable subtable) { if (subtable instanceof glyphclasssubtable) { this.gct = (glyphclasssubtable) subtable; } else if (subtable instanceof attachmentpointsubtable) { \/\/ todo - not yet used \/\/ this.apt = (attachmentpointsubtable) subtable; } else if (subtable instanceof ligaturecaretsubtable) { \/\/ todo - not yet used \/\/ this.lct = (ligaturecaretsubtable) subtable; } else if (subtable instanceof markattachmentsubtable) { this.mat = (markattachmentsubtable) subtable; } else { throw new unsupportedoperationexception(\"unsupported glyph definition subtable type: \" + subtable); } }","repo":"not2sirius\/fop"}
{"id":432,"comment_id":1,"comment":"\/\/ todo - not yet used \/\/ this.apt = (attachmentpointsubtable) subtable;","code":"protected void addsubtable(glyphsubtable subtable) { if (subtable instanceof glyphclasssubtable) { this.gct = (glyphclasssubtable) subtable; } else if (subtable instanceof attachmentpointsubtable) { \/\/ todo - not yet used \/\/ this.apt = (attachmentpointsubtable) subtable; } else if (subtable instanceof ligaturecaretsubtable) { \/\/ todo - not yet used \/\/ this.lct = (ligaturecaretsubtable) subtable; } else if (subtable instanceof markattachmentsubtable) { this.mat = (markattachmentsubtable) subtable; } else { throw new unsupportedoperationexception(\"unsupported glyph definition subtable type: \" + subtable); } }","classification":"DESIGN","isFinished":true,"code_context_2":"this.gct = (glyphclasssubtable) subtable; } else if (subtable instanceof attachmentpointsubtable) { \/\/ todo - not yet used \/\/ this.apt = (attachmentpointsubtable) subtable; } else if (subtable instanceof ligaturecaretsubtable) { \/\/ todo - not yet used","code_context_10":"protected void addsubtable(glyphsubtable subtable) { if (subtable instanceof glyphclasssubtable) { this.gct = (glyphclasssubtable) subtable; } else if (subtable instanceof attachmentpointsubtable) { \/\/ todo - not yet used \/\/ this.apt = (attachmentpointsubtable) subtable; } else if (subtable instanceof ligaturecaretsubtable) { \/\/ todo - not yet used \/\/ this.lct = (ligaturecaretsubtable) subtable; } else if (subtable instanceof markattachmentsubtable) { this.mat = (markattachmentsubtable) subtable; } else { throw new unsupportedoperationexception(\"unsupported glyph definition subtable type: \" + subtable); } }","code_context_20":"protected void addsubtable(glyphsubtable subtable) { if (subtable instanceof glyphclasssubtable) { this.gct = (glyphclasssubtable) subtable; } else if (subtable instanceof attachmentpointsubtable) { \/\/ todo - not yet used \/\/ this.apt = (attachmentpointsubtable) subtable; } else if (subtable instanceof ligaturecaretsubtable) { \/\/ todo - not yet used \/\/ this.lct = (ligaturecaretsubtable) subtable; } else if (subtable instanceof markattachmentsubtable) { this.mat = (markattachmentsubtable) subtable; } else { throw new unsupportedoperationexception(\"unsupported glyph definition subtable type: \" + subtable); } }","repo":"not2sirius\/fop"}
{"id":432,"comment_id":2,"comment":"\/\/ todo - not yet used \/\/ this.lct = (ligaturecaretsubtable) subtable;","code":"protected void addsubtable(glyphsubtable subtable) { if (subtable instanceof glyphclasssubtable) { this.gct = (glyphclasssubtable) subtable; } else if (subtable instanceof attachmentpointsubtable) { \/\/ todo - not yet used \/\/ this.apt = (attachmentpointsubtable) subtable; } else if (subtable instanceof ligaturecaretsubtable) { \/\/ todo - not yet used \/\/ this.lct = (ligaturecaretsubtable) subtable; } else if (subtable instanceof markattachmentsubtable) { this.mat = (markattachmentsubtable) subtable; } else { throw new unsupportedoperationexception(\"unsupported glyph definition subtable type: \" + subtable); } }","classification":"DESIGN","isFinished":true,"code_context_2":"this.gct = (glyphclasssubtable) subtable; } else if (subtable instanceof attachmentpointsubtable) { \/\/ todo - not yet used \/\/ this.apt = (attachmentpointsubtable) subtable; } else if (subtable instanceof ligaturecaretsubtable) { \/\/ todo - not yet used","code_context_10":"protected void addsubtable(glyphsubtable subtable) { if (subtable instanceof glyphclasssubtable) { this.gct = (glyphclasssubtable) subtable; } else if (subtable instanceof attachmentpointsubtable) { \/\/ todo - not yet used \/\/ this.apt = (attachmentpointsubtable) subtable; } else if (subtable instanceof ligaturecaretsubtable) { \/\/ todo - not yet used \/\/ this.lct = (ligaturecaretsubtable) subtable; } else if (subtable instanceof markattachmentsubtable) { this.mat = (markattachmentsubtable) subtable; } else { throw new unsupportedoperationexception(\"unsupported glyph definition subtable type: \" + subtable); } }","code_context_20":"protected void addsubtable(glyphsubtable subtable) { if (subtable instanceof glyphclasssubtable) { this.gct = (glyphclasssubtable) subtable; } else if (subtable instanceof attachmentpointsubtable) { \/\/ todo - not yet used \/\/ this.apt = (attachmentpointsubtable) subtable; } else if (subtable instanceof ligaturecaretsubtable) { \/\/ todo - not yet used \/\/ this.lct = (ligaturecaretsubtable) subtable; } else if (subtable instanceof markattachmentsubtable) { this.mat = (markattachmentsubtable) subtable; } else { throw new unsupportedoperationexception(\"unsupported glyph definition subtable type: \" + subtable); } }","repo":"not2sirius\/fop"}
{"id":8645,"comment_id":0,"comment":"\/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size());","code":"@override public void exitoperator_expr(operonmoduleparser.operator_exprcontext ctx) { \/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size()); list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); \/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator); op.setfunctionref(funcref); op.setcascade(iscascade); this.stack.push(op); }","classification":"NONSATD","isFinished":true,"code_context_2":"@override public void exitoperator_expr(operonmoduleparser.operator_exprcontext ctx) { \/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size()); list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size();","code_context_10":"@override public void exitoperator_expr(operonmoduleparser.operator_exprcontext ctx) { \/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size()); list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); \/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; }","code_context_20":"@override public void exitoperator_expr(operonmoduleparser.operator_exprcontext ctx) { \/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size()); list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); \/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required.","repo":"operon-io\/operon-lang"}
{"id":8645,"comment_id":1,"comment":"\/\/ get the functionref","code":"@override public void exitoperator_expr(operonmoduleparser.operator_exprcontext ctx) { \/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size()); list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); \/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator); op.setfunctionref(funcref); op.setcascade(iscascade); this.stack.push(op); }","classification":"NONSATD","isFinished":true,"code_context_2":"list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); \/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false;","code_context_10":"@override public void exitoperator_expr(operonmoduleparser.operator_exprcontext ctx) { \/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size()); list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); \/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname());","code_context_20":"@override public void exitoperator_expr(operonmoduleparser.operator_exprcontext ctx) { \/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size()); list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); \/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator); op.setfunctionref(funcref); op.setcascade(iscascade);","repo":"operon-io\/operon-lang"}
{"id":8645,"comment_id":2,"comment":"\/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext());","code":"@override public void exitoperator_expr(operonmoduleparser.operator_exprcontext ctx) { \/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size()); list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); \/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator); op.setfunctionref(funcref); op.setcascade(iscascade); this.stack.push(op); }","classification":"NONSATD","isFinished":true,"code_context_2":"if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; }","code_context_10":"@override public void exitoperator_expr(operonmoduleparser.operator_exprcontext ctx) { \/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size()); list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); \/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext();","code_context_20":"@override public void exitoperator_expr(operonmoduleparser.operator_exprcontext ctx) { \/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size()); list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); \/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator); op.setfunctionref(funcref); op.setcascade(iscascade); this.stack.push(op); }","repo":"operon-io\/operon-lang"}
{"id":8645,"comment_id":3,"comment":"\/\/ get the overloaded operator:","code":"@override public void exitoperator_expr(operonmoduleparser.operator_exprcontext ctx) { \/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size()); list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); \/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator); op.setfunctionref(funcref); op.setcascade(iscascade); this.stack.push(op); }","classification":"NONSATD","isFinished":true,"code_context_2":"iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname());","code_context_10":"list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); \/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator);","code_context_20":"@override public void exitoperator_expr(operonmoduleparser.operator_exprcontext ctx) { \/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size()); list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); \/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator); op.setfunctionref(funcref); op.setcascade(iscascade); this.stack.push(op); }","repo":"operon-io\/operon-lang"}
{"id":8645,"comment_id":4,"comment":"\/\/:off:log.debug(subnodes.get(i).getclass().getname());","code":"@override public void exitoperator_expr(operonmoduleparser.operator_exprcontext ctx) { \/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size()); list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); \/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator); op.setfunctionref(funcref); op.setcascade(iscascade); this.stack.push(op); }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\");","code_context_10":"\/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator); op.setfunctionref(funcref); op.setcascade(iscascade);","code_context_20":"@override public void exitoperator_expr(operonmoduleparser.operator_exprcontext ctx) { \/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size()); list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); \/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator); op.setfunctionref(funcref); op.setcascade(iscascade); this.stack.push(op); }","repo":"operon-io\/operon-lang"}
{"id":8645,"comment_id":5,"comment":"\/\/:off:log.debug(\" >> operator :: terminal-node found.\");","code":"@override public void exitoperator_expr(operonmoduleparser.operator_exprcontext ctx) { \/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size()); list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); \/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator); op.setfunctionref(funcref); op.setcascade(iscascade); this.stack.push(op); }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } }","code_context_10":"boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator); op.setfunctionref(funcref); op.setcascade(iscascade); this.stack.push(op); }","code_context_20":"@override public void exitoperator_expr(operonmoduleparser.operator_exprcontext ctx) { \/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size()); list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); \/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator); op.setfunctionref(funcref); op.setcascade(iscascade); this.stack.push(op); }","repo":"operon-io\/operon-lang"}
{"id":8645,"comment_id":6,"comment":"\/\/:off:log.debug(\" >> operator :: \" + operator);","code":"@override public void exitoperator_expr(operonmoduleparser.operator_exprcontext ctx) { \/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size()); list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); \/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator); op.setfunctionref(funcref); op.setcascade(iscascade); this.stack.push(op); }","classification":"NONSATD","isFinished":true,"code_context_2":"} string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator);","code_context_10":"iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator); op.setfunctionref(funcref); op.setcascade(iscascade); this.stack.push(op); }","code_context_20":"public void exitoperator_expr(operonmoduleparser.operator_exprcontext ctx) { \/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size()); list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); \/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator); op.setfunctionref(funcref); op.setcascade(iscascade); this.stack.push(op); }","repo":"operon-io\/operon-lang"}
{"id":8645,"comment_id":7,"comment":"\/\/ todo: might not to inherit node, therefore giving statement not required.","code":"@override public void exitoperator_expr(operonmoduleparser.operator_exprcontext ctx) { \/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size()); list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); \/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator); op.setfunctionref(funcref); op.setcascade(iscascade); this.stack.push(op); }","classification":"DESIGN","isFinished":true,"code_context_2":"string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator); op.setfunctionref(funcref);","code_context_10":"} \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator); op.setfunctionref(funcref); op.setcascade(iscascade); this.stack.push(op); }","code_context_20":"\/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size()); list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); \/\/ get the functionref functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { \/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext()); iscascade = true; } \/\/ get the overloaded operator: for (int i = 0; i < subnodessize; i ++) { \/\/:off:log.debug(subnodes.get(i).getclass().getname()); if (subnodes.get(i) instanceof terminalnode) { \/\/:off:log.debug(\" >> operator :: terminal-node found.\"); } } string operator = subnodes.get(2).gettext(); \/\/:off:log.debug(\" >> operator :: \" + operator); operator op = new operator(this.currentstatement); \/\/ todo: might not to inherit node, therefore giving statement not required. op.setoperator(operator); op.setfunctionref(funcref); op.setcascade(iscascade); this.stack.push(op); }","repo":"operon-io\/operon-lang"}
{"id":33243,"comment_id":0,"comment":"\/** * we may want to test this method with more then 1 ontology. this is why the implementation is in * aprivate method. this method tests if all the logical axioms in testexpectedid ontology are inferences * of the testid ontology. * * @param testid * \/\/ the id of the ontology to be the input (loaded in the testdata.manager) * @param testexpectedid * \/\/ the id of the ontology which contains logical axioms expected in the result *\/","code":"\/** * we may want to test this method with more then 1 ontology. this is why the implementation is in * aprivate method. this method tests if all the logical axioms in testexpectedid ontology are inferences * of the testid ontology. * * @param testid * \/\/ the id of the ontology to be the input (loaded in the testdata.manager) * @param testexpectedid * \/\/ the id of the ontology which contains logical axioms expected in the result *\/ private void testclassify(string testid, string testexpectedid) { log.info(\"testing the classify task\"); owlontologymanager manager = testdata.manager; \/\/ we prepare the input ontology try { owlontology testontology = manager.createontology(); owlontologyid testontologyid = testontology.getontologyid(); log.debug(\"created test ontology with id: {}\", testontologyid); manager.applychange(new addimport(testontology, testdata.factory.getowlimportsdeclaration(iri .create(testid)))); \/\/ maybe we want to see what is in before if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); \/\/ now we test the method log.debug(\"running hermit\"); set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify, manager.getontology(testontologyid)); \/\/ maybe we want to see the inferred axiom list if (log.isdebugenabled()) { testutils.debug(inferred, log); } set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid)) .getlogicalaxioms(); set<owlaxiom> missing = new hashset<owlaxiom>(); for (owlaxiom expected : expectedaxioms) { if (!inferred.contains(expected)) { log.error(\"missing expected axiom: {}\", expected); missing.add(expected); } } asserttrue(missing.isempty()); \/\/ we want only class related axioms in the result set for (owlaxiom a : inferred) { asserttrue(a instanceof owlclassassertionaxiom || a instanceof owlsubclassofaxiom || a instanceof owlequivalentclassesaxiom || a instanceof owldisjointclassesaxiom); } \/\/ we want to remove the ontology from the manager manager.removeontology(testontology); } catch (owlontologycreationexception e) { log.error(\"an {} have been thrown while creating the input ontology for test\", e.getclass()); asserttrue(false); } catch (reasoningserviceexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (inconsistentinputexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (unsupportedtaskexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } }","classification":"TEST","isFinished":true,"code_context_2":"private void testclassify(string testid, string testexpectedid) { log.info(\"testing the classify task\"); owlontologymanager manager = testdata.manager; \/\/ we prepare the input ontology try { owlontology testontology = manager.createontology(); owlontologyid testontologyid = testontology.getontologyid(); log.debug(\"created test ontology with id: {}\", testontologyid); manager.applychange(new addimport(testontology, testdata.factory.getowlimportsdeclaration(iri .create(testid)))); \/\/ maybe we want to see what is in before if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); \/\/ now we test the method log.debug(\"running hermit\"); set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify, manager.getontology(testontologyid)); \/\/ maybe we want to see the inferred axiom list if (log.isdebugenabled()) { testutils.debug(inferred, log); } set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid)) .getlogicalaxioms(); set<owlaxiom> missing = new hashset<owlaxiom>(); for (owlaxiom expected : expectedaxioms) { if (!inferred.contains(expected)) { log.error(\"missing expected axiom: {}\", expected); missing.add(expected); } } asserttrue(missing.isempty()); \/\/ we want only class related axioms in the result set for (owlaxiom a : inferred) { asserttrue(a instanceof owlclassassertionaxiom || a instanceof owlsubclassofaxiom || a instanceof owlequivalentclassesaxiom || a instanceof owldisjointclassesaxiom); } \/\/ we want to remove the ontology from the manager manager.removeontology(testontology); } catch (owlontologycreationexception e) { log.error(\"an {} have been thrown while creating the input ontology for test\", e.getclass()); asserttrue(false); } catch (reasoningserviceexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (inconsistentinputexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (unsupportedtaskexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } }","code_context_10":"private void testclassify(string testid, string testexpectedid) { log.info(\"testing the classify task\"); owlontologymanager manager = testdata.manager; \/\/ we prepare the input ontology try { owlontology testontology = manager.createontology(); owlontologyid testontologyid = testontology.getontologyid(); log.debug(\"created test ontology with id: {}\", testontologyid); manager.applychange(new addimport(testontology, testdata.factory.getowlimportsdeclaration(iri .create(testid)))); \/\/ maybe we want to see what is in before if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); \/\/ now we test the method log.debug(\"running hermit\"); set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify, manager.getontology(testontologyid)); \/\/ maybe we want to see the inferred axiom list if (log.isdebugenabled()) { testutils.debug(inferred, log); } set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid)) .getlogicalaxioms(); set<owlaxiom> missing = new hashset<owlaxiom>(); for (owlaxiom expected : expectedaxioms) { if (!inferred.contains(expected)) { log.error(\"missing expected axiom: {}\", expected); missing.add(expected); } } asserttrue(missing.isempty()); \/\/ we want only class related axioms in the result set for (owlaxiom a : inferred) { asserttrue(a instanceof owlclassassertionaxiom || a instanceof owlsubclassofaxiom || a instanceof owlequivalentclassesaxiom || a instanceof owldisjointclassesaxiom); } \/\/ we want to remove the ontology from the manager manager.removeontology(testontology); } catch (owlontologycreationexception e) { log.error(\"an {} have been thrown while creating the input ontology for test\", e.getclass()); asserttrue(false); } catch (reasoningserviceexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (inconsistentinputexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (unsupportedtaskexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } }","code_context_20":"private void testclassify(string testid, string testexpectedid) { log.info(\"testing the classify task\"); owlontologymanager manager = testdata.manager; \/\/ we prepare the input ontology try { owlontology testontology = manager.createontology(); owlontologyid testontologyid = testontology.getontologyid(); log.debug(\"created test ontology with id: {}\", testontologyid); manager.applychange(new addimport(testontology, testdata.factory.getowlimportsdeclaration(iri .create(testid)))); \/\/ maybe we want to see what is in before if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); \/\/ now we test the method log.debug(\"running hermit\"); set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify, manager.getontology(testontologyid)); \/\/ maybe we want to see the inferred axiom list if (log.isdebugenabled()) { testutils.debug(inferred, log); } set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid)) .getlogicalaxioms(); set<owlaxiom> missing = new hashset<owlaxiom>(); for (owlaxiom expected : expectedaxioms) { if (!inferred.contains(expected)) { log.error(\"missing expected axiom: {}\", expected); missing.add(expected); } } asserttrue(missing.isempty()); \/\/ we want only class related axioms in the result set for (owlaxiom a : inferred) { asserttrue(a instanceof owlclassassertionaxiom || a instanceof owlsubclassofaxiom || a instanceof owlequivalentclassesaxiom || a instanceof owldisjointclassesaxiom); } \/\/ we want to remove the ontology from the manager manager.removeontology(testontology); } catch (owlontologycreationexception e) { log.error(\"an {} have been thrown while creating the input ontology for test\", e.getclass()); asserttrue(false); } catch (reasoningserviceexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (inconsistentinputexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (unsupportedtaskexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } }","repo":"nikosnikolaidis\/stanbol"}
{"id":33243,"comment_id":1,"comment":"\/\/ we prepare the input ontology","code":"private void testclassify(string testid, string testexpectedid) { log.info(\"testing the classify task\"); owlontologymanager manager = testdata.manager; \/\/ we prepare the input ontology try { owlontology testontology = manager.createontology(); owlontologyid testontologyid = testontology.getontologyid(); log.debug(\"created test ontology with id: {}\", testontologyid); manager.applychange(new addimport(testontology, testdata.factory.getowlimportsdeclaration(iri .create(testid)))); \/\/ maybe we want to see what is in before if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); \/\/ now we test the method log.debug(\"running hermit\"); set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify, manager.getontology(testontologyid)); \/\/ maybe we want to see the inferred axiom list if (log.isdebugenabled()) { testutils.debug(inferred, log); } set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid)) .getlogicalaxioms(); set<owlaxiom> missing = new hashset<owlaxiom>(); for (owlaxiom expected : expectedaxioms) { if (!inferred.contains(expected)) { log.error(\"missing expected axiom: {}\", expected); missing.add(expected); } } asserttrue(missing.isempty()); \/\/ we want only class related axioms in the result set for (owlaxiom a : inferred) { asserttrue(a instanceof owlclassassertionaxiom || a instanceof owlsubclassofaxiom || a instanceof owlequivalentclassesaxiom || a instanceof owldisjointclassesaxiom); } \/\/ we want to remove the ontology from the manager manager.removeontology(testontology); } catch (owlontologycreationexception e) { log.error(\"an {} have been thrown while creating the input ontology for test\", e.getclass()); asserttrue(false); } catch (reasoningserviceexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (inconsistentinputexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (unsupportedtaskexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } }","classification":"NONSATD","isFinished":true,"code_context_2":"log.info(\"testing the classify task\"); owlontologymanager manager = testdata.manager; \/\/ we prepare the input ontology try { owlontology testontology = manager.createontology();","code_context_10":"private void testclassify(string testid, string testexpectedid) { log.info(\"testing the classify task\"); owlontologymanager manager = testdata.manager; \/\/ we prepare the input ontology try { owlontology testontology = manager.createontology(); owlontologyid testontologyid = testontology.getontologyid(); log.debug(\"created test ontology with id: {}\", testontologyid); manager.applychange(new addimport(testontology, testdata.factory.getowlimportsdeclaration(iri .create(testid)))); \/\/ maybe we want to see what is in before if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); \/\/ now we test the method log.debug(\"running hermit\");","code_context_20":"private void testclassify(string testid, string testexpectedid) { log.info(\"testing the classify task\"); owlontologymanager manager = testdata.manager; \/\/ we prepare the input ontology try { owlontology testontology = manager.createontology(); owlontologyid testontologyid = testontology.getontologyid(); log.debug(\"created test ontology with id: {}\", testontologyid); manager.applychange(new addimport(testontology, testdata.factory.getowlimportsdeclaration(iri .create(testid)))); \/\/ maybe we want to see what is in before if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); \/\/ now we test the method log.debug(\"running hermit\"); set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify, manager.getontology(testontologyid)); \/\/ maybe we want to see the inferred axiom list if (log.isdebugenabled()) { testutils.debug(inferred, log); } set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid)) .getlogicalaxioms(); set<owlaxiom> missing = new hashset<owlaxiom>(); for (owlaxiom expected : expectedaxioms) {","repo":"nikosnikolaidis\/stanbol"}
{"id":33243,"comment_id":2,"comment":"\/\/ maybe we want to see what is in before","code":"private void testclassify(string testid, string testexpectedid) { log.info(\"testing the classify task\"); owlontologymanager manager = testdata.manager; \/\/ we prepare the input ontology try { owlontology testontology = manager.createontology(); owlontologyid testontologyid = testontology.getontologyid(); log.debug(\"created test ontology with id: {}\", testontologyid); manager.applychange(new addimport(testontology, testdata.factory.getowlimportsdeclaration(iri .create(testid)))); \/\/ maybe we want to see what is in before if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); \/\/ now we test the method log.debug(\"running hermit\"); set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify, manager.getontology(testontologyid)); \/\/ maybe we want to see the inferred axiom list if (log.isdebugenabled()) { testutils.debug(inferred, log); } set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid)) .getlogicalaxioms(); set<owlaxiom> missing = new hashset<owlaxiom>(); for (owlaxiom expected : expectedaxioms) { if (!inferred.contains(expected)) { log.error(\"missing expected axiom: {}\", expected); missing.add(expected); } } asserttrue(missing.isempty()); \/\/ we want only class related axioms in the result set for (owlaxiom a : inferred) { asserttrue(a instanceof owlclassassertionaxiom || a instanceof owlsubclassofaxiom || a instanceof owlequivalentclassesaxiom || a instanceof owldisjointclassesaxiom); } \/\/ we want to remove the ontology from the manager manager.removeontology(testontology); } catch (owlontologycreationexception e) { log.error(\"an {} have been thrown while creating the input ontology for test\", e.getclass()); asserttrue(false); } catch (reasoningserviceexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (inconsistentinputexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (unsupportedtaskexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } }","classification":"NONSATD","isFinished":true,"code_context_2":"manager.applychange(new addimport(testontology, testdata.factory.getowlimportsdeclaration(iri .create(testid)))); \/\/ maybe we want to see what is in before if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); \/\/ now we test the method","code_context_10":"private void testclassify(string testid, string testexpectedid) { log.info(\"testing the classify task\"); owlontologymanager manager = testdata.manager; \/\/ we prepare the input ontology try { owlontology testontology = manager.createontology(); owlontologyid testontologyid = testontology.getontologyid(); log.debug(\"created test ontology with id: {}\", testontologyid); manager.applychange(new addimport(testontology, testdata.factory.getowlimportsdeclaration(iri .create(testid)))); \/\/ maybe we want to see what is in before if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); \/\/ now we test the method log.debug(\"running hermit\"); set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify, manager.getontology(testontologyid)); \/\/ maybe we want to see the inferred axiom list if (log.isdebugenabled()) { testutils.debug(inferred, log); } set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid))","code_context_20":"private void testclassify(string testid, string testexpectedid) { log.info(\"testing the classify task\"); owlontologymanager manager = testdata.manager; \/\/ we prepare the input ontology try { owlontology testontology = manager.createontology(); owlontologyid testontologyid = testontology.getontologyid(); log.debug(\"created test ontology with id: {}\", testontologyid); manager.applychange(new addimport(testontology, testdata.factory.getowlimportsdeclaration(iri .create(testid)))); \/\/ maybe we want to see what is in before if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); \/\/ now we test the method log.debug(\"running hermit\"); set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify, manager.getontology(testontologyid)); \/\/ maybe we want to see the inferred axiom list if (log.isdebugenabled()) { testutils.debug(inferred, log); } set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid)) .getlogicalaxioms(); set<owlaxiom> missing = new hashset<owlaxiom>(); for (owlaxiom expected : expectedaxioms) { if (!inferred.contains(expected)) { log.error(\"missing expected axiom: {}\", expected); missing.add(expected); } } asserttrue(missing.isempty()); \/\/ we want only class related axioms in the result set","repo":"nikosnikolaidis\/stanbol"}
{"id":33243,"comment_id":3,"comment":"\/\/ now we test the method","code":"private void testclassify(string testid, string testexpectedid) { log.info(\"testing the classify task\"); owlontologymanager manager = testdata.manager; \/\/ we prepare the input ontology try { owlontology testontology = manager.createontology(); owlontologyid testontologyid = testontology.getontologyid(); log.debug(\"created test ontology with id: {}\", testontologyid); manager.applychange(new addimport(testontology, testdata.factory.getowlimportsdeclaration(iri .create(testid)))); \/\/ maybe we want to see what is in before if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); \/\/ now we test the method log.debug(\"running hermit\"); set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify, manager.getontology(testontologyid)); \/\/ maybe we want to see the inferred axiom list if (log.isdebugenabled()) { testutils.debug(inferred, log); } set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid)) .getlogicalaxioms(); set<owlaxiom> missing = new hashset<owlaxiom>(); for (owlaxiom expected : expectedaxioms) { if (!inferred.contains(expected)) { log.error(\"missing expected axiom: {}\", expected); missing.add(expected); } } asserttrue(missing.isempty()); \/\/ we want only class related axioms in the result set for (owlaxiom a : inferred) { asserttrue(a instanceof owlclassassertionaxiom || a instanceof owlsubclassofaxiom || a instanceof owlequivalentclassesaxiom || a instanceof owldisjointclassesaxiom); } \/\/ we want to remove the ontology from the manager manager.removeontology(testontology); } catch (owlontologycreationexception e) { log.error(\"an {} have been thrown while creating the input ontology for test\", e.getclass()); asserttrue(false); } catch (reasoningserviceexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (inconsistentinputexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (unsupportedtaskexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ maybe we want to see what is in before if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); \/\/ now we test the method log.debug(\"running hermit\"); set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify,","code_context_10":"owlontologymanager manager = testdata.manager; \/\/ we prepare the input ontology try { owlontology testontology = manager.createontology(); owlontologyid testontologyid = testontology.getontologyid(); log.debug(\"created test ontology with id: {}\", testontologyid); manager.applychange(new addimport(testontology, testdata.factory.getowlimportsdeclaration(iri .create(testid)))); \/\/ maybe we want to see what is in before if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); \/\/ now we test the method log.debug(\"running hermit\"); set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify, manager.getontology(testontologyid)); \/\/ maybe we want to see the inferred axiom list if (log.isdebugenabled()) { testutils.debug(inferred, log); } set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid)) .getlogicalaxioms(); set<owlaxiom> missing = new hashset<owlaxiom>();","code_context_20":"private void testclassify(string testid, string testexpectedid) { log.info(\"testing the classify task\"); owlontologymanager manager = testdata.manager; \/\/ we prepare the input ontology try { owlontology testontology = manager.createontology(); owlontologyid testontologyid = testontology.getontologyid(); log.debug(\"created test ontology with id: {}\", testontologyid); manager.applychange(new addimport(testontology, testdata.factory.getowlimportsdeclaration(iri .create(testid)))); \/\/ maybe we want to see what is in before if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); \/\/ now we test the method log.debug(\"running hermit\"); set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify, manager.getontology(testontologyid)); \/\/ maybe we want to see the inferred axiom list if (log.isdebugenabled()) { testutils.debug(inferred, log); } set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid)) .getlogicalaxioms(); set<owlaxiom> missing = new hashset<owlaxiom>(); for (owlaxiom expected : expectedaxioms) { if (!inferred.contains(expected)) { log.error(\"missing expected axiom: {}\", expected); missing.add(expected); } } asserttrue(missing.isempty()); \/\/ we want only class related axioms in the result set for (owlaxiom a : inferred) { asserttrue(a instanceof owlclassassertionaxiom || a instanceof owlsubclassofaxiom","repo":"nikosnikolaidis\/stanbol"}
{"id":33243,"comment_id":4,"comment":"\/\/ maybe we want to see the inferred axiom list","code":"private void testclassify(string testid, string testexpectedid) { log.info(\"testing the classify task\"); owlontologymanager manager = testdata.manager; \/\/ we prepare the input ontology try { owlontology testontology = manager.createontology(); owlontologyid testontologyid = testontology.getontologyid(); log.debug(\"created test ontology with id: {}\", testontologyid); manager.applychange(new addimport(testontology, testdata.factory.getowlimportsdeclaration(iri .create(testid)))); \/\/ maybe we want to see what is in before if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); \/\/ now we test the method log.debug(\"running hermit\"); set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify, manager.getontology(testontologyid)); \/\/ maybe we want to see the inferred axiom list if (log.isdebugenabled()) { testutils.debug(inferred, log); } set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid)) .getlogicalaxioms(); set<owlaxiom> missing = new hashset<owlaxiom>(); for (owlaxiom expected : expectedaxioms) { if (!inferred.contains(expected)) { log.error(\"missing expected axiom: {}\", expected); missing.add(expected); } } asserttrue(missing.isempty()); \/\/ we want only class related axioms in the result set for (owlaxiom a : inferred) { asserttrue(a instanceof owlclassassertionaxiom || a instanceof owlsubclassofaxiom || a instanceof owlequivalentclassesaxiom || a instanceof owldisjointclassesaxiom); } \/\/ we want to remove the ontology from the manager manager.removeontology(testontology); } catch (owlontologycreationexception e) { log.error(\"an {} have been thrown while creating the input ontology for test\", e.getclass()); asserttrue(false); } catch (reasoningserviceexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (inconsistentinputexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (unsupportedtaskexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } }","classification":"NONSATD","isFinished":true,"code_context_2":"set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify, manager.getontology(testontologyid)); \/\/ maybe we want to see the inferred axiom list if (log.isdebugenabled()) { testutils.debug(inferred, log);","code_context_10":"owlontologyid testontologyid = testontology.getontologyid(); log.debug(\"created test ontology with id: {}\", testontologyid); manager.applychange(new addimport(testontology, testdata.factory.getowlimportsdeclaration(iri .create(testid)))); \/\/ maybe we want to see what is in before if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); \/\/ now we test the method log.debug(\"running hermit\"); set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify, manager.getontology(testontologyid)); \/\/ maybe we want to see the inferred axiom list if (log.isdebugenabled()) { testutils.debug(inferred, log); } set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid)) .getlogicalaxioms(); set<owlaxiom> missing = new hashset<owlaxiom>(); for (owlaxiom expected : expectedaxioms) { if (!inferred.contains(expected)) { log.error(\"missing expected axiom: {}\", expected); missing.add(expected);","code_context_20":"private void testclassify(string testid, string testexpectedid) { log.info(\"testing the classify task\"); owlontologymanager manager = testdata.manager; \/\/ we prepare the input ontology try { owlontology testontology = manager.createontology(); owlontologyid testontologyid = testontology.getontologyid(); log.debug(\"created test ontology with id: {}\", testontologyid); manager.applychange(new addimport(testontology, testdata.factory.getowlimportsdeclaration(iri .create(testid)))); \/\/ maybe we want to see what is in before if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); \/\/ now we test the method log.debug(\"running hermit\"); set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify, manager.getontology(testontologyid)); \/\/ maybe we want to see the inferred axiom list if (log.isdebugenabled()) { testutils.debug(inferred, log); } set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid)) .getlogicalaxioms(); set<owlaxiom> missing = new hashset<owlaxiom>(); for (owlaxiom expected : expectedaxioms) { if (!inferred.contains(expected)) { log.error(\"missing expected axiom: {}\", expected); missing.add(expected); } } asserttrue(missing.isempty()); \/\/ we want only class related axioms in the result set for (owlaxiom a : inferred) { asserttrue(a instanceof owlclassassertionaxiom || a instanceof owlsubclassofaxiom || a instanceof owlequivalentclassesaxiom || a instanceof owldisjointclassesaxiom); } \/\/ we want to remove the ontology from the manager manager.removeontology(testontology);","repo":"nikosnikolaidis\/stanbol"}
{"id":33243,"comment_id":5,"comment":"\/\/ we want only class related axioms in the result set","code":"private void testclassify(string testid, string testexpectedid) { log.info(\"testing the classify task\"); owlontologymanager manager = testdata.manager; \/\/ we prepare the input ontology try { owlontology testontology = manager.createontology(); owlontologyid testontologyid = testontology.getontologyid(); log.debug(\"created test ontology with id: {}\", testontologyid); manager.applychange(new addimport(testontology, testdata.factory.getowlimportsdeclaration(iri .create(testid)))); \/\/ maybe we want to see what is in before if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); \/\/ now we test the method log.debug(\"running hermit\"); set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify, manager.getontology(testontologyid)); \/\/ maybe we want to see the inferred axiom list if (log.isdebugenabled()) { testutils.debug(inferred, log); } set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid)) .getlogicalaxioms(); set<owlaxiom> missing = new hashset<owlaxiom>(); for (owlaxiom expected : expectedaxioms) { if (!inferred.contains(expected)) { log.error(\"missing expected axiom: {}\", expected); missing.add(expected); } } asserttrue(missing.isempty()); \/\/ we want only class related axioms in the result set for (owlaxiom a : inferred) { asserttrue(a instanceof owlclassassertionaxiom || a instanceof owlsubclassofaxiom || a instanceof owlequivalentclassesaxiom || a instanceof owldisjointclassesaxiom); } \/\/ we want to remove the ontology from the manager manager.removeontology(testontology); } catch (owlontologycreationexception e) { log.error(\"an {} have been thrown while creating the input ontology for test\", e.getclass()); asserttrue(false); } catch (reasoningserviceexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (inconsistentinputexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (unsupportedtaskexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} asserttrue(missing.isempty()); \/\/ we want only class related axioms in the result set for (owlaxiom a : inferred) { asserttrue(a instanceof owlclassassertionaxiom || a instanceof owlsubclassofaxiom","code_context_10":"set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid)) .getlogicalaxioms(); set<owlaxiom> missing = new hashset<owlaxiom>(); for (owlaxiom expected : expectedaxioms) { if (!inferred.contains(expected)) { log.error(\"missing expected axiom: {}\", expected); missing.add(expected); } } asserttrue(missing.isempty()); \/\/ we want only class related axioms in the result set for (owlaxiom a : inferred) { asserttrue(a instanceof owlclassassertionaxiom || a instanceof owlsubclassofaxiom || a instanceof owlequivalentclassesaxiom || a instanceof owldisjointclassesaxiom); } \/\/ we want to remove the ontology from the manager manager.removeontology(testontology); } catch (owlontologycreationexception e) { log.error(\"an {} have been thrown while creating the input ontology for test\", e.getclass()); asserttrue(false); } catch (reasoningserviceexception e) {","code_context_20":"\/\/ maybe we want to see what is in before if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); \/\/ now we test the method log.debug(\"running hermit\"); set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify, manager.getontology(testontologyid)); \/\/ maybe we want to see the inferred axiom list if (log.isdebugenabled()) { testutils.debug(inferred, log); } set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid)) .getlogicalaxioms(); set<owlaxiom> missing = new hashset<owlaxiom>(); for (owlaxiom expected : expectedaxioms) { if (!inferred.contains(expected)) { log.error(\"missing expected axiom: {}\", expected); missing.add(expected); } } asserttrue(missing.isempty()); \/\/ we want only class related axioms in the result set for (owlaxiom a : inferred) { asserttrue(a instanceof owlclassassertionaxiom || a instanceof owlsubclassofaxiom || a instanceof owlequivalentclassesaxiom || a instanceof owldisjointclassesaxiom); } \/\/ we want to remove the ontology from the manager manager.removeontology(testontology); } catch (owlontologycreationexception e) { log.error(\"an {} have been thrown while creating the input ontology for test\", e.getclass()); asserttrue(false); } catch (reasoningserviceexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (inconsistentinputexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (unsupportedtaskexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } }","repo":"nikosnikolaidis\/stanbol"}
{"id":33243,"comment_id":6,"comment":"\/\/ we want to remove the ontology from the manager","code":"private void testclassify(string testid, string testexpectedid) { log.info(\"testing the classify task\"); owlontologymanager manager = testdata.manager; \/\/ we prepare the input ontology try { owlontology testontology = manager.createontology(); owlontologyid testontologyid = testontology.getontologyid(); log.debug(\"created test ontology with id: {}\", testontologyid); manager.applychange(new addimport(testontology, testdata.factory.getowlimportsdeclaration(iri .create(testid)))); \/\/ maybe we want to see what is in before if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); \/\/ now we test the method log.debug(\"running hermit\"); set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify, manager.getontology(testontologyid)); \/\/ maybe we want to see the inferred axiom list if (log.isdebugenabled()) { testutils.debug(inferred, log); } set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid)) .getlogicalaxioms(); set<owlaxiom> missing = new hashset<owlaxiom>(); for (owlaxiom expected : expectedaxioms) { if (!inferred.contains(expected)) { log.error(\"missing expected axiom: {}\", expected); missing.add(expected); } } asserttrue(missing.isempty()); \/\/ we want only class related axioms in the result set for (owlaxiom a : inferred) { asserttrue(a instanceof owlclassassertionaxiom || a instanceof owlsubclassofaxiom || a instanceof owlequivalentclassesaxiom || a instanceof owldisjointclassesaxiom); } \/\/ we want to remove the ontology from the manager manager.removeontology(testontology); } catch (owlontologycreationexception e) { log.error(\"an {} have been thrown while creating the input ontology for test\", e.getclass()); asserttrue(false); } catch (reasoningserviceexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (inconsistentinputexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (unsupportedtaskexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } }","classification":"NONSATD","isFinished":true,"code_context_2":"|| a instanceof owlequivalentclassesaxiom || a instanceof owldisjointclassesaxiom); } \/\/ we want to remove the ontology from the manager manager.removeontology(testontology); } catch (owlontologycreationexception e) {","code_context_10":"log.error(\"missing expected axiom: {}\", expected); missing.add(expected); } } asserttrue(missing.isempty()); \/\/ we want only class related axioms in the result set for (owlaxiom a : inferred) { asserttrue(a instanceof owlclassassertionaxiom || a instanceof owlsubclassofaxiom || a instanceof owlequivalentclassesaxiom || a instanceof owldisjointclassesaxiom); } \/\/ we want to remove the ontology from the manager manager.removeontology(testontology); } catch (owlontologycreationexception e) { log.error(\"an {} have been thrown while creating the input ontology for test\", e.getclass()); asserttrue(false); } catch (reasoningserviceexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (inconsistentinputexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false);","code_context_20":"manager.getontology(testontologyid)); \/\/ maybe we want to see the inferred axiom list if (log.isdebugenabled()) { testutils.debug(inferred, log); } set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid)) .getlogicalaxioms(); set<owlaxiom> missing = new hashset<owlaxiom>(); for (owlaxiom expected : expectedaxioms) { if (!inferred.contains(expected)) { log.error(\"missing expected axiom: {}\", expected); missing.add(expected); } } asserttrue(missing.isempty()); \/\/ we want only class related axioms in the result set for (owlaxiom a : inferred) { asserttrue(a instanceof owlclassassertionaxiom || a instanceof owlsubclassofaxiom || a instanceof owlequivalentclassesaxiom || a instanceof owldisjointclassesaxiom); } \/\/ we want to remove the ontology from the manager manager.removeontology(testontology); } catch (owlontologycreationexception e) { log.error(\"an {} have been thrown while creating the input ontology for test\", e.getclass()); asserttrue(false); } catch (reasoningserviceexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (inconsistentinputexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (unsupportedtaskexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } }","repo":"nikosnikolaidis\/stanbol"}
{"id":8668,"comment_id":0,"comment":"\/\/ todo: get the remark line in there too.","code":"@test public void testaclextraction() { ciscoxrconfiguration c = parsevendorconfig(\"acl\"); assertthat(c.getipv4acls(), haskeys(\"acl\")); ipv4accesslist acl = c.getipv4acls().get(\"acl\"); \/\/ todo: get the remark line in there too. assertthat(acl.getlines(), hassize(7)); assertthat(c.getipv6acls(), haskeys(\"aclv6\")); ipv6accesslist aclv6 = c.getipv6acls().get(\"aclv6\"); \/\/ todo: get the remark line in there too. assertthat(aclv6.getlines(), hassize(4)); }","classification":"DESIGN","isFinished":true,"code_context_2":"assertthat(c.getipv4acls(), haskeys(\"acl\")); ipv4accesslist acl = c.getipv4acls().get(\"acl\"); \/\/ todo: get the remark line in there too. assertthat(acl.getlines(), hassize(7)); assertthat(c.getipv6acls(), haskeys(\"aclv6\"));","code_context_10":"@test public void testaclextraction() { ciscoxrconfiguration c = parsevendorconfig(\"acl\"); assertthat(c.getipv4acls(), haskeys(\"acl\")); ipv4accesslist acl = c.getipv4acls().get(\"acl\"); \/\/ todo: get the remark line in there too. assertthat(acl.getlines(), hassize(7)); assertthat(c.getipv6acls(), haskeys(\"aclv6\")); ipv6accesslist aclv6 = c.getipv6acls().get(\"aclv6\"); \/\/ todo: get the remark line in there too. assertthat(aclv6.getlines(), hassize(4)); }","code_context_20":"@test public void testaclextraction() { ciscoxrconfiguration c = parsevendorconfig(\"acl\"); assertthat(c.getipv4acls(), haskeys(\"acl\")); ipv4accesslist acl = c.getipv4acls().get(\"acl\"); \/\/ todo: get the remark line in there too. assertthat(acl.getlines(), hassize(7)); assertthat(c.getipv6acls(), haskeys(\"aclv6\")); ipv6accesslist aclv6 = c.getipv6acls().get(\"aclv6\"); \/\/ todo: get the remark line in there too. assertthat(aclv6.getlines(), hassize(4)); }","repo":"pranavbj-amzn\/batfish"}
{"id":8668,"comment_id":1,"comment":"\/\/ todo: get the remark line in there too.","code":"@test public void testaclextraction() { ciscoxrconfiguration c = parsevendorconfig(\"acl\"); assertthat(c.getipv4acls(), haskeys(\"acl\")); ipv4accesslist acl = c.getipv4acls().get(\"acl\"); \/\/ todo: get the remark line in there too. assertthat(acl.getlines(), hassize(7)); assertthat(c.getipv6acls(), haskeys(\"aclv6\")); ipv6accesslist aclv6 = c.getipv6acls().get(\"aclv6\"); \/\/ todo: get the remark line in there too. assertthat(aclv6.getlines(), hassize(4)); }","classification":"DESIGN","isFinished":true,"code_context_2":"assertthat(c.getipv4acls(), haskeys(\"acl\")); ipv4accesslist acl = c.getipv4acls().get(\"acl\"); \/\/ todo: get the remark line in there too. assertthat(acl.getlines(), hassize(7)); assertthat(c.getipv6acls(), haskeys(\"aclv6\"));","code_context_10":"@test public void testaclextraction() { ciscoxrconfiguration c = parsevendorconfig(\"acl\"); assertthat(c.getipv4acls(), haskeys(\"acl\")); ipv4accesslist acl = c.getipv4acls().get(\"acl\"); \/\/ todo: get the remark line in there too. assertthat(acl.getlines(), hassize(7)); assertthat(c.getipv6acls(), haskeys(\"aclv6\")); ipv6accesslist aclv6 = c.getipv6acls().get(\"aclv6\"); \/\/ todo: get the remark line in there too. assertthat(aclv6.getlines(), hassize(4)); }","code_context_20":"@test public void testaclextraction() { ciscoxrconfiguration c = parsevendorconfig(\"acl\"); assertthat(c.getipv4acls(), haskeys(\"acl\")); ipv4accesslist acl = c.getipv4acls().get(\"acl\"); \/\/ todo: get the remark line in there too. assertthat(acl.getlines(), hassize(7)); assertthat(c.getipv6acls(), haskeys(\"aclv6\")); ipv6accesslist aclv6 = c.getipv6acls().get(\"aclv6\"); \/\/ todo: get the remark line in there too. assertthat(aclv6.getlines(), hassize(4)); }","repo":"pranavbj-amzn\/batfish"}
{"id":8669,"comment_id":0,"comment":"\/\/ todo: get the remark line in there too.","code":"@test public void testaclconversion() { configuration c = parseconfig(\"acl\"); assertthat(c.getipaccesslists(), haskeys(\"acl\")); ipaccesslist acl = c.getipaccesslists().get(\"acl\"); \/\/ todo: get the remark line in there too. assertthat(acl.getlines(), hassize(7)); assertthat(c.getip6accesslists(), haskeys(\"aclv6\")); ip6accesslist aclv6 = c.getip6accesslists().get(\"aclv6\"); \/\/ todo: get the remark line in there too. assertthat(aclv6.getlines(), hassize(4)); }","classification":"DESIGN","isFinished":true,"code_context_2":"assertthat(c.getipaccesslists(), haskeys(\"acl\")); ipaccesslist acl = c.getipaccesslists().get(\"acl\"); \/\/ todo: get the remark line in there too. assertthat(acl.getlines(), hassize(7)); assertthat(c.getip6accesslists(), haskeys(\"aclv6\"));","code_context_10":"@test public void testaclconversion() { configuration c = parseconfig(\"acl\"); assertthat(c.getipaccesslists(), haskeys(\"acl\")); ipaccesslist acl = c.getipaccesslists().get(\"acl\"); \/\/ todo: get the remark line in there too. assertthat(acl.getlines(), hassize(7)); assertthat(c.getip6accesslists(), haskeys(\"aclv6\")); ip6accesslist aclv6 = c.getip6accesslists().get(\"aclv6\"); \/\/ todo: get the remark line in there too. assertthat(aclv6.getlines(), hassize(4)); }","code_context_20":"@test public void testaclconversion() { configuration c = parseconfig(\"acl\"); assertthat(c.getipaccesslists(), haskeys(\"acl\")); ipaccesslist acl = c.getipaccesslists().get(\"acl\"); \/\/ todo: get the remark line in there too. assertthat(acl.getlines(), hassize(7)); assertthat(c.getip6accesslists(), haskeys(\"aclv6\")); ip6accesslist aclv6 = c.getip6accesslists().get(\"aclv6\"); \/\/ todo: get the remark line in there too. assertthat(aclv6.getlines(), hassize(4)); }","repo":"pranavbj-amzn\/batfish"}
{"id":8669,"comment_id":1,"comment":"\/\/ todo: get the remark line in there too.","code":"@test public void testaclconversion() { configuration c = parseconfig(\"acl\"); assertthat(c.getipaccesslists(), haskeys(\"acl\")); ipaccesslist acl = c.getipaccesslists().get(\"acl\"); \/\/ todo: get the remark line in there too. assertthat(acl.getlines(), hassize(7)); assertthat(c.getip6accesslists(), haskeys(\"aclv6\")); ip6accesslist aclv6 = c.getip6accesslists().get(\"aclv6\"); \/\/ todo: get the remark line in there too. assertthat(aclv6.getlines(), hassize(4)); }","classification":"DESIGN","isFinished":true,"code_context_2":"assertthat(c.getipaccesslists(), haskeys(\"acl\")); ipaccesslist acl = c.getipaccesslists().get(\"acl\"); \/\/ todo: get the remark line in there too. assertthat(acl.getlines(), hassize(7)); assertthat(c.getip6accesslists(), haskeys(\"aclv6\"));","code_context_10":"@test public void testaclconversion() { configuration c = parseconfig(\"acl\"); assertthat(c.getipaccesslists(), haskeys(\"acl\")); ipaccesslist acl = c.getipaccesslists().get(\"acl\"); \/\/ todo: get the remark line in there too. assertthat(acl.getlines(), hassize(7)); assertthat(c.getip6accesslists(), haskeys(\"aclv6\")); ip6accesslist aclv6 = c.getip6accesslists().get(\"aclv6\"); \/\/ todo: get the remark line in there too. assertthat(aclv6.getlines(), hassize(4)); }","code_context_20":"@test public void testaclconversion() { configuration c = parseconfig(\"acl\"); assertthat(c.getipaccesslists(), haskeys(\"acl\")); ipaccesslist acl = c.getipaccesslists().get(\"acl\"); \/\/ todo: get the remark line in there too. assertthat(acl.getlines(), hassize(7)); assertthat(c.getip6accesslists(), haskeys(\"aclv6\")); ip6accesslist aclv6 = c.getip6accesslists().get(\"aclv6\"); \/\/ todo: get the remark line in there too. assertthat(aclv6.getlines(), hassize(4)); }","repo":"pranavbj-amzn\/batfish"}
{"id":33288,"comment_id":0,"comment":"\/\/ if there is no pre-existing task, create a new one","code":"@override public boolean ontouch(view v, motionevent event) { switch(event.getaction()){ case motionevent.action_cancel: _downtime.set(0); break; case motionevent.action_down: _downtime.set(system.currenttimemillis()); _downx = event.getx(); _downy = event.gety(); if(_longclicktimer == null){ \/\/ if there is no pre-existing task, create a new one _longclicktimer = new asynctask<void, void, boolean>(){ @override protected boolean doinbackground(void... params) { try{ for(long i=0;i<definitions.threshold_long_click_max_duration;i+=interval_long_click_check){ thread.sleep(interval_long_click_check); long downtime = _downtime.get(); if(downtime > 0 && system.currenttimemillis()-downtime > definitions.threshold_long_click_min_duration){ return true; } } }catch(interruptedexception ex){ logutils.warn(class_name, \"doinbackground\", ex.tostring()); } return false; } @override protected void onpostexecute(boolean result) { if(result){ centerchart(); _downtime.set(0); } _longclicktimer = null; } }; \/\/ new asynctask _longclicktimer.execute(); } break; case motionevent.action_move: checkformovement(event); break; case motionevent.action_up: long downtime = _downtime.getandset(0); if(downtime != 0 && (system.currenttimemillis()-downtime) < definitions.threshold_click_max_duration && !checkformovement(event)){ seriesselection selection = _viewchart.getcurrentseriesandpoint(); if(selection == null || selection.getseriesindex() != 0){ \/\/ if there was no selection or this is not the first series (point values) logutils.debug(class_name, \"ontouch\", \"no usable selection.\"); }else{ list<gaugevalue> values = _currentgauge.getvalues(); int valuecount = values.size(); int index = 0; \/\/todo: this will break if the chart shows something else than the last getmaxgraphpoints() of values if(valuecount - _settings.getmaxgraphpoints() > 0){ index = valuecount - _settings.getmaxgraphpoints() + selection.getpointindex(); }else{ index = selection.getpointindex(); } _currentvalue = _currentgauge.getvalues().get(index); (new gaugevaluedialog()).show(graphactivity.this.getsupportfragmentmanager(), gaugevaluedialog.tag); } } break; default: break; \/\/ ignore everything else } return false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls }","classification":"NONSATD","isFinished":true,"code_context_2":"_downx = event.getx(); _downy = event.gety(); if(_longclicktimer == null){ \/\/ if there is no pre-existing task, create a new one _longclicktimer = new asynctask<void, void, boolean>(){ @override","code_context_10":"@override public boolean ontouch(view v, motionevent event) { switch(event.getaction()){ case motionevent.action_cancel: _downtime.set(0); break; case motionevent.action_down: _downtime.set(system.currenttimemillis()); _downx = event.getx(); _downy = event.gety(); if(_longclicktimer == null){ \/\/ if there is no pre-existing task, create a new one _longclicktimer = new asynctask<void, void, boolean>(){ @override protected boolean doinbackground(void... params) { try{ for(long i=0;i<definitions.threshold_long_click_max_duration;i+=interval_long_click_check){ thread.sleep(interval_long_click_check); long downtime = _downtime.get(); if(downtime > 0 && system.currenttimemillis()-downtime > definitions.threshold_long_click_min_duration){ return true; }","code_context_20":"@override public boolean ontouch(view v, motionevent event) { switch(event.getaction()){ case motionevent.action_cancel: _downtime.set(0); break; case motionevent.action_down: _downtime.set(system.currenttimemillis()); _downx = event.getx(); _downy = event.gety(); if(_longclicktimer == null){ \/\/ if there is no pre-existing task, create a new one _longclicktimer = new asynctask<void, void, boolean>(){ @override protected boolean doinbackground(void... params) { try{ for(long i=0;i<definitions.threshold_long_click_max_duration;i+=interval_long_click_check){ thread.sleep(interval_long_click_check); long downtime = _downtime.get(); if(downtime > 0 && system.currenttimemillis()-downtime > definitions.threshold_long_click_min_duration){ return true; } } }catch(interruptedexception ex){ logutils.warn(class_name, \"doinbackground\", ex.tostring()); } return false; } @override protected void onpostexecute(boolean result) { if(result){ centerchart();","repo":"otula\/kiiaudata"}
{"id":33288,"comment_id":1,"comment":"\/\/ new asynctask","code":"@override public boolean ontouch(view v, motionevent event) { switch(event.getaction()){ case motionevent.action_cancel: _downtime.set(0); break; case motionevent.action_down: _downtime.set(system.currenttimemillis()); _downx = event.getx(); _downy = event.gety(); if(_longclicktimer == null){ \/\/ if there is no pre-existing task, create a new one _longclicktimer = new asynctask<void, void, boolean>(){ @override protected boolean doinbackground(void... params) { try{ for(long i=0;i<definitions.threshold_long_click_max_duration;i+=interval_long_click_check){ thread.sleep(interval_long_click_check); long downtime = _downtime.get(); if(downtime > 0 && system.currenttimemillis()-downtime > definitions.threshold_long_click_min_duration){ return true; } } }catch(interruptedexception ex){ logutils.warn(class_name, \"doinbackground\", ex.tostring()); } return false; } @override protected void onpostexecute(boolean result) { if(result){ centerchart(); _downtime.set(0); } _longclicktimer = null; } }; \/\/ new asynctask _longclicktimer.execute(); } break; case motionevent.action_move: checkformovement(event); break; case motionevent.action_up: long downtime = _downtime.getandset(0); if(downtime != 0 && (system.currenttimemillis()-downtime) < definitions.threshold_click_max_duration && !checkformovement(event)){ seriesselection selection = _viewchart.getcurrentseriesandpoint(); if(selection == null || selection.getseriesindex() != 0){ \/\/ if there was no selection or this is not the first series (point values) logutils.debug(class_name, \"ontouch\", \"no usable selection.\"); }else{ list<gaugevalue> values = _currentgauge.getvalues(); int valuecount = values.size(); int index = 0; \/\/todo: this will break if the chart shows something else than the last getmaxgraphpoints() of values if(valuecount - _settings.getmaxgraphpoints() > 0){ index = valuecount - _settings.getmaxgraphpoints() + selection.getpointindex(); }else{ index = selection.getpointindex(); } _currentvalue = _currentgauge.getvalues().get(index); (new gaugevaluedialog()).show(graphactivity.this.getsupportfragmentmanager(), gaugevaluedialog.tag); } } break; default: break; \/\/ ignore everything else } return false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls }","classification":"NONSATD","isFinished":true,"code_context_2":"_longclicktimer = null; } }; \/\/ new asynctask _longclicktimer.execute(); }","code_context_10":"return false; } @override protected void onpostexecute(boolean result) { if(result){ centerchart(); _downtime.set(0); } _longclicktimer = null; } }; \/\/ new asynctask _longclicktimer.execute(); } break; case motionevent.action_move: checkformovement(event); break; case motionevent.action_up: long downtime = _downtime.getandset(0); if(downtime != 0 && (system.currenttimemillis()-downtime) < definitions.threshold_click_max_duration && !checkformovement(event)){ seriesselection selection = _viewchart.getcurrentseriesandpoint();","code_context_20":"for(long i=0;i<definitions.threshold_long_click_max_duration;i+=interval_long_click_check){ thread.sleep(interval_long_click_check); long downtime = _downtime.get(); if(downtime > 0 && system.currenttimemillis()-downtime > definitions.threshold_long_click_min_duration){ return true; } } }catch(interruptedexception ex){ logutils.warn(class_name, \"doinbackground\", ex.tostring()); } return false; } @override protected void onpostexecute(boolean result) { if(result){ centerchart(); _downtime.set(0); } _longclicktimer = null; } }; \/\/ new asynctask _longclicktimer.execute(); } break; case motionevent.action_move: checkformovement(event); break; case motionevent.action_up: long downtime = _downtime.getandset(0); if(downtime != 0 && (system.currenttimemillis()-downtime) < definitions.threshold_click_max_duration && !checkformovement(event)){ seriesselection selection = _viewchart.getcurrentseriesandpoint(); if(selection == null || selection.getseriesindex() != 0){ \/\/ if there was no selection or this is not the first series (point values) logutils.debug(class_name, \"ontouch\", \"no usable selection.\"); }else{ list<gaugevalue> values = _currentgauge.getvalues(); int valuecount = values.size(); int index = 0; \/\/todo: this will break if the chart shows something else than the last getmaxgraphpoints() of values if(valuecount - _settings.getmaxgraphpoints() > 0){ index = valuecount - _settings.getmaxgraphpoints() + selection.getpointindex(); }else{","repo":"otula\/kiiaudata"}
{"id":33288,"comment_id":2,"comment":"\/\/ if there was no selection or this is not the first series (point values)","code":"@override public boolean ontouch(view v, motionevent event) { switch(event.getaction()){ case motionevent.action_cancel: _downtime.set(0); break; case motionevent.action_down: _downtime.set(system.currenttimemillis()); _downx = event.getx(); _downy = event.gety(); if(_longclicktimer == null){ \/\/ if there is no pre-existing task, create a new one _longclicktimer = new asynctask<void, void, boolean>(){ @override protected boolean doinbackground(void... params) { try{ for(long i=0;i<definitions.threshold_long_click_max_duration;i+=interval_long_click_check){ thread.sleep(interval_long_click_check); long downtime = _downtime.get(); if(downtime > 0 && system.currenttimemillis()-downtime > definitions.threshold_long_click_min_duration){ return true; } } }catch(interruptedexception ex){ logutils.warn(class_name, \"doinbackground\", ex.tostring()); } return false; } @override protected void onpostexecute(boolean result) { if(result){ centerchart(); _downtime.set(0); } _longclicktimer = null; } }; \/\/ new asynctask _longclicktimer.execute(); } break; case motionevent.action_move: checkformovement(event); break; case motionevent.action_up: long downtime = _downtime.getandset(0); if(downtime != 0 && (system.currenttimemillis()-downtime) < definitions.threshold_click_max_duration && !checkformovement(event)){ seriesselection selection = _viewchart.getcurrentseriesandpoint(); if(selection == null || selection.getseriesindex() != 0){ \/\/ if there was no selection or this is not the first series (point values) logutils.debug(class_name, \"ontouch\", \"no usable selection.\"); }else{ list<gaugevalue> values = _currentgauge.getvalues(); int valuecount = values.size(); int index = 0; \/\/todo: this will break if the chart shows something else than the last getmaxgraphpoints() of values if(valuecount - _settings.getmaxgraphpoints() > 0){ index = valuecount - _settings.getmaxgraphpoints() + selection.getpointindex(); }else{ index = selection.getpointindex(); } _currentvalue = _currentgauge.getvalues().get(index); (new gaugevaluedialog()).show(graphactivity.this.getsupportfragmentmanager(), gaugevaluedialog.tag); } } break; default: break; \/\/ ignore everything else } return false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls }","classification":"NONSATD","isFinished":true,"code_context_2":"if(downtime != 0 && (system.currenttimemillis()-downtime) < definitions.threshold_click_max_duration && !checkformovement(event)){ seriesselection selection = _viewchart.getcurrentseriesandpoint(); if(selection == null || selection.getseriesindex() != 0){ \/\/ if there was no selection or this is not the first series (point values) logutils.debug(class_name, \"ontouch\", \"no usable selection.\"); }else{","code_context_10":"_longclicktimer.execute(); } break; case motionevent.action_move: checkformovement(event); break; case motionevent.action_up: long downtime = _downtime.getandset(0); if(downtime != 0 && (system.currenttimemillis()-downtime) < definitions.threshold_click_max_duration && !checkformovement(event)){ seriesselection selection = _viewchart.getcurrentseriesandpoint(); if(selection == null || selection.getseriesindex() != 0){ \/\/ if there was no selection or this is not the first series (point values) logutils.debug(class_name, \"ontouch\", \"no usable selection.\"); }else{ list<gaugevalue> values = _currentgauge.getvalues(); int valuecount = values.size(); int index = 0; \/\/todo: this will break if the chart shows something else than the last getmaxgraphpoints() of values if(valuecount - _settings.getmaxgraphpoints() > 0){ index = valuecount - _settings.getmaxgraphpoints() + selection.getpointindex(); }else{ index = selection.getpointindex();","code_context_20":"} @override protected void onpostexecute(boolean result) { if(result){ centerchart(); _downtime.set(0); } _longclicktimer = null; } }; \/\/ new asynctask _longclicktimer.execute(); } break; case motionevent.action_move: checkformovement(event); break; case motionevent.action_up: long downtime = _downtime.getandset(0); if(downtime != 0 && (system.currenttimemillis()-downtime) < definitions.threshold_click_max_duration && !checkformovement(event)){ seriesselection selection = _viewchart.getcurrentseriesandpoint(); if(selection == null || selection.getseriesindex() != 0){ \/\/ if there was no selection or this is not the first series (point values) logutils.debug(class_name, \"ontouch\", \"no usable selection.\"); }else{ list<gaugevalue> values = _currentgauge.getvalues(); int valuecount = values.size(); int index = 0; \/\/todo: this will break if the chart shows something else than the last getmaxgraphpoints() of values if(valuecount - _settings.getmaxgraphpoints() > 0){ index = valuecount - _settings.getmaxgraphpoints() + selection.getpointindex(); }else{ index = selection.getpointindex(); } _currentvalue = _currentgauge.getvalues().get(index); (new gaugevaluedialog()).show(graphactivity.this.getsupportfragmentmanager(), gaugevaluedialog.tag); } } break; default: break; \/\/ ignore everything else } return false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls","repo":"otula\/kiiaudata"}
{"id":33288,"comment_id":3,"comment":"\/\/todo: this will break if the chart shows something else than the last getmaxgraphpoints() of values","code":"@override public boolean ontouch(view v, motionevent event) { switch(event.getaction()){ case motionevent.action_cancel: _downtime.set(0); break; case motionevent.action_down: _downtime.set(system.currenttimemillis()); _downx = event.getx(); _downy = event.gety(); if(_longclicktimer == null){ \/\/ if there is no pre-existing task, create a new one _longclicktimer = new asynctask<void, void, boolean>(){ @override protected boolean doinbackground(void... params) { try{ for(long i=0;i<definitions.threshold_long_click_max_duration;i+=interval_long_click_check){ thread.sleep(interval_long_click_check); long downtime = _downtime.get(); if(downtime > 0 && system.currenttimemillis()-downtime > definitions.threshold_long_click_min_duration){ return true; } } }catch(interruptedexception ex){ logutils.warn(class_name, \"doinbackground\", ex.tostring()); } return false; } @override protected void onpostexecute(boolean result) { if(result){ centerchart(); _downtime.set(0); } _longclicktimer = null; } }; \/\/ new asynctask _longclicktimer.execute(); } break; case motionevent.action_move: checkformovement(event); break; case motionevent.action_up: long downtime = _downtime.getandset(0); if(downtime != 0 && (system.currenttimemillis()-downtime) < definitions.threshold_click_max_duration && !checkformovement(event)){ seriesselection selection = _viewchart.getcurrentseriesandpoint(); if(selection == null || selection.getseriesindex() != 0){ \/\/ if there was no selection or this is not the first series (point values) logutils.debug(class_name, \"ontouch\", \"no usable selection.\"); }else{ list<gaugevalue> values = _currentgauge.getvalues(); int valuecount = values.size(); int index = 0; \/\/todo: this will break if the chart shows something else than the last getmaxgraphpoints() of values if(valuecount - _settings.getmaxgraphpoints() > 0){ index = valuecount - _settings.getmaxgraphpoints() + selection.getpointindex(); }else{ index = selection.getpointindex(); } _currentvalue = _currentgauge.getvalues().get(index); (new gaugevaluedialog()).show(graphactivity.this.getsupportfragmentmanager(), gaugevaluedialog.tag); } } break; default: break; \/\/ ignore everything else } return false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls }","classification":"DEFECT","isFinished":true,"code_context_2":"int valuecount = values.size(); int index = 0; \/\/todo: this will break if the chart shows something else than the last getmaxgraphpoints() of values if(valuecount - _settings.getmaxgraphpoints() > 0){ index = valuecount - _settings.getmaxgraphpoints() + selection.getpointindex();","code_context_10":"case motionevent.action_up: long downtime = _downtime.getandset(0); if(downtime != 0 && (system.currenttimemillis()-downtime) < definitions.threshold_click_max_duration && !checkformovement(event)){ seriesselection selection = _viewchart.getcurrentseriesandpoint(); if(selection == null || selection.getseriesindex() != 0){ \/\/ if there was no selection or this is not the first series (point values) logutils.debug(class_name, \"ontouch\", \"no usable selection.\"); }else{ list<gaugevalue> values = _currentgauge.getvalues(); int valuecount = values.size(); int index = 0; \/\/todo: this will break if the chart shows something else than the last getmaxgraphpoints() of values if(valuecount - _settings.getmaxgraphpoints() > 0){ index = valuecount - _settings.getmaxgraphpoints() + selection.getpointindex(); }else{ index = selection.getpointindex(); } _currentvalue = _currentgauge.getvalues().get(index); (new gaugevaluedialog()).show(graphactivity.this.getsupportfragmentmanager(), gaugevaluedialog.tag); } } break;","code_context_20":"} _longclicktimer = null; } }; \/\/ new asynctask _longclicktimer.execute(); } break; case motionevent.action_move: checkformovement(event); break; case motionevent.action_up: long downtime = _downtime.getandset(0); if(downtime != 0 && (system.currenttimemillis()-downtime) < definitions.threshold_click_max_duration && !checkformovement(event)){ seriesselection selection = _viewchart.getcurrentseriesandpoint(); if(selection == null || selection.getseriesindex() != 0){ \/\/ if there was no selection or this is not the first series (point values) logutils.debug(class_name, \"ontouch\", \"no usable selection.\"); }else{ list<gaugevalue> values = _currentgauge.getvalues(); int valuecount = values.size(); int index = 0; \/\/todo: this will break if the chart shows something else than the last getmaxgraphpoints() of values if(valuecount - _settings.getmaxgraphpoints() > 0){ index = valuecount - _settings.getmaxgraphpoints() + selection.getpointindex(); }else{ index = selection.getpointindex(); } _currentvalue = _currentgauge.getvalues().get(index); (new gaugevaluedialog()).show(graphactivity.this.getsupportfragmentmanager(), gaugevaluedialog.tag); } } break; default: break; \/\/ ignore everything else } return false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls }","repo":"otula\/kiiaudata"}
{"id":33288,"comment_id":4,"comment":"\/\/ ignore everything else","code":"@override public boolean ontouch(view v, motionevent event) { switch(event.getaction()){ case motionevent.action_cancel: _downtime.set(0); break; case motionevent.action_down: _downtime.set(system.currenttimemillis()); _downx = event.getx(); _downy = event.gety(); if(_longclicktimer == null){ \/\/ if there is no pre-existing task, create a new one _longclicktimer = new asynctask<void, void, boolean>(){ @override protected boolean doinbackground(void... params) { try{ for(long i=0;i<definitions.threshold_long_click_max_duration;i+=interval_long_click_check){ thread.sleep(interval_long_click_check); long downtime = _downtime.get(); if(downtime > 0 && system.currenttimemillis()-downtime > definitions.threshold_long_click_min_duration){ return true; } } }catch(interruptedexception ex){ logutils.warn(class_name, \"doinbackground\", ex.tostring()); } return false; } @override protected void onpostexecute(boolean result) { if(result){ centerchart(); _downtime.set(0); } _longclicktimer = null; } }; \/\/ new asynctask _longclicktimer.execute(); } break; case motionevent.action_move: checkformovement(event); break; case motionevent.action_up: long downtime = _downtime.getandset(0); if(downtime != 0 && (system.currenttimemillis()-downtime) < definitions.threshold_click_max_duration && !checkformovement(event)){ seriesselection selection = _viewchart.getcurrentseriesandpoint(); if(selection == null || selection.getseriesindex() != 0){ \/\/ if there was no selection or this is not the first series (point values) logutils.debug(class_name, \"ontouch\", \"no usable selection.\"); }else{ list<gaugevalue> values = _currentgauge.getvalues(); int valuecount = values.size(); int index = 0; \/\/todo: this will break if the chart shows something else than the last getmaxgraphpoints() of values if(valuecount - _settings.getmaxgraphpoints() > 0){ index = valuecount - _settings.getmaxgraphpoints() + selection.getpointindex(); }else{ index = selection.getpointindex(); } _currentvalue = _currentgauge.getvalues().get(index); (new gaugevaluedialog()).show(graphactivity.this.getsupportfragmentmanager(), gaugevaluedialog.tag); } } break; default: break; \/\/ ignore everything else } return false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls }","classification":"NONSATD","isFinished":true,"code_context_2":"break; default: break; \/\/ ignore everything else } return false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls","code_context_10":"index = valuecount - _settings.getmaxgraphpoints() + selection.getpointindex(); }else{ index = selection.getpointindex(); } _currentvalue = _currentgauge.getvalues().get(index); (new gaugevaluedialog()).show(graphactivity.this.getsupportfragmentmanager(), gaugevaluedialog.tag); } } break; default: break; \/\/ ignore everything else } return false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls }","code_context_20":"if(downtime != 0 && (system.currenttimemillis()-downtime) < definitions.threshold_click_max_duration && !checkformovement(event)){ seriesselection selection = _viewchart.getcurrentseriesandpoint(); if(selection == null || selection.getseriesindex() != 0){ \/\/ if there was no selection or this is not the first series (point values) logutils.debug(class_name, \"ontouch\", \"no usable selection.\"); }else{ list<gaugevalue> values = _currentgauge.getvalues(); int valuecount = values.size(); int index = 0; \/\/todo: this will break if the chart shows something else than the last getmaxgraphpoints() of values if(valuecount - _settings.getmaxgraphpoints() > 0){ index = valuecount - _settings.getmaxgraphpoints() + selection.getpointindex(); }else{ index = selection.getpointindex(); } _currentvalue = _currentgauge.getvalues().get(index); (new gaugevaluedialog()).show(graphactivity.this.getsupportfragmentmanager(), gaugevaluedialog.tag); } } break; default: break; \/\/ ignore everything else } return false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls }","repo":"otula\/kiiaudata"}
{"id":33288,"comment_id":5,"comment":"\/\/ always return false so that we do not interfere with the graph pan\/zoom controls","code":"@override public boolean ontouch(view v, motionevent event) { switch(event.getaction()){ case motionevent.action_cancel: _downtime.set(0); break; case motionevent.action_down: _downtime.set(system.currenttimemillis()); _downx = event.getx(); _downy = event.gety(); if(_longclicktimer == null){ \/\/ if there is no pre-existing task, create a new one _longclicktimer = new asynctask<void, void, boolean>(){ @override protected boolean doinbackground(void... params) { try{ for(long i=0;i<definitions.threshold_long_click_max_duration;i+=interval_long_click_check){ thread.sleep(interval_long_click_check); long downtime = _downtime.get(); if(downtime > 0 && system.currenttimemillis()-downtime > definitions.threshold_long_click_min_duration){ return true; } } }catch(interruptedexception ex){ logutils.warn(class_name, \"doinbackground\", ex.tostring()); } return false; } @override protected void onpostexecute(boolean result) { if(result){ centerchart(); _downtime.set(0); } _longclicktimer = null; } }; \/\/ new asynctask _longclicktimer.execute(); } break; case motionevent.action_move: checkformovement(event); break; case motionevent.action_up: long downtime = _downtime.getandset(0); if(downtime != 0 && (system.currenttimemillis()-downtime) < definitions.threshold_click_max_duration && !checkformovement(event)){ seriesselection selection = _viewchart.getcurrentseriesandpoint(); if(selection == null || selection.getseriesindex() != 0){ \/\/ if there was no selection or this is not the first series (point values) logutils.debug(class_name, \"ontouch\", \"no usable selection.\"); }else{ list<gaugevalue> values = _currentgauge.getvalues(); int valuecount = values.size(); int index = 0; \/\/todo: this will break if the chart shows something else than the last getmaxgraphpoints() of values if(valuecount - _settings.getmaxgraphpoints() > 0){ index = valuecount - _settings.getmaxgraphpoints() + selection.getpointindex(); }else{ index = selection.getpointindex(); } _currentvalue = _currentgauge.getvalues().get(index); (new gaugevaluedialog()).show(graphactivity.this.getsupportfragmentmanager(), gaugevaluedialog.tag); } } break; default: break; \/\/ ignore everything else } return false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls }","classification":"NONSATD","isFinished":true,"code_context_2":"break; \/\/ ignore everything else } return false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls }","code_context_10":"index = selection.getpointindex(); } _currentvalue = _currentgauge.getvalues().get(index); (new gaugevaluedialog()).show(graphactivity.this.getsupportfragmentmanager(), gaugevaluedialog.tag); } } break; default: break; \/\/ ignore everything else } return false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls }","code_context_20":"if(selection == null || selection.getseriesindex() != 0){ \/\/ if there was no selection or this is not the first series (point values) logutils.debug(class_name, \"ontouch\", \"no usable selection.\"); }else{ list<gaugevalue> values = _currentgauge.getvalues(); int valuecount = values.size(); int index = 0; \/\/todo: this will break if the chart shows something else than the last getmaxgraphpoints() of values if(valuecount - _settings.getmaxgraphpoints() > 0){ index = valuecount - _settings.getmaxgraphpoints() + selection.getpointindex(); }else{ index = selection.getpointindex(); } _currentvalue = _currentgauge.getvalues().get(index); (new gaugevaluedialog()).show(graphactivity.this.getsupportfragmentmanager(), gaugevaluedialog.tag); } } break; default: break; \/\/ ignore everything else } return false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls }","repo":"otula\/kiiaudata"}
{"id":675,"comment_id":0,"comment":"\/\/todo figure out how to act with this stuff","code":"@override public int describecontents() { return 0;\/\/todo figure out how to act with this stuff }","classification":"DESIGN","isFinished":true,"code_context_2":"@override public int describecontents() { return 0;\/\/todo figure out how to act with this stuff }","code_context_10":"@override public int describecontents() { return 0;\/\/todo figure out how to act with this stuff }","code_context_20":"@override public int describecontents() { return 0;\/\/todo figure out how to act with this stuff }","repo":"programmerr47\/breverkruntkin-test-task"}
{"id":8907,"comment_id":0,"comment":"\/\/ todo: document me","code":"public void setws(boolean b) { \/\/ todo: document me this.tr.setskipws(b); }","classification":"DOCUMENTATION","isFinished":true,"code_context_2":"public void setws(boolean b) { \/\/ todo: document me this.tr.setskipws(b); }","code_context_10":"public void setws(boolean b) { \/\/ todo: document me this.tr.setskipws(b); }","code_context_20":"public void setws(boolean b) { \/\/ todo: document me this.tr.setskipws(b); }","repo":"rebse\/flaka"}
{"id":8908,"comment_id":0,"comment":"\/\/ todo: document me","code":"public void setcl(boolean b) { \/\/ todo: document me this.tr.setresolvecontlines(b); }","classification":"DOCUMENTATION","isFinished":true,"code_context_2":"public void setcl(boolean b) { \/\/ todo: document me this.tr.setresolvecontlines(b); }","code_context_10":"public void setcl(boolean b) { \/\/ todo: document me this.tr.setresolvecontlines(b); }","code_context_20":"public void setcl(boolean b) { \/\/ todo: document me this.tr.setresolvecontlines(b); }","repo":"rebse\/flaka"}
{"id":781,"comment_id":0,"comment":"\/\/ todo: smarter initialization of the map","code":"private map<string, t> getchoicemap() { if (choicemap == null || alwaysreload()) { collection<t> choices = loadchoices(); choicemap = new hashmap<>(); for (t choice: choices) { \/\/ todo: smarter initialization of the map choicemap.put(choice.getlocalpart(), choice); } } return choicemap; }","classification":"DESIGN","isFinished":true,"code_context_2":"choicemap = new hashmap<>(); for (t choice: choices) { \/\/ todo: smarter initialization of the map choicemap.put(choice.getlocalpart(), choice); }","code_context_10":"private map<string, t> getchoicemap() { if (choicemap == null || alwaysreload()) { collection<t> choices = loadchoices(); choicemap = new hashmap<>(); for (t choice: choices) { \/\/ todo: smarter initialization of the map choicemap.put(choice.getlocalpart(), choice); } } return choicemap; }","code_context_20":"private map<string, t> getchoicemap() { if (choicemap == null || alwaysreload()) { collection<t> choices = loadchoices(); choicemap = new hashmap<>(); for (t choice: choices) { \/\/ todo: smarter initialization of the map choicemap.put(choice.getlocalpart(), choice); } } return choicemap; }","repo":"mythoss\/midpoint"}
{"id":9010,"comment_id":0,"comment":"\/** * main method to invoke this demo on how to send a message to an azure event hub. * * @param args unused arguments to the program. *\/","code":"\/** * main method to invoke this demo on how to send a message to an azure event hub. * * @param args unused arguments to the program. *\/ public static void main(string[] args) { \/\/ the connection string value can be obtained by: \/\/ 1. going to your event hubs namespace in azure portal. \/\/ 2. creating an event hub instance. \/\/ 3. creating a \"shared access policy\" for your event hub instance. \/\/ 4. copying the connection string from the policy's properties. string connectionstring = \"endpoint={endpoint};sharedaccesskeyname={sharedaccesskeyname};sharedaccesskey={sharedaccesskey};entitypath={eventhubname}\"; eventhubproducerasyncclient producer = new eventhubclientbuilder() .connectionstring(connectionstring) .buildasyncproducer(); \/\/ create an event to send. eventdata data = new eventdata(\"hello world!\".getbytes(utf_8)); \/\/ send that event. this call returns a mono<void>, which we subscribe to. it completes successfully when the \/\/ event has been delivered to the event hub. it completes with an error if an exception occurred while sending \/\/ the event. \/\/ sendoptions are not specified, so events sent are load balanced between all available partitions in the \/\/ event hub instance. producer.send(data).subscribe( (ignored) -> system.out.println(\"event sent.\"), error -> { system.err.println(\"there was an error sending the event: \" + error.tostring()); if (error instanceof amqpexception) { amqpexception amqpexception = (amqpexception) error; system.err.println(string.format(\"is send operation retriable? %s. error condition: %s\", amqpexception.istransient(), amqpexception.geterrorcondition())); } }, () -> { \/\/ disposing of our producer and client. producer.close(); }); }","classification":"NONSATD","isFinished":true,"code_context_2":"public static void main(string[] args) { \/\/ the connection string value can be obtained by: \/\/ 1. going to your event hubs namespace in azure portal. \/\/ 2. creating an event hub instance. \/\/ 3. creating a \"shared access policy\" for your event hub instance. \/\/ 4. copying the connection string from the policy's properties. string connectionstring = \"endpoint={endpoint};sharedaccesskeyname={sharedaccesskeyname};sharedaccesskey={sharedaccesskey};entitypath={eventhubname}\"; eventhubproducerasyncclient producer = new eventhubclientbuilder() .connectionstring(connectionstring) .buildasyncproducer(); \/\/ create an event to send. eventdata data = new eventdata(\"hello world!\".getbytes(utf_8)); \/\/ send that event. this call returns a mono<void>, which we subscribe to. it completes successfully when the \/\/ event has been delivered to the event hub. it completes with an error if an exception occurred while sending \/\/ the event. \/\/ sendoptions are not specified, so events sent are load balanced between all available partitions in the \/\/ event hub instance. producer.send(data).subscribe( (ignored) -> system.out.println(\"event sent.\"), error -> { system.err.println(\"there was an error sending the event: \" + error.tostring()); if (error instanceof amqpexception) { amqpexception amqpexception = (amqpexception) error; system.err.println(string.format(\"is send operation retriable? %s. error condition: %s\", amqpexception.istransient(), amqpexception.geterrorcondition())); } }, () -> { \/\/ disposing of our producer and client. producer.close(); }); }","code_context_10":"public static void main(string[] args) { \/\/ the connection string value can be obtained by: \/\/ 1. going to your event hubs namespace in azure portal. \/\/ 2. creating an event hub instance. \/\/ 3. creating a \"shared access policy\" for your event hub instance. \/\/ 4. copying the connection string from the policy's properties. string connectionstring = \"endpoint={endpoint};sharedaccesskeyname={sharedaccesskeyname};sharedaccesskey={sharedaccesskey};entitypath={eventhubname}\"; eventhubproducerasyncclient producer = new eventhubclientbuilder() .connectionstring(connectionstring) .buildasyncproducer(); \/\/ create an event to send. eventdata data = new eventdata(\"hello world!\".getbytes(utf_8)); \/\/ send that event. this call returns a mono<void>, which we subscribe to. it completes successfully when the \/\/ event has been delivered to the event hub. it completes with an error if an exception occurred while sending \/\/ the event. \/\/ sendoptions are not specified, so events sent are load balanced between all available partitions in the \/\/ event hub instance. producer.send(data).subscribe( (ignored) -> system.out.println(\"event sent.\"), error -> { system.err.println(\"there was an error sending the event: \" + error.tostring()); if (error instanceof amqpexception) { amqpexception amqpexception = (amqpexception) error; system.err.println(string.format(\"is send operation retriable? %s. error condition: %s\", amqpexception.istransient(), amqpexception.geterrorcondition())); } }, () -> { \/\/ disposing of our producer and client. producer.close(); }); }","code_context_20":"public static void main(string[] args) { \/\/ the connection string value can be obtained by: \/\/ 1. going to your event hubs namespace in azure portal. \/\/ 2. creating an event hub instance. \/\/ 3. creating a \"shared access policy\" for your event hub instance. \/\/ 4. copying the connection string from the policy's properties. string connectionstring = \"endpoint={endpoint};sharedaccesskeyname={sharedaccesskeyname};sharedaccesskey={sharedaccesskey};entitypath={eventhubname}\"; eventhubproducerasyncclient producer = new eventhubclientbuilder() .connectionstring(connectionstring) .buildasyncproducer(); \/\/ create an event to send. eventdata data = new eventdata(\"hello world!\".getbytes(utf_8)); \/\/ send that event. this call returns a mono<void>, which we subscribe to. it completes successfully when the \/\/ event has been delivered to the event hub. it completes with an error if an exception occurred while sending \/\/ the event. \/\/ sendoptions are not specified, so events sent are load balanced between all available partitions in the \/\/ event hub instance. producer.send(data).subscribe( (ignored) -> system.out.println(\"event sent.\"), error -> { system.err.println(\"there was an error sending the event: \" + error.tostring()); if (error instanceof amqpexception) { amqpexception amqpexception = (amqpexception) error; system.err.println(string.format(\"is send operation retriable? %s. error condition: %s\", amqpexception.istransient(), amqpexception.geterrorcondition())); } }, () -> { \/\/ disposing of our producer and client. producer.close(); }); }","repo":"ppsim\/azure-sdk-for-java"}
{"id":9010,"comment_id":1,"comment":"\/\/ the connection string value can be obtained by: \/\/ 1. going to your event hubs namespace in azure portal. \/\/ 2. creating an event hub instance. \/\/ 3. creating a \"shared access policy\" for your event hub instance. \/\/ 4. copying the connection string from the policy's properties.","code":"public static void main(string[] args) { \/\/ the connection string value can be obtained by: \/\/ 1. going to your event hubs namespace in azure portal. \/\/ 2. creating an event hub instance. \/\/ 3. creating a \"shared access policy\" for your event hub instance. \/\/ 4. copying the connection string from the policy's properties. string connectionstring = \"endpoint={endpoint};sharedaccesskeyname={sharedaccesskeyname};sharedaccesskey={sharedaccesskey};entitypath={eventhubname}\"; eventhubproducerasyncclient producer = new eventhubclientbuilder() .connectionstring(connectionstring) .buildasyncproducer(); \/\/ create an event to send. eventdata data = new eventdata(\"hello world!\".getbytes(utf_8)); \/\/ send that event. this call returns a mono<void>, which we subscribe to. it completes successfully when the \/\/ event has been delivered to the event hub. it completes with an error if an exception occurred while sending \/\/ the event. \/\/ sendoptions are not specified, so events sent are load balanced between all available partitions in the \/\/ event hub instance. producer.send(data).subscribe( (ignored) -> system.out.println(\"event sent.\"), error -> { system.err.println(\"there was an error sending the event: \" + error.tostring()); if (error instanceof amqpexception) { amqpexception amqpexception = (amqpexception) error; system.err.println(string.format(\"is send operation retriable? %s. error condition: %s\", amqpexception.istransient(), amqpexception.geterrorcondition())); } }, () -> { \/\/ disposing of our producer and client. producer.close(); }); }","classification":"NONSATD","isFinished":true,"code_context_2":"public static void main(string[] args) { \/\/ the connection string value can be obtained by: \/\/ 1. going to your event hubs namespace in azure portal. \/\/ 2. creating an event hub instance. \/\/ 3. creating a \"shared access policy\" for your event hub instance. \/\/ 4. copying the connection string from the policy's properties. string connectionstring = \"endpoint={endpoint};sharedaccesskeyname={sharedaccesskeyname};sharedaccesskey={sharedaccesskey};entitypath={eventhubname}\"; eventhubproducerasyncclient producer = new eventhubclientbuilder()","code_context_10":"public static void main(string[] args) { \/\/ the connection string value can be obtained by: \/\/ 1. going to your event hubs namespace in azure portal. \/\/ 2. creating an event hub instance. \/\/ 3. creating a \"shared access policy\" for your event hub instance. \/\/ 4. copying the connection string from the policy's properties. string connectionstring = \"endpoint={endpoint};sharedaccesskeyname={sharedaccesskeyname};sharedaccesskey={sharedaccesskey};entitypath={eventhubname}\"; eventhubproducerasyncclient producer = new eventhubclientbuilder() .connectionstring(connectionstring) .buildasyncproducer(); \/\/ create an event to send. eventdata data = new eventdata(\"hello world!\".getbytes(utf_8)); \/\/ send that event. this call returns a mono<void>, which we subscribe to. it completes successfully when the \/\/ event has been delivered to the event hub. it completes with an error if an exception occurred while sending \/\/ the event. \/\/ sendoptions are not specified, so events sent are load balanced between all available partitions in the","code_context_20":"public static void main(string[] args) { \/\/ the connection string value can be obtained by: \/\/ 1. going to your event hubs namespace in azure portal. \/\/ 2. creating an event hub instance. \/\/ 3. creating a \"shared access policy\" for your event hub instance. \/\/ 4. copying the connection string from the policy's properties. string connectionstring = \"endpoint={endpoint};sharedaccesskeyname={sharedaccesskeyname};sharedaccesskey={sharedaccesskey};entitypath={eventhubname}\"; eventhubproducerasyncclient producer = new eventhubclientbuilder() .connectionstring(connectionstring) .buildasyncproducer(); \/\/ create an event to send. eventdata data = new eventdata(\"hello world!\".getbytes(utf_8)); \/\/ send that event. this call returns a mono<void>, which we subscribe to. it completes successfully when the \/\/ event has been delivered to the event hub. it completes with an error if an exception occurred while sending \/\/ the event. \/\/ sendoptions are not specified, so events sent are load balanced between all available partitions in the \/\/ event hub instance. producer.send(data).subscribe( (ignored) -> system.out.println(\"event sent.\"), error -> { system.err.println(\"there was an error sending the event: \" + error.tostring()); if (error instanceof amqpexception) { amqpexception amqpexception = (amqpexception) error; system.err.println(string.format(\"is send operation retriable? %s. error condition: %s\", amqpexception.istransient(), amqpexception.geterrorcondition())); }","repo":"ppsim\/azure-sdk-for-java"}
{"id":9010,"comment_id":2,"comment":"\/\/ create an event to send.","code":"public static void main(string[] args) { \/\/ the connection string value can be obtained by: \/\/ 1. going to your event hubs namespace in azure portal. \/\/ 2. creating an event hub instance. \/\/ 3. creating a \"shared access policy\" for your event hub instance. \/\/ 4. copying the connection string from the policy's properties. string connectionstring = \"endpoint={endpoint};sharedaccesskeyname={sharedaccesskeyname};sharedaccesskey={sharedaccesskey};entitypath={eventhubname}\"; eventhubproducerasyncclient producer = new eventhubclientbuilder() .connectionstring(connectionstring) .buildasyncproducer(); \/\/ create an event to send. eventdata data = new eventdata(\"hello world!\".getbytes(utf_8)); \/\/ send that event. this call returns a mono<void>, which we subscribe to. it completes successfully when the \/\/ event has been delivered to the event hub. it completes with an error if an exception occurred while sending \/\/ the event. \/\/ sendoptions are not specified, so events sent are load balanced between all available partitions in the \/\/ event hub instance. producer.send(data).subscribe( (ignored) -> system.out.println(\"event sent.\"), error -> { system.err.println(\"there was an error sending the event: \" + error.tostring()); if (error instanceof amqpexception) { amqpexception amqpexception = (amqpexception) error; system.err.println(string.format(\"is send operation retriable? %s. error condition: %s\", amqpexception.istransient(), amqpexception.geterrorcondition())); } }, () -> { \/\/ disposing of our producer and client. producer.close(); }); }","classification":"NONSATD","isFinished":true,"code_context_2":".connectionstring(connectionstring) .buildasyncproducer(); \/\/ create an event to send. eventdata data = new eventdata(\"hello world!\".getbytes(utf_8)); \/\/ send that event. this call returns a mono<void>, which we subscribe to. it completes successfully when the","code_context_10":"public static void main(string[] args) { \/\/ the connection string value can be obtained by: \/\/ 1. going to your event hubs namespace in azure portal. \/\/ 2. creating an event hub instance. \/\/ 3. creating a \"shared access policy\" for your event hub instance. \/\/ 4. copying the connection string from the policy's properties. string connectionstring = \"endpoint={endpoint};sharedaccesskeyname={sharedaccesskeyname};sharedaccesskey={sharedaccesskey};entitypath={eventhubname}\"; eventhubproducerasyncclient producer = new eventhubclientbuilder() .connectionstring(connectionstring) .buildasyncproducer(); \/\/ create an event to send. eventdata data = new eventdata(\"hello world!\".getbytes(utf_8)); \/\/ send that event. this call returns a mono<void>, which we subscribe to. it completes successfully when the \/\/ event has been delivered to the event hub. it completes with an error if an exception occurred while sending \/\/ the event. \/\/ sendoptions are not specified, so events sent are load balanced between all available partitions in the \/\/ event hub instance. producer.send(data).subscribe( (ignored) -> system.out.println(\"event sent.\"), error -> { system.err.println(\"there was an error sending the event: \" + error.tostring());","code_context_20":"public static void main(string[] args) { \/\/ the connection string value can be obtained by: \/\/ 1. going to your event hubs namespace in azure portal. \/\/ 2. creating an event hub instance. \/\/ 3. creating a \"shared access policy\" for your event hub instance. \/\/ 4. copying the connection string from the policy's properties. string connectionstring = \"endpoint={endpoint};sharedaccesskeyname={sharedaccesskeyname};sharedaccesskey={sharedaccesskey};entitypath={eventhubname}\"; eventhubproducerasyncclient producer = new eventhubclientbuilder() .connectionstring(connectionstring) .buildasyncproducer(); \/\/ create an event to send. eventdata data = new eventdata(\"hello world!\".getbytes(utf_8)); \/\/ send that event. this call returns a mono<void>, which we subscribe to. it completes successfully when the \/\/ event has been delivered to the event hub. it completes with an error if an exception occurred while sending \/\/ the event. \/\/ sendoptions are not specified, so events sent are load balanced between all available partitions in the \/\/ event hub instance. producer.send(data).subscribe( (ignored) -> system.out.println(\"event sent.\"), error -> { system.err.println(\"there was an error sending the event: \" + error.tostring()); if (error instanceof amqpexception) { amqpexception amqpexception = (amqpexception) error; system.err.println(string.format(\"is send operation retriable? %s. error condition: %s\", amqpexception.istransient(), amqpexception.geterrorcondition())); } }, () -> { \/\/ disposing of our producer and client. producer.close(); }); }","repo":"ppsim\/azure-sdk-for-java"}
{"id":9010,"comment_id":3,"comment":"\/\/ send that event. this call returns a mono<void>, which we subscribe to. it completes successfully when the \/\/ event has been delivered to the event hub. it completes with an error if an exception occurred while sending \/\/ the event. \/\/ sendoptions are not specified, so events sent are load balanced between all available partitions in the \/\/ event hub instance.","code":"public static void main(string[] args) { \/\/ the connection string value can be obtained by: \/\/ 1. going to your event hubs namespace in azure portal. \/\/ 2. creating an event hub instance. \/\/ 3. creating a \"shared access policy\" for your event hub instance. \/\/ 4. copying the connection string from the policy's properties. string connectionstring = \"endpoint={endpoint};sharedaccesskeyname={sharedaccesskeyname};sharedaccesskey={sharedaccesskey};entitypath={eventhubname}\"; eventhubproducerasyncclient producer = new eventhubclientbuilder() .connectionstring(connectionstring) .buildasyncproducer(); \/\/ create an event to send. eventdata data = new eventdata(\"hello world!\".getbytes(utf_8)); \/\/ send that event. this call returns a mono<void>, which we subscribe to. it completes successfully when the \/\/ event has been delivered to the event hub. it completes with an error if an exception occurred while sending \/\/ the event. \/\/ sendoptions are not specified, so events sent are load balanced between all available partitions in the \/\/ event hub instance. producer.send(data).subscribe( (ignored) -> system.out.println(\"event sent.\"), error -> { system.err.println(\"there was an error sending the event: \" + error.tostring()); if (error instanceof amqpexception) { amqpexception amqpexception = (amqpexception) error; system.err.println(string.format(\"is send operation retriable? %s. error condition: %s\", amqpexception.istransient(), amqpexception.geterrorcondition())); } }, () -> { \/\/ disposing of our producer and client. producer.close(); }); }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ create an event to send. eventdata data = new eventdata(\"hello world!\".getbytes(utf_8)); \/\/ send that event. this call returns a mono<void>, which we subscribe to. it completes successfully when the \/\/ event has been delivered to the event hub. it completes with an error if an exception occurred while sending \/\/ the event. \/\/ sendoptions are not specified, so events sent are load balanced between all available partitions in the \/\/ event hub instance. producer.send(data).subscribe( (ignored) -> system.out.println(\"event sent.\"),","code_context_10":"\/\/ 1. going to your event hubs namespace in azure portal. \/\/ 2. creating an event hub instance. \/\/ 3. creating a \"shared access policy\" for your event hub instance. \/\/ 4. copying the connection string from the policy's properties. string connectionstring = \"endpoint={endpoint};sharedaccesskeyname={sharedaccesskeyname};sharedaccesskey={sharedaccesskey};entitypath={eventhubname}\"; eventhubproducerasyncclient producer = new eventhubclientbuilder() .connectionstring(connectionstring) .buildasyncproducer(); \/\/ create an event to send. eventdata data = new eventdata(\"hello world!\".getbytes(utf_8)); \/\/ send that event. this call returns a mono<void>, which we subscribe to. it completes successfully when the \/\/ event has been delivered to the event hub. it completes with an error if an exception occurred while sending \/\/ the event. \/\/ sendoptions are not specified, so events sent are load balanced between all available partitions in the \/\/ event hub instance. producer.send(data).subscribe( (ignored) -> system.out.println(\"event sent.\"), error -> { system.err.println(\"there was an error sending the event: \" + error.tostring()); if (error instanceof amqpexception) { amqpexception amqpexception = (amqpexception) error; system.err.println(string.format(\"is send operation retriable? %s. error condition: %s\", amqpexception.istransient(), amqpexception.geterrorcondition())); } }, () -> {","code_context_20":"public static void main(string[] args) { \/\/ the connection string value can be obtained by: \/\/ 1. going to your event hubs namespace in azure portal. \/\/ 2. creating an event hub instance. \/\/ 3. creating a \"shared access policy\" for your event hub instance. \/\/ 4. copying the connection string from the policy's properties. string connectionstring = \"endpoint={endpoint};sharedaccesskeyname={sharedaccesskeyname};sharedaccesskey={sharedaccesskey};entitypath={eventhubname}\"; eventhubproducerasyncclient producer = new eventhubclientbuilder() .connectionstring(connectionstring) .buildasyncproducer(); \/\/ create an event to send. eventdata data = new eventdata(\"hello world!\".getbytes(utf_8)); \/\/ send that event. this call returns a mono<void>, which we subscribe to. it completes successfully when the \/\/ event has been delivered to the event hub. it completes with an error if an exception occurred while sending \/\/ the event. \/\/ sendoptions are not specified, so events sent are load balanced between all available partitions in the \/\/ event hub instance. producer.send(data).subscribe( (ignored) -> system.out.println(\"event sent.\"), error -> { system.err.println(\"there was an error sending the event: \" + error.tostring()); if (error instanceof amqpexception) { amqpexception amqpexception = (amqpexception) error; system.err.println(string.format(\"is send operation retriable? %s. error condition: %s\", amqpexception.istransient(), amqpexception.geterrorcondition())); } }, () -> { \/\/ disposing of our producer and client. producer.close(); }); }","repo":"ppsim\/azure-sdk-for-java"}
{"id":9010,"comment_id":4,"comment":"\/\/ disposing of our producer and client.","code":"public static void main(string[] args) { \/\/ the connection string value can be obtained by: \/\/ 1. going to your event hubs namespace in azure portal. \/\/ 2. creating an event hub instance. \/\/ 3. creating a \"shared access policy\" for your event hub instance. \/\/ 4. copying the connection string from the policy's properties. string connectionstring = \"endpoint={endpoint};sharedaccesskeyname={sharedaccesskeyname};sharedaccesskey={sharedaccesskey};entitypath={eventhubname}\"; eventhubproducerasyncclient producer = new eventhubclientbuilder() .connectionstring(connectionstring) .buildasyncproducer(); \/\/ create an event to send. eventdata data = new eventdata(\"hello world!\".getbytes(utf_8)); \/\/ send that event. this call returns a mono<void>, which we subscribe to. it completes successfully when the \/\/ event has been delivered to the event hub. it completes with an error if an exception occurred while sending \/\/ the event. \/\/ sendoptions are not specified, so events sent are load balanced between all available partitions in the \/\/ event hub instance. producer.send(data).subscribe( (ignored) -> system.out.println(\"event sent.\"), error -> { system.err.println(\"there was an error sending the event: \" + error.tostring()); if (error instanceof amqpexception) { amqpexception amqpexception = (amqpexception) error; system.err.println(string.format(\"is send operation retriable? %s. error condition: %s\", amqpexception.istransient(), amqpexception.geterrorcondition())); } }, () -> { \/\/ disposing of our producer and client. producer.close(); }); }","classification":"NONSATD","isFinished":true,"code_context_2":"} }, () -> { \/\/ disposing of our producer and client. producer.close(); });","code_context_10":"producer.send(data).subscribe( (ignored) -> system.out.println(\"event sent.\"), error -> { system.err.println(\"there was an error sending the event: \" + error.tostring()); if (error instanceof amqpexception) { amqpexception amqpexception = (amqpexception) error; system.err.println(string.format(\"is send operation retriable? %s. error condition: %s\", amqpexception.istransient(), amqpexception.geterrorcondition())); } }, () -> { \/\/ disposing of our producer and client. producer.close(); }); }","code_context_20":"eventhubproducerasyncclient producer = new eventhubclientbuilder() .connectionstring(connectionstring) .buildasyncproducer(); \/\/ create an event to send. eventdata data = new eventdata(\"hello world!\".getbytes(utf_8)); \/\/ send that event. this call returns a mono<void>, which we subscribe to. it completes successfully when the \/\/ event has been delivered to the event hub. it completes with an error if an exception occurred while sending \/\/ the event. \/\/ sendoptions are not specified, so events sent are load balanced between all available partitions in the \/\/ event hub instance. producer.send(data).subscribe( (ignored) -> system.out.println(\"event sent.\"), error -> { system.err.println(\"there was an error sending the event: \" + error.tostring()); if (error instanceof amqpexception) { amqpexception amqpexception = (amqpexception) error; system.err.println(string.format(\"is send operation retriable? %s. error condition: %s\", amqpexception.istransient(), amqpexception.geterrorcondition())); } }, () -> { \/\/ disposing of our producer and client. producer.close(); }); }","repo":"ppsim\/azure-sdk-for-java"}
{"id":822,"comment_id":0,"comment":"\/\/todo(bazel-team): support \\x escapes","code":"private baseprinter escapecharacter(char c) { if (c == '\"') { return backslashchar(c); } switch (c) { case '\\\\': return backslashchar('\\\\'); case '\\r': return backslashchar('r'); case '\\n': return backslashchar('n'); case '\\t': return backslashchar('t'); default: if (c < 32) { \/\/todo(bazel-team): support \\x escapes return this.append(string.format(\"\\\\x%02x\", (int) c)); } return this.append(c); \/\/ no need to support utf-8 } \/\/ endswitch }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"default: if (c < 32) { \/\/todo(bazel-team): support \\x escapes return this.append(string.format(\"\\\\x%02x\", (int) c)); }","code_context_10":"case '\\\\': return backslashchar('\\\\'); case '\\r': return backslashchar('r'); case '\\n': return backslashchar('n'); case '\\t': return backslashchar('t'); default: if (c < 32) { \/\/todo(bazel-team): support \\x escapes return this.append(string.format(\"\\\\x%02x\", (int) c)); } return this.append(c); \/\/ no need to support utf-8 } \/\/ endswitch }","code_context_20":"private baseprinter escapecharacter(char c) { if (c == '\"') { return backslashchar(c); } switch (c) { case '\\\\': return backslashchar('\\\\'); case '\\r': return backslashchar('r'); case '\\n': return backslashchar('n'); case '\\t': return backslashchar('t'); default: if (c < 32) { \/\/todo(bazel-team): support \\x escapes return this.append(string.format(\"\\\\x%02x\", (int) c)); } return this.append(c); \/\/ no need to support utf-8 } \/\/ endswitch }","repo":"moroten\/bazel"}
{"id":822,"comment_id":1,"comment":"\/\/ no need to support utf-8","code":"private baseprinter escapecharacter(char c) { if (c == '\"') { return backslashchar(c); } switch (c) { case '\\\\': return backslashchar('\\\\'); case '\\r': return backslashchar('r'); case '\\n': return backslashchar('n'); case '\\t': return backslashchar('t'); default: if (c < 32) { \/\/todo(bazel-team): support \\x escapes return this.append(string.format(\"\\\\x%02x\", (int) c)); } return this.append(c); \/\/ no need to support utf-8 } \/\/ endswitch }","classification":"NONSATD","isFinished":true,"code_context_2":"return this.append(string.format(\"\\\\x%02x\", (int) c)); } return this.append(c); \/\/ no need to support utf-8 } \/\/ endswitch }","code_context_10":"return backslashchar('r'); case '\\n': return backslashchar('n'); case '\\t': return backslashchar('t'); default: if (c < 32) { \/\/todo(bazel-team): support \\x escapes return this.append(string.format(\"\\\\x%02x\", (int) c)); } return this.append(c); \/\/ no need to support utf-8 } \/\/ endswitch }","code_context_20":"private baseprinter escapecharacter(char c) { if (c == '\"') { return backslashchar(c); } switch (c) { case '\\\\': return backslashchar('\\\\'); case '\\r': return backslashchar('r'); case '\\n': return backslashchar('n'); case '\\t': return backslashchar('t'); default: if (c < 32) { \/\/todo(bazel-team): support \\x escapes return this.append(string.format(\"\\\\x%02x\", (int) c)); } return this.append(c); \/\/ no need to support utf-8 } \/\/ endswitch }","repo":"moroten\/bazel"}
{"id":822,"comment_id":2,"comment":"\/\/ endswitch","code":"private baseprinter escapecharacter(char c) { if (c == '\"') { return backslashchar(c); } switch (c) { case '\\\\': return backslashchar('\\\\'); case '\\r': return backslashchar('r'); case '\\n': return backslashchar('n'); case '\\t': return backslashchar('t'); default: if (c < 32) { \/\/todo(bazel-team): support \\x escapes return this.append(string.format(\"\\\\x%02x\", (int) c)); } return this.append(c); \/\/ no need to support utf-8 } \/\/ endswitch }","classification":"NONSATD","isFinished":true,"code_context_2":"} return this.append(c); \/\/ no need to support utf-8 } \/\/ endswitch }","code_context_10":"case '\\n': return backslashchar('n'); case '\\t': return backslashchar('t'); default: if (c < 32) { \/\/todo(bazel-team): support \\x escapes return this.append(string.format(\"\\\\x%02x\", (int) c)); } return this.append(c); \/\/ no need to support utf-8 } \/\/ endswitch }","code_context_20":"private baseprinter escapecharacter(char c) { if (c == '\"') { return backslashchar(c); } switch (c) { case '\\\\': return backslashchar('\\\\'); case '\\r': return backslashchar('r'); case '\\n': return backslashchar('n'); case '\\t': return backslashchar('t'); default: if (c < 32) { \/\/todo(bazel-team): support \\x escapes return this.append(string.format(\"\\\\x%02x\", (int) c)); } return this.append(c); \/\/ no need to support utf-8 } \/\/ endswitch }","repo":"moroten\/bazel"}
{"id":831,"comment_id":0,"comment":"\/\/todo: change filename param to int","code":"\/\/todo: change filename param to int private pair<imageview, string> loadimagewithcaption(int fileid, string caption, map <string, integer> weaponmap, integer id) { try { \/\/todo: use below when info is changed system.out.println(fileid); var image = new imageview(mylogic.getimage(fileid)); system.out.println(\"**********\"); system.out.println(image); weaponmap.put(image.tostring(), id); image.setfitwidth(100); image.setfitheight(100); pair pair = new pair<>(image, caption); return pair; \/\/ return new pair<>(image, caption); } catch(exception e){ system.out.println(e); \/\/this shouldn't ever happen } return null; }","classification":"NONSATD","isFinished":true,"code_context_2":"private pair<imageview, string> loadimagewithcaption(int fileid, string caption, map <string, integer> weaponmap, integer id) { try { \/\/todo: use below when info is changed system.out.println(fileid); var image = new imageview(mylogic.getimage(fileid)); system.out.println(\"**********\"); system.out.println(image); weaponmap.put(image.tostring(), id); image.setfitwidth(100); image.setfitheight(100); pair pair = new pair<>(image, caption); return pair; \/\/ return new pair<>(image, caption); } catch(exception e){ system.out.println(e); \/\/this shouldn't ever happen } return null; }","code_context_10":"private pair<imageview, string> loadimagewithcaption(int fileid, string caption, map <string, integer> weaponmap, integer id) { try { \/\/todo: use below when info is changed system.out.println(fileid); var image = new imageview(mylogic.getimage(fileid)); system.out.println(\"**********\"); system.out.println(image); weaponmap.put(image.tostring(), id); image.setfitwidth(100); image.setfitheight(100); pair pair = new pair<>(image, caption); return pair; \/\/ return new pair<>(image, caption); } catch(exception e){ system.out.println(e); \/\/this shouldn't ever happen } return null; }","code_context_20":"private pair<imageview, string> loadimagewithcaption(int fileid, string caption, map <string, integer> weaponmap, integer id) { try { \/\/todo: use below when info is changed system.out.println(fileid); var image = new imageview(mylogic.getimage(fileid)); system.out.println(\"**********\"); system.out.println(image); weaponmap.put(image.tostring(), id); image.setfitwidth(100); image.setfitheight(100); pair pair = new pair<>(image, caption); return pair; \/\/ return new pair<>(image, caption); } catch(exception e){ system.out.println(e); \/\/this shouldn't ever happen } return null; }","repo":"pandawithcat\/VoogaSalad"}
{"id":831,"comment_id":1,"comment":"\/\/todo: use below when info is changed","code":"private pair<imageview, string> loadimagewithcaption(int fileid, string caption, map <string, integer> weaponmap, integer id) { try { \/\/todo: use below when info is changed system.out.println(fileid); var image = new imageview(mylogic.getimage(fileid)); system.out.println(\"**********\"); system.out.println(image); weaponmap.put(image.tostring(), id); image.setfitwidth(100); image.setfitheight(100); pair pair = new pair<>(image, caption); return pair; \/\/ return new pair<>(image, caption); } catch(exception e){ system.out.println(e); \/\/this shouldn't ever happen } return null; }","classification":"DESIGN","isFinished":true,"code_context_2":"integer> weaponmap, integer id) { try { \/\/todo: use below when info is changed system.out.println(fileid); var image = new imageview(mylogic.getimage(fileid));","code_context_10":"private pair<imageview, string> loadimagewithcaption(int fileid, string caption, map <string, integer> weaponmap, integer id) { try { \/\/todo: use below when info is changed system.out.println(fileid); var image = new imageview(mylogic.getimage(fileid)); system.out.println(\"**********\"); system.out.println(image); weaponmap.put(image.tostring(), id); image.setfitwidth(100); image.setfitheight(100); pair pair = new pair<>(image, caption); return pair; \/\/ return new pair<>(image, caption);","code_context_20":"private pair<imageview, string> loadimagewithcaption(int fileid, string caption, map <string, integer> weaponmap, integer id) { try { \/\/todo: use below when info is changed system.out.println(fileid); var image = new imageview(mylogic.getimage(fileid)); system.out.println(\"**********\"); system.out.println(image); weaponmap.put(image.tostring(), id); image.setfitwidth(100); image.setfitheight(100); pair pair = new pair<>(image, caption); return pair; \/\/ return new pair<>(image, caption); } catch(exception e){ system.out.println(e); \/\/this shouldn't ever happen } return null; }","repo":"pandawithcat\/VoogaSalad"}
{"id":831,"comment_id":2,"comment":"\/\/ return new pair<>(image, caption);","code":"private pair<imageview, string> loadimagewithcaption(int fileid, string caption, map <string, integer> weaponmap, integer id) { try { \/\/todo: use below when info is changed system.out.println(fileid); var image = new imageview(mylogic.getimage(fileid)); system.out.println(\"**********\"); system.out.println(image); weaponmap.put(image.tostring(), id); image.setfitwidth(100); image.setfitheight(100); pair pair = new pair<>(image, caption); return pair; \/\/ return new pair<>(image, caption); } catch(exception e){ system.out.println(e); \/\/this shouldn't ever happen } return null; }","classification":"NONSATD","isFinished":true,"code_context_2":"pair pair = new pair<>(image, caption); return pair; \/\/ return new pair<>(image, caption); } catch(exception e){","code_context_10":"\/\/todo: use below when info is changed system.out.println(fileid); var image = new imageview(mylogic.getimage(fileid)); system.out.println(\"**********\"); system.out.println(image); weaponmap.put(image.tostring(), id); image.setfitwidth(100); image.setfitheight(100); pair pair = new pair<>(image, caption); return pair; \/\/ return new pair<>(image, caption); } catch(exception e){ system.out.println(e); \/\/this shouldn't ever happen } return null; }","code_context_20":"private pair<imageview, string> loadimagewithcaption(int fileid, string caption, map <string, integer> weaponmap, integer id) { try { \/\/todo: use below when info is changed system.out.println(fileid); var image = new imageview(mylogic.getimage(fileid)); system.out.println(\"**********\"); system.out.println(image); weaponmap.put(image.tostring(), id); image.setfitwidth(100); image.setfitheight(100); pair pair = new pair<>(image, caption); return pair; \/\/ return new pair<>(image, caption); } catch(exception e){ system.out.println(e); \/\/this shouldn't ever happen } return null; }","repo":"pandawithcat\/VoogaSalad"}
{"id":831,"comment_id":3,"comment":"\/\/this shouldn't ever happen","code":"private pair<imageview, string> loadimagewithcaption(int fileid, string caption, map <string, integer> weaponmap, integer id) { try { \/\/todo: use below when info is changed system.out.println(fileid); var image = new imageview(mylogic.getimage(fileid)); system.out.println(\"**********\"); system.out.println(image); weaponmap.put(image.tostring(), id); image.setfitwidth(100); image.setfitheight(100); pair pair = new pair<>(image, caption); return pair; \/\/ return new pair<>(image, caption); } catch(exception e){ system.out.println(e); \/\/this shouldn't ever happen } return null; }","classification":"NONSATD","isFinished":true,"code_context_2":"catch(exception e){ system.out.println(e); \/\/this shouldn't ever happen } return null;","code_context_10":"system.out.println(image); weaponmap.put(image.tostring(), id); image.setfitwidth(100); image.setfitheight(100); pair pair = new pair<>(image, caption); return pair; \/\/ return new pair<>(image, caption); } catch(exception e){ system.out.println(e); \/\/this shouldn't ever happen } return null; }","code_context_20":"private pair<imageview, string> loadimagewithcaption(int fileid, string caption, map <string, integer> weaponmap, integer id) { try { \/\/todo: use below when info is changed system.out.println(fileid); var image = new imageview(mylogic.getimage(fileid)); system.out.println(\"**********\"); system.out.println(image); weaponmap.put(image.tostring(), id); image.setfitwidth(100); image.setfitheight(100); pair pair = new pair<>(image, caption); return pair; \/\/ return new pair<>(image, caption); } catch(exception e){ system.out.println(e); \/\/this shouldn't ever happen } return null; }","repo":"pandawithcat\/VoogaSalad"}
{"id":25437,"comment_id":0,"comment":"\/\/ todo(peis): fix this, we should not assert here.","code":"@override public void channelread0(final channelhandlercontext ctx, final rpcmessage msg) throws ioexception { switch (msg.gettype()) { case rpc_block_read_request: assert msg instanceof rpcblockreadrequest; mblockhandler.handleblockreadrequest(ctx, (rpcblockreadrequest) msg); break; case rpc_block_write_request: assert msg instanceof rpcblockwriterequest; mblockhandler.handleblockwriterequest(ctx, (rpcblockwriterequest) msg); break; case rpc_file_read_request: assert msg instanceof rpcfilereadrequest; munderfilesystemhandler.handlefilereadrequest(ctx, (rpcfilereadrequest) msg); break; case rpc_file_write_request: assert msg instanceof rpcfilewriterequest; munderfilesystemhandler.handlefilewriterequest(ctx, (rpcfilewriterequest) msg); break; case rpc_error_response: \/\/ todo(peis): fix this, we should not assert here. assert msg instanceof rpcerrorresponse; log.error(\"received an error response from the client: \" + msg.tostring()); break; default: rpcerrorresponse resp = new rpcerrorresponse(rpcresponse.status.unknown_message_error); ctx.writeandflush(resp); \/\/ todo(peis): fix this. we should not throw an exception here. throw new illegalargumentexception( \"no handler implementation for rpc msg type: \" + msg.gettype()); } }","classification":"DESIGN","isFinished":true,"code_context_2":"break; case rpc_error_response: \/\/ todo(peis): fix this, we should not assert here. assert msg instanceof rpcerrorresponse; log.error(\"received an error response from the client: \" + msg.tostring());","code_context_10":"break; case rpc_file_read_request: assert msg instanceof rpcfilereadrequest; munderfilesystemhandler.handlefilereadrequest(ctx, (rpcfilereadrequest) msg); break; case rpc_file_write_request: assert msg instanceof rpcfilewriterequest; munderfilesystemhandler.handlefilewriterequest(ctx, (rpcfilewriterequest) msg); break; case rpc_error_response: \/\/ todo(peis): fix this, we should not assert here. assert msg instanceof rpcerrorresponse; log.error(\"received an error response from the client: \" + msg.tostring()); break; default: rpcerrorresponse resp = new rpcerrorresponse(rpcresponse.status.unknown_message_error); ctx.writeandflush(resp); \/\/ todo(peis): fix this. we should not throw an exception here. throw new illegalargumentexception( \"no handler implementation for rpc msg type: \" + msg.gettype()); }","code_context_20":"public void channelread0(final channelhandlercontext ctx, final rpcmessage msg) throws ioexception { switch (msg.gettype()) { case rpc_block_read_request: assert msg instanceof rpcblockreadrequest; mblockhandler.handleblockreadrequest(ctx, (rpcblockreadrequest) msg); break; case rpc_block_write_request: assert msg instanceof rpcblockwriterequest; mblockhandler.handleblockwriterequest(ctx, (rpcblockwriterequest) msg); break; case rpc_file_read_request: assert msg instanceof rpcfilereadrequest; munderfilesystemhandler.handlefilereadrequest(ctx, (rpcfilereadrequest) msg); break; case rpc_file_write_request: assert msg instanceof rpcfilewriterequest; munderfilesystemhandler.handlefilewriterequest(ctx, (rpcfilewriterequest) msg); break; case rpc_error_response: \/\/ todo(peis): fix this, we should not assert here. assert msg instanceof rpcerrorresponse; log.error(\"received an error response from the client: \" + msg.tostring()); break; default: rpcerrorresponse resp = new rpcerrorresponse(rpcresponse.status.unknown_message_error); ctx.writeandflush(resp); \/\/ todo(peis): fix this. we should not throw an exception here. throw new illegalargumentexception( \"no handler implementation for rpc msg type: \" + msg.gettype()); } }","repo":"ramiyer\/alluxio"}
{"id":25437,"comment_id":1,"comment":"\/\/ todo(peis): fix this. we should not throw an exception here.","code":"@override public void channelread0(final channelhandlercontext ctx, final rpcmessage msg) throws ioexception { switch (msg.gettype()) { case rpc_block_read_request: assert msg instanceof rpcblockreadrequest; mblockhandler.handleblockreadrequest(ctx, (rpcblockreadrequest) msg); break; case rpc_block_write_request: assert msg instanceof rpcblockwriterequest; mblockhandler.handleblockwriterequest(ctx, (rpcblockwriterequest) msg); break; case rpc_file_read_request: assert msg instanceof rpcfilereadrequest; munderfilesystemhandler.handlefilereadrequest(ctx, (rpcfilereadrequest) msg); break; case rpc_file_write_request: assert msg instanceof rpcfilewriterequest; munderfilesystemhandler.handlefilewriterequest(ctx, (rpcfilewriterequest) msg); break; case rpc_error_response: \/\/ todo(peis): fix this, we should not assert here. assert msg instanceof rpcerrorresponse; log.error(\"received an error response from the client: \" + msg.tostring()); break; default: rpcerrorresponse resp = new rpcerrorresponse(rpcresponse.status.unknown_message_error); ctx.writeandflush(resp); \/\/ todo(peis): fix this. we should not throw an exception here. throw new illegalargumentexception( \"no handler implementation for rpc msg type: \" + msg.gettype()); } }","classification":"DEFECT","isFinished":true,"code_context_2":"rpcerrorresponse resp = new rpcerrorresponse(rpcresponse.status.unknown_message_error); ctx.writeandflush(resp); \/\/ todo(peis): fix this. we should not throw an exception here. throw new illegalargumentexception( \"no handler implementation for rpc msg type: \" + msg.gettype());","code_context_10":"munderfilesystemhandler.handlefilewriterequest(ctx, (rpcfilewriterequest) msg); break; case rpc_error_response: \/\/ todo(peis): fix this, we should not assert here. assert msg instanceof rpcerrorresponse; log.error(\"received an error response from the client: \" + msg.tostring()); break; default: rpcerrorresponse resp = new rpcerrorresponse(rpcresponse.status.unknown_message_error); ctx.writeandflush(resp); \/\/ todo(peis): fix this. we should not throw an exception here. throw new illegalargumentexception( \"no handler implementation for rpc msg type: \" + msg.gettype()); } }","code_context_20":"case rpc_block_write_request: assert msg instanceof rpcblockwriterequest; mblockhandler.handleblockwriterequest(ctx, (rpcblockwriterequest) msg); break; case rpc_file_read_request: assert msg instanceof rpcfilereadrequest; munderfilesystemhandler.handlefilereadrequest(ctx, (rpcfilereadrequest) msg); break; case rpc_file_write_request: assert msg instanceof rpcfilewriterequest; munderfilesystemhandler.handlefilewriterequest(ctx, (rpcfilewriterequest) msg); break; case rpc_error_response: \/\/ todo(peis): fix this, we should not assert here. assert msg instanceof rpcerrorresponse; log.error(\"received an error response from the client: \" + msg.tostring()); break; default: rpcerrorresponse resp = new rpcerrorresponse(rpcresponse.status.unknown_message_error); ctx.writeandflush(resp); \/\/ todo(peis): fix this. we should not throw an exception here. throw new illegalargumentexception( \"no handler implementation for rpc msg type: \" + msg.gettype()); } }","repo":"ramiyer\/alluxio"}
{"id":25438,"comment_id":0,"comment":"\/\/ todo(peis): this doesn't have to be decode error, it can also be any network errors such as \/\/ connection reset. fix this alluxio-2235.","code":"@override public void exceptioncaught(channelhandlercontext ctx, throwable cause) throws exception { log.warn(\"exception thrown while processing request\", cause); \/\/ todo(peis): this doesn't have to be decode error, it can also be any network errors such as \/\/ connection reset. fix this alluxio-2235. rpcerrorresponse resp = new rpcerrorresponse(rpcresponse.status.decode_error); channelfuture channelfuture = ctx.writeandflush(resp); \/\/ close the channel because it is likely a network error. channelfuture.addlistener(channelfuturelistener.close); }","classification":"DEFECT","isFinished":true,"code_context_2":"public void exceptioncaught(channelhandlercontext ctx, throwable cause) throws exception { log.warn(\"exception thrown while processing request\", cause); \/\/ todo(peis): this doesn't have to be decode error, it can also be any network errors such as \/\/ connection reset. fix this alluxio-2235. rpcerrorresponse resp = new rpcerrorresponse(rpcresponse.status.decode_error); channelfuture channelfuture = ctx.writeandflush(resp);","code_context_10":"@override public void exceptioncaught(channelhandlercontext ctx, throwable cause) throws exception { log.warn(\"exception thrown while processing request\", cause); \/\/ todo(peis): this doesn't have to be decode error, it can also be any network errors such as \/\/ connection reset. fix this alluxio-2235. rpcerrorresponse resp = new rpcerrorresponse(rpcresponse.status.decode_error); channelfuture channelfuture = ctx.writeandflush(resp); \/\/ close the channel because it is likely a network error. channelfuture.addlistener(channelfuturelistener.close); }","code_context_20":"@override public void exceptioncaught(channelhandlercontext ctx, throwable cause) throws exception { log.warn(\"exception thrown while processing request\", cause); \/\/ todo(peis): this doesn't have to be decode error, it can also be any network errors such as \/\/ connection reset. fix this alluxio-2235. rpcerrorresponse resp = new rpcerrorresponse(rpcresponse.status.decode_error); channelfuture channelfuture = ctx.writeandflush(resp); \/\/ close the channel because it is likely a network error. channelfuture.addlistener(channelfuturelistener.close); }","repo":"ramiyer\/alluxio"}
{"id":25438,"comment_id":1,"comment":"\/\/ close the channel because it is likely a network error.","code":"@override public void exceptioncaught(channelhandlercontext ctx, throwable cause) throws exception { log.warn(\"exception thrown while processing request\", cause); \/\/ todo(peis): this doesn't have to be decode error, it can also be any network errors such as \/\/ connection reset. fix this alluxio-2235. rpcerrorresponse resp = new rpcerrorresponse(rpcresponse.status.decode_error); channelfuture channelfuture = ctx.writeandflush(resp); \/\/ close the channel because it is likely a network error. channelfuture.addlistener(channelfuturelistener.close); }","classification":"NONSATD","isFinished":true,"code_context_2":"rpcerrorresponse resp = new rpcerrorresponse(rpcresponse.status.decode_error); channelfuture channelfuture = ctx.writeandflush(resp); \/\/ close the channel because it is likely a network error. channelfuture.addlistener(channelfuturelistener.close); }","code_context_10":"@override public void exceptioncaught(channelhandlercontext ctx, throwable cause) throws exception { log.warn(\"exception thrown while processing request\", cause); \/\/ todo(peis): this doesn't have to be decode error, it can also be any network errors such as \/\/ connection reset. fix this alluxio-2235. rpcerrorresponse resp = new rpcerrorresponse(rpcresponse.status.decode_error); channelfuture channelfuture = ctx.writeandflush(resp); \/\/ close the channel because it is likely a network error. channelfuture.addlistener(channelfuturelistener.close); }","code_context_20":"@override public void exceptioncaught(channelhandlercontext ctx, throwable cause) throws exception { log.warn(\"exception thrown while processing request\", cause); \/\/ todo(peis): this doesn't have to be decode error, it can also be any network errors such as \/\/ connection reset. fix this alluxio-2235. rpcerrorresponse resp = new rpcerrorresponse(rpcresponse.status.decode_error); channelfuture channelfuture = ctx.writeandflush(resp); \/\/ close the channel because it is likely a network error. channelfuture.addlistener(channelfuturelistener.close); }","repo":"ramiyer\/alluxio"}
{"id":17264,"comment_id":0,"comment":"\/\/ ignored","code":"public static navigablemap<string, object> readattrs(buffer buffer, int version) { navigablemap<string, object> attrs = new treemap<>(string.case_insensitive_order); int flags = buffer.getint(); if (version >= sftpconstants.sftp_v4) { int type = buffer.getubyte(); switch (type) { case sftpconstants.ssh_filexfer_type_regular: attrs.put(\"isregular\", boolean.true); break; case sftpconstants.ssh_filexfer_type_directory: attrs.put(\"isdirectory\", boolean.true); break; case sftpconstants.ssh_filexfer_type_symlink: attrs.put(\"issymboliclink\", boolean.true); break; case sftpconstants.ssh_filexfer_type_socket: case sftpconstants.ssh_filexfer_type_char_device: case sftpconstants.ssh_filexfer_type_block_device: case sftpconstants.ssh_filexfer_type_fifo: attrs.put(\"isother\", boolean.true); break; default: \/\/ ignored } } if ((flags & sftpconstants.ssh_filexfer_attr_size) != 0) { attrs.put(\"size\", buffer.getlong()); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_uidgid) != 0) { attrs.put(\"uid\", buffer.getint()); attrs.put(\"gid\", buffer.getint()); } } else { if ((version >= sftpconstants.sftp_v6) && ((flags & sftpconstants.ssh_filexfer_attr_allocation_size) != 0)) { @suppresswarnings(\"unused\") long allocsize = buffer.getlong(); \/\/ todo handle allocation size } if ((flags & sftpconstants.ssh_filexfer_attr_ownergroup) != 0) { attrs.put(\"owner\", new defaultgroupprincipal(buffer.getstring())); attrs.put(\"group\", new defaultgroupprincipal(buffer.getstring())); } } if ((flags & sftpconstants.ssh_filexfer_attr_permissions) != 0) { attrs.put(\"permissions\", permissionstoattributes(buffer.getint())); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_acmodtime) != 0) { attrs.put(\"lastaccesstime\", readtime(buffer, version, flags)); attrs.put(\"lastmodifiedtime\", readtime(buffer, version, flags)); } } else if (version >= sftpconstants.sftp_v4) { if ((flags & sftpconstants.ssh_filexfer_attr_accesstime) != 0) { attrs.put(\"lastaccesstime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_createtime) != 0) { attrs.put(\"creationtime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_modifytime) != 0) { attrs.put(\"lastmodifiedtime\", readtime(buffer, version, flags)); } if ((version >= sftpconstants.sftp_v6) && (flags & sftpconstants.ssh_filexfer_attr_ctime) != 0) { attrs.put(\"ctime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_acl) != 0) { attrs.put(\"acl\", readacls(buffer, version)); } if ((flags & sftpconstants.ssh_filexfer_attr_bits) != 0) { @suppresswarnings(\"unused\") int bits = buffer.getint(); @suppresswarnings(\"unused\") int valid = 0xffffffff; if (version >= sftpconstants.sftp_v6) { valid = buffer.getint(); } \/\/ todo: handle attrib bits } if (version >= sftpconstants.sftp_v6) { if ((flags & sftpconstants.ssh_filexfer_attr_text_hint) != 0) { @suppresswarnings(\"unused\") boolean text = buffer.getboolean(); \/\/ todo: handle text } if ((flags & sftpconstants.ssh_filexfer_attr_mime_type) != 0) { @suppresswarnings(\"unused\") string mimetype = buffer.getstring(); \/\/ todo: handle mime-type } if ((flags & sftpconstants.ssh_filexfer_attr_link_count) != 0) { @suppresswarnings(\"unused\") int nlink = buffer.getint(); \/\/ todo: handle link-count } if ((flags & sftpconstants.ssh_filexfer_attr_untranslated_name) != 0) { @suppresswarnings(\"unused\") string untranslated = buffer.getstring(); \/\/ todo: handle untranslated-name } } } if ((flags & sftpconstants.ssh_filexfer_attr_extended) != 0) { attrs.put(\"extended\", readextensions(buffer)); } return attrs; }","classification":"NONSATD","isFinished":true,"code_context_2":"attrs.put(\"isother\", boolean.true); break; default: \/\/ ignored } }","code_context_10":"break; case sftpconstants.ssh_filexfer_type_symlink: attrs.put(\"issymboliclink\", boolean.true); break; case sftpconstants.ssh_filexfer_type_socket: case sftpconstants.ssh_filexfer_type_char_device: case sftpconstants.ssh_filexfer_type_block_device: case sftpconstants.ssh_filexfer_type_fifo: attrs.put(\"isother\", boolean.true); break; default: \/\/ ignored } } if ((flags & sftpconstants.ssh_filexfer_attr_size) != 0) { attrs.put(\"size\", buffer.getlong()); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_uidgid) != 0) { attrs.put(\"uid\", buffer.getint()); attrs.put(\"gid\", buffer.getint()); }","code_context_20":"navigablemap<string, object> attrs = new treemap<>(string.case_insensitive_order); int flags = buffer.getint(); if (version >= sftpconstants.sftp_v4) { int type = buffer.getubyte(); switch (type) { case sftpconstants.ssh_filexfer_type_regular: attrs.put(\"isregular\", boolean.true); break; case sftpconstants.ssh_filexfer_type_directory: attrs.put(\"isdirectory\", boolean.true); break; case sftpconstants.ssh_filexfer_type_symlink: attrs.put(\"issymboliclink\", boolean.true); break; case sftpconstants.ssh_filexfer_type_socket: case sftpconstants.ssh_filexfer_type_char_device: case sftpconstants.ssh_filexfer_type_block_device: case sftpconstants.ssh_filexfer_type_fifo: attrs.put(\"isother\", boolean.true); break; default: \/\/ ignored } } if ((flags & sftpconstants.ssh_filexfer_attr_size) != 0) { attrs.put(\"size\", buffer.getlong()); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_uidgid) != 0) { attrs.put(\"uid\", buffer.getint()); attrs.put(\"gid\", buffer.getint()); } } else { if ((version >= sftpconstants.sftp_v6) && ((flags & sftpconstants.ssh_filexfer_attr_allocation_size) != 0)) { @suppresswarnings(\"unused\") long allocsize = buffer.getlong(); \/\/ todo handle allocation size } if ((flags & sftpconstants.ssh_filexfer_attr_ownergroup) != 0) { attrs.put(\"owner\", new defaultgroupprincipal(buffer.getstring())); attrs.put(\"group\", new defaultgroupprincipal(buffer.getstring())); } }","repo":"msohn\/mina-sshd"}
{"id":17264,"comment_id":1,"comment":"\/\/ todo handle allocation size","code":"public static navigablemap<string, object> readattrs(buffer buffer, int version) { navigablemap<string, object> attrs = new treemap<>(string.case_insensitive_order); int flags = buffer.getint(); if (version >= sftpconstants.sftp_v4) { int type = buffer.getubyte(); switch (type) { case sftpconstants.ssh_filexfer_type_regular: attrs.put(\"isregular\", boolean.true); break; case sftpconstants.ssh_filexfer_type_directory: attrs.put(\"isdirectory\", boolean.true); break; case sftpconstants.ssh_filexfer_type_symlink: attrs.put(\"issymboliclink\", boolean.true); break; case sftpconstants.ssh_filexfer_type_socket: case sftpconstants.ssh_filexfer_type_char_device: case sftpconstants.ssh_filexfer_type_block_device: case sftpconstants.ssh_filexfer_type_fifo: attrs.put(\"isother\", boolean.true); break; default: \/\/ ignored } } if ((flags & sftpconstants.ssh_filexfer_attr_size) != 0) { attrs.put(\"size\", buffer.getlong()); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_uidgid) != 0) { attrs.put(\"uid\", buffer.getint()); attrs.put(\"gid\", buffer.getint()); } } else { if ((version >= sftpconstants.sftp_v6) && ((flags & sftpconstants.ssh_filexfer_attr_allocation_size) != 0)) { @suppresswarnings(\"unused\") long allocsize = buffer.getlong(); \/\/ todo handle allocation size } if ((flags & sftpconstants.ssh_filexfer_attr_ownergroup) != 0) { attrs.put(\"owner\", new defaultgroupprincipal(buffer.getstring())); attrs.put(\"group\", new defaultgroupprincipal(buffer.getstring())); } } if ((flags & sftpconstants.ssh_filexfer_attr_permissions) != 0) { attrs.put(\"permissions\", permissionstoattributes(buffer.getint())); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_acmodtime) != 0) { attrs.put(\"lastaccesstime\", readtime(buffer, version, flags)); attrs.put(\"lastmodifiedtime\", readtime(buffer, version, flags)); } } else if (version >= sftpconstants.sftp_v4) { if ((flags & sftpconstants.ssh_filexfer_attr_accesstime) != 0) { attrs.put(\"lastaccesstime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_createtime) != 0) { attrs.put(\"creationtime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_modifytime) != 0) { attrs.put(\"lastmodifiedtime\", readtime(buffer, version, flags)); } if ((version >= sftpconstants.sftp_v6) && (flags & sftpconstants.ssh_filexfer_attr_ctime) != 0) { attrs.put(\"ctime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_acl) != 0) { attrs.put(\"acl\", readacls(buffer, version)); } if ((flags & sftpconstants.ssh_filexfer_attr_bits) != 0) { @suppresswarnings(\"unused\") int bits = buffer.getint(); @suppresswarnings(\"unused\") int valid = 0xffffffff; if (version >= sftpconstants.sftp_v6) { valid = buffer.getint(); } \/\/ todo: handle attrib bits } if (version >= sftpconstants.sftp_v6) { if ((flags & sftpconstants.ssh_filexfer_attr_text_hint) != 0) { @suppresswarnings(\"unused\") boolean text = buffer.getboolean(); \/\/ todo: handle text } if ((flags & sftpconstants.ssh_filexfer_attr_mime_type) != 0) { @suppresswarnings(\"unused\") string mimetype = buffer.getstring(); \/\/ todo: handle mime-type } if ((flags & sftpconstants.ssh_filexfer_attr_link_count) != 0) { @suppresswarnings(\"unused\") int nlink = buffer.getint(); \/\/ todo: handle link-count } if ((flags & sftpconstants.ssh_filexfer_attr_untranslated_name) != 0) { @suppresswarnings(\"unused\") string untranslated = buffer.getstring(); \/\/ todo: handle untranslated-name } } } if ((flags & sftpconstants.ssh_filexfer_attr_extended) != 0) { attrs.put(\"extended\", readextensions(buffer)); } return attrs; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"if ((version >= sftpconstants.sftp_v6) && ((flags & sftpconstants.ssh_filexfer_attr_allocation_size) != 0)) { @suppresswarnings(\"unused\") long allocsize = buffer.getlong(); \/\/ todo handle allocation size } if ((flags & sftpconstants.ssh_filexfer_attr_ownergroup) != 0) {","code_context_10":"attrs.put(\"size\", buffer.getlong()); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_uidgid) != 0) { attrs.put(\"uid\", buffer.getint()); attrs.put(\"gid\", buffer.getint()); } } else { if ((version >= sftpconstants.sftp_v6) && ((flags & sftpconstants.ssh_filexfer_attr_allocation_size) != 0)) { @suppresswarnings(\"unused\") long allocsize = buffer.getlong(); \/\/ todo handle allocation size } if ((flags & sftpconstants.ssh_filexfer_attr_ownergroup) != 0) { attrs.put(\"owner\", new defaultgroupprincipal(buffer.getstring())); attrs.put(\"group\", new defaultgroupprincipal(buffer.getstring())); } } if ((flags & sftpconstants.ssh_filexfer_attr_permissions) != 0) { attrs.put(\"permissions\", permissionstoattributes(buffer.getint())); } if (version == sftpconstants.sftp_v3) {","code_context_20":"case sftpconstants.ssh_filexfer_type_socket: case sftpconstants.ssh_filexfer_type_char_device: case sftpconstants.ssh_filexfer_type_block_device: case sftpconstants.ssh_filexfer_type_fifo: attrs.put(\"isother\", boolean.true); break; default: \/\/ ignored } } if ((flags & sftpconstants.ssh_filexfer_attr_size) != 0) { attrs.put(\"size\", buffer.getlong()); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_uidgid) != 0) { attrs.put(\"uid\", buffer.getint()); attrs.put(\"gid\", buffer.getint()); } } else { if ((version >= sftpconstants.sftp_v6) && ((flags & sftpconstants.ssh_filexfer_attr_allocation_size) != 0)) { @suppresswarnings(\"unused\") long allocsize = buffer.getlong(); \/\/ todo handle allocation size } if ((flags & sftpconstants.ssh_filexfer_attr_ownergroup) != 0) { attrs.put(\"owner\", new defaultgroupprincipal(buffer.getstring())); attrs.put(\"group\", new defaultgroupprincipal(buffer.getstring())); } } if ((flags & sftpconstants.ssh_filexfer_attr_permissions) != 0) { attrs.put(\"permissions\", permissionstoattributes(buffer.getint())); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_acmodtime) != 0) { attrs.put(\"lastaccesstime\", readtime(buffer, version, flags)); attrs.put(\"lastmodifiedtime\", readtime(buffer, version, flags)); } } else if (version >= sftpconstants.sftp_v4) { if ((flags & sftpconstants.ssh_filexfer_attr_accesstime) != 0) { attrs.put(\"lastaccesstime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_createtime) != 0) { attrs.put(\"creationtime\", readtime(buffer, version, flags));","repo":"msohn\/mina-sshd"}
{"id":17264,"comment_id":2,"comment":"\/\/ todo: handle attrib bits","code":"public static navigablemap<string, object> readattrs(buffer buffer, int version) { navigablemap<string, object> attrs = new treemap<>(string.case_insensitive_order); int flags = buffer.getint(); if (version >= sftpconstants.sftp_v4) { int type = buffer.getubyte(); switch (type) { case sftpconstants.ssh_filexfer_type_regular: attrs.put(\"isregular\", boolean.true); break; case sftpconstants.ssh_filexfer_type_directory: attrs.put(\"isdirectory\", boolean.true); break; case sftpconstants.ssh_filexfer_type_symlink: attrs.put(\"issymboliclink\", boolean.true); break; case sftpconstants.ssh_filexfer_type_socket: case sftpconstants.ssh_filexfer_type_char_device: case sftpconstants.ssh_filexfer_type_block_device: case sftpconstants.ssh_filexfer_type_fifo: attrs.put(\"isother\", boolean.true); break; default: \/\/ ignored } } if ((flags & sftpconstants.ssh_filexfer_attr_size) != 0) { attrs.put(\"size\", buffer.getlong()); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_uidgid) != 0) { attrs.put(\"uid\", buffer.getint()); attrs.put(\"gid\", buffer.getint()); } } else { if ((version >= sftpconstants.sftp_v6) && ((flags & sftpconstants.ssh_filexfer_attr_allocation_size) != 0)) { @suppresswarnings(\"unused\") long allocsize = buffer.getlong(); \/\/ todo handle allocation size } if ((flags & sftpconstants.ssh_filexfer_attr_ownergroup) != 0) { attrs.put(\"owner\", new defaultgroupprincipal(buffer.getstring())); attrs.put(\"group\", new defaultgroupprincipal(buffer.getstring())); } } if ((flags & sftpconstants.ssh_filexfer_attr_permissions) != 0) { attrs.put(\"permissions\", permissionstoattributes(buffer.getint())); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_acmodtime) != 0) { attrs.put(\"lastaccesstime\", readtime(buffer, version, flags)); attrs.put(\"lastmodifiedtime\", readtime(buffer, version, flags)); } } else if (version >= sftpconstants.sftp_v4) { if ((flags & sftpconstants.ssh_filexfer_attr_accesstime) != 0) { attrs.put(\"lastaccesstime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_createtime) != 0) { attrs.put(\"creationtime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_modifytime) != 0) { attrs.put(\"lastmodifiedtime\", readtime(buffer, version, flags)); } if ((version >= sftpconstants.sftp_v6) && (flags & sftpconstants.ssh_filexfer_attr_ctime) != 0) { attrs.put(\"ctime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_acl) != 0) { attrs.put(\"acl\", readacls(buffer, version)); } if ((flags & sftpconstants.ssh_filexfer_attr_bits) != 0) { @suppresswarnings(\"unused\") int bits = buffer.getint(); @suppresswarnings(\"unused\") int valid = 0xffffffff; if (version >= sftpconstants.sftp_v6) { valid = buffer.getint(); } \/\/ todo: handle attrib bits } if (version >= sftpconstants.sftp_v6) { if ((flags & sftpconstants.ssh_filexfer_attr_text_hint) != 0) { @suppresswarnings(\"unused\") boolean text = buffer.getboolean(); \/\/ todo: handle text } if ((flags & sftpconstants.ssh_filexfer_attr_mime_type) != 0) { @suppresswarnings(\"unused\") string mimetype = buffer.getstring(); \/\/ todo: handle mime-type } if ((flags & sftpconstants.ssh_filexfer_attr_link_count) != 0) { @suppresswarnings(\"unused\") int nlink = buffer.getint(); \/\/ todo: handle link-count } if ((flags & sftpconstants.ssh_filexfer_attr_untranslated_name) != 0) { @suppresswarnings(\"unused\") string untranslated = buffer.getstring(); \/\/ todo: handle untranslated-name } } } if ((flags & sftpconstants.ssh_filexfer_attr_extended) != 0) { attrs.put(\"extended\", readextensions(buffer)); } return attrs; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"valid = buffer.getint(); } \/\/ todo: handle attrib bits } if (version >= sftpconstants.sftp_v6) {","code_context_10":"attrs.put(\"acl\", readacls(buffer, version)); } if ((flags & sftpconstants.ssh_filexfer_attr_bits) != 0) { @suppresswarnings(\"unused\") int bits = buffer.getint(); @suppresswarnings(\"unused\") int valid = 0xffffffff; if (version >= sftpconstants.sftp_v6) { valid = buffer.getint(); } \/\/ todo: handle attrib bits } if (version >= sftpconstants.sftp_v6) { if ((flags & sftpconstants.ssh_filexfer_attr_text_hint) != 0) { @suppresswarnings(\"unused\") boolean text = buffer.getboolean(); \/\/ todo: handle text } if ((flags & sftpconstants.ssh_filexfer_attr_mime_type) != 0) { @suppresswarnings(\"unused\") string mimetype = buffer.getstring(); \/\/ todo: handle mime-type }","code_context_20":"if ((flags & sftpconstants.ssh_filexfer_attr_createtime) != 0) { attrs.put(\"creationtime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_modifytime) != 0) { attrs.put(\"lastmodifiedtime\", readtime(buffer, version, flags)); } if ((version >= sftpconstants.sftp_v6) && (flags & sftpconstants.ssh_filexfer_attr_ctime) != 0) { attrs.put(\"ctime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_acl) != 0) { attrs.put(\"acl\", readacls(buffer, version)); } if ((flags & sftpconstants.ssh_filexfer_attr_bits) != 0) { @suppresswarnings(\"unused\") int bits = buffer.getint(); @suppresswarnings(\"unused\") int valid = 0xffffffff; if (version >= sftpconstants.sftp_v6) { valid = buffer.getint(); } \/\/ todo: handle attrib bits } if (version >= sftpconstants.sftp_v6) { if ((flags & sftpconstants.ssh_filexfer_attr_text_hint) != 0) { @suppresswarnings(\"unused\") boolean text = buffer.getboolean(); \/\/ todo: handle text } if ((flags & sftpconstants.ssh_filexfer_attr_mime_type) != 0) { @suppresswarnings(\"unused\") string mimetype = buffer.getstring(); \/\/ todo: handle mime-type } if ((flags & sftpconstants.ssh_filexfer_attr_link_count) != 0) { @suppresswarnings(\"unused\") int nlink = buffer.getint(); \/\/ todo: handle link-count } if ((flags & sftpconstants.ssh_filexfer_attr_untranslated_name) != 0) { @suppresswarnings(\"unused\") string untranslated = buffer.getstring(); \/\/ todo: handle untranslated-name } } }","repo":"msohn\/mina-sshd"}
{"id":17264,"comment_id":3,"comment":"\/\/ todo: handle text","code":"public static navigablemap<string, object> readattrs(buffer buffer, int version) { navigablemap<string, object> attrs = new treemap<>(string.case_insensitive_order); int flags = buffer.getint(); if (version >= sftpconstants.sftp_v4) { int type = buffer.getubyte(); switch (type) { case sftpconstants.ssh_filexfer_type_regular: attrs.put(\"isregular\", boolean.true); break; case sftpconstants.ssh_filexfer_type_directory: attrs.put(\"isdirectory\", boolean.true); break; case sftpconstants.ssh_filexfer_type_symlink: attrs.put(\"issymboliclink\", boolean.true); break; case sftpconstants.ssh_filexfer_type_socket: case sftpconstants.ssh_filexfer_type_char_device: case sftpconstants.ssh_filexfer_type_block_device: case sftpconstants.ssh_filexfer_type_fifo: attrs.put(\"isother\", boolean.true); break; default: \/\/ ignored } } if ((flags & sftpconstants.ssh_filexfer_attr_size) != 0) { attrs.put(\"size\", buffer.getlong()); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_uidgid) != 0) { attrs.put(\"uid\", buffer.getint()); attrs.put(\"gid\", buffer.getint()); } } else { if ((version >= sftpconstants.sftp_v6) && ((flags & sftpconstants.ssh_filexfer_attr_allocation_size) != 0)) { @suppresswarnings(\"unused\") long allocsize = buffer.getlong(); \/\/ todo handle allocation size } if ((flags & sftpconstants.ssh_filexfer_attr_ownergroup) != 0) { attrs.put(\"owner\", new defaultgroupprincipal(buffer.getstring())); attrs.put(\"group\", new defaultgroupprincipal(buffer.getstring())); } } if ((flags & sftpconstants.ssh_filexfer_attr_permissions) != 0) { attrs.put(\"permissions\", permissionstoattributes(buffer.getint())); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_acmodtime) != 0) { attrs.put(\"lastaccesstime\", readtime(buffer, version, flags)); attrs.put(\"lastmodifiedtime\", readtime(buffer, version, flags)); } } else if (version >= sftpconstants.sftp_v4) { if ((flags & sftpconstants.ssh_filexfer_attr_accesstime) != 0) { attrs.put(\"lastaccesstime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_createtime) != 0) { attrs.put(\"creationtime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_modifytime) != 0) { attrs.put(\"lastmodifiedtime\", readtime(buffer, version, flags)); } if ((version >= sftpconstants.sftp_v6) && (flags & sftpconstants.ssh_filexfer_attr_ctime) != 0) { attrs.put(\"ctime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_acl) != 0) { attrs.put(\"acl\", readacls(buffer, version)); } if ((flags & sftpconstants.ssh_filexfer_attr_bits) != 0) { @suppresswarnings(\"unused\") int bits = buffer.getint(); @suppresswarnings(\"unused\") int valid = 0xffffffff; if (version >= sftpconstants.sftp_v6) { valid = buffer.getint(); } \/\/ todo: handle attrib bits } if (version >= sftpconstants.sftp_v6) { if ((flags & sftpconstants.ssh_filexfer_attr_text_hint) != 0) { @suppresswarnings(\"unused\") boolean text = buffer.getboolean(); \/\/ todo: handle text } if ((flags & sftpconstants.ssh_filexfer_attr_mime_type) != 0) { @suppresswarnings(\"unused\") string mimetype = buffer.getstring(); \/\/ todo: handle mime-type } if ((flags & sftpconstants.ssh_filexfer_attr_link_count) != 0) { @suppresswarnings(\"unused\") int nlink = buffer.getint(); \/\/ todo: handle link-count } if ((flags & sftpconstants.ssh_filexfer_attr_untranslated_name) != 0) { @suppresswarnings(\"unused\") string untranslated = buffer.getstring(); \/\/ todo: handle untranslated-name } } } if ((flags & sftpconstants.ssh_filexfer_attr_extended) != 0) { attrs.put(\"extended\", readextensions(buffer)); } return attrs; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"if ((flags & sftpconstants.ssh_filexfer_attr_text_hint) != 0) { @suppresswarnings(\"unused\") boolean text = buffer.getboolean(); \/\/ todo: handle text } if ((flags & sftpconstants.ssh_filexfer_attr_mime_type) != 0) {","code_context_10":"@suppresswarnings(\"unused\") int valid = 0xffffffff; if (version >= sftpconstants.sftp_v6) { valid = buffer.getint(); } \/\/ todo: handle attrib bits } if (version >= sftpconstants.sftp_v6) { if ((flags & sftpconstants.ssh_filexfer_attr_text_hint) != 0) { @suppresswarnings(\"unused\") boolean text = buffer.getboolean(); \/\/ todo: handle text } if ((flags & sftpconstants.ssh_filexfer_attr_mime_type) != 0) { @suppresswarnings(\"unused\") string mimetype = buffer.getstring(); \/\/ todo: handle mime-type } if ((flags & sftpconstants.ssh_filexfer_attr_link_count) != 0) { @suppresswarnings(\"unused\") int nlink = buffer.getint(); \/\/ todo: handle link-count } if ((flags & sftpconstants.ssh_filexfer_attr_untranslated_name) != 0) {","code_context_20":"} if ((version >= sftpconstants.sftp_v6) && (flags & sftpconstants.ssh_filexfer_attr_ctime) != 0) { attrs.put(\"ctime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_acl) != 0) { attrs.put(\"acl\", readacls(buffer, version)); } if ((flags & sftpconstants.ssh_filexfer_attr_bits) != 0) { @suppresswarnings(\"unused\") int bits = buffer.getint(); @suppresswarnings(\"unused\") int valid = 0xffffffff; if (version >= sftpconstants.sftp_v6) { valid = buffer.getint(); } \/\/ todo: handle attrib bits } if (version >= sftpconstants.sftp_v6) { if ((flags & sftpconstants.ssh_filexfer_attr_text_hint) != 0) { @suppresswarnings(\"unused\") boolean text = buffer.getboolean(); \/\/ todo: handle text } if ((flags & sftpconstants.ssh_filexfer_attr_mime_type) != 0) { @suppresswarnings(\"unused\") string mimetype = buffer.getstring(); \/\/ todo: handle mime-type } if ((flags & sftpconstants.ssh_filexfer_attr_link_count) != 0) { @suppresswarnings(\"unused\") int nlink = buffer.getint(); \/\/ todo: handle link-count } if ((flags & sftpconstants.ssh_filexfer_attr_untranslated_name) != 0) { @suppresswarnings(\"unused\") string untranslated = buffer.getstring(); \/\/ todo: handle untranslated-name } } } if ((flags & sftpconstants.ssh_filexfer_attr_extended) != 0) { attrs.put(\"extended\", readextensions(buffer)); } return attrs; }","repo":"msohn\/mina-sshd"}
{"id":17264,"comment_id":4,"comment":"\/\/ todo: handle mime-type","code":"public static navigablemap<string, object> readattrs(buffer buffer, int version) { navigablemap<string, object> attrs = new treemap<>(string.case_insensitive_order); int flags = buffer.getint(); if (version >= sftpconstants.sftp_v4) { int type = buffer.getubyte(); switch (type) { case sftpconstants.ssh_filexfer_type_regular: attrs.put(\"isregular\", boolean.true); break; case sftpconstants.ssh_filexfer_type_directory: attrs.put(\"isdirectory\", boolean.true); break; case sftpconstants.ssh_filexfer_type_symlink: attrs.put(\"issymboliclink\", boolean.true); break; case sftpconstants.ssh_filexfer_type_socket: case sftpconstants.ssh_filexfer_type_char_device: case sftpconstants.ssh_filexfer_type_block_device: case sftpconstants.ssh_filexfer_type_fifo: attrs.put(\"isother\", boolean.true); break; default: \/\/ ignored } } if ((flags & sftpconstants.ssh_filexfer_attr_size) != 0) { attrs.put(\"size\", buffer.getlong()); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_uidgid) != 0) { attrs.put(\"uid\", buffer.getint()); attrs.put(\"gid\", buffer.getint()); } } else { if ((version >= sftpconstants.sftp_v6) && ((flags & sftpconstants.ssh_filexfer_attr_allocation_size) != 0)) { @suppresswarnings(\"unused\") long allocsize = buffer.getlong(); \/\/ todo handle allocation size } if ((flags & sftpconstants.ssh_filexfer_attr_ownergroup) != 0) { attrs.put(\"owner\", new defaultgroupprincipal(buffer.getstring())); attrs.put(\"group\", new defaultgroupprincipal(buffer.getstring())); } } if ((flags & sftpconstants.ssh_filexfer_attr_permissions) != 0) { attrs.put(\"permissions\", permissionstoattributes(buffer.getint())); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_acmodtime) != 0) { attrs.put(\"lastaccesstime\", readtime(buffer, version, flags)); attrs.put(\"lastmodifiedtime\", readtime(buffer, version, flags)); } } else if (version >= sftpconstants.sftp_v4) { if ((flags & sftpconstants.ssh_filexfer_attr_accesstime) != 0) { attrs.put(\"lastaccesstime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_createtime) != 0) { attrs.put(\"creationtime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_modifytime) != 0) { attrs.put(\"lastmodifiedtime\", readtime(buffer, version, flags)); } if ((version >= sftpconstants.sftp_v6) && (flags & sftpconstants.ssh_filexfer_attr_ctime) != 0) { attrs.put(\"ctime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_acl) != 0) { attrs.put(\"acl\", readacls(buffer, version)); } if ((flags & sftpconstants.ssh_filexfer_attr_bits) != 0) { @suppresswarnings(\"unused\") int bits = buffer.getint(); @suppresswarnings(\"unused\") int valid = 0xffffffff; if (version >= sftpconstants.sftp_v6) { valid = buffer.getint(); } \/\/ todo: handle attrib bits } if (version >= sftpconstants.sftp_v6) { if ((flags & sftpconstants.ssh_filexfer_attr_text_hint) != 0) { @suppresswarnings(\"unused\") boolean text = buffer.getboolean(); \/\/ todo: handle text } if ((flags & sftpconstants.ssh_filexfer_attr_mime_type) != 0) { @suppresswarnings(\"unused\") string mimetype = buffer.getstring(); \/\/ todo: handle mime-type } if ((flags & sftpconstants.ssh_filexfer_attr_link_count) != 0) { @suppresswarnings(\"unused\") int nlink = buffer.getint(); \/\/ todo: handle link-count } if ((flags & sftpconstants.ssh_filexfer_attr_untranslated_name) != 0) { @suppresswarnings(\"unused\") string untranslated = buffer.getstring(); \/\/ todo: handle untranslated-name } } } if ((flags & sftpconstants.ssh_filexfer_attr_extended) != 0) { attrs.put(\"extended\", readextensions(buffer)); } return attrs; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"if ((flags & sftpconstants.ssh_filexfer_attr_mime_type) != 0) { @suppresswarnings(\"unused\") string mimetype = buffer.getstring(); \/\/ todo: handle mime-type } if ((flags & sftpconstants.ssh_filexfer_attr_link_count) != 0) {","code_context_10":"} \/\/ todo: handle attrib bits } if (version >= sftpconstants.sftp_v6) { if ((flags & sftpconstants.ssh_filexfer_attr_text_hint) != 0) { @suppresswarnings(\"unused\") boolean text = buffer.getboolean(); \/\/ todo: handle text } if ((flags & sftpconstants.ssh_filexfer_attr_mime_type) != 0) { @suppresswarnings(\"unused\") string mimetype = buffer.getstring(); \/\/ todo: handle mime-type } if ((flags & sftpconstants.ssh_filexfer_attr_link_count) != 0) { @suppresswarnings(\"unused\") int nlink = buffer.getint(); \/\/ todo: handle link-count } if ((flags & sftpconstants.ssh_filexfer_attr_untranslated_name) != 0) { @suppresswarnings(\"unused\") string untranslated = buffer.getstring(); \/\/ todo: handle untranslated-name } }","code_context_20":"if ((flags & sftpconstants.ssh_filexfer_attr_acl) != 0) { attrs.put(\"acl\", readacls(buffer, version)); } if ((flags & sftpconstants.ssh_filexfer_attr_bits) != 0) { @suppresswarnings(\"unused\") int bits = buffer.getint(); @suppresswarnings(\"unused\") int valid = 0xffffffff; if (version >= sftpconstants.sftp_v6) { valid = buffer.getint(); } \/\/ todo: handle attrib bits } if (version >= sftpconstants.sftp_v6) { if ((flags & sftpconstants.ssh_filexfer_attr_text_hint) != 0) { @suppresswarnings(\"unused\") boolean text = buffer.getboolean(); \/\/ todo: handle text } if ((flags & sftpconstants.ssh_filexfer_attr_mime_type) != 0) { @suppresswarnings(\"unused\") string mimetype = buffer.getstring(); \/\/ todo: handle mime-type } if ((flags & sftpconstants.ssh_filexfer_attr_link_count) != 0) { @suppresswarnings(\"unused\") int nlink = buffer.getint(); \/\/ todo: handle link-count } if ((flags & sftpconstants.ssh_filexfer_attr_untranslated_name) != 0) { @suppresswarnings(\"unused\") string untranslated = buffer.getstring(); \/\/ todo: handle untranslated-name } } } if ((flags & sftpconstants.ssh_filexfer_attr_extended) != 0) { attrs.put(\"extended\", readextensions(buffer)); } return attrs; }","repo":"msohn\/mina-sshd"}
{"id":17264,"comment_id":5,"comment":"\/\/ todo: handle link-count","code":"public static navigablemap<string, object> readattrs(buffer buffer, int version) { navigablemap<string, object> attrs = new treemap<>(string.case_insensitive_order); int flags = buffer.getint(); if (version >= sftpconstants.sftp_v4) { int type = buffer.getubyte(); switch (type) { case sftpconstants.ssh_filexfer_type_regular: attrs.put(\"isregular\", boolean.true); break; case sftpconstants.ssh_filexfer_type_directory: attrs.put(\"isdirectory\", boolean.true); break; case sftpconstants.ssh_filexfer_type_symlink: attrs.put(\"issymboliclink\", boolean.true); break; case sftpconstants.ssh_filexfer_type_socket: case sftpconstants.ssh_filexfer_type_char_device: case sftpconstants.ssh_filexfer_type_block_device: case sftpconstants.ssh_filexfer_type_fifo: attrs.put(\"isother\", boolean.true); break; default: \/\/ ignored } } if ((flags & sftpconstants.ssh_filexfer_attr_size) != 0) { attrs.put(\"size\", buffer.getlong()); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_uidgid) != 0) { attrs.put(\"uid\", buffer.getint()); attrs.put(\"gid\", buffer.getint()); } } else { if ((version >= sftpconstants.sftp_v6) && ((flags & sftpconstants.ssh_filexfer_attr_allocation_size) != 0)) { @suppresswarnings(\"unused\") long allocsize = buffer.getlong(); \/\/ todo handle allocation size } if ((flags & sftpconstants.ssh_filexfer_attr_ownergroup) != 0) { attrs.put(\"owner\", new defaultgroupprincipal(buffer.getstring())); attrs.put(\"group\", new defaultgroupprincipal(buffer.getstring())); } } if ((flags & sftpconstants.ssh_filexfer_attr_permissions) != 0) { attrs.put(\"permissions\", permissionstoattributes(buffer.getint())); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_acmodtime) != 0) { attrs.put(\"lastaccesstime\", readtime(buffer, version, flags)); attrs.put(\"lastmodifiedtime\", readtime(buffer, version, flags)); } } else if (version >= sftpconstants.sftp_v4) { if ((flags & sftpconstants.ssh_filexfer_attr_accesstime) != 0) { attrs.put(\"lastaccesstime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_createtime) != 0) { attrs.put(\"creationtime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_modifytime) != 0) { attrs.put(\"lastmodifiedtime\", readtime(buffer, version, flags)); } if ((version >= sftpconstants.sftp_v6) && (flags & sftpconstants.ssh_filexfer_attr_ctime) != 0) { attrs.put(\"ctime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_acl) != 0) { attrs.put(\"acl\", readacls(buffer, version)); } if ((flags & sftpconstants.ssh_filexfer_attr_bits) != 0) { @suppresswarnings(\"unused\") int bits = buffer.getint(); @suppresswarnings(\"unused\") int valid = 0xffffffff; if (version >= sftpconstants.sftp_v6) { valid = buffer.getint(); } \/\/ todo: handle attrib bits } if (version >= sftpconstants.sftp_v6) { if ((flags & sftpconstants.ssh_filexfer_attr_text_hint) != 0) { @suppresswarnings(\"unused\") boolean text = buffer.getboolean(); \/\/ todo: handle text } if ((flags & sftpconstants.ssh_filexfer_attr_mime_type) != 0) { @suppresswarnings(\"unused\") string mimetype = buffer.getstring(); \/\/ todo: handle mime-type } if ((flags & sftpconstants.ssh_filexfer_attr_link_count) != 0) { @suppresswarnings(\"unused\") int nlink = buffer.getint(); \/\/ todo: handle link-count } if ((flags & sftpconstants.ssh_filexfer_attr_untranslated_name) != 0) { @suppresswarnings(\"unused\") string untranslated = buffer.getstring(); \/\/ todo: handle untranslated-name } } } if ((flags & sftpconstants.ssh_filexfer_attr_extended) != 0) { attrs.put(\"extended\", readextensions(buffer)); } return attrs; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"if ((flags & sftpconstants.ssh_filexfer_attr_link_count) != 0) { @suppresswarnings(\"unused\") int nlink = buffer.getint(); \/\/ todo: handle link-count } if ((flags & sftpconstants.ssh_filexfer_attr_untranslated_name) != 0) {","code_context_10":"if ((flags & sftpconstants.ssh_filexfer_attr_text_hint) != 0) { @suppresswarnings(\"unused\") boolean text = buffer.getboolean(); \/\/ todo: handle text } if ((flags & sftpconstants.ssh_filexfer_attr_mime_type) != 0) { @suppresswarnings(\"unused\") string mimetype = buffer.getstring(); \/\/ todo: handle mime-type } if ((flags & sftpconstants.ssh_filexfer_attr_link_count) != 0) { @suppresswarnings(\"unused\") int nlink = buffer.getint(); \/\/ todo: handle link-count } if ((flags & sftpconstants.ssh_filexfer_attr_untranslated_name) != 0) { @suppresswarnings(\"unused\") string untranslated = buffer.getstring(); \/\/ todo: handle untranslated-name } } } if ((flags & sftpconstants.ssh_filexfer_attr_extended) != 0) { attrs.put(\"extended\", readextensions(buffer)); }","code_context_20":"@suppresswarnings(\"unused\") int bits = buffer.getint(); @suppresswarnings(\"unused\") int valid = 0xffffffff; if (version >= sftpconstants.sftp_v6) { valid = buffer.getint(); } \/\/ todo: handle attrib bits } if (version >= sftpconstants.sftp_v6) { if ((flags & sftpconstants.ssh_filexfer_attr_text_hint) != 0) { @suppresswarnings(\"unused\") boolean text = buffer.getboolean(); \/\/ todo: handle text } if ((flags & sftpconstants.ssh_filexfer_attr_mime_type) != 0) { @suppresswarnings(\"unused\") string mimetype = buffer.getstring(); \/\/ todo: handle mime-type } if ((flags & sftpconstants.ssh_filexfer_attr_link_count) != 0) { @suppresswarnings(\"unused\") int nlink = buffer.getint(); \/\/ todo: handle link-count } if ((flags & sftpconstants.ssh_filexfer_attr_untranslated_name) != 0) { @suppresswarnings(\"unused\") string untranslated = buffer.getstring(); \/\/ todo: handle untranslated-name } } } if ((flags & sftpconstants.ssh_filexfer_attr_extended) != 0) { attrs.put(\"extended\", readextensions(buffer)); } return attrs; }","repo":"msohn\/mina-sshd"}
{"id":17264,"comment_id":6,"comment":"\/\/ todo: handle untranslated-name","code":"public static navigablemap<string, object> readattrs(buffer buffer, int version) { navigablemap<string, object> attrs = new treemap<>(string.case_insensitive_order); int flags = buffer.getint(); if (version >= sftpconstants.sftp_v4) { int type = buffer.getubyte(); switch (type) { case sftpconstants.ssh_filexfer_type_regular: attrs.put(\"isregular\", boolean.true); break; case sftpconstants.ssh_filexfer_type_directory: attrs.put(\"isdirectory\", boolean.true); break; case sftpconstants.ssh_filexfer_type_symlink: attrs.put(\"issymboliclink\", boolean.true); break; case sftpconstants.ssh_filexfer_type_socket: case sftpconstants.ssh_filexfer_type_char_device: case sftpconstants.ssh_filexfer_type_block_device: case sftpconstants.ssh_filexfer_type_fifo: attrs.put(\"isother\", boolean.true); break; default: \/\/ ignored } } if ((flags & sftpconstants.ssh_filexfer_attr_size) != 0) { attrs.put(\"size\", buffer.getlong()); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_uidgid) != 0) { attrs.put(\"uid\", buffer.getint()); attrs.put(\"gid\", buffer.getint()); } } else { if ((version >= sftpconstants.sftp_v6) && ((flags & sftpconstants.ssh_filexfer_attr_allocation_size) != 0)) { @suppresswarnings(\"unused\") long allocsize = buffer.getlong(); \/\/ todo handle allocation size } if ((flags & sftpconstants.ssh_filexfer_attr_ownergroup) != 0) { attrs.put(\"owner\", new defaultgroupprincipal(buffer.getstring())); attrs.put(\"group\", new defaultgroupprincipal(buffer.getstring())); } } if ((flags & sftpconstants.ssh_filexfer_attr_permissions) != 0) { attrs.put(\"permissions\", permissionstoattributes(buffer.getint())); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_acmodtime) != 0) { attrs.put(\"lastaccesstime\", readtime(buffer, version, flags)); attrs.put(\"lastmodifiedtime\", readtime(buffer, version, flags)); } } else if (version >= sftpconstants.sftp_v4) { if ((flags & sftpconstants.ssh_filexfer_attr_accesstime) != 0) { attrs.put(\"lastaccesstime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_createtime) != 0) { attrs.put(\"creationtime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_modifytime) != 0) { attrs.put(\"lastmodifiedtime\", readtime(buffer, version, flags)); } if ((version >= sftpconstants.sftp_v6) && (flags & sftpconstants.ssh_filexfer_attr_ctime) != 0) { attrs.put(\"ctime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_acl) != 0) { attrs.put(\"acl\", readacls(buffer, version)); } if ((flags & sftpconstants.ssh_filexfer_attr_bits) != 0) { @suppresswarnings(\"unused\") int bits = buffer.getint(); @suppresswarnings(\"unused\") int valid = 0xffffffff; if (version >= sftpconstants.sftp_v6) { valid = buffer.getint(); } \/\/ todo: handle attrib bits } if (version >= sftpconstants.sftp_v6) { if ((flags & sftpconstants.ssh_filexfer_attr_text_hint) != 0) { @suppresswarnings(\"unused\") boolean text = buffer.getboolean(); \/\/ todo: handle text } if ((flags & sftpconstants.ssh_filexfer_attr_mime_type) != 0) { @suppresswarnings(\"unused\") string mimetype = buffer.getstring(); \/\/ todo: handle mime-type } if ((flags & sftpconstants.ssh_filexfer_attr_link_count) != 0) { @suppresswarnings(\"unused\") int nlink = buffer.getint(); \/\/ todo: handle link-count } if ((flags & sftpconstants.ssh_filexfer_attr_untranslated_name) != 0) { @suppresswarnings(\"unused\") string untranslated = buffer.getstring(); \/\/ todo: handle untranslated-name } } } if ((flags & sftpconstants.ssh_filexfer_attr_extended) != 0) { attrs.put(\"extended\", readextensions(buffer)); } return attrs; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"if ((flags & sftpconstants.ssh_filexfer_attr_untranslated_name) != 0) { @suppresswarnings(\"unused\") string untranslated = buffer.getstring(); \/\/ todo: handle untranslated-name } }","code_context_10":"if ((flags & sftpconstants.ssh_filexfer_attr_mime_type) != 0) { @suppresswarnings(\"unused\") string mimetype = buffer.getstring(); \/\/ todo: handle mime-type } if ((flags & sftpconstants.ssh_filexfer_attr_link_count) != 0) { @suppresswarnings(\"unused\") int nlink = buffer.getint(); \/\/ todo: handle link-count } if ((flags & sftpconstants.ssh_filexfer_attr_untranslated_name) != 0) { @suppresswarnings(\"unused\") string untranslated = buffer.getstring(); \/\/ todo: handle untranslated-name } } } if ((flags & sftpconstants.ssh_filexfer_attr_extended) != 0) { attrs.put(\"extended\", readextensions(buffer)); } return attrs; }","code_context_20":"if (version >= sftpconstants.sftp_v6) { valid = buffer.getint(); } \/\/ todo: handle attrib bits } if (version >= sftpconstants.sftp_v6) { if ((flags & sftpconstants.ssh_filexfer_attr_text_hint) != 0) { @suppresswarnings(\"unused\") boolean text = buffer.getboolean(); \/\/ todo: handle text } if ((flags & sftpconstants.ssh_filexfer_attr_mime_type) != 0) { @suppresswarnings(\"unused\") string mimetype = buffer.getstring(); \/\/ todo: handle mime-type } if ((flags & sftpconstants.ssh_filexfer_attr_link_count) != 0) { @suppresswarnings(\"unused\") int nlink = buffer.getint(); \/\/ todo: handle link-count } if ((flags & sftpconstants.ssh_filexfer_attr_untranslated_name) != 0) { @suppresswarnings(\"unused\") string untranslated = buffer.getstring(); \/\/ todo: handle untranslated-name } } } if ((flags & sftpconstants.ssh_filexfer_attr_extended) != 0) { attrs.put(\"extended\", readextensions(buffer)); } return attrs; }","repo":"msohn\/mina-sshd"}
{"id":17318,"comment_id":0,"comment":"\/\/ store chnages in manifest","code":"@override void storeproperties() throws ioexception { super.storeproperties(); \/\/ store chnages in manifest storemanifestchanges(); \/\/ store localized info if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { \/\/ store friends packages pxm.replacefriends(friends, publicpkgs); } else { \/\/ store public packages pxm.replacepublicpackages(publicpkgs); } refreshmodulelist = true; } \/\/ store class-path-extensions + its src & javadoc if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel); map<string, string> newcpext = new hashmap<string, string>(); for (item item : cpextlist) { string binpath = item.getfilepath(); if (binpath != null) { fileobject fo = fileutil.tofileobject(propertyutils.resolvefile(getprojectdirectoryfile(), binpath)); if(fo != null) { string runtimepath = apisupportantutils.cpext_runtime_relative_path + fo.getnameext(); newcpext.put(runtimepath, binpath); } } } \/\/ delete removed jars, remove any remaining exported packages and src&javadoc refs left iterator<item> it = getcpextiterator(); hashset<string> jarsset = new hashset<string>(newcpext.values()); while (it.hasnext()) { item item = it.next(); if (!jarsset.contains(item.getfilepath())) { \/\/ xxx deleting here doesn't work on windows: \/\/ file f = propertyutils.resolvefile(getprojectdirectoryfile(), item.getfilepath()); \/\/ fileobject todel = fileutil.tofileobject(f); \/\/ if (todel != null) { \/\/ todel.delete(); \/\/ } assert item.getreference() != null : \"getcpextiterator() initializes references to wrapped jars\"; item.removesourceandjavadoc(getupdatehelper()); getrefhelper().destroyreference(item.getreference()); } } cps.encodetostrings(cpextlist, cpext); pxm.replaceclasspathextensions(newcpext); wrappedjarschanged = false; } if (isstandalone()) { moduleproperties.storeplatform(gethelper(), getactiveplatform()); if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), false); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(getprojectdirectoryfile()); } } else if (issuitecomponent() && refreshmodulelist) { modulelist.refreshmodulelistforroot(getsuitedirectory()); } else if (isnetbeansorg()) { if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), true); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(modulelist.findnetbeansorg(getprojectdirectoryfile())); } } }","classification":"NONSATD","isFinished":true,"code_context_2":"void storeproperties() throws ioexception { super.storeproperties(); \/\/ store chnages in manifest storemanifestchanges(); \/\/ store localized info","code_context_10":"@override void storeproperties() throws ioexception { super.storeproperties(); \/\/ store chnages in manifest storemanifestchanges(); \/\/ store localized info if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) {","code_context_20":"@override void storeproperties() throws ioexception { super.storeproperties(); \/\/ store chnages in manifest storemanifestchanges(); \/\/ store localized info if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages();","repo":"pokebadgerswithspoon\/incubator-netbeans"}
{"id":17318,"comment_id":1,"comment":"\/\/ store localized info","code":"@override void storeproperties() throws ioexception { super.storeproperties(); \/\/ store chnages in manifest storemanifestchanges(); \/\/ store localized info if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { \/\/ store friends packages pxm.replacefriends(friends, publicpkgs); } else { \/\/ store public packages pxm.replacepublicpackages(publicpkgs); } refreshmodulelist = true; } \/\/ store class-path-extensions + its src & javadoc if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel); map<string, string> newcpext = new hashmap<string, string>(); for (item item : cpextlist) { string binpath = item.getfilepath(); if (binpath != null) { fileobject fo = fileutil.tofileobject(propertyutils.resolvefile(getprojectdirectoryfile(), binpath)); if(fo != null) { string runtimepath = apisupportantutils.cpext_runtime_relative_path + fo.getnameext(); newcpext.put(runtimepath, binpath); } } } \/\/ delete removed jars, remove any remaining exported packages and src&javadoc refs left iterator<item> it = getcpextiterator(); hashset<string> jarsset = new hashset<string>(newcpext.values()); while (it.hasnext()) { item item = it.next(); if (!jarsset.contains(item.getfilepath())) { \/\/ xxx deleting here doesn't work on windows: \/\/ file f = propertyutils.resolvefile(getprojectdirectoryfile(), item.getfilepath()); \/\/ fileobject todel = fileutil.tofileobject(f); \/\/ if (todel != null) { \/\/ todel.delete(); \/\/ } assert item.getreference() != null : \"getcpextiterator() initializes references to wrapped jars\"; item.removesourceandjavadoc(getupdatehelper()); getrefhelper().destroyreference(item.getreference()); } } cps.encodetostrings(cpextlist, cpext); pxm.replaceclasspathextensions(newcpext); wrappedjarschanged = false; } if (isstandalone()) { moduleproperties.storeplatform(gethelper(), getactiveplatform()); if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), false); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(getprojectdirectoryfile()); } } else if (issuitecomponent() && refreshmodulelist) { modulelist.refreshmodulelistforroot(getsuitedirectory()); } else if (isnetbeansorg()) { if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), true); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(modulelist.findnetbeansorg(getprojectdirectoryfile())); } } }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ store chnages in manifest storemanifestchanges(); \/\/ store localized info if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store();","code_context_10":"@override void storeproperties() throws ioexception { super.storeproperties(); \/\/ store chnages in manifest storemanifestchanges(); \/\/ store localized info if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n","code_context_20":"@override void storeproperties() throws ioexception { super.storeproperties(); \/\/ store chnages in manifest storemanifestchanges(); \/\/ store localized info if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) {","repo":"pokebadgerswithspoon\/incubator-netbeans"}
{"id":17318,"comment_id":2,"comment":"\/\/ xxx else ignore for now but we could save into some default location","code":"@override void storeproperties() throws ioexception { super.storeproperties(); \/\/ store chnages in manifest storemanifestchanges(); \/\/ store localized info if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { \/\/ store friends packages pxm.replacefriends(friends, publicpkgs); } else { \/\/ store public packages pxm.replacepublicpackages(publicpkgs); } refreshmodulelist = true; } \/\/ store class-path-extensions + its src & javadoc if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel); map<string, string> newcpext = new hashmap<string, string>(); for (item item : cpextlist) { string binpath = item.getfilepath(); if (binpath != null) { fileobject fo = fileutil.tofileobject(propertyutils.resolvefile(getprojectdirectoryfile(), binpath)); if(fo != null) { string runtimepath = apisupportantutils.cpext_runtime_relative_path + fo.getnameext(); newcpext.put(runtimepath, binpath); } } } \/\/ delete removed jars, remove any remaining exported packages and src&javadoc refs left iterator<item> it = getcpextiterator(); hashset<string> jarsset = new hashset<string>(newcpext.values()); while (it.hasnext()) { item item = it.next(); if (!jarsset.contains(item.getfilepath())) { \/\/ xxx deleting here doesn't work on windows: \/\/ file f = propertyutils.resolvefile(getprojectdirectoryfile(), item.getfilepath()); \/\/ fileobject todel = fileutil.tofileobject(f); \/\/ if (todel != null) { \/\/ todel.delete(); \/\/ } assert item.getreference() != null : \"getcpextiterator() initializes references to wrapped jars\"; item.removesourceandjavadoc(getupdatehelper()); getrefhelper().destroyreference(item.getreference()); } } cps.encodetostrings(cpextlist, cpext); pxm.replaceclasspathextensions(newcpext); wrappedjarschanged = false; } if (isstandalone()) { moduleproperties.storeplatform(gethelper(), getactiveplatform()); if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), false); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(getprojectdirectoryfile()); } } else if (issuitecomponent() && refreshmodulelist) { modulelist.refreshmodulelistforroot(getsuitedirectory()); } else if (isnetbeansorg()) { if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), true); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(modulelist.findnetbeansorg(getprojectdirectoryfile())); } } }","classification":"DESIGN","isFinished":true,"code_context_2":"if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes","code_context_10":"@override void storeproperties() throws ioexception { super.storeproperties(); \/\/ store chnages in manifest storemanifestchanges(); \/\/ store localized info if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) {","code_context_20":"@override void storeproperties() throws ioexception { super.storeproperties(); \/\/ store chnages in manifest storemanifestchanges(); \/\/ store localized info if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { \/\/ store friends packages pxm.replacefriends(friends, publicpkgs); } else { \/\/ store public packages","repo":"pokebadgerswithspoon\/incubator-netbeans"}
{"id":17318,"comment_id":3,"comment":"\/\/ store project.xml changes \/\/ store module dependencies","code":"@override void storeproperties() throws ioexception { super.storeproperties(); \/\/ store chnages in manifest storemanifestchanges(); \/\/ store localized info if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { \/\/ store friends packages pxm.replacefriends(friends, publicpkgs); } else { \/\/ store public packages pxm.replacepublicpackages(publicpkgs); } refreshmodulelist = true; } \/\/ store class-path-extensions + its src & javadoc if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel); map<string, string> newcpext = new hashmap<string, string>(); for (item item : cpextlist) { string binpath = item.getfilepath(); if (binpath != null) { fileobject fo = fileutil.tofileobject(propertyutils.resolvefile(getprojectdirectoryfile(), binpath)); if(fo != null) { string runtimepath = apisupportantutils.cpext_runtime_relative_path + fo.getnameext(); newcpext.put(runtimepath, binpath); } } } \/\/ delete removed jars, remove any remaining exported packages and src&javadoc refs left iterator<item> it = getcpextiterator(); hashset<string> jarsset = new hashset<string>(newcpext.values()); while (it.hasnext()) { item item = it.next(); if (!jarsset.contains(item.getfilepath())) { \/\/ xxx deleting here doesn't work on windows: \/\/ file f = propertyutils.resolvefile(getprojectdirectoryfile(), item.getfilepath()); \/\/ fileobject todel = fileutil.tofileobject(f); \/\/ if (todel != null) { \/\/ todel.delete(); \/\/ } assert item.getreference() != null : \"getcpextiterator() initializes references to wrapped jars\"; item.removesourceandjavadoc(getupdatehelper()); getrefhelper().destroyreference(item.getreference()); } } cps.encodetostrings(cpextlist, cpext); pxm.replaceclasspathextensions(newcpext); wrappedjarschanged = false; } if (isstandalone()) { moduleproperties.storeplatform(gethelper(), getactiveplatform()); if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), false); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(getprojectdirectoryfile()); } } else if (issuitecomponent() && refreshmodulelist) { modulelist.refreshmodulelistforroot(getsuitedirectory()); } else if (isnetbeansorg()) { if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), true); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(modulelist.findnetbeansorg(getprojectdirectoryfile())); } } }","classification":"NONSATD","isFinished":true,"code_context_2":"} \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) {","code_context_10":"@override void storeproperties() throws ioexception { super.storeproperties(); \/\/ store chnages in manifest storemanifestchanges(); \/\/ store localized info if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } }","code_context_20":"@override void storeproperties() throws ioexception { super.storeproperties(); \/\/ store chnages in manifest storemanifestchanges(); \/\/ store localized info if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { \/\/ store friends packages pxm.replacefriends(friends, publicpkgs); } else { \/\/ store public packages pxm.replacepublicpackages(publicpkgs); } refreshmodulelist = true;","repo":"pokebadgerswithspoon\/incubator-netbeans"}
{"id":17318,"comment_id":4,"comment":"\/\/ noi18n","code":"@override void storeproperties() throws ioexception { super.storeproperties(); \/\/ store chnages in manifest storemanifestchanges(); \/\/ store localized info if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { \/\/ store friends packages pxm.replacefriends(friends, publicpkgs); } else { \/\/ store public packages pxm.replacepublicpackages(publicpkgs); } refreshmodulelist = true; } \/\/ store class-path-extensions + its src & javadoc if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel); map<string, string> newcpext = new hashmap<string, string>(); for (item item : cpextlist) { string binpath = item.getfilepath(); if (binpath != null) { fileobject fo = fileutil.tofileobject(propertyutils.resolvefile(getprojectdirectoryfile(), binpath)); if(fo != null) { string runtimepath = apisupportantutils.cpext_runtime_relative_path + fo.getnameext(); newcpext.put(runtimepath, binpath); } } } \/\/ delete removed jars, remove any remaining exported packages and src&javadoc refs left iterator<item> it = getcpextiterator(); hashset<string> jarsset = new hashset<string>(newcpext.values()); while (it.hasnext()) { item item = it.next(); if (!jarsset.contains(item.getfilepath())) { \/\/ xxx deleting here doesn't work on windows: \/\/ file f = propertyutils.resolvefile(getprojectdirectoryfile(), item.getfilepath()); \/\/ fileobject todel = fileutil.tofileobject(f); \/\/ if (todel != null) { \/\/ todel.delete(); \/\/ } assert item.getreference() != null : \"getcpextiterator() initializes references to wrapped jars\"; item.removesourceandjavadoc(getupdatehelper()); getrefhelper().destroyreference(item.getreference()); } } cps.encodetostrings(cpextlist, cpext); pxm.replaceclasspathextensions(newcpext); wrappedjarschanged = false; } if (isstandalone()) { moduleproperties.storeplatform(gethelper(), getactiveplatform()); if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), false); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(getprojectdirectoryfile()); } } else if (issuitecomponent() && refreshmodulelist) { modulelist.refreshmodulelistforroot(getsuitedirectory()); } else if (isnetbeansorg()) { if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), true); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(modulelist.findnetbeansorg(getprojectdirectoryfile())); } } }","classification":"NONSATD","isFinished":true,"code_context_2":"if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave);","code_context_10":"\/\/ store localized info if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) {","code_context_20":"@override void storeproperties() throws ioexception { super.storeproperties(); \/\/ store chnages in manifest storemanifestchanges(); \/\/ store localized info if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { \/\/ store friends packages pxm.replacefriends(friends, publicpkgs); } else { \/\/ store public packages pxm.replacepublicpackages(publicpkgs); } refreshmodulelist = true; } \/\/ store class-path-extensions + its src & javadoc if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel);","repo":"pokebadgerswithspoon\/incubator-netbeans"}
{"id":17318,"comment_id":5,"comment":"\/\/ store friends packages","code":"@override void storeproperties() throws ioexception { super.storeproperties(); \/\/ store chnages in manifest storemanifestchanges(); \/\/ store localized info if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { \/\/ store friends packages pxm.replacefriends(friends, publicpkgs); } else { \/\/ store public packages pxm.replacepublicpackages(publicpkgs); } refreshmodulelist = true; } \/\/ store class-path-extensions + its src & javadoc if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel); map<string, string> newcpext = new hashmap<string, string>(); for (item item : cpextlist) { string binpath = item.getfilepath(); if (binpath != null) { fileobject fo = fileutil.tofileobject(propertyutils.resolvefile(getprojectdirectoryfile(), binpath)); if(fo != null) { string runtimepath = apisupportantutils.cpext_runtime_relative_path + fo.getnameext(); newcpext.put(runtimepath, binpath); } } } \/\/ delete removed jars, remove any remaining exported packages and src&javadoc refs left iterator<item> it = getcpextiterator(); hashset<string> jarsset = new hashset<string>(newcpext.values()); while (it.hasnext()) { item item = it.next(); if (!jarsset.contains(item.getfilepath())) { \/\/ xxx deleting here doesn't work on windows: \/\/ file f = propertyutils.resolvefile(getprojectdirectoryfile(), item.getfilepath()); \/\/ fileobject todel = fileutil.tofileobject(f); \/\/ if (todel != null) { \/\/ todel.delete(); \/\/ } assert item.getreference() != null : \"getcpextiterator() initializes references to wrapped jars\"; item.removesourceandjavadoc(getupdatehelper()); getrefhelper().destroyreference(item.getreference()); } } cps.encodetostrings(cpextlist, cpext); pxm.replaceclasspathextensions(newcpext); wrappedjarschanged = false; } if (isstandalone()) { moduleproperties.storeplatform(gethelper(), getactiveplatform()); if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), false); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(getprojectdirectoryfile()); } } else if (issuitecomponent() && refreshmodulelist) { modulelist.refreshmodulelistforroot(getsuitedirectory()); } else if (isnetbeansorg()) { if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), true); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(modulelist.findnetbeansorg(getprojectdirectoryfile())); } } }","classification":"NONSATD","isFinished":true,"code_context_2":"boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { \/\/ store friends packages pxm.replacefriends(friends, publicpkgs); } else { \/\/ store public packages","code_context_10":"try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { \/\/ store friends packages pxm.replacefriends(friends, publicpkgs); } else { \/\/ store public packages pxm.replacepublicpackages(publicpkgs); } refreshmodulelist = true; } \/\/ store class-path-extensions + its src & javadoc if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel); map<string, string> newcpext = new hashmap<string, string>();","code_context_20":"if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { \/\/ store friends packages pxm.replacefriends(friends, publicpkgs); } else { \/\/ store public packages pxm.replacepublicpackages(publicpkgs); } refreshmodulelist = true; } \/\/ store class-path-extensions + its src & javadoc if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel); map<string, string> newcpext = new hashmap<string, string>(); for (item item : cpextlist) { string binpath = item.getfilepath(); if (binpath != null) { fileobject fo = fileutil.tofileobject(propertyutils.resolvefile(getprojectdirectoryfile(), binpath)); if(fo != null) { string runtimepath = apisupportantutils.cpext_runtime_relative_path + fo.getnameext(); newcpext.put(runtimepath, binpath); } }","repo":"pokebadgerswithspoon\/incubator-netbeans"}
{"id":17318,"comment_id":6,"comment":"\/\/ store public packages","code":"@override void storeproperties() throws ioexception { super.storeproperties(); \/\/ store chnages in manifest storemanifestchanges(); \/\/ store localized info if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { \/\/ store friends packages pxm.replacefriends(friends, publicpkgs); } else { \/\/ store public packages pxm.replacepublicpackages(publicpkgs); } refreshmodulelist = true; } \/\/ store class-path-extensions + its src & javadoc if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel); map<string, string> newcpext = new hashmap<string, string>(); for (item item : cpextlist) { string binpath = item.getfilepath(); if (binpath != null) { fileobject fo = fileutil.tofileobject(propertyutils.resolvefile(getprojectdirectoryfile(), binpath)); if(fo != null) { string runtimepath = apisupportantutils.cpext_runtime_relative_path + fo.getnameext(); newcpext.put(runtimepath, binpath); } } } \/\/ delete removed jars, remove any remaining exported packages and src&javadoc refs left iterator<item> it = getcpextiterator(); hashset<string> jarsset = new hashset<string>(newcpext.values()); while (it.hasnext()) { item item = it.next(); if (!jarsset.contains(item.getfilepath())) { \/\/ xxx deleting here doesn't work on windows: \/\/ file f = propertyutils.resolvefile(getprojectdirectoryfile(), item.getfilepath()); \/\/ fileobject todel = fileutil.tofileobject(f); \/\/ if (todel != null) { \/\/ todel.delete(); \/\/ } assert item.getreference() != null : \"getcpextiterator() initializes references to wrapped jars\"; item.removesourceandjavadoc(getupdatehelper()); getrefhelper().destroyreference(item.getreference()); } } cps.encodetostrings(cpextlist, cpext); pxm.replaceclasspathextensions(newcpext); wrappedjarschanged = false; } if (isstandalone()) { moduleproperties.storeplatform(gethelper(), getactiveplatform()); if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), false); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(getprojectdirectoryfile()); } } else if (issuitecomponent() && refreshmodulelist) { modulelist.refreshmodulelistforroot(getsuitedirectory()); } else if (isnetbeansorg()) { if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), true); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(modulelist.findnetbeansorg(getprojectdirectoryfile())); } } }","classification":"NONSATD","isFinished":true,"code_context_2":"if (friends.size() > 0) { \/\/ store friends packages pxm.replacefriends(friends, publicpkgs); } else { \/\/ store public packages pxm.replacepublicpackages(publicpkgs); }","code_context_10":"} catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { \/\/ store friends packages pxm.replacefriends(friends, publicpkgs); } else { \/\/ store public packages pxm.replacepublicpackages(publicpkgs); } refreshmodulelist = true; } \/\/ store class-path-extensions + its src & javadoc if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel); map<string, string> newcpext = new hashmap<string, string>(); for (item item : cpextlist) { string binpath = item.getfilepath();","code_context_20":"} \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { \/\/ store friends packages pxm.replacefriends(friends, publicpkgs); } else { \/\/ store public packages pxm.replacepublicpackages(publicpkgs); } refreshmodulelist = true; } \/\/ store class-path-extensions + its src & javadoc if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel); map<string, string> newcpext = new hashmap<string, string>(); for (item item : cpextlist) { string binpath = item.getfilepath(); if (binpath != null) { fileobject fo = fileutil.tofileobject(propertyutils.resolvefile(getprojectdirectoryfile(), binpath)); if(fo != null) { string runtimepath = apisupportantutils.cpext_runtime_relative_path + fo.getnameext(); newcpext.put(runtimepath, binpath); } } } \/\/ delete removed jars, remove any remaining exported packages and src&javadoc refs left","repo":"pokebadgerswithspoon\/incubator-netbeans"}
{"id":17318,"comment_id":7,"comment":"\/\/ store class-path-extensions + its src & javadoc","code":"@override void storeproperties() throws ioexception { super.storeproperties(); \/\/ store chnages in manifest storemanifestchanges(); \/\/ store localized info if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { \/\/ store friends packages pxm.replacefriends(friends, publicpkgs); } else { \/\/ store public packages pxm.replacepublicpackages(publicpkgs); } refreshmodulelist = true; } \/\/ store class-path-extensions + its src & javadoc if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel); map<string, string> newcpext = new hashmap<string, string>(); for (item item : cpextlist) { string binpath = item.getfilepath(); if (binpath != null) { fileobject fo = fileutil.tofileobject(propertyutils.resolvefile(getprojectdirectoryfile(), binpath)); if(fo != null) { string runtimepath = apisupportantutils.cpext_runtime_relative_path + fo.getnameext(); newcpext.put(runtimepath, binpath); } } } \/\/ delete removed jars, remove any remaining exported packages and src&javadoc refs left iterator<item> it = getcpextiterator(); hashset<string> jarsset = new hashset<string>(newcpext.values()); while (it.hasnext()) { item item = it.next(); if (!jarsset.contains(item.getfilepath())) { \/\/ xxx deleting here doesn't work on windows: \/\/ file f = propertyutils.resolvefile(getprojectdirectoryfile(), item.getfilepath()); \/\/ fileobject todel = fileutil.tofileobject(f); \/\/ if (todel != null) { \/\/ todel.delete(); \/\/ } assert item.getreference() != null : \"getcpextiterator() initializes references to wrapped jars\"; item.removesourceandjavadoc(getupdatehelper()); getrefhelper().destroyreference(item.getreference()); } } cps.encodetostrings(cpextlist, cpext); pxm.replaceclasspathextensions(newcpext); wrappedjarschanged = false; } if (isstandalone()) { moduleproperties.storeplatform(gethelper(), getactiveplatform()); if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), false); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(getprojectdirectoryfile()); } } else if (issuitecomponent() && refreshmodulelist) { modulelist.refreshmodulelistforroot(getsuitedirectory()); } else if (isnetbeansorg()) { if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), true); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(modulelist.findnetbeansorg(getprojectdirectoryfile())); } } }","classification":"NONSATD","isFinished":true,"code_context_2":"refreshmodulelist = true; } \/\/ store class-path-extensions + its src & javadoc if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel);","code_context_10":"set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { \/\/ store friends packages pxm.replacefriends(friends, publicpkgs); } else { \/\/ store public packages pxm.replacepublicpackages(publicpkgs); } refreshmodulelist = true; } \/\/ store class-path-extensions + its src & javadoc if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel); map<string, string> newcpext = new hashmap<string, string>(); for (item item : cpextlist) { string binpath = item.getfilepath(); if (binpath != null) { fileobject fo = fileutil.tofileobject(propertyutils.resolvefile(getprojectdirectoryfile(), binpath)); if(fo != null) { string runtimepath = apisupportantutils.cpext_runtime_relative_path + fo.getnameext();","code_context_20":"if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { \/\/ store friends packages pxm.replacefriends(friends, publicpkgs); } else { \/\/ store public packages pxm.replacepublicpackages(publicpkgs); } refreshmodulelist = true; } \/\/ store class-path-extensions + its src & javadoc if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel); map<string, string> newcpext = new hashmap<string, string>(); for (item item : cpextlist) { string binpath = item.getfilepath(); if (binpath != null) { fileobject fo = fileutil.tofileobject(propertyutils.resolvefile(getprojectdirectoryfile(), binpath)); if(fo != null) { string runtimepath = apisupportantutils.cpext_runtime_relative_path + fo.getnameext(); newcpext.put(runtimepath, binpath); } } } \/\/ delete removed jars, remove any remaining exported packages and src&javadoc refs left iterator<item> it = getcpextiterator(); hashset<string> jarsset = new hashset<string>(newcpext.values()); while (it.hasnext()) { item item = it.next(); if (!jarsset.contains(item.getfilepath())) {","repo":"pokebadgerswithspoon\/incubator-netbeans"}
{"id":17318,"comment_id":8,"comment":"\/\/ delete removed jars, remove any remaining exported packages and src&javadoc refs left","code":"@override void storeproperties() throws ioexception { super.storeproperties(); \/\/ store chnages in manifest storemanifestchanges(); \/\/ store localized info if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { \/\/ store friends packages pxm.replacefriends(friends, publicpkgs); } else { \/\/ store public packages pxm.replacepublicpackages(publicpkgs); } refreshmodulelist = true; } \/\/ store class-path-extensions + its src & javadoc if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel); map<string, string> newcpext = new hashmap<string, string>(); for (item item : cpextlist) { string binpath = item.getfilepath(); if (binpath != null) { fileobject fo = fileutil.tofileobject(propertyutils.resolvefile(getprojectdirectoryfile(), binpath)); if(fo != null) { string runtimepath = apisupportantutils.cpext_runtime_relative_path + fo.getnameext(); newcpext.put(runtimepath, binpath); } } } \/\/ delete removed jars, remove any remaining exported packages and src&javadoc refs left iterator<item> it = getcpextiterator(); hashset<string> jarsset = new hashset<string>(newcpext.values()); while (it.hasnext()) { item item = it.next(); if (!jarsset.contains(item.getfilepath())) { \/\/ xxx deleting here doesn't work on windows: \/\/ file f = propertyutils.resolvefile(getprojectdirectoryfile(), item.getfilepath()); \/\/ fileobject todel = fileutil.tofileobject(f); \/\/ if (todel != null) { \/\/ todel.delete(); \/\/ } assert item.getreference() != null : \"getcpextiterator() initializes references to wrapped jars\"; item.removesourceandjavadoc(getupdatehelper()); getrefhelper().destroyreference(item.getreference()); } } cps.encodetostrings(cpextlist, cpext); pxm.replaceclasspathextensions(newcpext); wrappedjarschanged = false; } if (isstandalone()) { moduleproperties.storeplatform(gethelper(), getactiveplatform()); if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), false); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(getprojectdirectoryfile()); } } else if (issuitecomponent() && refreshmodulelist) { modulelist.refreshmodulelistforroot(getsuitedirectory()); } else if (isnetbeansorg()) { if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), true); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(modulelist.findnetbeansorg(getprojectdirectoryfile())); } } }","classification":"NONSATD","isFinished":true,"code_context_2":"} } \/\/ delete removed jars, remove any remaining exported packages and src&javadoc refs left iterator<item> it = getcpextiterator(); hashset<string> jarsset = new hashset<string>(newcpext.values());","code_context_10":"string binpath = item.getfilepath(); if (binpath != null) { fileobject fo = fileutil.tofileobject(propertyutils.resolvefile(getprojectdirectoryfile(), binpath)); if(fo != null) { string runtimepath = apisupportantutils.cpext_runtime_relative_path + fo.getnameext(); newcpext.put(runtimepath, binpath); } } } \/\/ delete removed jars, remove any remaining exported packages and src&javadoc refs left iterator<item> it = getcpextiterator(); hashset<string> jarsset = new hashset<string>(newcpext.values()); while (it.hasnext()) { item item = it.next(); if (!jarsset.contains(item.getfilepath())) { \/\/ xxx deleting here doesn't work on windows: \/\/ file f = propertyutils.resolvefile(getprojectdirectoryfile(), item.getfilepath()); \/\/ fileobject todel = fileutil.tofileobject(f); \/\/ if (todel != null) { \/\/ todel.delete();","code_context_20":"} else { \/\/ store public packages pxm.replacepublicpackages(publicpkgs); } refreshmodulelist = true; } \/\/ store class-path-extensions + its src & javadoc if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel); map<string, string> newcpext = new hashmap<string, string>(); for (item item : cpextlist) { string binpath = item.getfilepath(); if (binpath != null) { fileobject fo = fileutil.tofileobject(propertyutils.resolvefile(getprojectdirectoryfile(), binpath)); if(fo != null) { string runtimepath = apisupportantutils.cpext_runtime_relative_path + fo.getnameext(); newcpext.put(runtimepath, binpath); } } } \/\/ delete removed jars, remove any remaining exported packages and src&javadoc refs left iterator<item> it = getcpextiterator(); hashset<string> jarsset = new hashset<string>(newcpext.values()); while (it.hasnext()) { item item = it.next(); if (!jarsset.contains(item.getfilepath())) { \/\/ xxx deleting here doesn't work on windows: \/\/ file f = propertyutils.resolvefile(getprojectdirectoryfile(), item.getfilepath()); \/\/ fileobject todel = fileutil.tofileobject(f); \/\/ if (todel != null) { \/\/ todel.delete(); \/\/ } assert item.getreference() != null : \"getcpextiterator() initializes references to wrapped jars\"; item.removesourceandjavadoc(getupdatehelper()); getrefhelper().destroyreference(item.getreference()); } } cps.encodetostrings(cpextlist, cpext); pxm.replaceclasspathextensions(newcpext); wrappedjarschanged = false; }","repo":"pokebadgerswithspoon\/incubator-netbeans"}
{"id":17318,"comment_id":9,"comment":"\/\/ xxx deleting here doesn't work on windows: \/\/ file f = propertyutils.resolvefile(getprojectdirectoryfile(), item.getfilepath()); \/\/ fileobject todel = fileutil.tofileobject(f); \/\/ if (todel != null) { \/\/ todel.delete(); \/\/ }","code":"@override void storeproperties() throws ioexception { super.storeproperties(); \/\/ store chnages in manifest storemanifestchanges(); \/\/ store localized info if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } \/\/ xxx else ignore for now but we could save into some default location projectxmlmanager pxm = getprojectxmlmanager(); \/\/ store project.xml changes \/\/ store module dependencies dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); \/\/ noi18n try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { \/\/ store friends packages pxm.replacefriends(friends, publicpkgs); } else { \/\/ store public packages pxm.replacepublicpackages(publicpkgs); } refreshmodulelist = true; } \/\/ store class-path-extensions + its src & javadoc if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel); map<string, string> newcpext = new hashmap<string, string>(); for (item item : cpextlist) { string binpath = item.getfilepath(); if (binpath != null) { fileobject fo = fileutil.tofileobject(propertyutils.resolvefile(getprojectdirectoryfile(), binpath)); if(fo != null) { string runtimepath = apisupportantutils.cpext_runtime_relative_path + fo.getnameext(); newcpext.put(runtimepath, binpath); } } } \/\/ delete removed jars, remove any remaining exported packages and src&javadoc refs left iterator<item> it = getcpextiterator(); hashset<string> jarsset = new hashset<string>(newcpext.values()); while (it.hasnext()) { item item = it.next(); if (!jarsset.contains(item.getfilepath())) { \/\/ xxx deleting here doesn't work on windows: \/\/ file f = propertyutils.resolvefile(getprojectdirectoryfile(), item.getfilepath()); \/\/ fileobject todel = fileutil.tofileobject(f); \/\/ if (todel != null) { \/\/ todel.delete(); \/\/ } assert item.getreference() != null : \"getcpextiterator() initializes references to wrapped jars\"; item.removesourceandjavadoc(getupdatehelper()); getrefhelper().destroyreference(item.getreference()); } } cps.encodetostrings(cpextlist, cpext); pxm.replaceclasspathextensions(newcpext); wrappedjarschanged = false; } if (isstandalone()) { moduleproperties.storeplatform(gethelper(), getactiveplatform()); if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), false); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(getprojectdirectoryfile()); } } else if (issuitecomponent() && refreshmodulelist) { modulelist.refreshmodulelistforroot(getsuitedirectory()); } else if (isnetbeansorg()) { if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), true); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(modulelist.findnetbeansorg(getprojectdirectoryfile())); } } }","classification":"DEFECT","isFinished":true,"code_context_2":"item item = it.next(); if (!jarsset.contains(item.getfilepath())) { \/\/ xxx deleting here doesn't work on windows: \/\/ file f = propertyutils.resolvefile(getprojectdirectoryfile(), item.getfilepath()); \/\/ fileobject todel = fileutil.tofileobject(f); \/\/ if (todel != null) { \/\/ todel.delete(); \/\/ } assert item.getreference() != null : \"getcpextiterator() initializes references to wrapped jars\"; item.removesourceandjavadoc(getupdatehelper());","code_context_10":"newcpext.put(runtimepath, binpath); } } } \/\/ delete removed jars, remove any remaining exported packages and src&javadoc refs left iterator<item> it = getcpextiterator(); hashset<string> jarsset = new hashset<string>(newcpext.values()); while (it.hasnext()) { item item = it.next(); if (!jarsset.contains(item.getfilepath())) { \/\/ xxx deleting here doesn't work on windows: \/\/ file f = propertyutils.resolvefile(getprojectdirectoryfile(), item.getfilepath()); \/\/ fileobject todel = fileutil.tofileobject(f); \/\/ if (todel != null) { \/\/ todel.delete(); \/\/ } assert item.getreference() != null : \"getcpextiterator() initializes references to wrapped jars\"; item.removesourceandjavadoc(getupdatehelper()); getrefhelper().destroyreference(item.getreference()); } } cps.encodetostrings(cpextlist, cpext); pxm.replaceclasspathextensions(newcpext); wrappedjarschanged = false; } if (isstandalone()) {","code_context_20":"if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel); map<string, string> newcpext = new hashmap<string, string>(); for (item item : cpextlist) { string binpath = item.getfilepath(); if (binpath != null) { fileobject fo = fileutil.tofileobject(propertyutils.resolvefile(getprojectdirectoryfile(), binpath)); if(fo != null) { string runtimepath = apisupportantutils.cpext_runtime_relative_path + fo.getnameext(); newcpext.put(runtimepath, binpath); } } } \/\/ delete removed jars, remove any remaining exported packages and src&javadoc refs left iterator<item> it = getcpextiterator(); hashset<string> jarsset = new hashset<string>(newcpext.values()); while (it.hasnext()) { item item = it.next(); if (!jarsset.contains(item.getfilepath())) { \/\/ xxx deleting here doesn't work on windows: \/\/ file f = propertyutils.resolvefile(getprojectdirectoryfile(), item.getfilepath()); \/\/ fileobject todel = fileutil.tofileobject(f); \/\/ if (todel != null) { \/\/ todel.delete(); \/\/ } assert item.getreference() != null : \"getcpextiterator() initializes references to wrapped jars\"; item.removesourceandjavadoc(getupdatehelper()); getrefhelper().destroyreference(item.getreference()); } } cps.encodetostrings(cpextlist, cpext); pxm.replaceclasspathextensions(newcpext); wrappedjarschanged = false; } if (isstandalone()) { moduleproperties.storeplatform(gethelper(), getactiveplatform()); if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), false); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(getprojectdirectoryfile()); } } else if (issuitecomponent() && refreshmodulelist) { modulelist.refreshmodulelistforroot(getsuitedirectory()); } else if (isnetbeansorg()) {","repo":"pokebadgerswithspoon\/incubator-netbeans"}
{"id":17373,"comment_id":0,"comment":"\/\/todo vt need to think how to send id to observers","code":"public void deletebyuserid(int userid) { try { deletebuilder<userrequest, long> deletebuilder = dao.deletebuilder(); deletebuilder.where().eq(qmusercolumns.id, userid); if (deletebuilder.delete() > 0) { \/\/todo vt need to think how to send id to observers notifyobserversdeletedbyid(userid); } } catch (sqlexception e) { errorutils.logerror(e); } }","classification":"DESIGN","isFinished":true,"code_context_2":"deletebuilder.where().eq(qmusercolumns.id, userid); if (deletebuilder.delete() > 0) { \/\/todo vt need to think how to send id to observers notifyobserversdeletedbyid(userid); }","code_context_10":"public void deletebyuserid(int userid) { try { deletebuilder<userrequest, long> deletebuilder = dao.deletebuilder(); deletebuilder.where().eq(qmusercolumns.id, userid); if (deletebuilder.delete() > 0) { \/\/todo vt need to think how to send id to observers notifyobserversdeletedbyid(userid); } } catch (sqlexception e) { errorutils.logerror(e); } }","code_context_20":"public void deletebyuserid(int userid) { try { deletebuilder<userrequest, long> deletebuilder = dao.deletebuilder(); deletebuilder.where().eq(qmusercolumns.id, userid); if (deletebuilder.delete() > 0) { \/\/todo vt need to think how to send id to observers notifyobserversdeletedbyid(userid); } } catch (sqlexception e) { errorutils.logerror(e); } }","repo":"philz127\/CAPSTONE"}
{"id":25568,"comment_id":0,"comment":"\/** * tests whether a short number matches a valid pattern in a region. note that this doesn't verify * the number is actually in use, which is impossible to tell by just looking at the number * itself. * * @param shortnumber the short number to check as a string * @param regiondialingfrom the region from which the number is dialed * @return whether the short number matches a valid pattern * @deprecated anyone who was using it and passing in a string with whitespace (or other * formatting characters) would have been getting the wrong result. you should parse * the string to phonenumber and use the method * {@code #isvalidshortnumberforregion(phonenumber, string)}. this method will be * removed in the next release. *\/","code":"\/** * tests whether a short number matches a valid pattern in a region. note that this doesn't verify * the number is actually in use, which is impossible to tell by just looking at the number * itself. * * @param shortnumber the short number to check as a string * @param regiondialingfrom the region from which the number is dialed * @return whether the short number matches a valid pattern * @deprecated anyone who was using it and passing in a string with whitespace (or other * formatting characters) would have been getting the wrong result. you should parse * the string to phonenumber and use the method * {@code #isvalidshortnumberforregion(phonenumber, string)}. this method will be * removed in the next release. *\/ @deprecated public boolean isvalidshortnumberforregion(string shortnumber, string regiondialingfrom) { phonemetadata phonemetadata = metadatamanager.getshortnumbermetadataforregion(regiondialingfrom); if (phonemetadata == null) { return false; } phonenumberdesc generaldesc = phonemetadata.getgeneraldesc(); if (!matchespossiblenumberandnationalnumber(shortnumber, generaldesc)) { return false; } phonenumberdesc shortnumberdesc = phonemetadata.getshortcode(); return matchespossiblenumberandnationalnumber(shortnumber, shortnumberdesc); }","classification":"NONSATD","isFinished":true,"code_context_2":"@deprecated public boolean isvalidshortnumberforregion(string shortnumber, string regiondialingfrom) { phonemetadata phonemetadata = metadatamanager.getshortnumbermetadataforregion(regiondialingfrom); if (phonemetadata == null) { return false; } phonenumberdesc generaldesc = phonemetadata.getgeneraldesc(); if (!matchespossiblenumberandnationalnumber(shortnumber, generaldesc)) { return false; } phonenumberdesc shortnumberdesc = phonemetadata.getshortcode(); return matchespossiblenumberandnationalnumber(shortnumber, shortnumberdesc); }","code_context_10":"@deprecated public boolean isvalidshortnumberforregion(string shortnumber, string regiondialingfrom) { phonemetadata phonemetadata = metadatamanager.getshortnumbermetadataforregion(regiondialingfrom); if (phonemetadata == null) { return false; } phonenumberdesc generaldesc = phonemetadata.getgeneraldesc(); if (!matchespossiblenumberandnationalnumber(shortnumber, generaldesc)) { return false; } phonenumberdesc shortnumberdesc = phonemetadata.getshortcode(); return matchespossiblenumberandnationalnumber(shortnumber, shortnumberdesc); }","code_context_20":"@deprecated public boolean isvalidshortnumberforregion(string shortnumber, string regiondialingfrom) { phonemetadata phonemetadata = metadatamanager.getshortnumbermetadataforregion(regiondialingfrom); if (phonemetadata == null) { return false; } phonenumberdesc generaldesc = phonemetadata.getgeneraldesc(); if (!matchespossiblenumberandnationalnumber(shortnumber, generaldesc)) { return false; } phonenumberdesc shortnumberdesc = phonemetadata.getshortcode(); return matchespossiblenumberandnationalnumber(shortnumber, shortnumberdesc); }","repo":"nickbarban\/libphonenumber"}
{"id":33777,"comment_id":0,"comment":"\/\/ we use the highlighted text to put the table caption","code":"private list<annotatedattributevaluepair> getattributevaluepairs(jsonoutcome outcome, jsonreference reference) { optional<string> docnametrue = getfirstdocname(reference); string docname = docnametrue.orelse(outcome.getshorttitle()); \/\/ we use the highlighted text to put the table caption string highlightedtext = outcome.getoutcomedescription(); arm arm1 = getassignedarm(outcome.getitemarmidgrp1(), outcome.getgrp1armname()); arm arm2 = getassignedarm(outcome.getitemarmidgrp2(), outcome.getgrp2armname()); \/\/ outcome values attribute ovattribute = attributes.getfromname(\"outcome value\"); annotatedattributevaluepair ov1 = new annotatedattributevaluepair(ovattribute, outcome.getdata3(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ov2 = new annotatedattributevaluepair(ovattribute, outcome.getdata4(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoints attribute timepointattribute = attributes.getfromname(\"longest follow up\"); annotatedattributevaluepair tp1 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tp2 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoint units attribute timepointunitattribute = attributes.getfromname(\"longest follow up (metric)\"); annotatedattributevaluepair tpunit1 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tpunit2 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ sample size attribute samplesizeattribute = attributes.getfromname(\"individual-level analysed\"); annotatedattributevaluepair ss1 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata1(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ss2 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata2(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ todo: anything else? return lists.newarraylist(ov1, ov2, tp1, tp2, tpunit1, tpunit2, ss1, ss2); }","classification":"NONSATD","isFinished":true,"code_context_2":"optional<string> docnametrue = getfirstdocname(reference); string docname = docnametrue.orelse(outcome.getshorttitle()); \/\/ we use the highlighted text to put the table caption string highlightedtext = outcome.getoutcomedescription(); arm arm1 = getassignedarm(outcome.getitemarmidgrp1(), outcome.getgrp1armname());","code_context_10":"private list<annotatedattributevaluepair> getattributevaluepairs(jsonoutcome outcome, jsonreference reference) { optional<string> docnametrue = getfirstdocname(reference); string docname = docnametrue.orelse(outcome.getshorttitle()); \/\/ we use the highlighted text to put the table caption string highlightedtext = outcome.getoutcomedescription(); arm arm1 = getassignedarm(outcome.getitemarmidgrp1(), outcome.getgrp1armname()); arm arm2 = getassignedarm(outcome.getitemarmidgrp2(), outcome.getgrp2armname()); \/\/ outcome values attribute ovattribute = attributes.getfromname(\"outcome value\"); annotatedattributevaluepair ov1 = new annotatedattributevaluepair(ovattribute, outcome.getdata3(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ov2 = new annotatedattributevaluepair(ovattribute, outcome.getdata4(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoints","code_context_20":"private list<annotatedattributevaluepair> getattributevaluepairs(jsonoutcome outcome, jsonreference reference) { optional<string> docnametrue = getfirstdocname(reference); string docname = docnametrue.orelse(outcome.getshorttitle()); \/\/ we use the highlighted text to put the table caption string highlightedtext = outcome.getoutcomedescription(); arm arm1 = getassignedarm(outcome.getitemarmidgrp1(), outcome.getgrp1armname()); arm arm2 = getassignedarm(outcome.getitemarmidgrp2(), outcome.getgrp2armname()); \/\/ outcome values attribute ovattribute = attributes.getfromname(\"outcome value\"); annotatedattributevaluepair ov1 = new annotatedattributevaluepair(ovattribute, outcome.getdata3(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ov2 = new annotatedattributevaluepair(ovattribute, outcome.getdata4(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoints attribute timepointattribute = attributes.getfromname(\"longest follow up\"); annotatedattributevaluepair tp1 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tp2 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoint units attribute timepointunitattribute = attributes.getfromname(\"longest follow up (metric)\"); annotatedattributevaluepair tpunit1 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tpunit2 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(),","repo":"ouyangzhiping\/Info-extract"}
{"id":33777,"comment_id":1,"comment":"\/\/ outcome values","code":"private list<annotatedattributevaluepair> getattributevaluepairs(jsonoutcome outcome, jsonreference reference) { optional<string> docnametrue = getfirstdocname(reference); string docname = docnametrue.orelse(outcome.getshorttitle()); \/\/ we use the highlighted text to put the table caption string highlightedtext = outcome.getoutcomedescription(); arm arm1 = getassignedarm(outcome.getitemarmidgrp1(), outcome.getgrp1armname()); arm arm2 = getassignedarm(outcome.getitemarmidgrp2(), outcome.getgrp2armname()); \/\/ outcome values attribute ovattribute = attributes.getfromname(\"outcome value\"); annotatedattributevaluepair ov1 = new annotatedattributevaluepair(ovattribute, outcome.getdata3(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ov2 = new annotatedattributevaluepair(ovattribute, outcome.getdata4(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoints attribute timepointattribute = attributes.getfromname(\"longest follow up\"); annotatedattributevaluepair tp1 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tp2 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoint units attribute timepointunitattribute = attributes.getfromname(\"longest follow up (metric)\"); annotatedattributevaluepair tpunit1 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tpunit2 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ sample size attribute samplesizeattribute = attributes.getfromname(\"individual-level analysed\"); annotatedattributevaluepair ss1 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata1(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ss2 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata2(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ todo: anything else? return lists.newarraylist(ov1, ov2, tp1, tp2, tpunit1, tpunit2, ss1, ss2); }","classification":"NONSATD","isFinished":true,"code_context_2":"arm arm1 = getassignedarm(outcome.getitemarmidgrp1(), outcome.getgrp1armname()); arm arm2 = getassignedarm(outcome.getitemarmidgrp2(), outcome.getgrp2armname()); \/\/ outcome values attribute ovattribute = attributes.getfromname(\"outcome value\"); annotatedattributevaluepair ov1 = new annotatedattributevaluepair(ovattribute, outcome.getdata3(),","code_context_10":"private list<annotatedattributevaluepair> getattributevaluepairs(jsonoutcome outcome, jsonreference reference) { optional<string> docnametrue = getfirstdocname(reference); string docname = docnametrue.orelse(outcome.getshorttitle()); \/\/ we use the highlighted text to put the table caption string highlightedtext = outcome.getoutcomedescription(); arm arm1 = getassignedarm(outcome.getitemarmidgrp1(), outcome.getgrp1armname()); arm arm2 = getassignedarm(outcome.getitemarmidgrp2(), outcome.getgrp2armname()); \/\/ outcome values attribute ovattribute = attributes.getfromname(\"outcome value\"); annotatedattributevaluepair ov1 = new annotatedattributevaluepair(ovattribute, outcome.getdata3(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ov2 = new annotatedattributevaluepair(ovattribute, outcome.getdata4(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoints attribute timepointattribute = attributes.getfromname(\"longest follow up\"); annotatedattributevaluepair tp1 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tp2 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(),","code_context_20":"private list<annotatedattributevaluepair> getattributevaluepairs(jsonoutcome outcome, jsonreference reference) { optional<string> docnametrue = getfirstdocname(reference); string docname = docnametrue.orelse(outcome.getshorttitle()); \/\/ we use the highlighted text to put the table caption string highlightedtext = outcome.getoutcomedescription(); arm arm1 = getassignedarm(outcome.getitemarmidgrp1(), outcome.getgrp1armname()); arm arm2 = getassignedarm(outcome.getitemarmidgrp2(), outcome.getgrp2armname()); \/\/ outcome values attribute ovattribute = attributes.getfromname(\"outcome value\"); annotatedattributevaluepair ov1 = new annotatedattributevaluepair(ovattribute, outcome.getdata3(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ov2 = new annotatedattributevaluepair(ovattribute, outcome.getdata4(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoints attribute timepointattribute = attributes.getfromname(\"longest follow up\"); annotatedattributevaluepair tp1 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tp2 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoint units attribute timepointunitattribute = attributes.getfromname(\"longest follow up (metric)\"); annotatedattributevaluepair tpunit1 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tpunit2 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ sample size attribute samplesizeattribute = attributes.getfromname(\"individual-level analysed\"); annotatedattributevaluepair ss1 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata1(),","repo":"ouyangzhiping\/Info-extract"}
{"id":33777,"comment_id":2,"comment":"\/\/ timepoints","code":"private list<annotatedattributevaluepair> getattributevaluepairs(jsonoutcome outcome, jsonreference reference) { optional<string> docnametrue = getfirstdocname(reference); string docname = docnametrue.orelse(outcome.getshorttitle()); \/\/ we use the highlighted text to put the table caption string highlightedtext = outcome.getoutcomedescription(); arm arm1 = getassignedarm(outcome.getitemarmidgrp1(), outcome.getgrp1armname()); arm arm2 = getassignedarm(outcome.getitemarmidgrp2(), outcome.getgrp2armname()); \/\/ outcome values attribute ovattribute = attributes.getfromname(\"outcome value\"); annotatedattributevaluepair ov1 = new annotatedattributevaluepair(ovattribute, outcome.getdata3(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ov2 = new annotatedattributevaluepair(ovattribute, outcome.getdata4(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoints attribute timepointattribute = attributes.getfromname(\"longest follow up\"); annotatedattributevaluepair tp1 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tp2 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoint units attribute timepointunitattribute = attributes.getfromname(\"longest follow up (metric)\"); annotatedattributevaluepair tpunit1 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tpunit2 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ sample size attribute samplesizeattribute = attributes.getfromname(\"individual-level analysed\"); annotatedattributevaluepair ss1 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata1(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ss2 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata2(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ todo: anything else? return lists.newarraylist(ov1, ov2, tp1, tp2, tpunit1, tpunit2, ss1, ss2); }","classification":"NONSATD","isFinished":true,"code_context_2":"annotatedattributevaluepair ov2 = new annotatedattributevaluepair(ovattribute, outcome.getdata4(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoints attribute timepointattribute = attributes.getfromname(\"longest follow up\"); annotatedattributevaluepair tp1 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(),","code_context_10":"\/\/ we use the highlighted text to put the table caption string highlightedtext = outcome.getoutcomedescription(); arm arm1 = getassignedarm(outcome.getitemarmidgrp1(), outcome.getgrp1armname()); arm arm2 = getassignedarm(outcome.getitemarmidgrp2(), outcome.getgrp2armname()); \/\/ outcome values attribute ovattribute = attributes.getfromname(\"outcome value\"); annotatedattributevaluepair ov1 = new annotatedattributevaluepair(ovattribute, outcome.getdata3(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ov2 = new annotatedattributevaluepair(ovattribute, outcome.getdata4(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoints attribute timepointattribute = attributes.getfromname(\"longest follow up\"); annotatedattributevaluepair tp1 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tp2 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoint units attribute timepointunitattribute = attributes.getfromname(\"longest follow up (metric)\"); annotatedattributevaluepair tpunit1 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tpunit2 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(),","code_context_20":"private list<annotatedattributevaluepair> getattributevaluepairs(jsonoutcome outcome, jsonreference reference) { optional<string> docnametrue = getfirstdocname(reference); string docname = docnametrue.orelse(outcome.getshorttitle()); \/\/ we use the highlighted text to put the table caption string highlightedtext = outcome.getoutcomedescription(); arm arm1 = getassignedarm(outcome.getitemarmidgrp1(), outcome.getgrp1armname()); arm arm2 = getassignedarm(outcome.getitemarmidgrp2(), outcome.getgrp2armname()); \/\/ outcome values attribute ovattribute = attributes.getfromname(\"outcome value\"); annotatedattributevaluepair ov1 = new annotatedattributevaluepair(ovattribute, outcome.getdata3(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ov2 = new annotatedattributevaluepair(ovattribute, outcome.getdata4(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoints attribute timepointattribute = attributes.getfromname(\"longest follow up\"); annotatedattributevaluepair tp1 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tp2 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoint units attribute timepointunitattribute = attributes.getfromname(\"longest follow up (metric)\"); annotatedattributevaluepair tpunit1 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tpunit2 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ sample size attribute samplesizeattribute = attributes.getfromname(\"individual-level analysed\"); annotatedattributevaluepair ss1 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata1(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ss2 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata2(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ todo: anything else? return lists.newarraylist(ov1, ov2, tp1, tp2, tpunit1, tpunit2, ss1, ss2); }","repo":"ouyangzhiping\/Info-extract"}
{"id":33777,"comment_id":3,"comment":"\/\/ timepoint units","code":"private list<annotatedattributevaluepair> getattributevaluepairs(jsonoutcome outcome, jsonreference reference) { optional<string> docnametrue = getfirstdocname(reference); string docname = docnametrue.orelse(outcome.getshorttitle()); \/\/ we use the highlighted text to put the table caption string highlightedtext = outcome.getoutcomedescription(); arm arm1 = getassignedarm(outcome.getitemarmidgrp1(), outcome.getgrp1armname()); arm arm2 = getassignedarm(outcome.getitemarmidgrp2(), outcome.getgrp2armname()); \/\/ outcome values attribute ovattribute = attributes.getfromname(\"outcome value\"); annotatedattributevaluepair ov1 = new annotatedattributevaluepair(ovattribute, outcome.getdata3(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ov2 = new annotatedattributevaluepair(ovattribute, outcome.getdata4(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoints attribute timepointattribute = attributes.getfromname(\"longest follow up\"); annotatedattributevaluepair tp1 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tp2 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoint units attribute timepointunitattribute = attributes.getfromname(\"longest follow up (metric)\"); annotatedattributevaluepair tpunit1 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tpunit2 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ sample size attribute samplesizeattribute = attributes.getfromname(\"individual-level analysed\"); annotatedattributevaluepair ss1 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata1(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ss2 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata2(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ todo: anything else? return lists.newarraylist(ov1, ov2, tp1, tp2, tpunit1, tpunit2, ss1, ss2); }","classification":"NONSATD","isFinished":true,"code_context_2":"annotatedattributevaluepair tp2 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoint units attribute timepointunitattribute = attributes.getfromname(\"longest follow up (metric)\"); annotatedattributevaluepair tpunit1 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(),","code_context_10":"annotatedattributevaluepair ov1 = new annotatedattributevaluepair(ovattribute, outcome.getdata3(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ov2 = new annotatedattributevaluepair(ovattribute, outcome.getdata4(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoints attribute timepointattribute = attributes.getfromname(\"longest follow up\"); annotatedattributevaluepair tp1 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tp2 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoint units attribute timepointunitattribute = attributes.getfromname(\"longest follow up (metric)\"); annotatedattributevaluepair tpunit1 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tpunit2 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ sample size attribute samplesizeattribute = attributes.getfromname(\"individual-level analysed\"); annotatedattributevaluepair ss1 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata1(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ss2 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata2(),","code_context_20":"private list<annotatedattributevaluepair> getattributevaluepairs(jsonoutcome outcome, jsonreference reference) { optional<string> docnametrue = getfirstdocname(reference); string docname = docnametrue.orelse(outcome.getshorttitle()); \/\/ we use the highlighted text to put the table caption string highlightedtext = outcome.getoutcomedescription(); arm arm1 = getassignedarm(outcome.getitemarmidgrp1(), outcome.getgrp1armname()); arm arm2 = getassignedarm(outcome.getitemarmidgrp2(), outcome.getgrp2armname()); \/\/ outcome values attribute ovattribute = attributes.getfromname(\"outcome value\"); annotatedattributevaluepair ov1 = new annotatedattributevaluepair(ovattribute, outcome.getdata3(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ov2 = new annotatedattributevaluepair(ovattribute, outcome.getdata4(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoints attribute timepointattribute = attributes.getfromname(\"longest follow up\"); annotatedattributevaluepair tp1 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tp2 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoint units attribute timepointunitattribute = attributes.getfromname(\"longest follow up (metric)\"); annotatedattributevaluepair tpunit1 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tpunit2 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ sample size attribute samplesizeattribute = attributes.getfromname(\"individual-level analysed\"); annotatedattributevaluepair ss1 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata1(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ss2 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata2(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ todo: anything else? return lists.newarraylist(ov1, ov2, tp1, tp2, tpunit1, tpunit2, ss1, ss2); }","repo":"ouyangzhiping\/Info-extract"}
{"id":33777,"comment_id":4,"comment":"\/\/ sample size","code":"private list<annotatedattributevaluepair> getattributevaluepairs(jsonoutcome outcome, jsonreference reference) { optional<string> docnametrue = getfirstdocname(reference); string docname = docnametrue.orelse(outcome.getshorttitle()); \/\/ we use the highlighted text to put the table caption string highlightedtext = outcome.getoutcomedescription(); arm arm1 = getassignedarm(outcome.getitemarmidgrp1(), outcome.getgrp1armname()); arm arm2 = getassignedarm(outcome.getitemarmidgrp2(), outcome.getgrp2armname()); \/\/ outcome values attribute ovattribute = attributes.getfromname(\"outcome value\"); annotatedattributevaluepair ov1 = new annotatedattributevaluepair(ovattribute, outcome.getdata3(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ov2 = new annotatedattributevaluepair(ovattribute, outcome.getdata4(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoints attribute timepointattribute = attributes.getfromname(\"longest follow up\"); annotatedattributevaluepair tp1 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tp2 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoint units attribute timepointunitattribute = attributes.getfromname(\"longest follow up (metric)\"); annotatedattributevaluepair tpunit1 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tpunit2 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ sample size attribute samplesizeattribute = attributes.getfromname(\"individual-level analysed\"); annotatedattributevaluepair ss1 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata1(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ss2 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata2(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ todo: anything else? return lists.newarraylist(ov1, ov2, tp1, tp2, tpunit1, tpunit2, ss1, ss2); }","classification":"NONSATD","isFinished":true,"code_context_2":"annotatedattributevaluepair tpunit2 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ sample size attribute samplesizeattribute = attributes.getfromname(\"individual-level analysed\"); annotatedattributevaluepair ss1 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata1(),","code_context_10":"annotatedattributevaluepair tp1 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tp2 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoint units attribute timepointunitattribute = attributes.getfromname(\"longest follow up (metric)\"); annotatedattributevaluepair tpunit1 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tpunit2 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ sample size attribute samplesizeattribute = attributes.getfromname(\"individual-level analysed\"); annotatedattributevaluepair ss1 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata1(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ss2 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata2(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ todo: anything else? return lists.newarraylist(ov1, ov2, tp1, tp2, tpunit1, tpunit2, ss1, ss2); }","code_context_20":"arm arm1 = getassignedarm(outcome.getitemarmidgrp1(), outcome.getgrp1armname()); arm arm2 = getassignedarm(outcome.getitemarmidgrp2(), outcome.getgrp2armname()); \/\/ outcome values attribute ovattribute = attributes.getfromname(\"outcome value\"); annotatedattributevaluepair ov1 = new annotatedattributevaluepair(ovattribute, outcome.getdata3(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ov2 = new annotatedattributevaluepair(ovattribute, outcome.getdata4(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoints attribute timepointattribute = attributes.getfromname(\"longest follow up\"); annotatedattributevaluepair tp1 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tp2 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoint units attribute timepointunitattribute = attributes.getfromname(\"longest follow up (metric)\"); annotatedattributevaluepair tpunit1 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tpunit2 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ sample size attribute samplesizeattribute = attributes.getfromname(\"individual-level analysed\"); annotatedattributevaluepair ss1 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata1(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ss2 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata2(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ todo: anything else? return lists.newarraylist(ov1, ov2, tp1, tp2, tpunit1, tpunit2, ss1, ss2); }","repo":"ouyangzhiping\/Info-extract"}
{"id":33777,"comment_id":5,"comment":"\/\/ todo: anything else?","code":"private list<annotatedattributevaluepair> getattributevaluepairs(jsonoutcome outcome, jsonreference reference) { optional<string> docnametrue = getfirstdocname(reference); string docname = docnametrue.orelse(outcome.getshorttitle()); \/\/ we use the highlighted text to put the table caption string highlightedtext = outcome.getoutcomedescription(); arm arm1 = getassignedarm(outcome.getitemarmidgrp1(), outcome.getgrp1armname()); arm arm2 = getassignedarm(outcome.getitemarmidgrp2(), outcome.getgrp2armname()); \/\/ outcome values attribute ovattribute = attributes.getfromname(\"outcome value\"); annotatedattributevaluepair ov1 = new annotatedattributevaluepair(ovattribute, outcome.getdata3(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ov2 = new annotatedattributevaluepair(ovattribute, outcome.getdata4(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoints attribute timepointattribute = attributes.getfromname(\"longest follow up\"); annotatedattributevaluepair tp1 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tp2 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoint units attribute timepointunitattribute = attributes.getfromname(\"longest follow up (metric)\"); annotatedattributevaluepair tpunit1 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tpunit2 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ sample size attribute samplesizeattribute = attributes.getfromname(\"individual-level analysed\"); annotatedattributevaluepair ss1 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata1(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ss2 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata2(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ todo: anything else? return lists.newarraylist(ov1, ov2, tp1, tp2, tpunit1, tpunit2, ss1, ss2); }","classification":"DESIGN","isFinished":true,"code_context_2":"annotatedattributevaluepair ss2 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata2(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ todo: anything else? return lists.newarraylist(ov1, ov2, tp1, tp2, tpunit1, tpunit2, ss1, ss2); }","code_context_10":"annotatedattributevaluepair tpunit1 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tpunit2 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ sample size attribute samplesizeattribute = attributes.getfromname(\"individual-level analysed\"); annotatedattributevaluepair ss1 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata1(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ss2 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata2(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ todo: anything else? return lists.newarraylist(ov1, ov2, tp1, tp2, tpunit1, tpunit2, ss1, ss2); }","code_context_20":"annotatedattributevaluepair ov2 = new annotatedattributevaluepair(ovattribute, outcome.getdata4(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoints attribute timepointattribute = attributes.getfromname(\"longest follow up\"); annotatedattributevaluepair tp1 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tp2 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ timepoint units attribute timepointunitattribute = attributes.getfromname(\"longest follow up (metric)\"); annotatedattributevaluepair tpunit1 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tpunit2 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ sample size attribute samplesizeattribute = attributes.getfromname(\"individual-level analysed\"); annotatedattributevaluepair ss1 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata1(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ss2 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata2(), docname, arm2, \"\", highlightedtext, \"\", 0); \/\/ todo: anything else? return lists.newarraylist(ov1, ov2, tp1, tp2, tpunit1, tpunit2, ss1, ss2); }","repo":"ouyangzhiping\/Info-extract"}
{"id":33859,"comment_id":0,"comment":"\/\/ todo -- why is this here?","code":"public void sortrows(alignmenttrack.sortoption option, double location) { if (alignmentrows == null) { return; } for (alignmentinterval.row row : alignmentrows) { if (option == alignmenttrack.sortoption.nucelotide) { \/\/ todo -- why is this here? } row.updatescore(option, location, this); } collections.sort(alignmentrows, new comparator<row>() { public int compare(alignmentinterval.row arg0, alignmentinterval.row arg1) { if (arg0.getscore() > arg1.getscore()) { return 1; } else if (arg0.getscore() > arg1.getscore()) { return -1; } return 0; } }); }","classification":"DESIGN","isFinished":true,"code_context_2":"for (alignmentinterval.row row : alignmentrows) { if (option == alignmenttrack.sortoption.nucelotide) { \/\/ todo -- why is this here? } row.updatescore(option, location, this);","code_context_10":"public void sortrows(alignmenttrack.sortoption option, double location) { if (alignmentrows == null) { return; } for (alignmentinterval.row row : alignmentrows) { if (option == alignmenttrack.sortoption.nucelotide) { \/\/ todo -- why is this here? } row.updatescore(option, location, this); } collections.sort(alignmentrows, new comparator<row>() { public int compare(alignmentinterval.row arg0, alignmentinterval.row arg1) { if (arg0.getscore() > arg1.getscore()) { return 1; } else if (arg0.getscore() > arg1.getscore()) { return -1; }","code_context_20":"public void sortrows(alignmenttrack.sortoption option, double location) { if (alignmentrows == null) { return; } for (alignmentinterval.row row : alignmentrows) { if (option == alignmenttrack.sortoption.nucelotide) { \/\/ todo -- why is this here? } row.updatescore(option, location, this); } collections.sort(alignmentrows, new comparator<row>() { public int compare(alignmentinterval.row arg0, alignmentinterval.row arg1) { if (arg0.getscore() > arg1.getscore()) { return 1; } else if (arg0.getscore() > arg1.getscore()) { return -1; } return 0; } }); }","repo":"nrgene\/NRGene-IGV"}
{"id":17516,"comment_id":0,"comment":"\/\/ get client ip address. ipv6 is not tested yet. (code for ipv6 maybe buggy)","code":"\/\/ get client ip address. ipv6 is not tested yet. (code for ipv6 maybe buggy) public native byte [] getclientip();","classification":"DEFECT","isFinished":true,"code_context_2":"public native byte [] getclientip();","code_context_10":"public native byte [] getclientip();","code_context_20":"public native byte [] getclientip();","repo":"recolic\/hbase-2.1.0"}
{"id":25782,"comment_id":0,"comment":"\/\/ todo - cleanup redundancies","code":"\/\/ todo - cleanup redundancies public static list<jsonobject> constructrokunativeelements(jsonobject elementobj) { list<jsonobject> elements = new arraylist<>(); jsonarray valuearr = (jsonarray) elementobj.get(\"value\"); if (valuearr == null) { return elements; } for (int i = 0; i < valuearr.size(); i++) { string[] boundscomponents = { \"0\", \"0\", \"0\", \"0\" }; string text = \"\"; jsonobject valueobj = (jsonobject) valuearr.get(i); jsonarray attrarr = (jsonarray) valueobj.get(\"attrs\"); for (int i2 = 0; i2 < attrarr.size(); i2++) { jsonobject attrobj = (jsonobject) attrarr.get(i2); jsonobject nameobj = (jsonobject) attrobj.get(\"name\"); if (nameobj.containsvalue(\"bounds\")) { string boundsstr = (string) attrobj.get(\"value\"); boundsstr = boundsstr.replace(\"{\", \"\").replace(\"}\", \"\"); boundscomponents = boundsstr.split(\", \"); } if (nameobj.containsvalue(\"text\")) { text = (string) attrobj.get(\"value\"); } } elements.add(constructrokunativeelementjson(elementobj, text, boundscomponents)); } return elements; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"public static list<jsonobject> constructrokunativeelements(jsonobject elementobj) { list<jsonobject> elements = new arraylist<>(); jsonarray valuearr = (jsonarray) elementobj.get(\"value\"); if (valuearr == null) { return elements; } for (int i = 0; i < valuearr.size(); i++) { string[] boundscomponents = { \"0\", \"0\", \"0\", \"0\" }; string text = \"\"; jsonobject valueobj = (jsonobject) valuearr.get(i); jsonarray attrarr = (jsonarray) valueobj.get(\"attrs\"); for (int i2 = 0; i2 < attrarr.size(); i2++) { jsonobject attrobj = (jsonobject) attrarr.get(i2); jsonobject nameobj = (jsonobject) attrobj.get(\"name\"); if (nameobj.containsvalue(\"bounds\")) { string boundsstr = (string) attrobj.get(\"value\"); boundsstr = boundsstr.replace(\"{\", \"\").replace(\"}\", \"\"); boundscomponents = boundsstr.split(\", \"); } if (nameobj.containsvalue(\"text\")) { text = (string) attrobj.get(\"value\"); } } elements.add(constructrokunativeelementjson(elementobj, text, boundscomponents)); } return elements; }","code_context_10":"public static list<jsonobject> constructrokunativeelements(jsonobject elementobj) { list<jsonobject> elements = new arraylist<>(); jsonarray valuearr = (jsonarray) elementobj.get(\"value\"); if (valuearr == null) { return elements; } for (int i = 0; i < valuearr.size(); i++) { string[] boundscomponents = { \"0\", \"0\", \"0\", \"0\" }; string text = \"\"; jsonobject valueobj = (jsonobject) valuearr.get(i); jsonarray attrarr = (jsonarray) valueobj.get(\"attrs\"); for (int i2 = 0; i2 < attrarr.size(); i2++) { jsonobject attrobj = (jsonobject) attrarr.get(i2); jsonobject nameobj = (jsonobject) attrobj.get(\"name\"); if (nameobj.containsvalue(\"bounds\")) { string boundsstr = (string) attrobj.get(\"value\"); boundsstr = boundsstr.replace(\"{\", \"\").replace(\"}\", \"\"); boundscomponents = boundsstr.split(\", \"); } if (nameobj.containsvalue(\"text\")) { text = (string) attrobj.get(\"value\"); } } elements.add(constructrokunativeelementjson(elementobj, text, boundscomponents)); } return elements; }","code_context_20":"public static list<jsonobject> constructrokunativeelements(jsonobject elementobj) { list<jsonobject> elements = new arraylist<>(); jsonarray valuearr = (jsonarray) elementobj.get(\"value\"); if (valuearr == null) { return elements; } for (int i = 0; i < valuearr.size(); i++) { string[] boundscomponents = { \"0\", \"0\", \"0\", \"0\" }; string text = \"\"; jsonobject valueobj = (jsonobject) valuearr.get(i); jsonarray attrarr = (jsonarray) valueobj.get(\"attrs\"); for (int i2 = 0; i2 < attrarr.size(); i2++) { jsonobject attrobj = (jsonobject) attrarr.get(i2); jsonobject nameobj = (jsonobject) attrobj.get(\"name\"); if (nameobj.containsvalue(\"bounds\")) { string boundsstr = (string) attrobj.get(\"value\"); boundsstr = boundsstr.replace(\"{\", \"\").replace(\"}\", \"\"); boundscomponents = boundsstr.split(\", \"); } if (nameobj.containsvalue(\"text\")) { text = (string) attrobj.get(\"value\"); } } elements.add(constructrokunativeelementjson(elementobj, text, boundscomponents)); } return elements; }","repo":"mohanakrishna12\/rokuality-server"}
{"id":1229,"comment_id":0,"comment":"\/\/ todo (lwhite): these tests don't fail. what was their intent?","code":"@test public void testreadfailure() throws ioexception { \/\/ todo (lwhite): these tests don't fail. what was their intent? table table1 = table.read() .csv(csvreadoptions.builder(\"..\/data\/read_failure_test.csv\").minimizecolumnsizes()); table1.structure(); \/\/ just make sure the import completed shortcolumn test = table1.shortcolumn(\"test\"); \/\/ todo(lwhite): better tests assertnotnull(test.summary()); }","classification":"TEST","isFinished":true,"code_context_2":"@test public void testreadfailure() throws ioexception { \/\/ todo (lwhite): these tests don't fail. what was their intent? table table1 = table.read()","code_context_10":"@test public void testreadfailure() throws ioexception { \/\/ todo (lwhite): these tests don't fail. what was their intent? table table1 = table.read() .csv(csvreadoptions.builder(\"..\/data\/read_failure_test.csv\").minimizecolumnsizes()); table1.structure(); \/\/ just make sure the import completed shortcolumn test = table1.shortcolumn(\"test\"); \/\/ todo(lwhite): better tests assertnotnull(test.summary()); }","code_context_20":"@test public void testreadfailure() throws ioexception { \/\/ todo (lwhite): these tests don't fail. what was their intent? table table1 = table.read() .csv(csvreadoptions.builder(\"..\/data\/read_failure_test.csv\").minimizecolumnsizes()); table1.structure(); \/\/ just make sure the import completed shortcolumn test = table1.shortcolumn(\"test\"); \/\/ todo(lwhite): better tests assertnotnull(test.summary()); }","repo":"rayeaster\/tablesaw"}
{"id":1229,"comment_id":1,"comment":"\/\/ just make sure the import completed","code":"@test public void testreadfailure() throws ioexception { \/\/ todo (lwhite): these tests don't fail. what was their intent? table table1 = table.read() .csv(csvreadoptions.builder(\"..\/data\/read_failure_test.csv\").minimizecolumnsizes()); table1.structure(); \/\/ just make sure the import completed shortcolumn test = table1.shortcolumn(\"test\"); \/\/ todo(lwhite): better tests assertnotnull(test.summary()); }","classification":"NONSATD","isFinished":true,"code_context_2":"table.read() .csv(csvreadoptions.builder(\"..\/data\/read_failure_test.csv\").minimizecolumnsizes()); table1.structure(); \/\/ just make sure the import completed shortcolumn test = table1.shortcolumn(\"test\"); \/\/ todo(lwhite): better tests","code_context_10":"@test public void testreadfailure() throws ioexception { \/\/ todo (lwhite): these tests don't fail. what was their intent? table table1 = table.read() .csv(csvreadoptions.builder(\"..\/data\/read_failure_test.csv\").minimizecolumnsizes()); table1.structure(); \/\/ just make sure the import completed shortcolumn test = table1.shortcolumn(\"test\"); \/\/ todo(lwhite): better tests assertnotnull(test.summary()); }","code_context_20":"@test public void testreadfailure() throws ioexception { \/\/ todo (lwhite): these tests don't fail. what was their intent? table table1 = table.read() .csv(csvreadoptions.builder(\"..\/data\/read_failure_test.csv\").minimizecolumnsizes()); table1.structure(); \/\/ just make sure the import completed shortcolumn test = table1.shortcolumn(\"test\"); \/\/ todo(lwhite): better tests assertnotnull(test.summary()); }","repo":"rayeaster\/tablesaw"}
{"id":1229,"comment_id":2,"comment":"\/\/ todo(lwhite): better tests","code":"@test public void testreadfailure() throws ioexception { \/\/ todo (lwhite): these tests don't fail. what was their intent? table table1 = table.read() .csv(csvreadoptions.builder(\"..\/data\/read_failure_test.csv\").minimizecolumnsizes()); table1.structure(); \/\/ just make sure the import completed shortcolumn test = table1.shortcolumn(\"test\"); \/\/ todo(lwhite): better tests assertnotnull(test.summary()); }","classification":"TEST","isFinished":true,"code_context_2":"table1.structure(); \/\/ just make sure the import completed shortcolumn test = table1.shortcolumn(\"test\"); \/\/ todo(lwhite): better tests assertnotnull(test.summary()); }","code_context_10":"@test public void testreadfailure() throws ioexception { \/\/ todo (lwhite): these tests don't fail. what was their intent? table table1 = table.read() .csv(csvreadoptions.builder(\"..\/data\/read_failure_test.csv\").minimizecolumnsizes()); table1.structure(); \/\/ just make sure the import completed shortcolumn test = table1.shortcolumn(\"test\"); \/\/ todo(lwhite): better tests assertnotnull(test.summary()); }","code_context_20":"@test public void testreadfailure() throws ioexception { \/\/ todo (lwhite): these tests don't fail. what was their intent? table table1 = table.read() .csv(csvreadoptions.builder(\"..\/data\/read_failure_test.csv\").minimizecolumnsizes()); table1.structure(); \/\/ just make sure the import completed shortcolumn test = table1.shortcolumn(\"test\"); \/\/ todo(lwhite): better tests assertnotnull(test.summary()); }","repo":"rayeaster\/tablesaw"}
{"id":34107,"comment_id":0,"comment":"\/** * copy the keys and values from the source to this object. this will * not copy the default values. this is meant to be used by going from * a higher precedence object to a lower precedence object, so that if a * key already exists, this method will not reset it. * * @param opsrc non-null reference to an outputproperties. *\/","code":"\/** * copy the keys and values from the source to this object. this will * not copy the default values. this is meant to be used by going from * a higher precedence object to a lower precedence object, so that if a * key already exists, this method will not reset it. * * @param opsrc non-null reference to an outputproperties. *\/ public void copyfrom(outputproperties opsrc) throws transformerexception { \/\/ bugzilla 6157: recover from xsl:output statements \/\/ checkduplicates(opsrc); copyfrom(opsrc.getproperties()); }","classification":"NONSATD","isFinished":true,"code_context_2":"public void copyfrom(outputproperties opsrc) throws transformerexception { \/\/ bugzilla 6157: recover from xsl:output statements \/\/ checkduplicates(opsrc); copyfrom(opsrc.getproperties()); }","code_context_10":"public void copyfrom(outputproperties opsrc) throws transformerexception { \/\/ bugzilla 6157: recover from xsl:output statements \/\/ checkduplicates(opsrc); copyfrom(opsrc.getproperties()); }","code_context_20":"public void copyfrom(outputproperties opsrc) throws transformerexception { \/\/ bugzilla 6157: recover from xsl:output statements \/\/ checkduplicates(opsrc); copyfrom(opsrc.getproperties()); }","repo":"oradian\/xalan-j"}
{"id":34107,"comment_id":1,"comment":"\/\/ bugzilla 6157: recover from xsl:output statements \/\/ checkduplicates(opsrc);","code":"public void copyfrom(outputproperties opsrc) throws transformerexception { \/\/ bugzilla 6157: recover from xsl:output statements \/\/ checkduplicates(opsrc); copyfrom(opsrc.getproperties()); }","classification":"DEFECT","isFinished":true,"code_context_2":"throws transformerexception { \/\/ bugzilla 6157: recover from xsl:output statements \/\/ checkduplicates(opsrc); copyfrom(opsrc.getproperties()); }","code_context_10":"public void copyfrom(outputproperties opsrc) throws transformerexception { \/\/ bugzilla 6157: recover from xsl:output statements \/\/ checkduplicates(opsrc); copyfrom(opsrc.getproperties()); }","code_context_20":"public void copyfrom(outputproperties opsrc) throws transformerexception { \/\/ bugzilla 6157: recover from xsl:output statements \/\/ checkduplicates(opsrc); copyfrom(opsrc.getproperties()); }","repo":"oradian\/xalan-j"}
{"id":25919,"comment_id":0,"comment":"\/\/ get remote repositories","code":"private void builddependencytree( queue<dependencynode> nodequeue, boolean full, boolean online, session session, map<string, profile> profiles, pomfileloader loader, log log ) { int neededlevels = full ? -1 : 1; while( !nodequeue.isempty() ) { dependencynode node = nodequeue.poll(); if( neededlevels >= 0 && node.getlevel() >= neededlevels ) continue; node.collectdependencymanagement( profiles, session.projects(), log ); map<dependencykey, rawdependency> localdependencies = gethierarchicaldependencies( session, node.getproject(), null, online, profiles, log ); if( localdependencies == null ) continue; for( entry<dependencykey, rawdependency> e : localdependencies.entryset() ) { dependencykey dependencykey = e.getkey(); rawdependency dependency = e.getvalue(); if( dependency.isoptional() && !node.isroot() ) continue; groupartifact ga = new groupartifact( dependencykey.getgroupid(), dependencykey.getartifactid() ); if( isgroupartifactexcluded( node, ga ) ) continue; dependencynode existingnode = node.searchnodeforgroupartifact( ga ); if( existingnode != null ) { if( existingnode.getlevel() <= node.getlevel() + 1 ) continue; else existingnode.removefromparent(); } final optional<versionscope> optionalvs = getversionscopefromdependencymanagement( node, dependencykey, dependency ); final versionscope vs; if(optionalvs.ispresent() ) { vs = optionalvs.get(); } else { vs = dependency.getvs(); if( node.isroot() ) { if(vs.getscope() == null) { vs.setscope( scope.compile ); } } else { scope scope = scope.getscopetransformation( node.getvs().getscope(), dependency.getvs().getscope() ); if(scope == null ) continue; vs.setscope( scope ); } } scope scope = vs.getscope(); assert scope != null; assert vs.getversion() != null : \"null version of dependency \" + dependencykey + \" -> \" + dependency + \" (for project \" + project + \")\"; if( scope == scope.import || scope == scope.system ) continue; \/\/ get remote repositories list<repository> additionalrepos = getprojectrepositories( session, node.getproject(), log ); gav dependencygav = new gav( dependencykey.getgroupid(), dependencykey.getartifactid(), vs.getversion() ); project childproject = null; if( neededlevels < 0 || node.getlevel() >= neededlevels ) { childproject = session.projects().forgav( dependencygav ); if( childproject == null ) { file pomfile = loader.loadpomfileforgav( dependencygav, additionalrepos, log ); if( pomfile == null ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } pomanalysis analysis = new pomanalysis( session, loader, null, false, log ); analysis.addfile( pomfile ); set<project> loadedprojects = analysis.loadprojects(); if( loadedprojects.size() != 1 ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } childproject = loadedprojects.iterator().next(); analysis.completeloadedprojects(); analysis.addcompletedprojectstosession(); set<project> addedtograph = analysis.addcompletedprojectstograph(); if( !addedtograph.contains( childproject ) ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } } if( childproject == null ) { \/\/ todo : use specified repositories if needed ! log.html( tools.warningmessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() + (dependency.isoptional() ? \" (this is an optional dependency)\" : \"\") ) ); continue; } } dependencynode child = new dependencynode( childproject, dependencykey, vs ); child.addexclusions( dependency.getexclusions() ); node.addchild( child ); dependencymanagement dm = node.getlocalmanagement( dependencykey ); if( dm != null ) child.addexclusions( dm.getexclusions() ); \/\/fixme is always false if( scope == scope.system ) continue; \/\/ todo it seems to me that transitive dependency policy only \/\/ applies to jar artifacts, is that true ?? \/\/ if( \"jar\".equals( dependencykey.gettype() ) ) nodequeue.add( child ); } } }","classification":"NONSATD","isFinished":true,"code_context_2":"if( scope == scope.import || scope == scope.system ) continue; \/\/ get remote repositories list<repository> additionalrepos = getprojectrepositories( session, node.getproject(), log ); gav dependencygav = new gav( dependencykey.getgroupid(), dependencykey.getartifactid(), vs.getversion() );","code_context_10":"if(scope == null ) continue; vs.setscope( scope ); } } scope scope = vs.getscope(); assert scope != null; assert vs.getversion() != null : \"null version of dependency \" + dependencykey + \" -> \" + dependency + \" (for project \" + project + \")\"; if( scope == scope.import || scope == scope.system ) continue; \/\/ get remote repositories list<repository> additionalrepos = getprojectrepositories( session, node.getproject(), log ); gav dependencygav = new gav( dependencykey.getgroupid(), dependencykey.getartifactid(), vs.getversion() ); project childproject = null; if( neededlevels < 0 || node.getlevel() >= neededlevels ) { childproject = session.projects().forgav( dependencygav ); if( childproject == null ) { file pomfile = loader.loadpomfileforgav( dependencygav, additionalrepos, log ); if( pomfile == null )","code_context_20":"vs = dependency.getvs(); if( node.isroot() ) { if(vs.getscope() == null) { vs.setscope( scope.compile ); } } else { scope scope = scope.getscopetransformation( node.getvs().getscope(), dependency.getvs().getscope() ); if(scope == null ) continue; vs.setscope( scope ); } } scope scope = vs.getscope(); assert scope != null; assert vs.getversion() != null : \"null version of dependency \" + dependencykey + \" -> \" + dependency + \" (for project \" + project + \")\"; if( scope == scope.import || scope == scope.system ) continue; \/\/ get remote repositories list<repository> additionalrepos = getprojectrepositories( session, node.getproject(), log ); gav dependencygav = new gav( dependencykey.getgroupid(), dependencykey.getartifactid(), vs.getversion() ); project childproject = null; if( neededlevels < 0 || node.getlevel() >= neededlevels ) { childproject = session.projects().forgav( dependencygav ); if( childproject == null ) { file pomfile = loader.loadpomfileforgav( dependencygav, additionalrepos, log ); if( pomfile == null ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } pomanalysis analysis = new pomanalysis( session, loader, null, false, log ); analysis.addfile( pomfile ); set<project> loadedprojects = analysis.loadprojects(); if( loadedprojects.size() != 1 ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) );","repo":"mpicque\/pom-explorer"}
{"id":25919,"comment_id":1,"comment":"\/\/ todo : use specified repositories if needed !","code":"private void builddependencytree( queue<dependencynode> nodequeue, boolean full, boolean online, session session, map<string, profile> profiles, pomfileloader loader, log log ) { int neededlevels = full ? -1 : 1; while( !nodequeue.isempty() ) { dependencynode node = nodequeue.poll(); if( neededlevels >= 0 && node.getlevel() >= neededlevels ) continue; node.collectdependencymanagement( profiles, session.projects(), log ); map<dependencykey, rawdependency> localdependencies = gethierarchicaldependencies( session, node.getproject(), null, online, profiles, log ); if( localdependencies == null ) continue; for( entry<dependencykey, rawdependency> e : localdependencies.entryset() ) { dependencykey dependencykey = e.getkey(); rawdependency dependency = e.getvalue(); if( dependency.isoptional() && !node.isroot() ) continue; groupartifact ga = new groupartifact( dependencykey.getgroupid(), dependencykey.getartifactid() ); if( isgroupartifactexcluded( node, ga ) ) continue; dependencynode existingnode = node.searchnodeforgroupartifact( ga ); if( existingnode != null ) { if( existingnode.getlevel() <= node.getlevel() + 1 ) continue; else existingnode.removefromparent(); } final optional<versionscope> optionalvs = getversionscopefromdependencymanagement( node, dependencykey, dependency ); final versionscope vs; if(optionalvs.ispresent() ) { vs = optionalvs.get(); } else { vs = dependency.getvs(); if( node.isroot() ) { if(vs.getscope() == null) { vs.setscope( scope.compile ); } } else { scope scope = scope.getscopetransformation( node.getvs().getscope(), dependency.getvs().getscope() ); if(scope == null ) continue; vs.setscope( scope ); } } scope scope = vs.getscope(); assert scope != null; assert vs.getversion() != null : \"null version of dependency \" + dependencykey + \" -> \" + dependency + \" (for project \" + project + \")\"; if( scope == scope.import || scope == scope.system ) continue; \/\/ get remote repositories list<repository> additionalrepos = getprojectrepositories( session, node.getproject(), log ); gav dependencygav = new gav( dependencykey.getgroupid(), dependencykey.getartifactid(), vs.getversion() ); project childproject = null; if( neededlevels < 0 || node.getlevel() >= neededlevels ) { childproject = session.projects().forgav( dependencygav ); if( childproject == null ) { file pomfile = loader.loadpomfileforgav( dependencygav, additionalrepos, log ); if( pomfile == null ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } pomanalysis analysis = new pomanalysis( session, loader, null, false, log ); analysis.addfile( pomfile ); set<project> loadedprojects = analysis.loadprojects(); if( loadedprojects.size() != 1 ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } childproject = loadedprojects.iterator().next(); analysis.completeloadedprojects(); analysis.addcompletedprojectstosession(); set<project> addedtograph = analysis.addcompletedprojectstograph(); if( !addedtograph.contains( childproject ) ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } } if( childproject == null ) { \/\/ todo : use specified repositories if needed ! log.html( tools.warningmessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() + (dependency.isoptional() ? \" (this is an optional dependency)\" : \"\") ) ); continue; } } dependencynode child = new dependencynode( childproject, dependencykey, vs ); child.addexclusions( dependency.getexclusions() ); node.addchild( child ); dependencymanagement dm = node.getlocalmanagement( dependencykey ); if( dm != null ) child.addexclusions( dm.getexclusions() ); \/\/fixme is always false if( scope == scope.system ) continue; \/\/ todo it seems to me that transitive dependency policy only \/\/ applies to jar artifacts, is that true ?? \/\/ if( \"jar\".equals( dependencykey.gettype() ) ) nodequeue.add( child ); } } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"if( childproject == null ) { \/\/ todo : use specified repositories if needed ! log.html( tools.warningmessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() + (dependency.isoptional() ? \" (this is an optional dependency)\" : \"\") ) ); continue;","code_context_10":"analysis.addcompletedprojectstosession(); set<project> addedtograph = analysis.addcompletedprojectstograph(); if( !addedtograph.contains( childproject ) ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } } if( childproject == null ) { \/\/ todo : use specified repositories if needed ! log.html( tools.warningmessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() + (dependency.isoptional() ? \" (this is an optional dependency)\" : \"\") ) ); continue; } } dependencynode child = new dependencynode( childproject, dependencykey, vs ); child.addexclusions( dependency.getexclusions() ); node.addchild( child ); dependencymanagement dm = node.getlocalmanagement( dependencykey ); if( dm != null ) child.addexclusions( dm.getexclusions() );","code_context_20":"pomanalysis analysis = new pomanalysis( session, loader, null, false, log ); analysis.addfile( pomfile ); set<project> loadedprojects = analysis.loadprojects(); if( loadedprojects.size() != 1 ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } childproject = loadedprojects.iterator().next(); analysis.completeloadedprojects(); analysis.addcompletedprojectstosession(); set<project> addedtograph = analysis.addcompletedprojectstograph(); if( !addedtograph.contains( childproject ) ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } } if( childproject == null ) { \/\/ todo : use specified repositories if needed ! log.html( tools.warningmessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() + (dependency.isoptional() ? \" (this is an optional dependency)\" : \"\") ) ); continue; } } dependencynode child = new dependencynode( childproject, dependencykey, vs ); child.addexclusions( dependency.getexclusions() ); node.addchild( child ); dependencymanagement dm = node.getlocalmanagement( dependencykey ); if( dm != null ) child.addexclusions( dm.getexclusions() ); \/\/fixme is always false if( scope == scope.system ) continue; \/\/ todo it seems to me that transitive dependency policy only \/\/ applies to jar artifacts, is that true ?? \/\/ if( \"jar\".equals( dependencykey.gettype() ) ) nodequeue.add( child ); } } }","repo":"mpicque\/pom-explorer"}
{"id":25919,"comment_id":2,"comment":"\/\/fixme is always false","code":"private void builddependencytree( queue<dependencynode> nodequeue, boolean full, boolean online, session session, map<string, profile> profiles, pomfileloader loader, log log ) { int neededlevels = full ? -1 : 1; while( !nodequeue.isempty() ) { dependencynode node = nodequeue.poll(); if( neededlevels >= 0 && node.getlevel() >= neededlevels ) continue; node.collectdependencymanagement( profiles, session.projects(), log ); map<dependencykey, rawdependency> localdependencies = gethierarchicaldependencies( session, node.getproject(), null, online, profiles, log ); if( localdependencies == null ) continue; for( entry<dependencykey, rawdependency> e : localdependencies.entryset() ) { dependencykey dependencykey = e.getkey(); rawdependency dependency = e.getvalue(); if( dependency.isoptional() && !node.isroot() ) continue; groupartifact ga = new groupartifact( dependencykey.getgroupid(), dependencykey.getartifactid() ); if( isgroupartifactexcluded( node, ga ) ) continue; dependencynode existingnode = node.searchnodeforgroupartifact( ga ); if( existingnode != null ) { if( existingnode.getlevel() <= node.getlevel() + 1 ) continue; else existingnode.removefromparent(); } final optional<versionscope> optionalvs = getversionscopefromdependencymanagement( node, dependencykey, dependency ); final versionscope vs; if(optionalvs.ispresent() ) { vs = optionalvs.get(); } else { vs = dependency.getvs(); if( node.isroot() ) { if(vs.getscope() == null) { vs.setscope( scope.compile ); } } else { scope scope = scope.getscopetransformation( node.getvs().getscope(), dependency.getvs().getscope() ); if(scope == null ) continue; vs.setscope( scope ); } } scope scope = vs.getscope(); assert scope != null; assert vs.getversion() != null : \"null version of dependency \" + dependencykey + \" -> \" + dependency + \" (for project \" + project + \")\"; if( scope == scope.import || scope == scope.system ) continue; \/\/ get remote repositories list<repository> additionalrepos = getprojectrepositories( session, node.getproject(), log ); gav dependencygav = new gav( dependencykey.getgroupid(), dependencykey.getartifactid(), vs.getversion() ); project childproject = null; if( neededlevels < 0 || node.getlevel() >= neededlevels ) { childproject = session.projects().forgav( dependencygav ); if( childproject == null ) { file pomfile = loader.loadpomfileforgav( dependencygav, additionalrepos, log ); if( pomfile == null ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } pomanalysis analysis = new pomanalysis( session, loader, null, false, log ); analysis.addfile( pomfile ); set<project> loadedprojects = analysis.loadprojects(); if( loadedprojects.size() != 1 ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } childproject = loadedprojects.iterator().next(); analysis.completeloadedprojects(); analysis.addcompletedprojectstosession(); set<project> addedtograph = analysis.addcompletedprojectstograph(); if( !addedtograph.contains( childproject ) ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } } if( childproject == null ) { \/\/ todo : use specified repositories if needed ! log.html( tools.warningmessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() + (dependency.isoptional() ? \" (this is an optional dependency)\" : \"\") ) ); continue; } } dependencynode child = new dependencynode( childproject, dependencykey, vs ); child.addexclusions( dependency.getexclusions() ); node.addchild( child ); dependencymanagement dm = node.getlocalmanagement( dependencykey ); if( dm != null ) child.addexclusions( dm.getexclusions() ); \/\/fixme is always false if( scope == scope.system ) continue; \/\/ todo it seems to me that transitive dependency policy only \/\/ applies to jar artifacts, is that true ?? \/\/ if( \"jar\".equals( dependencykey.gettype() ) ) nodequeue.add( child ); } } }","classification":"DEFECT","isFinished":true,"code_context_2":"if( dm != null ) child.addexclusions( dm.getexclusions() ); \/\/fixme is always false if( scope == scope.system ) continue;","code_context_10":"log.html( tools.warningmessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() + (dependency.isoptional() ? \" (this is an optional dependency)\" : \"\") ) ); continue; } } dependencynode child = new dependencynode( childproject, dependencykey, vs ); child.addexclusions( dependency.getexclusions() ); node.addchild( child ); dependencymanagement dm = node.getlocalmanagement( dependencykey ); if( dm != null ) child.addexclusions( dm.getexclusions() ); \/\/fixme is always false if( scope == scope.system ) continue; \/\/ todo it seems to me that transitive dependency policy only \/\/ applies to jar artifacts, is that true ?? \/\/ if( \"jar\".equals( dependencykey.gettype() ) ) nodequeue.add( child ); } } }","code_context_20":"set<project> addedtograph = analysis.addcompletedprojectstograph(); if( !addedtograph.contains( childproject ) ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } } if( childproject == null ) { \/\/ todo : use specified repositories if needed ! log.html( tools.warningmessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() + (dependency.isoptional() ? \" (this is an optional dependency)\" : \"\") ) ); continue; } } dependencynode child = new dependencynode( childproject, dependencykey, vs ); child.addexclusions( dependency.getexclusions() ); node.addchild( child ); dependencymanagement dm = node.getlocalmanagement( dependencykey ); if( dm != null ) child.addexclusions( dm.getexclusions() ); \/\/fixme is always false if( scope == scope.system ) continue; \/\/ todo it seems to me that transitive dependency policy only \/\/ applies to jar artifacts, is that true ?? \/\/ if( \"jar\".equals( dependencykey.gettype() ) ) nodequeue.add( child ); } } }","repo":"mpicque\/pom-explorer"}
{"id":25919,"comment_id":3,"comment":"\/\/ todo it seems to me that transitive dependency policy only \/\/ applies to jar artifacts, is that true ?? \/\/ if( \"jar\".equals( dependencykey.gettype() ) )","code":"private void builddependencytree( queue<dependencynode> nodequeue, boolean full, boolean online, session session, map<string, profile> profiles, pomfileloader loader, log log ) { int neededlevels = full ? -1 : 1; while( !nodequeue.isempty() ) { dependencynode node = nodequeue.poll(); if( neededlevels >= 0 && node.getlevel() >= neededlevels ) continue; node.collectdependencymanagement( profiles, session.projects(), log ); map<dependencykey, rawdependency> localdependencies = gethierarchicaldependencies( session, node.getproject(), null, online, profiles, log ); if( localdependencies == null ) continue; for( entry<dependencykey, rawdependency> e : localdependencies.entryset() ) { dependencykey dependencykey = e.getkey(); rawdependency dependency = e.getvalue(); if( dependency.isoptional() && !node.isroot() ) continue; groupartifact ga = new groupartifact( dependencykey.getgroupid(), dependencykey.getartifactid() ); if( isgroupartifactexcluded( node, ga ) ) continue; dependencynode existingnode = node.searchnodeforgroupartifact( ga ); if( existingnode != null ) { if( existingnode.getlevel() <= node.getlevel() + 1 ) continue; else existingnode.removefromparent(); } final optional<versionscope> optionalvs = getversionscopefromdependencymanagement( node, dependencykey, dependency ); final versionscope vs; if(optionalvs.ispresent() ) { vs = optionalvs.get(); } else { vs = dependency.getvs(); if( node.isroot() ) { if(vs.getscope() == null) { vs.setscope( scope.compile ); } } else { scope scope = scope.getscopetransformation( node.getvs().getscope(), dependency.getvs().getscope() ); if(scope == null ) continue; vs.setscope( scope ); } } scope scope = vs.getscope(); assert scope != null; assert vs.getversion() != null : \"null version of dependency \" + dependencykey + \" -> \" + dependency + \" (for project \" + project + \")\"; if( scope == scope.import || scope == scope.system ) continue; \/\/ get remote repositories list<repository> additionalrepos = getprojectrepositories( session, node.getproject(), log ); gav dependencygav = new gav( dependencykey.getgroupid(), dependencykey.getartifactid(), vs.getversion() ); project childproject = null; if( neededlevels < 0 || node.getlevel() >= neededlevels ) { childproject = session.projects().forgav( dependencygav ); if( childproject == null ) { file pomfile = loader.loadpomfileforgav( dependencygav, additionalrepos, log ); if( pomfile == null ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } pomanalysis analysis = new pomanalysis( session, loader, null, false, log ); analysis.addfile( pomfile ); set<project> loadedprojects = analysis.loadprojects(); if( loadedprojects.size() != 1 ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } childproject = loadedprojects.iterator().next(); analysis.completeloadedprojects(); analysis.addcompletedprojectstosession(); set<project> addedtograph = analysis.addcompletedprojectstograph(); if( !addedtograph.contains( childproject ) ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } } if( childproject == null ) { \/\/ todo : use specified repositories if needed ! log.html( tools.warningmessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() + (dependency.isoptional() ? \" (this is an optional dependency)\" : \"\") ) ); continue; } } dependencynode child = new dependencynode( childproject, dependencykey, vs ); child.addexclusions( dependency.getexclusions() ); node.addchild( child ); dependencymanagement dm = node.getlocalmanagement( dependencykey ); if( dm != null ) child.addexclusions( dm.getexclusions() ); \/\/fixme is always false if( scope == scope.system ) continue; \/\/ todo it seems to me that transitive dependency policy only \/\/ applies to jar artifacts, is that true ?? \/\/ if( \"jar\".equals( dependencykey.gettype() ) ) nodequeue.add( child ); } } }","classification":"DESIGN","isFinished":true,"code_context_2":"if( scope == scope.system ) continue; \/\/ todo it seems to me that transitive dependency policy only \/\/ applies to jar artifacts, is that true ?? \/\/ if( \"jar\".equals( dependencykey.gettype() ) ) nodequeue.add( child ); }","code_context_10":"} dependencynode child = new dependencynode( childproject, dependencykey, vs ); child.addexclusions( dependency.getexclusions() ); node.addchild( child ); dependencymanagement dm = node.getlocalmanagement( dependencykey ); if( dm != null ) child.addexclusions( dm.getexclusions() ); \/\/fixme is always false if( scope == scope.system ) continue; \/\/ todo it seems to me that transitive dependency policy only \/\/ applies to jar artifacts, is that true ?? \/\/ if( \"jar\".equals( dependencykey.gettype() ) ) nodequeue.add( child ); } } }","code_context_20":"log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } } if( childproject == null ) { \/\/ todo : use specified repositories if needed ! log.html( tools.warningmessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() + (dependency.isoptional() ? \" (this is an optional dependency)\" : \"\") ) ); continue; } } dependencynode child = new dependencynode( childproject, dependencykey, vs ); child.addexclusions( dependency.getexclusions() ); node.addchild( child ); dependencymanagement dm = node.getlocalmanagement( dependencykey ); if( dm != null ) child.addexclusions( dm.getexclusions() ); \/\/fixme is always false if( scope == scope.system ) continue; \/\/ todo it seems to me that transitive dependency policy only \/\/ applies to jar artifacts, is that true ?? \/\/ if( \"jar\".equals( dependencykey.gettype() ) ) nodequeue.add( child ); } } }","repo":"mpicque\/pom-explorer"}
{"id":34120,"comment_id":0,"comment":"\/\/ todo: see if we can replace the words with icons in the future","code":"private void setupviewpager(viewpager viewpager) { \/\/ todo: see if we can replace the words with icons in the future msectionspageadapter.addfragment(new homefragment(), \"home\"); msectionspageadapter.addfragment(new settingsfragment(), \"settings\"); viewpager.setadapter(msectionspageadapter); }","classification":"DESIGN","isFinished":true,"code_context_2":"private void setupviewpager(viewpager viewpager) { \/\/ todo: see if we can replace the words with icons in the future msectionspageadapter.addfragment(new homefragment(), \"home\"); msectionspageadapter.addfragment(new settingsfragment(), \"settings\");","code_context_10":"private void setupviewpager(viewpager viewpager) { \/\/ todo: see if we can replace the words with icons in the future msectionspageadapter.addfragment(new homefragment(), \"home\"); msectionspageadapter.addfragment(new settingsfragment(), \"settings\"); viewpager.setadapter(msectionspageadapter); }","code_context_20":"private void setupviewpager(viewpager viewpager) { \/\/ todo: see if we can replace the words with icons in the future msectionspageadapter.addfragment(new homefragment(), \"home\"); msectionspageadapter.addfragment(new settingsfragment(), \"settings\"); viewpager.setadapter(msectionspageadapter); }","repo":"mo-morgan\/Food-Radar"}
{"id":1432,"comment_id":0,"comment":"\/\/ always call the superclass","code":"@override public void ondestroy() { super.ondestroy(); \/\/ always call the superclass \/\/ probably not needed, onstop closes the socket, which should make the thread stop (?) if (recvasynctask != null) recvasynctask.cancel(true); recvasynctask = null; }","classification":"NONSATD","isFinished":true,"code_context_2":"@override public void ondestroy() { super.ondestroy(); \/\/ always call the superclass \/\/ probably not needed, onstop closes the socket, which should make the thread stop (?) if (recvasynctask != null)","code_context_10":"@override public void ondestroy() { super.ondestroy(); \/\/ always call the superclass \/\/ probably not needed, onstop closes the socket, which should make the thread stop (?) if (recvasynctask != null) recvasynctask.cancel(true); recvasynctask = null; }","code_context_20":"@override public void ondestroy() { super.ondestroy(); \/\/ always call the superclass \/\/ probably not needed, onstop closes the socket, which should make the thread stop (?) if (recvasynctask != null) recvasynctask.cancel(true); recvasynctask = null; }","repo":"phques\/androidpush"}
{"id":1432,"comment_id":1,"comment":"\/\/ probably not needed, onstop closes the socket, which should make the thread stop (?)","code":"@override public void ondestroy() { super.ondestroy(); \/\/ always call the superclass \/\/ probably not needed, onstop closes the socket, which should make the thread stop (?) if (recvasynctask != null) recvasynctask.cancel(true); recvasynctask = null; }","classification":"DESIGN","isFinished":true,"code_context_2":"public void ondestroy() { super.ondestroy(); \/\/ always call the superclass \/\/ probably not needed, onstop closes the socket, which should make the thread stop (?) if (recvasynctask != null) recvasynctask.cancel(true);","code_context_10":"@override public void ondestroy() { super.ondestroy(); \/\/ always call the superclass \/\/ probably not needed, onstop closes the socket, which should make the thread stop (?) if (recvasynctask != null) recvasynctask.cancel(true); recvasynctask = null; }","code_context_20":"@override public void ondestroy() { super.ondestroy(); \/\/ always call the superclass \/\/ probably not needed, onstop closes the socket, which should make the thread stop (?) if (recvasynctask != null) recvasynctask.cancel(true); recvasynctask = null; }","repo":"phques\/androidpush"}
{"id":1435,"comment_id":0,"comment":"\/\/ todo: get client\/loan\/savings details","code":"public static cashiertransaction fromjson( final cashier cashier, final jsoncommand command) { final integer txntype = command.integervalueofparameternamed(\"txntype\"); final bigdecimal txnamount = command.bigdecimalvalueofparameternamed(\"txnamount\"); final localdate txndate = command.localdatevalueofparameternamed(\"txndate\"); final string entitytype = command.stringvalueofparameternamed(\"entitytype\"); final string txnnote = command.stringvalueofparameternamed(\"txnnote\"); final long entityid = command.longvalueofparameternamed(\"entityid\"); final string currencycode = command.stringvalueofparameternamed(\"currencycode\"); \/\/ todo: get client\/loan\/savings details return new cashiertransaction (cashier, txntype, txnamount, txndate, entitytype, entityid, txnnote, currencycode); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"final long entityid = command.longvalueofparameternamed(\"entityid\"); final string currencycode = command.stringvalueofparameternamed(\"currencycode\"); \/\/ todo: get client\/loan\/savings details return new cashiertransaction (cashier, txntype, txnamount, txndate, entitytype, entityid, txnnote, currencycode);","code_context_10":"public static cashiertransaction fromjson( final cashier cashier, final jsoncommand command) { final integer txntype = command.integervalueofparameternamed(\"txntype\"); final bigdecimal txnamount = command.bigdecimalvalueofparameternamed(\"txnamount\"); final localdate txndate = command.localdatevalueofparameternamed(\"txndate\"); final string entitytype = command.stringvalueofparameternamed(\"entitytype\"); final string txnnote = command.stringvalueofparameternamed(\"txnnote\"); final long entityid = command.longvalueofparameternamed(\"entityid\"); final string currencycode = command.stringvalueofparameternamed(\"currencycode\"); \/\/ todo: get client\/loan\/savings details return new cashiertransaction (cashier, txntype, txnamount, txndate, entitytype, entityid, txnnote, currencycode); }","code_context_20":"public static cashiertransaction fromjson( final cashier cashier, final jsoncommand command) { final integer txntype = command.integervalueofparameternamed(\"txntype\"); final bigdecimal txnamount = command.bigdecimalvalueofparameternamed(\"txnamount\"); final localdate txndate = command.localdatevalueofparameternamed(\"txndate\"); final string entitytype = command.stringvalueofparameternamed(\"entitytype\"); final string txnnote = command.stringvalueofparameternamed(\"txnnote\"); final long entityid = command.longvalueofparameternamed(\"entityid\"); final string currencycode = command.stringvalueofparameternamed(\"currencycode\"); \/\/ todo: get client\/loan\/savings details return new cashiertransaction (cashier, txntype, txnamount, txndate, entitytype, entityid, txnnote, currencycode); }","repo":"raghuvissu\/GST"}
{"id":1463,"comment_id":0,"comment":"\/\/ todo should we set keywords too? \/\/ all tested photo managers set the same in iptc.application2.keywords and xmp.dc.subject","code":"public void parse(inputstream file) throws ioexception, tikaexception { bytearrayoutputstream xmpraw = new bytearrayoutputstream(); if (!scanner.parse(file, xmpraw)) { return; } reader decoded = new inputstreamreader( new bytearrayinputstream(xmpraw.tobytearray()), default_xmp_charset); try { xmpmetadata xmp = xmpmetadata.load(new inputsource(decoded)); xmpschemadublincore dc = xmp.getdublincoreschema(); if (dc != null) { if (dc.gettitle() != null) { metadata.set(dublincore.title, dc.gettitle()); } if (dc.getdescription() != null) { metadata.set(dublincore.description, dc.getdescription()); } if (dc.getcreators() != null && dc.getcreators().size() > 0) { metadata.set(dublincore.creator, joincreators(dc.getcreators())); } if (dc.getsubjects() != null && dc.getsubjects().size() > 0) { iterator<string> keywords = dc.getsubjects().iterator(); while (keywords.hasnext()) { metadata.add(dublincore.subject, keywords.next()); } \/\/ todo should we set keywords too? \/\/ all tested photo managers set the same in iptc.application2.keywords and xmp.dc.subject } } } catch (ioexception e) { \/\/ could not parse embedded xmp metadata. that's not a serious \/\/ problem, so we'll just ignore the issue for now. \/\/ todo: make error handling like this configurable. } }","classification":"DESIGN","isFinished":true,"code_context_2":"metadata.add(dublincore.subject, keywords.next()); } \/\/ todo should we set keywords too? \/\/ all tested photo managers set the same in iptc.application2.keywords and xmp.dc.subject } }","code_context_10":"metadata.set(dublincore.description, dc.getdescription()); } if (dc.getcreators() != null && dc.getcreators().size() > 0) { metadata.set(dublincore.creator, joincreators(dc.getcreators())); } if (dc.getsubjects() != null && dc.getsubjects().size() > 0) { iterator<string> keywords = dc.getsubjects().iterator(); while (keywords.hasnext()) { metadata.add(dublincore.subject, keywords.next()); } \/\/ todo should we set keywords too? \/\/ all tested photo managers set the same in iptc.application2.keywords and xmp.dc.subject } } } catch (ioexception e) { \/\/ could not parse embedded xmp metadata. that's not a serious \/\/ problem, so we'll just ignore the issue for now. \/\/ todo: make error handling like this configurable. } }","code_context_20":"new bytearrayinputstream(xmpraw.tobytearray()), default_xmp_charset); try { xmpmetadata xmp = xmpmetadata.load(new inputsource(decoded)); xmpschemadublincore dc = xmp.getdublincoreschema(); if (dc != null) { if (dc.gettitle() != null) { metadata.set(dublincore.title, dc.gettitle()); } if (dc.getdescription() != null) { metadata.set(dublincore.description, dc.getdescription()); } if (dc.getcreators() != null && dc.getcreators().size() > 0) { metadata.set(dublincore.creator, joincreators(dc.getcreators())); } if (dc.getsubjects() != null && dc.getsubjects().size() > 0) { iterator<string> keywords = dc.getsubjects().iterator(); while (keywords.hasnext()) { metadata.add(dublincore.subject, keywords.next()); } \/\/ todo should we set keywords too? \/\/ all tested photo managers set the same in iptc.application2.keywords and xmp.dc.subject } } } catch (ioexception e) { \/\/ could not parse embedded xmp metadata. that's not a serious \/\/ problem, so we'll just ignore the issue for now. \/\/ todo: make error handling like this configurable. } }","repo":"ontometrics\/tika"}
{"id":1463,"comment_id":1,"comment":"\/\/ could not parse embedded xmp metadata. that's not a serious \/\/ problem, so we'll just ignore the issue for now. \/\/ todo: make error handling like this configurable.","code":"public void parse(inputstream file) throws ioexception, tikaexception { bytearrayoutputstream xmpraw = new bytearrayoutputstream(); if (!scanner.parse(file, xmpraw)) { return; } reader decoded = new inputstreamreader( new bytearrayinputstream(xmpraw.tobytearray()), default_xmp_charset); try { xmpmetadata xmp = xmpmetadata.load(new inputsource(decoded)); xmpschemadublincore dc = xmp.getdublincoreschema(); if (dc != null) { if (dc.gettitle() != null) { metadata.set(dublincore.title, dc.gettitle()); } if (dc.getdescription() != null) { metadata.set(dublincore.description, dc.getdescription()); } if (dc.getcreators() != null && dc.getcreators().size() > 0) { metadata.set(dublincore.creator, joincreators(dc.getcreators())); } if (dc.getsubjects() != null && dc.getsubjects().size() > 0) { iterator<string> keywords = dc.getsubjects().iterator(); while (keywords.hasnext()) { metadata.add(dublincore.subject, keywords.next()); } \/\/ todo should we set keywords too? \/\/ all tested photo managers set the same in iptc.application2.keywords and xmp.dc.subject } } } catch (ioexception e) { \/\/ could not parse embedded xmp metadata. that's not a serious \/\/ problem, so we'll just ignore the issue for now. \/\/ todo: make error handling like this configurable. } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"} } catch (ioexception e) { \/\/ could not parse embedded xmp metadata. that's not a serious \/\/ problem, so we'll just ignore the issue for now. \/\/ todo: make error handling like this configurable. } }","code_context_10":"if (dc.getsubjects() != null && dc.getsubjects().size() > 0) { iterator<string> keywords = dc.getsubjects().iterator(); while (keywords.hasnext()) { metadata.add(dublincore.subject, keywords.next()); } \/\/ todo should we set keywords too? \/\/ all tested photo managers set the same in iptc.application2.keywords and xmp.dc.subject } } } catch (ioexception e) { \/\/ could not parse embedded xmp metadata. that's not a serious \/\/ problem, so we'll just ignore the issue for now. \/\/ todo: make error handling like this configurable. } }","code_context_20":"if (dc != null) { if (dc.gettitle() != null) { metadata.set(dublincore.title, dc.gettitle()); } if (dc.getdescription() != null) { metadata.set(dublincore.description, dc.getdescription()); } if (dc.getcreators() != null && dc.getcreators().size() > 0) { metadata.set(dublincore.creator, joincreators(dc.getcreators())); } if (dc.getsubjects() != null && dc.getsubjects().size() > 0) { iterator<string> keywords = dc.getsubjects().iterator(); while (keywords.hasnext()) { metadata.add(dublincore.subject, keywords.next()); } \/\/ todo should we set keywords too? \/\/ all tested photo managers set the same in iptc.application2.keywords and xmp.dc.subject } } } catch (ioexception e) { \/\/ could not parse embedded xmp metadata. that's not a serious \/\/ problem, so we'll just ignore the issue for now. \/\/ todo: make error handling like this configurable. } }","repo":"ontometrics\/tika"}
{"id":9676,"comment_id":0,"comment":"\/\/ todo: write query to retrieve all movies rated by user with id userid","code":"@override public list<movie> getmoviesratedbyuser(int userid) { \/\/ todo: write query to retrieve all movies rated by user with id userid list<movie> movies = new linkedlist<movie>(); genre genre0 = new genre(0, \"genre0\"); genre genre1 = new genre(1, \"genre1\"); genre genre2 = new genre(2, \"genre2\"); movies.add(new movie(0, \"titre 0\", arrays.aslist(new genre[]{genre0, genre1}))); movies.add(new movie(3, \"titre 3\", arrays.aslist(new genre[]{genre0, genre1, genre2}))); return movies; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"@override public list<movie> getmoviesratedbyuser(int userid) { \/\/ todo: write query to retrieve all movies rated by user with id userid list<movie> movies = new linkedlist<movie>(); genre genre0 = new genre(0, \"genre0\");","code_context_10":"@override public list<movie> getmoviesratedbyuser(int userid) { \/\/ todo: write query to retrieve all movies rated by user with id userid list<movie> movies = new linkedlist<movie>(); genre genre0 = new genre(0, \"genre0\"); genre genre1 = new genre(1, \"genre1\"); genre genre2 = new genre(2, \"genre2\"); movies.add(new movie(0, \"titre 0\", arrays.aslist(new genre[]{genre0, genre1}))); movies.add(new movie(3, \"titre 3\", arrays.aslist(new genre[]{genre0, genre1, genre2}))); return movies; }","code_context_20":"@override public list<movie> getmoviesratedbyuser(int userid) { \/\/ todo: write query to retrieve all movies rated by user with id userid list<movie> movies = new linkedlist<movie>(); genre genre0 = new genre(0, \"genre0\"); genre genre1 = new genre(1, \"genre1\"); genre genre2 = new genre(2, \"genre2\"); movies.add(new movie(0, \"titre 0\", arrays.aslist(new genre[]{genre0, genre1}))); movies.add(new movie(3, \"titre 3\", arrays.aslist(new genre[]{genre0, genre1, genre2}))); return movies; }","repo":"quentinceschin123456\/MovieRecommender"}
{"id":1545,"comment_id":0,"comment":"\/\/todo: optimize","code":"\/\/todo: optimize public void execute(list<string> statements) throws metastoreexception { for (string statement : statements) { execute(statement); } }","classification":"DESIGN","isFinished":true,"code_context_2":"public void execute(list<string> statements) throws metastoreexception { for (string statement : statements) { execute(statement); } }","code_context_10":"public void execute(list<string> statements) throws metastoreexception { for (string statement : statements) { execute(statement); } }","code_context_20":"public void execute(list<string> statements) throws metastoreexception { for (string statement : statements) { execute(statement); } }","repo":"plusplusjiajia\/SSM"}
{"id":9749,"comment_id":0,"comment":"\/\/ there seems to be a bug in the optimizer of 1.6.0_45 so that the output \/\/ values are sometimes reordered - dunno why :(","code":"@test public void testgetformatted () { imutablecurrencyvalue acv = new currencyvalue (ecurrency.eur, mathhelper.tobigdecimal (5)); if (ejavaversion.jdk_9.issupportedversion ()) assertequals (\"5,00\" + currency_space + \"\u20ac\", acv.getcurrencyformatted ()); else assertequals (\"\u20ac\" + currency_space + \"5,00\", acv.getcurrencyformatted ()); acv = new currencyvalue (ecurrency.eur, new bigdecimal (\"5.12\")); if (ejavaversion.jdk_9.issupportedversion ()) assertequals (\"5,12\" + currency_space + \"\u20ac\", acv.getcurrencyformatted ()); else assertequals (\"\u20ac\" + currency_space + \"5,12\", acv.getcurrencyformatted ()); acv = new currencyvalue (ecurrency.usd, new bigdecimal (\"5.12\")); assertequals (\"$5.12\", acv.getcurrencyformatted ()); for (final ecurrency ecurrency : ecurrency.values ()) { acv = new currencyvalue (ecurrency, new bigdecimal (\"5.12\")); final string scurrencyformatted = acv.getcurrencyformatted (); assertnotnull (scurrencyformatted); final string svalueformatted = acv.getvalueformatted (); assertnotnull (svalueformatted); asserttrue (svalueformatted, svalueformatted.indexof (currencyhelper.getcurrencysymbol (ecurrency)) < 0); commonstesthelper.testgetclone (acv); \/\/ there seems to be a bug in the optimizer of 1.6.0_45 so that the output \/\/ values are sometimes reordered - dunno why :( logger.info (\"[\" + scurrencyformatted + \"][\" + svalueformatted + \"]\"); } }","classification":"DEFECT","isFinished":true,"code_context_2":"asserttrue (svalueformatted, svalueformatted.indexof (currencyhelper.getcurrencysymbol (ecurrency)) < 0); commonstesthelper.testgetclone (acv); \/\/ there seems to be a bug in the optimizer of 1.6.0_45 so that the output \/\/ values are sometimes reordered - dunno why :( logger.info (\"[\" + scurrencyformatted + \"][\" + svalueformatted + \"]\"); }","code_context_10":"assertequals (\"$5.12\", acv.getcurrencyformatted ()); for (final ecurrency ecurrency : ecurrency.values ()) { acv = new currencyvalue (ecurrency, new bigdecimal (\"5.12\")); final string scurrencyformatted = acv.getcurrencyformatted (); assertnotnull (scurrencyformatted); final string svalueformatted = acv.getvalueformatted (); assertnotnull (svalueformatted); asserttrue (svalueformatted, svalueformatted.indexof (currencyhelper.getcurrencysymbol (ecurrency)) < 0); commonstesthelper.testgetclone (acv); \/\/ there seems to be a bug in the optimizer of 1.6.0_45 so that the output \/\/ values are sometimes reordered - dunno why :( logger.info (\"[\" + scurrencyformatted + \"][\" + svalueformatted + \"]\"); } }","code_context_20":"if (ejavaversion.jdk_9.issupportedversion ()) assertequals (\"5,00\" + currency_space + \"\u20ac\", acv.getcurrencyformatted ()); else assertequals (\"\u20ac\" + currency_space + \"5,00\", acv.getcurrencyformatted ()); acv = new currencyvalue (ecurrency.eur, new bigdecimal (\"5.12\")); if (ejavaversion.jdk_9.issupportedversion ()) assertequals (\"5,12\" + currency_space + \"\u20ac\", acv.getcurrencyformatted ()); else assertequals (\"\u20ac\" + currency_space + \"5,12\", acv.getcurrencyformatted ()); acv = new currencyvalue (ecurrency.usd, new bigdecimal (\"5.12\")); assertequals (\"$5.12\", acv.getcurrencyformatted ()); for (final ecurrency ecurrency : ecurrency.values ()) { acv = new currencyvalue (ecurrency, new bigdecimal (\"5.12\")); final string scurrencyformatted = acv.getcurrencyformatted (); assertnotnull (scurrencyformatted); final string svalueformatted = acv.getvalueformatted (); assertnotnull (svalueformatted); asserttrue (svalueformatted, svalueformatted.indexof (currencyhelper.getcurrencysymbol (ecurrency)) < 0); commonstesthelper.testgetclone (acv); \/\/ there seems to be a bug in the optimizer of 1.6.0_45 so that the output \/\/ values are sometimes reordered - dunno why :( logger.info (\"[\" + scurrencyformatted + \"][\" + svalueformatted + \"]\"); } }","repo":"phax\/ph-masterdata"}
{"id":34357,"comment_id":0,"comment":"\/** * this method finds all the candidate fields for a given type * candidate fields will ony ever be fields that have either been directly annotated, * or are custom appsmith types (and can hence have fields annotated for encryption within them), * or are parameterized collections of custom appsmith types, * or are parameterized maps with custom appsmith type values (keys are not scanned for encrypted fields) * * @param source document that needs to be checked for encrypted annotations * @return list of candidate fields for the given type and null if this list can not be found at this time *\/","code":"\/** * this method finds all the candidate fields for a given type * candidate fields will ony ever be fields that have either been directly annotated, * or are custom appsmith types (and can hence have fields annotated for encryption within them), * or are parameterized collections of custom appsmith types, * or are parameterized maps with custom appsmith type values (keys are not scanned for encrypted fields) * * @param source document that needs to be checked for encrypted annotations * @return list of candidate fields for the given type and null if this list can not be found at this time *\/ list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","classification":"NONSATD","isFinished":true,"code_context_2":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","code_context_10":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","code_context_20":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","repo":"profencer\/appsmith"}
{"id":34357,"comment_id":1,"comment":"\/\/ at this point source class represents the true polymorphic type of the document","code":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","classification":"NONSATD","isFinished":true,"code_context_2":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type","code_context_10":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives","code_context_20":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null;","repo":"profencer\/appsmith"}
{"id":34357,"comment_id":2,"comment":"\/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap","code":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) {","code_context_10":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) {","code_context_20":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) {","repo":"profencer\/appsmith"}
{"id":34357,"comment_id":3,"comment":"\/\/ the cache is already aware of this type, return candidate fields for it","code":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","classification":"NONSATD","isFinished":true,"code_context_2":"list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; }","code_context_10":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field);","code_context_20":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known);","repo":"profencer\/appsmith"}
{"id":34357,"comment_id":4,"comment":"\/\/ don't bother with primitives","code":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","classification":"NONSATD","isFinished":true,"code_context_2":"return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type","code_context_10":"\/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null;","code_context_20":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic)","repo":"profencer\/appsmith"}
{"id":34357,"comment_id":5,"comment":"\/\/ if it is not known, scan each field for annotation or appsmith type","code":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) {","code_context_10":"\/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source);","code_context_20":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); }","repo":"profencer\/appsmith"}
{"id":34357,"comment_id":6,"comment":"\/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations","code":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","classification":"NONSATD","isFinished":true,"code_context_2":"if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else {","code_context_10":"reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) {","code_context_20":"list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic)","repo":"profencer\/appsmith"}
{"id":34357,"comment_id":7,"comment":"\/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic)","code":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","classification":"NONSATD","isFinished":true,"code_context_2":"candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); }","code_context_10":"} else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic,","code_context_20":"} \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype);","repo":"profencer\/appsmith"}
{"id":34357,"comment_id":8,"comment":"\/\/ if an object exists, check if the object type is the same as the field type","code":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","classification":"NONSATD","isFinished":true,"code_context_2":"} } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) {","code_context_10":"if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat","code_context_20":"synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) {","repo":"profencer\/appsmith"}
{"id":34357,"comment_id":9,"comment":"\/\/ if they match, then this is going to be an appsmith known field","code":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","classification":"NONSATD","isFinished":true,"code_context_2":"candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else {","code_context_10":"candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) {","code_context_20":"candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield);","repo":"profencer\/appsmith"}
{"id":34357,"comment_id":10,"comment":"\/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time","code":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","classification":"NONSATD","isFinished":true,"code_context_2":"appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; }","code_context_10":"\/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); }","code_context_20":"candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain","repo":"profencer\/appsmith"}
{"id":34357,"comment_id":11,"comment":"\/\/ now, go into field type and repeat","code":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","classification":"NONSATD","isFinished":true,"code_context_2":"appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic)","code_context_10":"\/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) {","code_context_20":"if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments();","repo":"profencer\/appsmith"}
{"id":34357,"comment_id":12,"comment":"\/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates","code":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","classification":"NONSATD","isFinished":true,"code_context_2":"if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); }","code_context_10":"appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) &&","code_context_20":"} else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null;","repo":"profencer\/appsmith"}
{"id":34357,"comment_id":13,"comment":"\/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field","code":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","classification":"NONSATD","isFinished":true,"code_context_2":"field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); }","code_context_10":"list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try {","code_context_20":"candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) {","repo":"profencer\/appsmith"}
{"id":34357,"comment_id":14,"comment":"\/\/ if this is a collection, check if the type parameter is an appsmithdomain","code":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","classification":"NONSATD","isFinished":true,"code_context_2":"} else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype();","code_context_10":"} } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) {","code_context_20":"\/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true);","repo":"profencer\/appsmith"}
{"id":34357,"comment_id":15,"comment":"\/\/ this is a known type, it should necessarily be of appsmithdomain type","code":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","classification":"NONSATD","isFinished":true,"code_context_2":"if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype);","code_context_10":"parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue;","code_context_20":"field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) {","repo":"profencer\/appsmith"}
{"id":34357,"comment_id":16,"comment":"\/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations","code":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","classification":"NONSATD","isFinished":true,"code_context_2":"} } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source);","code_context_10":"} if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; }","code_context_20":"field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; }","repo":"profencer\/appsmith"}
{"id":34357,"comment_id":17,"comment":"\/\/ todo add support for nested collections","code":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"} } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) {","code_context_10":"} } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype);","code_context_20":"finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown));","repo":"profencer\/appsmith"}
{"id":34357,"comment_id":18,"comment":"\/\/ this is a known type, it should necessarily be of appsmithdomain type","code":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","classification":"NONSATD","isFinished":true,"code_context_2":"if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype);","code_context_10":"parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue;","code_context_20":"field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) {","repo":"profencer\/appsmith"}
{"id":34357,"comment_id":19,"comment":"\/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations","code":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","classification":"NONSATD","isFinished":true,"code_context_2":"} } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source);","code_context_10":"} if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; }","code_context_20":"field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; }","repo":"profencer\/appsmith"}
{"id":34357,"comment_id":20,"comment":"\/\/ update cache for next use","code":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { \/\/ at this point source class represents the true polymorphic type of the document class<?> sourceclass = source.getclass(); \/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { \/\/ the cache is already aware of this type, return candidate fields for it return candidatefields; } \/\/ don't bother with primitives if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); \/\/ if it is not known, scan each field for annotation or appsmith type list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { \/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { \/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic) candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { \/\/ if an object exists, check if the object type is the same as the field type candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { \/\/ if they match, then this is going to be an appsmith known field appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { \/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } \/\/ now, go into field type and repeat list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { \/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { \/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { \/\/ if this is a collection, check if the type parameter is an appsmithdomain type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } \/\/ todo add support for nested collections } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { \/\/ this is a known type, it should necessarily be of appsmithdomain type assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { \/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","classification":"NONSATD","isFinished":true,"code_context_2":"map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields;","code_context_10":"} } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","code_context_20":"} if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } \/\/ update cache for next use encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","repo":"profencer\/appsmith"}
{"id":1644,"comment_id":0,"comment":"\/** * @desc sets the first timex of type date in the document timex list as the * document creation time todo: make sure \"first\" in list is necessarily * first that appears in document! should be, unless the relevant string * is somehow dropped during sentence tokenization. *\/","code":"\/** * @desc sets the first timex of type date in the document timex list as the * document creation time todo: make sure \"first\" in list is necessarily * first that appears in document! should be, unless the relevant string * is somehow dropped during sentence tokenization. *\/ public static void setfirstdateasdct(sievedocument doc) { if (doc.getdocstamp() == null) { for (timex nexttimex : doc.gettimexes()) { if (nexttimex.gettype().equals(timex.type.date)) { nexttimex.setdocumentfunction(documentfunction.creation_time); doc.addcreationtime(nexttimex); break; } } } }","classification":"DESIGN","isFinished":true,"code_context_2":"public static void setfirstdateasdct(sievedocument doc) { if (doc.getdocstamp() == null) { for (timex nexttimex : doc.gettimexes()) { if (nexttimex.gettype().equals(timex.type.date)) { nexttimex.setdocumentfunction(documentfunction.creation_time); doc.addcreationtime(nexttimex); break; } } } }","code_context_10":"public static void setfirstdateasdct(sievedocument doc) { if (doc.getdocstamp() == null) { for (timex nexttimex : doc.gettimexes()) { if (nexttimex.gettype().equals(timex.type.date)) { nexttimex.setdocumentfunction(documentfunction.creation_time); doc.addcreationtime(nexttimex); break; } } } }","code_context_20":"public static void setfirstdateasdct(sievedocument doc) { if (doc.getdocstamp() == null) { for (timex nexttimex : doc.gettimexes()) { if (nexttimex.gettype().equals(timex.type.date)) { nexttimex.setdocumentfunction(documentfunction.creation_time); doc.addcreationtime(nexttimex); break; } } } }","repo":"nchambers\/caevo"}
{"id":26251,"comment_id":0,"comment":"\/** * a setterwriter expression is one of the following * * \/\/ set: * \/\/ setf: * \/\/ setb: * * @param expression * @return *\/","code":"\/** * a setterwriter expression is one of the following * * \/\/ set: * \/\/ setf: * \/\/ setb: * * @param expression * @return *\/ public settertype determinesettertype(string expression) { \/\/ todo: if (expression.contains(\"setb\")) return settertype.builder; if(expression.contains(\"setf\")) return settertype.field; return settertype.method; }","classification":"NONSATD","isFinished":true,"code_context_2":"public settertype determinesettertype(string expression) { \/\/ todo: if (expression.contains(\"setb\")) return settertype.builder; if(expression.contains(\"setf\")) return settertype.field; return settertype.method; }","code_context_10":"public settertype determinesettertype(string expression) { \/\/ todo: if (expression.contains(\"setb\")) return settertype.builder; if(expression.contains(\"setf\")) return settertype.field; return settertype.method; }","code_context_20":"public settertype determinesettertype(string expression) { \/\/ todo: if (expression.contains(\"setb\")) return settertype.builder; if(expression.contains(\"setf\")) return settertype.field; return settertype.method; }","repo":"nndi-oss\/intellij-just-sett"}
{"id":26251,"comment_id":1,"comment":"\/\/ todo: if (expression.contains(\"setb\")) return settertype.builder;","code":"public settertype determinesettertype(string expression) { \/\/ todo: if (expression.contains(\"setb\")) return settertype.builder; if(expression.contains(\"setf\")) return settertype.field; return settertype.method; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"public settertype determinesettertype(string expression) { \/\/ todo: if (expression.contains(\"setb\")) return settertype.builder; if(expression.contains(\"setf\")) return settertype.field;","code_context_10":"public settertype determinesettertype(string expression) { \/\/ todo: if (expression.contains(\"setb\")) return settertype.builder; if(expression.contains(\"setf\")) return settertype.field; return settertype.method; }","code_context_20":"public settertype determinesettertype(string expression) { \/\/ todo: if (expression.contains(\"setb\")) return settertype.builder; if(expression.contains(\"setf\")) return settertype.field; return settertype.method; }","repo":"nndi-oss\/intellij-just-sett"}
{"id":1701,"comment_id":0,"comment":"\/\/todo: replace this with your own logic","code":"public static boolean ispasswordvalid(string password) { \/\/todo: replace this with your own logic return password.length() > 4; }","classification":"DESIGN","isFinished":true,"code_context_2":"public static boolean ispasswordvalid(string password) { \/\/todo: replace this with your own logic return password.length() > 4; }","code_context_10":"public static boolean ispasswordvalid(string password) { \/\/todo: replace this with your own logic return password.length() > 4; }","code_context_20":"public static boolean ispasswordvalid(string password) { \/\/todo: replace this with your own logic return password.length() > 4; }","repo":"neiplz\/Pedometer"}
{"id":26305,"comment_id":0,"comment":"\/\/ todo: use zone id of context (entry, calendar)","code":"private void updaterule() { recur.builder<localdate> rbuilder = new recur.builder<>(); switch (frequencybox.getvalue()) { case daily: rbuilder.frequency(net.fortuna.ical4j.model.recur.frequency.daily); break; case monthly: rbuilder.frequency(net.fortuna.ical4j.model.recur.frequency.monthly); break; case weekly: rbuilder.frequency(net.fortuna.ical4j.model.recur.frequency.weekly); break; case yearly: rbuilder.frequency(net.fortuna.ical4j.model.recur.frequency.yearly); break; default: break; } int interval = repeatcountspinner.getvalue(); if (interval > 1) { rbuilder.interval(interval); } else { rbuilder.interval(0); } if (endsonbutton.isselected()) { localdate date = endsondatepicker.getvalue(); rbuilder.until(date); } if (endsafterbutton.isselected()) { rbuilder.count(endsaftercounterspinner.getvalue()); } if (frequencybox.getvalue() == frequency.monthly) { if (repeatbydayofthemonth.isselected()) { int value = getskinnable().getstartdate().getdayofmonth(); rbuilder.monthlist(new numberlist(value, value, false)); } else { localdate localdate = getskinnable().getstartdate(); \/\/ todo: use zone id of context (entry, calendar) zoneddatetime zoneddatetime = zoneddatetime.of(localdate, localtime.now(), zoneid.systemdefault()); int hits = 1; zoneddatetime current = zoneddatetime.withdayofmonth(1); do { if (current.getdayofweek() .equals(zoneddatetime.getdayofweek())) { hits++; } current = current.plusdays(1); } while (current.tolocaldate().isbefore(localdate)); weekdaylist weekdays = new weekdaylist(); switch (zoneddatetime.getdayofweek()) { case friday: weekdays.add(new weekday(weekday.fr, hits)); break; case monday: weekdays.add(new weekday(weekday.mo, hits)); break; case saturday: weekdays.add(new weekday(weekday.sa, hits)); break; case sunday: weekdays.add(new weekday(weekday.su, hits)); break; case thursday: weekdays.add(new weekday(weekday.th, hits)); break; case tuesday: weekdays.add(new weekday(weekday.tu, hits)); break; case wednesday: weekdays.add(new weekday(weekday.we, hits)); break; default: break; } rbuilder.daylist(weekdays); } } if (frequencybox.getvalue() == frequency.weekly) { \/* * weekdays mo, tu, .... su *\/ weekdaylist weekdays = new weekdaylist(); maybeaddweekday(weekdays, weekday.mo, weekdaymondaybutton); maybeaddweekday(weekdays, weekday.tu, weekdaytuesdaybutton); maybeaddweekday(weekdays, weekday.we, weekdaywednesdaybutton); maybeaddweekday(weekdays, weekday.th, weekdaythursdaybutton); maybeaddweekday(weekdays, weekday.fr, weekdayfridaybutton); maybeaddweekday(weekdays, weekday.sa, weekdaysaturdaybutton); maybeaddweekday(weekdays, weekday.su, weekdaysundaybutton); rbuilder.daylist(weekdays); } recur<localdate> rule = rbuilder.build(); getskinnable().setrecurrencerule(rule.tostring()); if (loggingdomain.recurrence.isloggable(level.fine)) { loggingdomain.recurrence.fine( \"test dumping 10 recurrences starting with today's date\"); localdate today = localdate.of(2015, 8, 18); list<localdate> dates = rule.getdates(today, today, localdate.max, 10); for (localdate repeatingdate : dates) { loggingdomain.recurrence.fine(repeatingdate.tostring()); } } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"} else { localdate localdate = getskinnable().getstartdate(); \/\/ todo: use zone id of context (entry, calendar) zoneddatetime zoneddatetime = zoneddatetime.of(localdate, localtime.now(), zoneid.systemdefault());","code_context_10":"} if (endsafterbutton.isselected()) { rbuilder.count(endsaftercounterspinner.getvalue()); } if (frequencybox.getvalue() == frequency.monthly) { if (repeatbydayofthemonth.isselected()) { int value = getskinnable().getstartdate().getdayofmonth(); rbuilder.monthlist(new numberlist(value, value, false)); } else { localdate localdate = getskinnable().getstartdate(); \/\/ todo: use zone id of context (entry, calendar) zoneddatetime zoneddatetime = zoneddatetime.of(localdate, localtime.now(), zoneid.systemdefault()); int hits = 1; zoneddatetime current = zoneddatetime.withdayofmonth(1); do { if (current.getdayofweek() .equals(zoneddatetime.getdayofweek())) { hits++; } current = current.plusdays(1);","code_context_20":"} int interval = repeatcountspinner.getvalue(); if (interval > 1) { rbuilder.interval(interval); } else { rbuilder.interval(0); } if (endsonbutton.isselected()) { localdate date = endsondatepicker.getvalue(); rbuilder.until(date); } if (endsafterbutton.isselected()) { rbuilder.count(endsaftercounterspinner.getvalue()); } if (frequencybox.getvalue() == frequency.monthly) { if (repeatbydayofthemonth.isselected()) { int value = getskinnable().getstartdate().getdayofmonth(); rbuilder.monthlist(new numberlist(value, value, false)); } else { localdate localdate = getskinnable().getstartdate(); \/\/ todo: use zone id of context (entry, calendar) zoneddatetime zoneddatetime = zoneddatetime.of(localdate, localtime.now(), zoneid.systemdefault()); int hits = 1; zoneddatetime current = zoneddatetime.withdayofmonth(1); do { if (current.getdayofweek() .equals(zoneddatetime.getdayofweek())) { hits++; } current = current.plusdays(1); } while (current.tolocaldate().isbefore(localdate)); weekdaylist weekdays = new weekdaylist(); switch (zoneddatetime.getdayofweek()) { case friday: weekdays.add(new weekday(weekday.fr, hits)); break; case monday: weekdays.add(new weekday(weekday.mo, hits)); break; case saturday:","repo":"mwkroening\/CalendarFX"}
{"id":26305,"comment_id":1,"comment":"\/* * weekdays mo, tu, .... su *\/","code":"private void updaterule() { recur.builder<localdate> rbuilder = new recur.builder<>(); switch (frequencybox.getvalue()) { case daily: rbuilder.frequency(net.fortuna.ical4j.model.recur.frequency.daily); break; case monthly: rbuilder.frequency(net.fortuna.ical4j.model.recur.frequency.monthly); break; case weekly: rbuilder.frequency(net.fortuna.ical4j.model.recur.frequency.weekly); break; case yearly: rbuilder.frequency(net.fortuna.ical4j.model.recur.frequency.yearly); break; default: break; } int interval = repeatcountspinner.getvalue(); if (interval > 1) { rbuilder.interval(interval); } else { rbuilder.interval(0); } if (endsonbutton.isselected()) { localdate date = endsondatepicker.getvalue(); rbuilder.until(date); } if (endsafterbutton.isselected()) { rbuilder.count(endsaftercounterspinner.getvalue()); } if (frequencybox.getvalue() == frequency.monthly) { if (repeatbydayofthemonth.isselected()) { int value = getskinnable().getstartdate().getdayofmonth(); rbuilder.monthlist(new numberlist(value, value, false)); } else { localdate localdate = getskinnable().getstartdate(); \/\/ todo: use zone id of context (entry, calendar) zoneddatetime zoneddatetime = zoneddatetime.of(localdate, localtime.now(), zoneid.systemdefault()); int hits = 1; zoneddatetime current = zoneddatetime.withdayofmonth(1); do { if (current.getdayofweek() .equals(zoneddatetime.getdayofweek())) { hits++; } current = current.plusdays(1); } while (current.tolocaldate().isbefore(localdate)); weekdaylist weekdays = new weekdaylist(); switch (zoneddatetime.getdayofweek()) { case friday: weekdays.add(new weekday(weekday.fr, hits)); break; case monday: weekdays.add(new weekday(weekday.mo, hits)); break; case saturday: weekdays.add(new weekday(weekday.sa, hits)); break; case sunday: weekdays.add(new weekday(weekday.su, hits)); break; case thursday: weekdays.add(new weekday(weekday.th, hits)); break; case tuesday: weekdays.add(new weekday(weekday.tu, hits)); break; case wednesday: weekdays.add(new weekday(weekday.we, hits)); break; default: break; } rbuilder.daylist(weekdays); } } if (frequencybox.getvalue() == frequency.weekly) { \/* * weekdays mo, tu, .... su *\/ weekdaylist weekdays = new weekdaylist(); maybeaddweekday(weekdays, weekday.mo, weekdaymondaybutton); maybeaddweekday(weekdays, weekday.tu, weekdaytuesdaybutton); maybeaddweekday(weekdays, weekday.we, weekdaywednesdaybutton); maybeaddweekday(weekdays, weekday.th, weekdaythursdaybutton); maybeaddweekday(weekdays, weekday.fr, weekdayfridaybutton); maybeaddweekday(weekdays, weekday.sa, weekdaysaturdaybutton); maybeaddweekday(weekdays, weekday.su, weekdaysundaybutton); rbuilder.daylist(weekdays); } recur<localdate> rule = rbuilder.build(); getskinnable().setrecurrencerule(rule.tostring()); if (loggingdomain.recurrence.isloggable(level.fine)) { loggingdomain.recurrence.fine( \"test dumping 10 recurrences starting with today's date\"); localdate today = localdate.of(2015, 8, 18); list<localdate> dates = rule.getdates(today, today, localdate.max, 10); for (localdate repeatingdate : dates) { loggingdomain.recurrence.fine(repeatingdate.tostring()); } } }","classification":"NONSATD","isFinished":true,"code_context_2":"} if (frequencybox.getvalue() == frequency.weekly) { \/* * weekdays mo, tu, .... su *\/ weekdaylist weekdays = new weekdaylist(); maybeaddweekday(weekdays, weekday.mo,","code_context_10":"case wednesday: weekdays.add(new weekday(weekday.we, hits)); break; default: break; } rbuilder.daylist(weekdays); } } if (frequencybox.getvalue() == frequency.weekly) { \/* * weekdays mo, tu, .... su *\/ weekdaylist weekdays = new weekdaylist(); maybeaddweekday(weekdays, weekday.mo, weekdaymondaybutton); maybeaddweekday(weekdays, weekday.tu, weekdaytuesdaybutton); maybeaddweekday(weekdays, weekday.we, weekdaywednesdaybutton); maybeaddweekday(weekdays, weekday.th, weekdaythursdaybutton); maybeaddweekday(weekdays, weekday.fr,","code_context_20":"break; case sunday: weekdays.add(new weekday(weekday.su, hits)); break; case thursday: weekdays.add(new weekday(weekday.th, hits)); break; case tuesday: weekdays.add(new weekday(weekday.tu, hits)); break; case wednesday: weekdays.add(new weekday(weekday.we, hits)); break; default: break; } rbuilder.daylist(weekdays); } } if (frequencybox.getvalue() == frequency.weekly) { \/* * weekdays mo, tu, .... su *\/ weekdaylist weekdays = new weekdaylist(); maybeaddweekday(weekdays, weekday.mo, weekdaymondaybutton); maybeaddweekday(weekdays, weekday.tu, weekdaytuesdaybutton); maybeaddweekday(weekdays, weekday.we, weekdaywednesdaybutton); maybeaddweekday(weekdays, weekday.th, weekdaythursdaybutton); maybeaddweekday(weekdays, weekday.fr, weekdayfridaybutton); maybeaddweekday(weekdays, weekday.sa, weekdaysaturdaybutton); maybeaddweekday(weekdays, weekday.su, weekdaysundaybutton); rbuilder.daylist(weekdays); } recur<localdate> rule = rbuilder.build(); getskinnable().setrecurrencerule(rule.tostring()); if (loggingdomain.recurrence.isloggable(level.fine)) {","repo":"mwkroening\/CalendarFX"}
{"id":18334,"comment_id":0,"comment":"\/\/todo unit test, document, cleanup","code":"\/\/todo unit test, document, cleanup private boolean checkdoorissealed(world world, blockposition pos, int meta) { \/\/todo: door corners return ((meta & 8) == 8 || ((meta & 4) >> 2 == (meta & 1) && checkdoorseal(world, pos.getpositionatoffset(0, 0, 1), meta) && checkdoorseal(world, pos.getpositionatoffset(0, 0, -1), meta)) || (meta & 4) >> 2 != (meta & 1) && checkdoorseal(world, pos.getpositionatoffset(1, 0, 0), meta) && checkdoorseal(world, pos.getpositionatoffset(-1, 0, 0), meta)); }","classification":"DOCUMENTATION","isFinished":true,"code_context_2":"private boolean checkdoorissealed(world world, blockposition pos, int meta) { \/\/todo: door corners return ((meta & 8) == 8 || ((meta & 4) >> 2 == (meta & 1) && checkdoorseal(world, pos.getpositionatoffset(0, 0, 1), meta) && checkdoorseal(world, pos.getpositionatoffset(0, 0, -1), meta)) || (meta & 4) >> 2 != (meta & 1) && checkdoorseal(world, pos.getpositionatoffset(1, 0, 0), meta) && checkdoorseal(world, pos.getpositionatoffset(-1, 0, 0), meta)); }","code_context_10":"private boolean checkdoorissealed(world world, blockposition pos, int meta) { \/\/todo: door corners return ((meta & 8) == 8 || ((meta & 4) >> 2 == (meta & 1) && checkdoorseal(world, pos.getpositionatoffset(0, 0, 1), meta) && checkdoorseal(world, pos.getpositionatoffset(0, 0, -1), meta)) || (meta & 4) >> 2 != (meta & 1) && checkdoorseal(world, pos.getpositionatoffset(1, 0, 0), meta) && checkdoorseal(world, pos.getpositionatoffset(-1, 0, 0), meta)); }","code_context_20":"private boolean checkdoorissealed(world world, blockposition pos, int meta) { \/\/todo: door corners return ((meta & 8) == 8 || ((meta & 4) >> 2 == (meta & 1) && checkdoorseal(world, pos.getpositionatoffset(0, 0, 1), meta) && checkdoorseal(world, pos.getpositionatoffset(0, 0, -1), meta)) || (meta & 4) >> 2 != (meta & 1) && checkdoorseal(world, pos.getpositionatoffset(1, 0, 0), meta) && checkdoorseal(world, pos.getpositionatoffset(-1, 0, 0), meta)); }","repo":"phit\/AdvancedRocketry"}
{"id":18334,"comment_id":1,"comment":"\/\/todo: door corners","code":"private boolean checkdoorissealed(world world, blockposition pos, int meta) { \/\/todo: door corners return ((meta & 8) == 8 || ((meta & 4) >> 2 == (meta & 1) && checkdoorseal(world, pos.getpositionatoffset(0, 0, 1), meta) && checkdoorseal(world, pos.getpositionatoffset(0, 0, -1), meta)) || (meta & 4) >> 2 != (meta & 1) && checkdoorseal(world, pos.getpositionatoffset(1, 0, 0), meta) && checkdoorseal(world, pos.getpositionatoffset(-1, 0, 0), meta)); }","classification":"DESIGN","isFinished":true,"code_context_2":"private boolean checkdoorissealed(world world, blockposition pos, int meta) { \/\/todo: door corners return ((meta & 8) == 8 ||","code_context_10":"private boolean checkdoorissealed(world world, blockposition pos, int meta) { \/\/todo: door corners return ((meta & 8) == 8 || ((meta & 4) >> 2 == (meta & 1) && checkdoorseal(world, pos.getpositionatoffset(0, 0, 1), meta) && checkdoorseal(world, pos.getpositionatoffset(0, 0, -1), meta)) || (meta & 4) >> 2 != (meta & 1) && checkdoorseal(world, pos.getpositionatoffset(1, 0, 0), meta) && checkdoorseal(world, pos.getpositionatoffset(-1, 0, 0), meta)); }","code_context_20":"private boolean checkdoorissealed(world world, blockposition pos, int meta) { \/\/todo: door corners return ((meta & 8) == 8 || ((meta & 4) >> 2 == (meta & 1) && checkdoorseal(world, pos.getpositionatoffset(0, 0, 1), meta) && checkdoorseal(world, pos.getpositionatoffset(0, 0, -1), meta)) || (meta & 4) >> 2 != (meta & 1) && checkdoorseal(world, pos.getpositionatoffset(1, 0, 0), meta) && checkdoorseal(world, pos.getpositionatoffset(-1, 0, 0), meta)); }","repo":"phit\/AdvancedRocketry"}
{"id":18335,"comment_id":0,"comment":"\/\/todo unit test, document, cleanup","code":"\/\/todo unit test, document, cleanup private boolean checkdoorseal(world world, blockposition pos, int meta) { block otherblock = world.getblock(pos.x, pos.y, pos.z); int othermeta = world.getblockmetadata(pos.x, pos.y, pos.z); return (otherblock == advancedrocketryblocks.blockairlock && (othermeta & 1) == (meta & 1)) || (otherblock != advancedrocketryblocks.blockairlock && isblocksealed(world, pos)); }","classification":"DOCUMENTATION","isFinished":true,"code_context_2":"private boolean checkdoorseal(world world, blockposition pos, int meta) { block otherblock = world.getblock(pos.x, pos.y, pos.z); int othermeta = world.getblockmetadata(pos.x, pos.y, pos.z); return (otherblock == advancedrocketryblocks.blockairlock && (othermeta & 1) == (meta & 1)) || (otherblock != advancedrocketryblocks.blockairlock && isblocksealed(world, pos)); }","code_context_10":"private boolean checkdoorseal(world world, blockposition pos, int meta) { block otherblock = world.getblock(pos.x, pos.y, pos.z); int othermeta = world.getblockmetadata(pos.x, pos.y, pos.z); return (otherblock == advancedrocketryblocks.blockairlock && (othermeta & 1) == (meta & 1)) || (otherblock != advancedrocketryblocks.blockairlock && isblocksealed(world, pos)); }","code_context_20":"private boolean checkdoorseal(world world, blockposition pos, int meta) { block otherblock = world.getblock(pos.x, pos.y, pos.z); int othermeta = world.getblockmetadata(pos.x, pos.y, pos.z); return (otherblock == advancedrocketryblocks.blockairlock && (othermeta & 1) == (meta & 1)) || (otherblock != advancedrocketryblocks.blockairlock && isblocksealed(world, pos)); }","repo":"phit\/AdvancedRocketry"}
{"id":34826,"comment_id":0,"comment":"\/\/ fixme should we support this now?","code":"\/\/ fixme should we support this now? @test(enabled=false) public void testgetfutureconfigwhenready() throws exception { mypolicy policy = new mypolicy(mutablemap.builder() .put(testentity.conf_name, dependentconfiguration.whendone(callables.returning(\"aval\"))) .build()); app.policies().add(policy); assertequals(policy.getconfig(testentity.conf_name), \"aval\"); }","classification":"DESIGN","isFinished":true,"code_context_2":"@test(enabled=false) public void testgetfutureconfigwhenready() throws exception { mypolicy policy = new mypolicy(mutablemap.builder() .put(testentity.conf_name, dependentconfiguration.whendone(callables.returning(\"aval\"))) .build()); app.policies().add(policy); assertequals(policy.getconfig(testentity.conf_name), \"aval\"); }","code_context_10":"@test(enabled=false) public void testgetfutureconfigwhenready() throws exception { mypolicy policy = new mypolicy(mutablemap.builder() .put(testentity.conf_name, dependentconfiguration.whendone(callables.returning(\"aval\"))) .build()); app.policies().add(policy); assertequals(policy.getconfig(testentity.conf_name), \"aval\"); }","code_context_20":"@test(enabled=false) public void testgetfutureconfigwhenready() throws exception { mypolicy policy = new mypolicy(mutablemap.builder() .put(testentity.conf_name, dependentconfiguration.whendone(callables.returning(\"aval\"))) .build()); app.policies().add(policy); assertequals(policy.getconfig(testentity.conf_name), \"aval\"); }","repo":"nakomis\/incubator-brooklyn"}
{"id":34827,"comment_id":0,"comment":"\/\/ fixme should we support this now?","code":"\/\/ fixme should we support this now? @test(enabled=false) public void testgetfutureconfigblocksuntilready() throws exception { final countdownlatch latch = new countdownlatch(1); mypolicy policy = new mypolicy(mutablemap.builder() .put(testentity.conf_name, dependentconfiguration.whendone(new callable<string>() { public string call() { try { latch.await(); return \"aval\"; } catch (interruptedexception e) { throw exceptions.propagate(e); } }})) .build()); app.policies().add(policy); thread t = new thread(new runnable() { public void run() { try { thread.sleep(10+early_return_grace); latch.countdown(); } catch (interruptedexception e) { throw exceptions.propagate(e); } }}); try { long starttime = system.currenttimemillis(); t.start(); assertequals(policy.getconfig(testentity.conf_name), \"aval\"); long endtime = system.currenttimemillis(); asserttrue((endtime - starttime) >= 10, \"starttime=\"+starttime+\"; endtime=\"+endtime); } finally { t.interrupt(); } }","classification":"DESIGN","isFinished":true,"code_context_2":"@test(enabled=false) public void testgetfutureconfigblocksuntilready() throws exception { final countdownlatch latch = new countdownlatch(1); mypolicy policy = new mypolicy(mutablemap.builder() .put(testentity.conf_name, dependentconfiguration.whendone(new callable<string>() { public string call() { try { latch.await(); return \"aval\"; } catch (interruptedexception e) { throw exceptions.propagate(e); } }})) .build()); app.policies().add(policy); thread t = new thread(new runnable() { public void run() { try { thread.sleep(10+early_return_grace); latch.countdown(); } catch (interruptedexception e) { throw exceptions.propagate(e); } }}); try { long starttime = system.currenttimemillis(); t.start(); assertequals(policy.getconfig(testentity.conf_name), \"aval\"); long endtime = system.currenttimemillis(); asserttrue((endtime - starttime) >= 10, \"starttime=\"+starttime+\"; endtime=\"+endtime); } finally { t.interrupt(); } }","code_context_10":"@test(enabled=false) public void testgetfutureconfigblocksuntilready() throws exception { final countdownlatch latch = new countdownlatch(1); mypolicy policy = new mypolicy(mutablemap.builder() .put(testentity.conf_name, dependentconfiguration.whendone(new callable<string>() { public string call() { try { latch.await(); return \"aval\"; } catch (interruptedexception e) { throw exceptions.propagate(e); } }})) .build()); app.policies().add(policy); thread t = new thread(new runnable() { public void run() { try { thread.sleep(10+early_return_grace); latch.countdown(); } catch (interruptedexception e) { throw exceptions.propagate(e); } }}); try { long starttime = system.currenttimemillis(); t.start(); assertequals(policy.getconfig(testentity.conf_name), \"aval\"); long endtime = system.currenttimemillis(); asserttrue((endtime - starttime) >= 10, \"starttime=\"+starttime+\"; endtime=\"+endtime); } finally { t.interrupt(); } }","code_context_20":"@test(enabled=false) public void testgetfutureconfigblocksuntilready() throws exception { final countdownlatch latch = new countdownlatch(1); mypolicy policy = new mypolicy(mutablemap.builder() .put(testentity.conf_name, dependentconfiguration.whendone(new callable<string>() { public string call() { try { latch.await(); return \"aval\"; } catch (interruptedexception e) { throw exceptions.propagate(e); } }})) .build()); app.policies().add(policy); thread t = new thread(new runnable() { public void run() { try { thread.sleep(10+early_return_grace); latch.countdown(); } catch (interruptedexception e) { throw exceptions.propagate(e); } }}); try { long starttime = system.currenttimemillis(); t.start(); assertequals(policy.getconfig(testentity.conf_name), \"aval\"); long endtime = system.currenttimemillis(); asserttrue((endtime - starttime) >= 10, \"starttime=\"+starttime+\"; endtime=\"+endtime); } finally { t.interrupt(); } }","repo":"nakomis\/incubator-brooklyn"}
{"id":18502,"comment_id":0,"comment":"\/\/ note: painting code, cannot test","code":"public void testupdate() { \/\/ note: painting code, cannot test }","classification":"TEST","isFinished":true,"code_context_2":"public void testupdate() { \/\/ note: painting code, cannot test }","code_context_10":"public void testupdate() { \/\/ note: painting code, cannot test }","code_context_20":"public void testupdate() { \/\/ note: painting code, cannot test }","repo":"qinFamily\/freeVM"}
{"id":18503,"comment_id":0,"comment":"\/\/ note: painting code, cannot test","code":"public void testpaint() { \/\/ note: painting code, cannot test }","classification":"TEST","isFinished":true,"code_context_2":"public void testpaint() { \/\/ note: painting code, cannot test }","code_context_10":"public void testpaint() { \/\/ note: painting code, cannot test }","code_context_20":"public void testpaint() { \/\/ note: painting code, cannot test }","repo":"qinFamily\/freeVM"}
{"id":18504,"comment_id":0,"comment":"\/\/ note: painting code, cannot test","code":"public void testpaintcontentborderbottomedge() { \/\/ note: painting code, cannot test }","classification":"TEST","isFinished":true,"code_context_2":"public void testpaintcontentborderbottomedge() { \/\/ note: painting code, cannot test }","code_context_10":"public void testpaintcontentborderbottomedge() { \/\/ note: painting code, cannot test }","code_context_20":"public void testpaintcontentborderbottomedge() { \/\/ note: painting code, cannot test }","repo":"qinFamily\/freeVM"}
{"id":18505,"comment_id":0,"comment":"\/\/ note: painting code, cannot test","code":"public void testpaintcontentborderleftedge() { \/\/ note: painting code, cannot test }","classification":"TEST","isFinished":true,"code_context_2":"public void testpaintcontentborderleftedge() { \/\/ note: painting code, cannot test }","code_context_10":"public void testpaintcontentborderleftedge() { \/\/ note: painting code, cannot test }","code_context_20":"public void testpaintcontentborderleftedge() { \/\/ note: painting code, cannot test }","repo":"qinFamily\/freeVM"}
{"id":18506,"comment_id":0,"comment":"\/\/ note: painting code, cannot test","code":"public void testpaintcontentborderrightedge() { \/\/ note: painting code, cannot test }","classification":"TEST","isFinished":true,"code_context_2":"public void testpaintcontentborderrightedge() { \/\/ note: painting code, cannot test }","code_context_10":"public void testpaintcontentborderrightedge() { \/\/ note: painting code, cannot test }","code_context_20":"public void testpaintcontentborderrightedge() { \/\/ note: painting code, cannot test }","repo":"qinFamily\/freeVM"}
{"id":18507,"comment_id":0,"comment":"\/\/ note: painting code, cannot test","code":"public void testpaintcontentbordertopedge() { \/\/ note: painting code, cannot test }","classification":"TEST","isFinished":true,"code_context_2":"public void testpaintcontentbordertopedge() { \/\/ note: painting code, cannot test }","code_context_10":"public void testpaintcontentbordertopedge() { \/\/ note: painting code, cannot test }","code_context_20":"public void testpaintcontentbordertopedge() { \/\/ note: painting code, cannot test }","repo":"qinFamily\/freeVM"}
{"id":18508,"comment_id":0,"comment":"\/\/ note: painting code, cannot test","code":"public void testpaintfocusindicator() { \/\/ note: painting code, cannot test }","classification":"TEST","isFinished":true,"code_context_2":"public void testpaintfocusindicator() { \/\/ note: painting code, cannot test }","code_context_10":"public void testpaintfocusindicator() { \/\/ note: painting code, cannot test }","code_context_20":"public void testpaintfocusindicator() { \/\/ note: painting code, cannot test }","repo":"qinFamily\/freeVM"}
{"id":18509,"comment_id":0,"comment":"\/\/ note: painting code, cannot test","code":"public void testpainttabbackground() { \/\/ note: painting code, cannot test }","classification":"TEST","isFinished":true,"code_context_2":"public void testpainttabbackground() { \/\/ note: painting code, cannot test }","code_context_10":"public void testpainttabbackground() { \/\/ note: painting code, cannot test }","code_context_20":"public void testpainttabbackground() { \/\/ note: painting code, cannot test }","repo":"qinFamily\/freeVM"}
{"id":18510,"comment_id":0,"comment":"\/\/ note: painting code, cannot test","code":"public void testpainttabborder() { \/\/ note: painting code, cannot test }","classification":"TEST","isFinished":true,"code_context_2":"public void testpainttabborder() { \/\/ note: painting code, cannot test }","code_context_10":"public void testpainttabborder() { \/\/ note: painting code, cannot test }","code_context_20":"public void testpainttabborder() { \/\/ note: painting code, cannot test }","repo":"qinFamily\/freeVM"}
{"id":18511,"comment_id":0,"comment":"\/\/ note: painting code, cannot test","code":"public void testpainthighlightbelowtab() { \/\/ note: painting code, cannot test }","classification":"TEST","isFinished":true,"code_context_2":"public void testpainthighlightbelowtab() { \/\/ note: painting code, cannot test }","code_context_10":"public void testpainthighlightbelowtab() { \/\/ note: painting code, cannot test }","code_context_20":"public void testpainthighlightbelowtab() { \/\/ note: painting code, cannot test }","repo":"qinFamily\/freeVM"}
{"id":18512,"comment_id":0,"comment":"\/\/ note: painting code, cannot test","code":"public void testpaintbottomtabborder() { \/\/ note: painting code, cannot test }","classification":"TEST","isFinished":true,"code_context_2":"public void testpaintbottomtabborder() { \/\/ note: painting code, cannot test }","code_context_10":"public void testpaintbottomtabborder() { \/\/ note: painting code, cannot test }","code_context_20":"public void testpaintbottomtabborder() { \/\/ note: painting code, cannot test }","repo":"qinFamily\/freeVM"}
{"id":18513,"comment_id":0,"comment":"\/\/ note: painting code, cannot test","code":"public void testpaintlefttabborder() { \/\/ note: painting code, cannot test }","classification":"TEST","isFinished":true,"code_context_2":"public void testpaintlefttabborder() { \/\/ note: painting code, cannot test }","code_context_10":"public void testpaintlefttabborder() { \/\/ note: painting code, cannot test }","code_context_20":"public void testpaintlefttabborder() { \/\/ note: painting code, cannot test }","repo":"qinFamily\/freeVM"}
{"id":18514,"comment_id":0,"comment":"\/\/ note: painting code, cannot test","code":"public void testpaintrighttabborder() { \/\/ note: painting code, cannot test }","classification":"TEST","isFinished":true,"code_context_2":"public void testpaintrighttabborder() { \/\/ note: painting code, cannot test }","code_context_10":"public void testpaintrighttabborder() { \/\/ note: painting code, cannot test }","code_context_20":"public void testpaintrighttabborder() { \/\/ note: painting code, cannot test }","repo":"qinFamily\/freeVM"}
{"id":18515,"comment_id":0,"comment":"\/\/ note: painting code, cannot test","code":"public void testpainttoptabborder() { \/\/ note: painting code, cannot test }","classification":"TEST","isFinished":true,"code_context_2":"public void testpainttoptabborder() { \/\/ note: painting code, cannot test }","code_context_10":"public void testpainttoptabborder() { \/\/ note: painting code, cannot test }","code_context_20":"public void testpainttoptabborder() { \/\/ note: painting code, cannot test }","repo":"qinFamily\/freeVM"}
{"id":18636,"comment_id":0,"comment":"\/\/todo: download (in background?)","code":"@override public set<javaplatform> instantiate() throws ioexception { \/\/todo: download (in background?) string downloadedfolder = (string) wizard.getproperty(discoplatformit.prop_download); if (downloadedfolder != null) { file f = new file(downloadedfolder); if (!f.isdirectory()) { \/\/open the file manager for the parent folder desktop.getdesktop().open(f.getparentfile()); return collections.empty_set; } string name = state.selection.getjavaplatformdisplayname(); return collections.singleton(j2seplatformutils.register(new file(downloadedfolder), name)); } else { \/\/todo: notifcation? return collections.empty_set; } }","classification":"DESIGN","isFinished":true,"code_context_2":"@override public set<javaplatform> instantiate() throws ioexception { \/\/todo: download (in background?) string downloadedfolder = (string) wizard.getproperty(discoplatformit.prop_download); if (downloadedfolder != null) {","code_context_10":"@override public set<javaplatform> instantiate() throws ioexception { \/\/todo: download (in background?) string downloadedfolder = (string) wizard.getproperty(discoplatformit.prop_download); if (downloadedfolder != null) { file f = new file(downloadedfolder); if (!f.isdirectory()) { \/\/open the file manager for the parent folder desktop.getdesktop().open(f.getparentfile()); return collections.empty_set; } string name = state.selection.getjavaplatformdisplayname(); return collections.singleton(j2seplatformutils.register(new file(downloadedfolder), name));","code_context_20":"@override public set<javaplatform> instantiate() throws ioexception { \/\/todo: download (in background?) string downloadedfolder = (string) wizard.getproperty(discoplatformit.prop_download); if (downloadedfolder != null) { file f = new file(downloadedfolder); if (!f.isdirectory()) { \/\/open the file manager for the parent folder desktop.getdesktop().open(f.getparentfile()); return collections.empty_set; } string name = state.selection.getjavaplatformdisplayname(); return collections.singleton(j2seplatformutils.register(new file(downloadedfolder), name)); } else { \/\/todo: notifcation? return collections.empty_set; } }","repo":"oyarzun\/incubator-netbeans"}
{"id":18636,"comment_id":1,"comment":"\/\/open the file manager for the parent folder","code":"@override public set<javaplatform> instantiate() throws ioexception { \/\/todo: download (in background?) string downloadedfolder = (string) wizard.getproperty(discoplatformit.prop_download); if (downloadedfolder != null) { file f = new file(downloadedfolder); if (!f.isdirectory()) { \/\/open the file manager for the parent folder desktop.getdesktop().open(f.getparentfile()); return collections.empty_set; } string name = state.selection.getjavaplatformdisplayname(); return collections.singleton(j2seplatformutils.register(new file(downloadedfolder), name)); } else { \/\/todo: notifcation? return collections.empty_set; } }","classification":"NONSATD","isFinished":true,"code_context_2":"file f = new file(downloadedfolder); if (!f.isdirectory()) { \/\/open the file manager for the parent folder desktop.getdesktop().open(f.getparentfile()); return collections.empty_set;","code_context_10":"@override public set<javaplatform> instantiate() throws ioexception { \/\/todo: download (in background?) string downloadedfolder = (string) wizard.getproperty(discoplatformit.prop_download); if (downloadedfolder != null) { file f = new file(downloadedfolder); if (!f.isdirectory()) { \/\/open the file manager for the parent folder desktop.getdesktop().open(f.getparentfile()); return collections.empty_set; } string name = state.selection.getjavaplatformdisplayname(); return collections.singleton(j2seplatformutils.register(new file(downloadedfolder), name)); } else { \/\/todo: notifcation? return collections.empty_set; } }","code_context_20":"@override public set<javaplatform> instantiate() throws ioexception { \/\/todo: download (in background?) string downloadedfolder = (string) wizard.getproperty(discoplatformit.prop_download); if (downloadedfolder != null) { file f = new file(downloadedfolder); if (!f.isdirectory()) { \/\/open the file manager for the parent folder desktop.getdesktop().open(f.getparentfile()); return collections.empty_set; } string name = state.selection.getjavaplatformdisplayname(); return collections.singleton(j2seplatformutils.register(new file(downloadedfolder), name)); } else { \/\/todo: notifcation? return collections.empty_set; } }","repo":"oyarzun\/incubator-netbeans"}
{"id":18636,"comment_id":2,"comment":"\/\/todo: notifcation?","code":"@override public set<javaplatform> instantiate() throws ioexception { \/\/todo: download (in background?) string downloadedfolder = (string) wizard.getproperty(discoplatformit.prop_download); if (downloadedfolder != null) { file f = new file(downloadedfolder); if (!f.isdirectory()) { \/\/open the file manager for the parent folder desktop.getdesktop().open(f.getparentfile()); return collections.empty_set; } string name = state.selection.getjavaplatformdisplayname(); return collections.singleton(j2seplatformutils.register(new file(downloadedfolder), name)); } else { \/\/todo: notifcation? return collections.empty_set; } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"return collections.singleton(j2seplatformutils.register(new file(downloadedfolder), name)); } else { \/\/todo: notifcation? return collections.empty_set; }","code_context_10":"if (downloadedfolder != null) { file f = new file(downloadedfolder); if (!f.isdirectory()) { \/\/open the file manager for the parent folder desktop.getdesktop().open(f.getparentfile()); return collections.empty_set; } string name = state.selection.getjavaplatformdisplayname(); return collections.singleton(j2seplatformutils.register(new file(downloadedfolder), name)); } else { \/\/todo: notifcation? return collections.empty_set; } }","code_context_20":"@override public set<javaplatform> instantiate() throws ioexception { \/\/todo: download (in background?) string downloadedfolder = (string) wizard.getproperty(discoplatformit.prop_download); if (downloadedfolder != null) { file f = new file(downloadedfolder); if (!f.isdirectory()) { \/\/open the file manager for the parent folder desktop.getdesktop().open(f.getparentfile()); return collections.empty_set; } string name = state.selection.getjavaplatformdisplayname(); return collections.singleton(j2seplatformutils.register(new file(downloadedfolder), name)); } else { \/\/todo: notifcation? return collections.empty_set; } }","repo":"oyarzun\/incubator-netbeans"}
{"id":2277,"comment_id":0,"comment":"\/\/ todo 7: [optional] fill with your own implementation for handling \/\/ asynchronous data from the driver layer to the device service","code":"@suppresswarnings(\"unused\") private void receive() { \/\/ todo 7: [optional] fill with your own implementation for handling \/\/ asynchronous data from the driver layer to the device service modbusdevice device = null; string result = \"\"; resourceoperation operation = null; objectcache.putreadings(device, operation, result); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"@suppresswarnings(\"unused\") private void receive() { \/\/ todo 7: [optional] fill with your own implementation for handling \/\/ asynchronous data from the driver layer to the device service modbusdevice device = null; string result = \"\";","code_context_10":"@suppresswarnings(\"unused\") private void receive() { \/\/ todo 7: [optional] fill with your own implementation for handling \/\/ asynchronous data from the driver layer to the device service modbusdevice device = null; string result = \"\"; resourceoperation operation = null; objectcache.putreadings(device, operation, result); }","code_context_20":"@suppresswarnings(\"unused\") private void receive() { \/\/ todo 7: [optional] fill with your own implementation for handling \/\/ asynchronous data from the driver layer to the device service modbusdevice device = null; string result = \"\"; resourceoperation operation = null; objectcache.putreadings(device, operation, result); }","repo":"pk-80\/device-modbus"}
{"id":18772,"comment_id":0,"comment":"\/\/todo switch s and w","code":"private void initstate(){ \/\/todo switch s and w this.s = bigdecimal.one; \/\/new bigdecimal(this.cloudsnum); \/\/ @todo erro? (x = bigdecimal.one) this.w = super.getinitvalue(); \/\/clear message received buffer this.msgrcvbuffer = new hashmap<string, message<?>>(); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"private void initstate(){ \/\/todo switch s and w this.s = bigdecimal.one; \/\/new bigdecimal(this.cloudsnum); \/\/ @todo erro? (x = bigdecimal.one) this.w = super.getinitvalue();","code_context_10":"private void initstate(){ \/\/todo switch s and w this.s = bigdecimal.one; \/\/new bigdecimal(this.cloudsnum); \/\/ @todo erro? (x = bigdecimal.one) this.w = super.getinitvalue(); \/\/clear message received buffer this.msgrcvbuffer = new hashmap<string, message<?>>(); }","code_context_20":"private void initstate(){ \/\/todo switch s and w this.s = bigdecimal.one; \/\/new bigdecimal(this.cloudsnum); \/\/ @todo erro? (x = bigdecimal.one) this.w = super.getinitvalue(); \/\/clear message received buffer this.msgrcvbuffer = new hashmap<string, message<?>>(); }","repo":"pcjesus\/NetworkSimulator"}
{"id":18772,"comment_id":1,"comment":"\/\/new bigdecimal(this.cloudsnum); \/\/ @todo erro? (x = bigdecimal.one)","code":"private void initstate(){ \/\/todo switch s and w this.s = bigdecimal.one; \/\/new bigdecimal(this.cloudsnum); \/\/ @todo erro? (x = bigdecimal.one) this.w = super.getinitvalue(); \/\/clear message received buffer this.msgrcvbuffer = new hashmap<string, message<?>>(); }","classification":"DESIGN","isFinished":true,"code_context_2":"private void initstate(){ \/\/todo switch s and w this.s = bigdecimal.one; \/\/new bigdecimal(this.cloudsnum); \/\/ @todo erro? (x = bigdecimal.one) this.w = super.getinitvalue(); \/\/clear message received buffer","code_context_10":"private void initstate(){ \/\/todo switch s and w this.s = bigdecimal.one; \/\/new bigdecimal(this.cloudsnum); \/\/ @todo erro? (x = bigdecimal.one) this.w = super.getinitvalue(); \/\/clear message received buffer this.msgrcvbuffer = new hashmap<string, message<?>>(); }","code_context_20":"private void initstate(){ \/\/todo switch s and w this.s = bigdecimal.one; \/\/new bigdecimal(this.cloudsnum); \/\/ @todo erro? (x = bigdecimal.one) this.w = super.getinitvalue(); \/\/clear message received buffer this.msgrcvbuffer = new hashmap<string, message<?>>(); }","repo":"pcjesus\/NetworkSimulator"}
{"id":18772,"comment_id":2,"comment":"\/\/clear message received buffer","code":"private void initstate(){ \/\/todo switch s and w this.s = bigdecimal.one; \/\/new bigdecimal(this.cloudsnum); \/\/ @todo erro? (x = bigdecimal.one) this.w = super.getinitvalue(); \/\/clear message received buffer this.msgrcvbuffer = new hashmap<string, message<?>>(); }","classification":"NONSATD","isFinished":true,"code_context_2":"this.s = bigdecimal.one; \/\/new bigdecimal(this.cloudsnum); \/\/ @todo erro? (x = bigdecimal.one) this.w = super.getinitvalue(); \/\/clear message received buffer this.msgrcvbuffer = new hashmap<string, message<?>>(); }","code_context_10":"private void initstate(){ \/\/todo switch s and w this.s = bigdecimal.one; \/\/new bigdecimal(this.cloudsnum); \/\/ @todo erro? (x = bigdecimal.one) this.w = super.getinitvalue(); \/\/clear message received buffer this.msgrcvbuffer = new hashmap<string, message<?>>(); }","code_context_20":"private void initstate(){ \/\/todo switch s and w this.s = bigdecimal.one; \/\/new bigdecimal(this.cloudsnum); \/\/ @todo erro? (x = bigdecimal.one) this.w = super.getinitvalue(); \/\/clear message received buffer this.msgrcvbuffer = new hashmap<string, message<?>>(); }","repo":"pcjesus\/NetworkSimulator"}
{"id":10767,"comment_id":0,"comment":"\/\/ this is problematic as the user code class loader is not \/\/ available at this point.","code":"@override public void shutdown() throws exception { synchronized (shutdownlock) { \/\/ this is problematic as the user code class loader is not \/\/ available at this point. for (savepoint savepoint : savepoints.values()) { try { savepoint.dispose(); } catch (throwable t) { log.warn(\"failed to dispose savepoint \" + savepoint.getcheckpointid(), t); } } savepoints.clear(); \/\/ remove shutdown hook to prevent resource leaks, unless this is \/\/ invoked by the shutdown hook itself. if (shutdownhook != null && shutdownhook != thread.currentthread()) { try { runtime.getruntime().removeshutdownhook(shutdownhook); } catch (illegalstateexception ignored) { \/\/ race, jvm is in shutdown already, we can safely ignore this } catch (throwable t) { log.warn(\"failed to unregister shut down hook.\"); } } shutdown = true; } }","classification":"DEFECT","isFinished":true,"code_context_2":"public void shutdown() throws exception { synchronized (shutdownlock) { \/\/ this is problematic as the user code class loader is not \/\/ available at this point. for (savepoint savepoint : savepoints.values()) { try {","code_context_10":"@override public void shutdown() throws exception { synchronized (shutdownlock) { \/\/ this is problematic as the user code class loader is not \/\/ available at this point. for (savepoint savepoint : savepoints.values()) { try { savepoint.dispose(); } catch (throwable t) { log.warn(\"failed to dispose savepoint \" + savepoint.getcheckpointid(), t); } } savepoints.clear(); \/\/ remove shutdown hook to prevent resource leaks, unless this is \/\/ invoked by the shutdown hook itself.","code_context_20":"@override public void shutdown() throws exception { synchronized (shutdownlock) { \/\/ this is problematic as the user code class loader is not \/\/ available at this point. for (savepoint savepoint : savepoints.values()) { try { savepoint.dispose(); } catch (throwable t) { log.warn(\"failed to dispose savepoint \" + savepoint.getcheckpointid(), t); } } savepoints.clear(); \/\/ remove shutdown hook to prevent resource leaks, unless this is \/\/ invoked by the shutdown hook itself. if (shutdownhook != null && shutdownhook != thread.currentthread()) { try { runtime.getruntime().removeshutdownhook(shutdownhook); } catch (illegalstateexception ignored) { \/\/ race, jvm is in shutdown already, we can safely ignore this } catch (throwable t) { log.warn(\"failed to unregister shut down hook.\"); } } shutdown = true;","repo":"qingdao81\/flink"}
{"id":10767,"comment_id":1,"comment":"\/\/ remove shutdown hook to prevent resource leaks, unless this is \/\/ invoked by the shutdown hook itself.","code":"@override public void shutdown() throws exception { synchronized (shutdownlock) { \/\/ this is problematic as the user code class loader is not \/\/ available at this point. for (savepoint savepoint : savepoints.values()) { try { savepoint.dispose(); } catch (throwable t) { log.warn(\"failed to dispose savepoint \" + savepoint.getcheckpointid(), t); } } savepoints.clear(); \/\/ remove shutdown hook to prevent resource leaks, unless this is \/\/ invoked by the shutdown hook itself. if (shutdownhook != null && shutdownhook != thread.currentthread()) { try { runtime.getruntime().removeshutdownhook(shutdownhook); } catch (illegalstateexception ignored) { \/\/ race, jvm is in shutdown already, we can safely ignore this } catch (throwable t) { log.warn(\"failed to unregister shut down hook.\"); } } shutdown = true; } }","classification":"NONSATD","isFinished":true,"code_context_2":"} savepoints.clear(); \/\/ remove shutdown hook to prevent resource leaks, unless this is \/\/ invoked by the shutdown hook itself. if (shutdownhook != null && shutdownhook != thread.currentthread()) { try {","code_context_10":"\/\/ this is problematic as the user code class loader is not \/\/ available at this point. for (savepoint savepoint : savepoints.values()) { try { savepoint.dispose(); } catch (throwable t) { log.warn(\"failed to dispose savepoint \" + savepoint.getcheckpointid(), t); } } savepoints.clear(); \/\/ remove shutdown hook to prevent resource leaks, unless this is \/\/ invoked by the shutdown hook itself. if (shutdownhook != null && shutdownhook != thread.currentthread()) { try { runtime.getruntime().removeshutdownhook(shutdownhook); } catch (illegalstateexception ignored) { \/\/ race, jvm is in shutdown already, we can safely ignore this } catch (throwable t) { log.warn(\"failed to unregister shut down hook.\"); } } shutdown = true;","code_context_20":"@override public void shutdown() throws exception { synchronized (shutdownlock) { \/\/ this is problematic as the user code class loader is not \/\/ available at this point. for (savepoint savepoint : savepoints.values()) { try { savepoint.dispose(); } catch (throwable t) { log.warn(\"failed to dispose savepoint \" + savepoint.getcheckpointid(), t); } } savepoints.clear(); \/\/ remove shutdown hook to prevent resource leaks, unless this is \/\/ invoked by the shutdown hook itself. if (shutdownhook != null && shutdownhook != thread.currentthread()) { try { runtime.getruntime().removeshutdownhook(shutdownhook); } catch (illegalstateexception ignored) { \/\/ race, jvm is in shutdown already, we can safely ignore this } catch (throwable t) { log.warn(\"failed to unregister shut down hook.\"); } } shutdown = true; } }","repo":"qingdao81\/flink"}
{"id":10767,"comment_id":2,"comment":"\/\/ race, jvm is in shutdown already, we can safely ignore this","code":"@override public void shutdown() throws exception { synchronized (shutdownlock) { \/\/ this is problematic as the user code class loader is not \/\/ available at this point. for (savepoint savepoint : savepoints.values()) { try { savepoint.dispose(); } catch (throwable t) { log.warn(\"failed to dispose savepoint \" + savepoint.getcheckpointid(), t); } } savepoints.clear(); \/\/ remove shutdown hook to prevent resource leaks, unless this is \/\/ invoked by the shutdown hook itself. if (shutdownhook != null && shutdownhook != thread.currentthread()) { try { runtime.getruntime().removeshutdownhook(shutdownhook); } catch (illegalstateexception ignored) { \/\/ race, jvm is in shutdown already, we can safely ignore this } catch (throwable t) { log.warn(\"failed to unregister shut down hook.\"); } } shutdown = true; } }","classification":"NONSATD","isFinished":true,"code_context_2":"runtime.getruntime().removeshutdownhook(shutdownhook); } catch (illegalstateexception ignored) { \/\/ race, jvm is in shutdown already, we can safely ignore this } catch (throwable t) { log.warn(\"failed to unregister shut down hook.\");","code_context_10":"log.warn(\"failed to dispose savepoint \" + savepoint.getcheckpointid(), t); } } savepoints.clear(); \/\/ remove shutdown hook to prevent resource leaks, unless this is \/\/ invoked by the shutdown hook itself. if (shutdownhook != null && shutdownhook != thread.currentthread()) { try { runtime.getruntime().removeshutdownhook(shutdownhook); } catch (illegalstateexception ignored) { \/\/ race, jvm is in shutdown already, we can safely ignore this } catch (throwable t) { log.warn(\"failed to unregister shut down hook.\"); } } shutdown = true; } }","code_context_20":"@override public void shutdown() throws exception { synchronized (shutdownlock) { \/\/ this is problematic as the user code class loader is not \/\/ available at this point. for (savepoint savepoint : savepoints.values()) { try { savepoint.dispose(); } catch (throwable t) { log.warn(\"failed to dispose savepoint \" + savepoint.getcheckpointid(), t); } } savepoints.clear(); \/\/ remove shutdown hook to prevent resource leaks, unless this is \/\/ invoked by the shutdown hook itself. if (shutdownhook != null && shutdownhook != thread.currentthread()) { try { runtime.getruntime().removeshutdownhook(shutdownhook); } catch (illegalstateexception ignored) { \/\/ race, jvm is in shutdown already, we can safely ignore this } catch (throwable t) { log.warn(\"failed to unregister shut down hook.\"); } } shutdown = true; } }","repo":"qingdao81\/flink"}
{"id":2671,"comment_id":0,"comment":"\/** * does nothing *\/","code":"\/** * does nothing *\/ public void beginstep() { \/\/ todo: probably, we don't need to synchronize data here, \/\/ because this method is always called from the same thread \/\/ synchronize all cached data synchronized (readdata) { synchronized (writedata) { super.beginstep(); } } }","classification":"NONSATD","isFinished":true,"code_context_2":"public void beginstep() { \/\/ todo: probably, we don't need to synchronize data here, \/\/ because this method is always called from the same thread \/\/ synchronize all cached data synchronized (readdata) { synchronized (writedata) { super.beginstep(); } } }","code_context_10":"public void beginstep() { \/\/ todo: probably, we don't need to synchronize data here, \/\/ because this method is always called from the same thread \/\/ synchronize all cached data synchronized (readdata) { synchronized (writedata) { super.beginstep(); } } }","code_context_20":"public void beginstep() { \/\/ todo: probably, we don't need to synchronize data here, \/\/ because this method is always called from the same thread \/\/ synchronize all cached data synchronized (readdata) { synchronized (writedata) { super.beginstep(); } } }","repo":"monadius\/spark-abm"}
{"id":2671,"comment_id":1,"comment":"\/\/ todo: probably, we don't need to synchronize data here, \/\/ because this method is always called from the same thread \/\/ synchronize all cached data","code":"public void beginstep() { \/\/ todo: probably, we don't need to synchronize data here, \/\/ because this method is always called from the same thread \/\/ synchronize all cached data synchronized (readdata) { synchronized (writedata) { super.beginstep(); } } }","classification":"DESIGN","isFinished":true,"code_context_2":"public void beginstep() { \/\/ todo: probably, we don't need to synchronize data here, \/\/ because this method is always called from the same thread \/\/ synchronize all cached data synchronized (readdata) { synchronized (writedata) {","code_context_10":"public void beginstep() { \/\/ todo: probably, we don't need to synchronize data here, \/\/ because this method is always called from the same thread \/\/ synchronize all cached data synchronized (readdata) { synchronized (writedata) { super.beginstep(); } } }","code_context_20":"public void beginstep() { \/\/ todo: probably, we don't need to synchronize data here, \/\/ because this method is always called from the same thread \/\/ synchronize all cached data synchronized (readdata) { synchronized (writedata) { super.beginstep(); } } }","repo":"monadius\/spark-abm"}
{"id":2740,"comment_id":0,"comment":"\/* check for infinity and nan *\/","code":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); \/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/ digit++; } } done = true; } else if (j1 > 0) { digit++; done = true; } buffer.append(basedigit(digit)); } while (!done); return buffer.tostring(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\";","code_context_10":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) {","code_context_20":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) {","repo":"pitbox46\/graaljs-forge"}
{"id":2740,"comment_id":1,"comment":"\/\/ alert: should it distinguish -0.0 from +0.0 ?","code":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); \/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/ digit++; } } done = true; } else if (j1 > 0) { digit++; done = true; } buffer.append(basedigit(digit)); } while (!done); return buffer.tostring(); } }","classification":"DESIGN","isFinished":true,"code_context_2":"return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; }","code_context_10":"if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/","code_context_20":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); }","repo":"pitbox46\/graaljs-forge"}
{"id":2740,"comment_id":2,"comment":"\/* get the integer part of d including '-' sign. *\/","code":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); \/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/ digit++; } } done = true; } else if (j1 > 0) { digit++; done = true; } buffer.append(basedigit(digit)); } while (!done); return buffer.tostring(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d);","code_context_10":"\/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); }","code_context_20":"if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; }","repo":"pitbox46\/graaljs-forge"}
{"id":2740,"comment_id":3,"comment":"\/\/ int part fits long","code":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); \/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/ digit++; } } done = true; } else if (j1 > 0) { digit++; done = true; } buffer.append(basedigit(digit)); } while (!done); return buffer.tostring(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix","code_context_10":"negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa;","code_context_20":"if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa);","repo":"pitbox46\/graaljs-forge"}
{"id":2740,"comment_id":4,"comment":"\/\/ cwirth fix","code":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); \/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/ digit++; } } done = true; } else if (j1 > 0) { digit++; done = true; } buffer.append(basedigit(digit)); } while (!done); return buffer.tostring(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base);","code_context_10":"negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1;","code_context_20":"} else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp);","repo":"pitbox46\/graaljs-forge"}
{"id":2740,"comment_id":5,"comment":"\/\/ biginteger should be used","code":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); \/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/ digit++; } } done = true; } else if (j1 > 0) { digit++; done = true; } buffer.append(basedigit(digit)); } while (!done); return buffer.tostring(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted;","code_context_10":"double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa;","code_context_20":"} boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); }","repo":"pitbox46\/graaljs-forge"}
{"id":2740,"comment_id":6,"comment":"\/\/ no fraction part","code":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); \/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/ digit++; } } done = true; } else if (j1 > 0) { digit++; done = true; } buffer.append(basedigit(digit)); } while (!done); return buffer.tostring(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} if (d == dfloor) { \/\/ no fraction part return intdigits; } else {","code_context_10":"exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor;","code_context_20":"int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1;","repo":"pitbox46\/graaljs-forge"}
{"id":2740,"comment_id":7,"comment":"\/* we have a fraction. *\/","code":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); \/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/ digit++; } } done = true; } else if (j1 > 0) { digit++; done = true; } buffer.append(basedigit(digit)); } while (!done); return buffer.tostring(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit;","code_context_10":"x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits);","code_context_20":"mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/","repo":"pitbox46\/graaljs-forge"}
{"id":2740,"comment_id":8,"comment":"\/* the output string *\/","code":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); \/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/ digit++; } } done = true; } else if (j1 > 0) { digit++; done = true; } buffer.append(basedigit(digit)); } while (!done); return buffer.tostring(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/","code_context_10":"} else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1];","code_context_20":"} else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one;","repo":"pitbox46\/graaljs-forge"}
{"id":2740,"comment_id":9,"comment":"\/* the fractional part of d *\/","code":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); \/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/ digit++; } } done = true; } else if (j1 > 0) { digit++; done = true; } buffer.append(basedigit(digit)); } while (!done); return buffer.tostring(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder();","code_context_10":"} intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits);","code_context_20":"} if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) {","repo":"pitbox46\/graaljs-forge"}
{"id":2740,"comment_id":10,"comment":"\/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/","code":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); \/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/ digit++; } } done = true; } else if (j1 > 0) { digit++; done = true; } buffer.append(basedigit(digit)); } while (!done); return buffer.tostring(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) {","code_context_10":"biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/*","code_context_20":"intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2);","repo":"pitbox46\/graaljs-forge"}
{"id":2740,"comment_id":11,"comment":"\/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/","code":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); \/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/ digit++; } } done = true; } else if (j1 > 0) { digit++; done = true; } buffer.append(basedigit(digit)); } while (!done); return buffer.tostring(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo;","code_context_10":"int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p);","code_context_20":"\/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); \/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2;","repo":"pitbox46\/graaljs-forge"}
{"id":2740,"comment_id":12,"comment":"\/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/","code":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); \/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/ digit++; } } done = true; } else if (j1 > 0) { digit++; done = true; } buffer.append(basedigit(digit)); } while (!done); return buffer.tostring(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ?","code_context_10":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d;","code_context_20":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else {","repo":"pitbox46\/graaljs-forge"}
{"id":2740,"comment_id":13,"comment":"\/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/","code":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); \/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/ digit++; } } done = true; } else if (j1 > 0) { digit++; done = true; } buffer.append(basedigit(digit)); } while (!done); return buffer.tostring(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) {","code_context_10":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d);","code_context_20":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used","repo":"pitbox46\/graaljs-forge"}
{"id":2740,"comment_id":14,"comment":"\/* do we yet have the shortest string that will round to d? *\/","code":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); \/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/ digit++; } } done = true; } else if (j1 > 0) { digit++; done = true; } buffer.append(basedigit(digit)); } while (!done); return buffer.tostring(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/","code_context_10":"b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true;","code_context_20":"* at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/*","repo":"pitbox46\/graaljs-forge"}
{"id":2740,"comment_id":15,"comment":"\/* j is b\/2^s2 compared with mlo\/2^s2. *\/","code":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); \/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/ digit++; } } done = true; } else if (j1 > 0) { digit++; done = true; } buffer.append(basedigit(digit)); } while (!done); return buffer.tostring(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"\/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta);","code_context_10":"b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) {","code_context_20":"* 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3.","repo":"pitbox46\/graaljs-forge"}
{"id":2740,"comment_id":16,"comment":"\/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/","code":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); \/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/ digit++; } } done = true; } else if (j1 > 0) { digit++; done = true; } buffer.append(basedigit(digit)); } while (!done); return buffer.tostring(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) {","code_context_10":"mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d.","code_context_20":"* @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/ digit++; }","repo":"pitbox46\/graaljs-forge"}
{"id":2740,"comment_id":17,"comment":"\/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/","code":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); \/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/ digit++; } } done = true; } else if (j1 > 0) { digit++; done = true; } buffer.append(basedigit(digit)); } while (!done); return buffer.tostring(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) {","code_context_10":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true;","code_context_20":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix","repo":"pitbox46\/graaljs-forge"}
{"id":2740,"comment_id":18,"comment":"\/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/","code":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { \/\/ biginteger should be used long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { \/\/ no fraction part return intdigits; } else { \/* we have a fraction. *\/ stringbuilder buffer; \/* the output string *\/ int digit; double df; \/* the fractional part of d *\/ biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); \/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/ int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; \/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/ biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { \/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/ s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); \/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/ biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } \/* do we yet have the shortest string that will round to d? *\/ int j = b.compareto(mlo); \/* j is b\/2^s2 compared with mlo\/2^s2. *\/ biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/ if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { \/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/ b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { \/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/ digit++; } } done = true; } else if (j1 > 0) { digit++; done = true; } buffer.append(basedigit(digit)); } while (!done); return buffer.tostring(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) {","code_context_10":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true;","code_context_20":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; \/* check for infinity and nan *\/ if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { \/\/ alert: should it distinguish -0.0 from +0.0 ? return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } \/* get the integer part of d including '-' sign. *\/ string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { \/\/ int part fits long if (lfloor == 0 && negative) { intdigits = \"-0\"; \/\/ cwirth fix","repo":"pitbox46\/graaljs-forge"}
{"id":11112,"comment_id":0,"comment":"\/\/ xxx note: this assumes that the reference of the generator value does not change!","code":"@override public final boolean equals(final object other) { if (!(other instanceof production)) { return false; } \/\/ xxx note: this assumes that the reference of the generator value does not change! final production otherproduction = (production) other; return this.id == otherproduction.id && this.ownclass.equals(otherproduction.ownclass) && this.generatorvalue == otherproduction.generatorvalue; }","classification":"DESIGN","isFinished":true,"code_context_2":"return false; } \/\/ xxx note: this assumes that the reference of the generator value does not change! final production otherproduction = (production) other; return this.id == otherproduction.id","code_context_10":"@override public final boolean equals(final object other) { if (!(other instanceof production)) { return false; } \/\/ xxx note: this assumes that the reference of the generator value does not change! final production otherproduction = (production) other; return this.id == otherproduction.id && this.ownclass.equals(otherproduction.ownclass) && this.generatorvalue == otherproduction.generatorvalue; }","code_context_20":"@override public final boolean equals(final object other) { if (!(other instanceof production)) { return false; } \/\/ xxx note: this assumes that the reference of the generator value does not change! final production otherproduction = (production) other; return this.id == otherproduction.id && this.ownclass.equals(otherproduction.ownclass) && this.generatorvalue == otherproduction.generatorvalue; }","repo":"mskamp\/StarSmith"}
{"id":2951,"comment_id":0,"comment":"\/\/ todo: orc file now not support target file size before closed","code":"private boolean shouldrolltonewfile() { \/\/ todo: orc file now not support target file size before closed return !format.equals(fileformat.orc) && currentrows % rows_divisor == 0 && length(currentwriter) >= targetfilesize; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"private boolean shouldrolltonewfile() { \/\/ todo: orc file now not support target file size before closed return !format.equals(fileformat.orc) && currentrows % rows_divisor == 0 && length(currentwriter) >= targetfilesize;","code_context_10":"private boolean shouldrolltonewfile() { \/\/ todo: orc file now not support target file size before closed return !format.equals(fileformat.orc) && currentrows % rows_divisor == 0 && length(currentwriter) >= targetfilesize; }","code_context_20":"private boolean shouldrolltonewfile() { \/\/ todo: orc file now not support target file size before closed return !format.equals(fileformat.orc) && currentrows % rows_divisor == 0 && length(currentwriter) >= targetfilesize; }","repo":"rajarshisarkar\/iceberg"}
{"id":19374,"comment_id":0,"comment":"\/\/ warning : use synchronized. is it possible to reduce the blocking part ?","code":"\/\/ warning : use synchronized. is it possible to reduce the blocking part ? boolean isalreadylogged(stacktraceelement[] stack) { hashstacktraceelement hse = new hashstacktraceelement(stack); \/\/ ok, it's block the code, but for a small period synchronized (this) { \/\/ detect with the precalculated hash value return !logged.add(hse); } }","classification":"DESIGN","isFinished":true,"code_context_2":"boolean isalreadylogged(stacktraceelement[] stack) { hashstacktraceelement hse = new hashstacktraceelement(stack); \/\/ ok, it's block the code, but for a small period synchronized (this) { \/\/ detect with the precalculated hash value return !logged.add(hse); } }","code_context_10":"boolean isalreadylogged(stacktraceelement[] stack) { hashstacktraceelement hse = new hashstacktraceelement(stack); \/\/ ok, it's block the code, but for a small period synchronized (this) { \/\/ detect with the precalculated hash value return !logged.add(hse); } }","code_context_20":"boolean isalreadylogged(stacktraceelement[] stack) { hashstacktraceelement hse = new hashstacktraceelement(stack); \/\/ ok, it's block the code, but for a small period synchronized (this) { \/\/ detect with the precalculated hash value return !logged.add(hse); } }","repo":"octo-online\/reactive-aud"}
{"id":19374,"comment_id":1,"comment":"\/\/ ok, it's block the code, but for a small period","code":"boolean isalreadylogged(stacktraceelement[] stack) { hashstacktraceelement hse = new hashstacktraceelement(stack); \/\/ ok, it's block the code, but for a small period synchronized (this) { \/\/ detect with the precalculated hash value return !logged.add(hse); } }","classification":"NONSATD","isFinished":true,"code_context_2":"{ hashstacktraceelement hse = new hashstacktraceelement(stack); \/\/ ok, it's block the code, but for a small period synchronized (this) {","code_context_10":"boolean isalreadylogged(stacktraceelement[] stack) { hashstacktraceelement hse = new hashstacktraceelement(stack); \/\/ ok, it's block the code, but for a small period synchronized (this) { \/\/ detect with the precalculated hash value return !logged.add(hse); } }","code_context_20":"boolean isalreadylogged(stacktraceelement[] stack) { hashstacktraceelement hse = new hashstacktraceelement(stack); \/\/ ok, it's block the code, but for a small period synchronized (this) { \/\/ detect with the precalculated hash value return !logged.add(hse); } }","repo":"octo-online\/reactive-aud"}
{"id":19374,"comment_id":2,"comment":"\/\/ detect with the precalculated hash value","code":"boolean isalreadylogged(stacktraceelement[] stack) { hashstacktraceelement hse = new hashstacktraceelement(stack); \/\/ ok, it's block the code, but for a small period synchronized (this) { \/\/ detect with the precalculated hash value return !logged.add(hse); } }","classification":"NONSATD","isFinished":true,"code_context_2":"synchronized (this) { \/\/ detect with the precalculated hash value return !logged.add(hse); }","code_context_10":"boolean isalreadylogged(stacktraceelement[] stack) { hashstacktraceelement hse = new hashstacktraceelement(stack); \/\/ ok, it's block the code, but for a small period synchronized (this) { \/\/ detect with the precalculated hash value return !logged.add(hse); } }","code_context_20":"boolean isalreadylogged(stacktraceelement[] stack) { hashstacktraceelement hse = new hashstacktraceelement(stack); \/\/ ok, it's block the code, but for a small period synchronized (this) { \/\/ detect with the precalculated hash value return !logged.add(hse); } }","repo":"octo-online\/reactive-aud"}
{"id":2992,"comment_id":0,"comment":"\/* ignore blank section definitions *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore","code_context_10":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ --------------------------------------------------------------------","code_context_20":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":1,"comment":"\/\/ -- ignore","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; }","code_context_10":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) {","code_context_20":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":2,"comment":"\/* not a match? *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore","code_context_10":"httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try {","code_context_20":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload);","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":3,"comment":"\/\/ -- ignore","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; }","code_context_10":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) {","code_context_20":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":4,"comment":"\/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload);","code_context_10":"\/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page;","code_context_20":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":5,"comment":"\/* \"onunload='...'\" *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload);","code_context_10":"string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page;","code_context_20":"return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page;","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":6,"comment":"\/\/ -------------------------------------------------------------------- \/* expandmenu style *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload);","code_context_10":"\/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page;","code_context_20":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":7,"comment":"\/* expandmenu javascript *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try {","code_context_10":"\/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) {","code_context_20":"string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ --------------------------------------------------------------------","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":8,"comment":"\/* expandmenu *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try {","code_context_10":"} \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","code_context_20":"} \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring());","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":9,"comment":"\/*menuid*\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) {","code_context_10":"expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body);","code_context_20":"try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":10,"comment":"\/*expandablemenu*\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) {","code_context_10":"expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body);","code_context_20":"try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":11,"comment":"\/*showicon*\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring());","code_context_10":"} catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) {","code_context_20":"expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":12,"comment":"\/*showmenuhelp*\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring());","code_context_10":"} catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) {","code_context_20":"expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":13,"comment":"\/\/ -------------------------------------------------------------------- \/* content table class *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload);","code_context_10":"\/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page;","code_context_20":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":14,"comment":"\/* content cell class *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body);","code_context_10":"if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } }","code_context_20":"false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page;","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":15,"comment":"\/* content message id *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try {","code_context_10":"if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) {","code_context_20":"out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body);","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":16,"comment":"\/* content message class *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try {","code_context_10":"} \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) {","code_context_20":"htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) {","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":17,"comment":"\/* content menubar *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body);","code_context_10":"} \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); }","code_context_20":"return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\";","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":18,"comment":"\/* content message *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body);","code_context_10":"menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","code_context_20":"} return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":19,"comment":"\/\/ todo: html encode?","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"DESIGN","isFinished":true,"code_context_2":"string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring());","code_context_10":"throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath());","code_context_20":"htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) {","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":20,"comment":"\/\/ -------------------------------------------------------------------- \/* request context path *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload);","code_context_10":"\/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page;","code_context_20":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":21,"comment":"\/\/ -------------------------------------------------------------------- \/* css file *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload);","code_context_10":"\/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page;","code_context_20":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":22,"comment":"\/\/ -------------------------------------------------------------------- \/* banner image height *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload);","code_context_10":"\/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page;","code_context_20":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":23,"comment":"\/\/ key suffix","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values","code_context_10":"webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else","code_context_20":"} return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":24,"comment":"\/\/ property values","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) {","code_context_10":"throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0);","code_context_20":"} \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":25,"comment":"\/\/ minimum valie","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\";","code_context_10":"\/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth);","code_context_20":"if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":26,"comment":"\/\/ generate html","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth);","code_context_10":"bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix","code_context_20":"return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":27,"comment":"\/* banner style *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix","code_context_10":"bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) {","code_context_20":"string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":28,"comment":"\/\/ key suffix","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values","code_context_10":"webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else","code_context_20":"} return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":29,"comment":"\/\/ property values","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) {","code_context_10":"throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0);","code_context_20":"} \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":30,"comment":"\/\/ generate html","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth);","code_context_10":"bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix","code_context_20":"return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":31,"comment":"\/* banner image *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix","code_context_10":"} else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) {","code_context_20":"string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\");","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":32,"comment":"\/\/ key suffix","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values","code_context_10":"webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else","code_context_20":"} return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":33,"comment":"\/\/ property values","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) {","code_context_10":"throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0);","code_context_20":"} \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":34,"comment":"\/\/ generate html","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth);","code_context_10":"bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix","code_context_20":"return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":35,"comment":"\/* banner image *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix","code_context_10":"} else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) {","code_context_20":"string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\");","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":36,"comment":"\/\/ key suffix","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values","code_context_10":"webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else","code_context_20":"} return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":37,"comment":"\/\/ property values","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) {","code_context_10":"throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0);","code_context_20":"} \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":38,"comment":"\/\/ generate html","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth);","code_context_10":"bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix","code_context_20":"return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":39,"comment":"\/\/print.sysprintln(\"property image source: \" + imgsrc);","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc);","code_context_10":"return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault());","code_context_20":"throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg());","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":40,"comment":"\/\/print.sysprintln(\"default image source: \" + this.getdefault());","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"} else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault());","code_context_10":"\/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) {","code_context_20":"} } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring());","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":41,"comment":"\/* banner image height *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"} \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix","code_context_10":"try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) {","code_context_20":"} catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) {","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":42,"comment":"\/\/ key suffix","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values","code_context_10":"webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else","code_context_20":"} return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":43,"comment":"\/\/ property values","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) {","code_context_10":"throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0);","code_context_20":"} \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":44,"comment":"\/\/ generate html","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth);","code_context_10":"bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix","code_context_20":"return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":45,"comment":"\/* banner image height *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"} \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix","code_context_10":"try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) {","code_context_20":"} catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) {","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":46,"comment":"\/\/ key suffix","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values","code_context_10":"webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else","code_context_20":"} return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":47,"comment":"\/\/ property values","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) {","code_context_10":"throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0);","code_context_20":"} \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":48,"comment":"\/\/ generate html","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth);","code_context_10":"bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix","code_context_20":"return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":49,"comment":"\/\/ -------------------------------------------------------------------- \/* javascript *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload);","code_context_10":"\/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page;","code_context_20":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":50,"comment":"\/\/ always write \"utils.js\"","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript","code_context_10":"} catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring());","code_context_20":"if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename);","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":51,"comment":"\/\/ check for other javascript","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) {","code_context_10":"} } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page;","code_context_20":"out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring());","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":52,"comment":"\/\/ -------------------------------------------------------------------- \/* current page name *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload);","code_context_10":"\/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page;","code_context_20":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":53,"comment":"\/\/ \"pagename\"","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) {","code_context_10":"} else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; }","code_context_20":"\/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try {","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":54,"comment":"\/\/ -------------------------------------------------------------------- \/* page url *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload);","code_context_10":"\/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page;","code_context_20":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":55,"comment":"\/\/ \"pageurl\"","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null;","code_context_10":"try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring());","code_context_20":"} catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\");","repo":"paragp\/GTS-PreUAT"}
{"id":2992,"comment_id":56,"comment":"\/\/ -------------------------------------------------------------------- \/* htmloutput *\/","code":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* expandmenu style *\/ if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu javascript *\/ if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* expandmenu *\/ if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, null\/*menuid*\/, true\/*expandablemenu*\/, false\/*showicon*\/, expandmenu.desc_long, false\/*showmenuhelp*\/); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* content table class *\/ if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content cell class *\/ if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message id *\/ if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content message class *\/ if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* content menubar *\/ if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* content message *\/ if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); \/\/ todo: html encode? } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* request context path *\/ if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* css file *\/ if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* banner image height *\/ if (s.equalsignorecase(section_banner_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } \/\/ minimum valie if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } \/\/ generate html try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/* banner style *\/ if (s.equalsignorecase(section_banner_style)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); \/\/ generate html if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image *\/ if (s.equalsignorecase(section_banner_image_source)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgsrc)) { \/\/print.sysprintln(\"property image source: \" + imgsrc); try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { \/\/print.sysprintln(\"default image source: \" + this.getdefault()); try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_width)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* banner image height *\/ if (s.equalsignorecase(section_banner_image_height)) { \/\/ key suffix string ksfx = stringtools.trim(this.getarg()); \/\/ property values string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); \/\/ generate html if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* javascript *\/ if (s.equalsignorecase(section_javascript)) { try { \/\/ always write \"utils.js\" javascripttools.writeutilsjs(out, request); \/\/ check for other javascript object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } \/\/ -------------------------------------------------------------------- \/* current page name *\/ if (s.equalsignorecase(section_page_name)) { \/\/ \"pagename\" string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* page url *\/ if (s.equalsignorecase(section_page_url)) { \/\/ \"pageurl\" string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/\/ -------------------------------------------------------------------- \/* htmloutput *\/ try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","classification":"NONSATD","isFinished":true,"code_context_2":"return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload);","code_context_10":"\/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page;","code_context_20":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); \/* ignore blank section definitions *\/ if (stringtools.isblank(s)) { \/\/ -- ignore return eval_page; } \/* not a match? *\/ if (!this.ismatch()) { \/\/ -- ignore return eval_page; } \/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/ if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } \/* \"onunload='...'\" *\/ if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); }","repo":"paragp\/GTS-PreUAT"}
{"id":19480,"comment_id":0,"comment":"\/** * determines whether to accept or drop a vp8 frame. * * note that, at the time of this writing, there's no practical need for a * synchronized keyword because there's only one thread accessing this * method at a time. * * @param frame the vp8 frame. * @param incomingindex the quality index of the incoming rtp packet * @param externaltargetindex the target quality index that the user of this * instance wants to achieve. * @param receivedms the current time (in millis) * @return true to accept the vp8 frame, otherwise false. *\/","code":"\/** * determines whether to accept or drop a vp8 frame. * * note that, at the time of this writing, there's no practical need for a * synchronized keyword because there's only one thread accessing this * method at a time. * * @param frame the vp8 frame. * @param incomingindex the quality index of the incoming rtp packet * @param externaltargetindex the target quality index that the user of this * instance wants to achieve. * @param receivedms the current time (in millis) * @return true to accept the vp8 frame, otherwise false. *\/ synchronized boolean acceptframe( @notnull vp8frame frame, int incomingindex, int externaltargetindex, long receivedms) { \/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread). int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0; } int encodingid = rtplayerdesc.geteidfromindex(incomingindex); if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true; return false; } }","classification":"NONSATD","isFinished":true,"code_context_2":"synchronized boolean acceptframe( @notnull vp8frame frame, int incomingindex, int externaltargetindex, long receivedms) { \/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread). int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0; } int encodingid = rtplayerdesc.geteidfromindex(incomingindex); if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true; return false; } }","code_context_10":"synchronized boolean acceptframe( @notnull vp8frame frame, int incomingindex, int externaltargetindex, long receivedms) { \/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread). int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0; } int encodingid = rtplayerdesc.geteidfromindex(incomingindex); if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true; return false; } }","code_context_20":"synchronized boolean acceptframe( @notnull vp8frame frame, int incomingindex, int externaltargetindex, long receivedms) { \/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread). int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0; } int encodingid = rtplayerdesc.geteidfromindex(incomingindex); if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true; return false; } }","repo":"ngi-nix\/jitsi-videobridge"}
{"id":19480,"comment_id":1,"comment":"\/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread).","code":"synchronized boolean acceptframe( @notnull vp8frame frame, int incomingindex, int externaltargetindex, long receivedms) { \/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread). int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0; } int encodingid = rtplayerdesc.geteidfromindex(incomingindex); if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true; return false; } }","classification":"NONSATD","isFinished":true,"code_context_2":"int externaltargetindex, long receivedms) { \/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread). int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex);","code_context_10":"synchronized boolean acceptframe( @notnull vp8frame frame, int incomingindex, int externaltargetindex, long receivedms) { \/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread). int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id)","code_context_20":"synchronized boolean acceptframe( @notnull vp8frame frame, int incomingindex, int externaltargetindex, long receivedms) { \/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread). int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id;","repo":"ngi-nix\/jitsi-videobridge"}
{"id":19480,"comment_id":2,"comment":"\/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe.","code":"synchronized boolean acceptframe( @notnull vp8frame frame, int incomingindex, int externaltargetindex, long receivedms) { \/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread). int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0; } int encodingid = rtplayerdesc.geteidfromindex(incomingindex); if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true; return false; } }","classification":"DESIGN","isFinished":true,"code_context_2":"if (externalencodingidtarget != internalencodingidtarget) { \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id)","code_context_10":"{ \/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread). int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order","code_context_20":"synchronized boolean acceptframe( @notnull vp8frame frame, int incomingindex, int externaltargetindex, long receivedms) { \/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread). int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0;","repo":"ngi-nix\/jitsi-videobridge"}
{"id":19480,"comment_id":3,"comment":"\/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume.","code":"synchronized boolean acceptframe( @notnull vp8frame frame, int incomingindex, int externaltargetindex, long receivedms) { \/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread). int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0; } int encodingid = rtplayerdesc.geteidfromindex(incomingindex); if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true; return false; } }","classification":"NONSATD","isFinished":true,"code_context_2":"|| externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id; return false;","code_context_10":"\/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0; }","code_context_20":"\/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread). int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0; } int encodingid = rtplayerdesc.geteidfromindex(incomingindex); if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid))","repo":"ngi-nix\/jitsi-videobridge"}
{"id":19480,"comment_id":4,"comment":"\/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer.","code":"synchronized boolean acceptframe( @notnull vp8frame frame, int incomingindex, int externaltargetindex, long receivedms) { \/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread). int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0; } int encodingid = rtplayerdesc.geteidfromindex(incomingindex); if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true; return false; } }","classification":"NONSATD","isFinished":true,"code_context_2":"if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0; }","code_context_10":"|| externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0; } int encodingid = rtplayerdesc.geteidfromindex(incomingindex); if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id)","code_context_20":"{ \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0; } int encodingid = rtplayerdesc.geteidfromindex(incomingindex); if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer","repo":"ngi-nix\/jitsi-videobridge"}
{"id":19480,"comment_id":5,"comment":"\/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames","code":"synchronized boolean acceptframe( @notnull vp8frame frame, int incomingindex, int externaltargetindex, long receivedms) { \/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread). int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0; } int encodingid = rtplayerdesc.geteidfromindex(incomingindex); if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true; return false; } }","classification":"NONSATD","isFinished":true,"code_context_2":"if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; }","code_context_10":"if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget)","code_context_20":"return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0; } int encodingid = rtplayerdesc.geteidfromindex(incomingindex); if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; }","repo":"ngi-nix\/jitsi-videobridge"}
{"id":19480,"comment_id":6,"comment":"\/\/ for non-keyframes, we can't route anything but the current encoding","code":"synchronized boolean acceptframe( @notnull vp8frame frame, int incomingindex, int externaltargetindex, long receivedms) { \/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread). int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0; } int encodingid = rtplayerdesc.geteidfromindex(incomingindex); if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true; return false; } }","classification":"NONSATD","isFinished":true,"code_context_2":"if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; }","code_context_10":"\/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; }","code_context_20":"logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget;","repo":"ngi-nix\/jitsi-videobridge"}
{"id":19480,"comment_id":7,"comment":"\/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer.","code":"synchronized boolean acceptframe( @notnull vp8frame frame, int incomingindex, int externaltargetindex, long receivedms) { \/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread). int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0; } int encodingid = rtplayerdesc.geteidfromindex(incomingindex); if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true; return false; } }","classification":"NONSATD","isFinished":true,"code_context_2":"return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) {","code_context_10":"\/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true;","code_context_20":"} else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else {","repo":"ngi-nix\/jitsi-videobridge"}
{"id":19480,"comment_id":8,"comment":"\/\/ pending downscale, decrease the frame rate until we \/\/ downscale.","code":"synchronized boolean acceptframe( @notnull vp8frame frame, int incomingindex, int externaltargetindex, long receivedms) { \/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread). int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0; } int encodingid = rtplayerdesc.geteidfromindex(incomingindex); if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true; return false; } }","classification":"NONSATD","isFinished":true,"code_context_2":"if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; }","code_context_10":"} if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target","code_context_20":"{ \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both","repo":"ngi-nix\/jitsi-videobridge"}
{"id":19480,"comment_id":9,"comment":"\/\/ pending upscale, increase the frame rate until we upscale.","code":"synchronized boolean acceptframe( @notnull vp8frame frame, int incomingindex, int externaltargetindex, long receivedms) { \/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread). int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0; } int encodingid = rtplayerdesc.geteidfromindex(incomingindex); if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true; return false; } }","classification":"NONSATD","isFinished":true,"code_context_2":"else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; }","code_context_10":"\/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else","code_context_20":"\/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true; return false; }","repo":"ngi-nix\/jitsi-videobridge"}
{"id":19480,"comment_id":10,"comment":"\/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid.","code":"synchronized boolean acceptframe( @notnull vp8frame frame, int incomingindex, int externaltargetindex, long receivedms) { \/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread). int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0; } int encodingid = rtplayerdesc.geteidfromindex(incomingindex); if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true; return false; } }","classification":"NONSATD","isFinished":true,"code_context_2":"else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; }","code_context_10":"\/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget","code_context_20":"if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true; return false; } }","repo":"ngi-nix\/jitsi-videobridge"}
{"id":19480,"comment_id":11,"comment":"\/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true;","code":"synchronized boolean acceptframe( @notnull vp8frame frame, int incomingindex, int externaltargetindex, long receivedms) { \/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread). int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { \/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe. internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { \/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume. currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { \/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer. temporallayeridofframe = 0; } int encodingid = rtplayerdesc.geteidfromindex(incomingindex); if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { \/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames needskeyframe = true; } if (encodingid != currentencodingid) { \/\/ for non-keyframes, we can't route anything but the current encoding return false; } \/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer. if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true; return false; } }","classification":"NONSATD","isFinished":true,"code_context_2":"else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true; return false; }","code_context_10":"} else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true; return false; } }","code_context_20":"if (currentencodingid > externalencodingidtarget) { \/\/ pending downscale, decrease the frame rate until we \/\/ downscale. return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { \/\/ pending upscale, increase the frame rate until we upscale. return true; } else { \/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid. return temporallayeridofframe <= externaltemporallayeridtarget; } } else { \/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true; return false; } }","repo":"ngi-nix\/jitsi-videobridge"}
{"id":19563,"comment_id":0,"comment":"\/\/ what follows is a poor man's crl extractor, for those lacking \/\/ a bouncycastle \"bcprov.jar\" in their classpath. \/\/ it's a very basic state-machine: look for a standard url scheme \/\/ (such as http), and then start looking for a terminator. after \/\/ running hexdump a few times on these things, it looks to me like \/\/ the utf-8 value \"65533\" seems to happen near where these things \/\/ terminate. (of course this stuff is asn.1 and not utf-8, but \/\/ i happen to like some of the functions available to the string \/\/ object). - juliusdavies@cucbc.com, may 10th, 2006","code":"public static list getcrls(x509extension cert) { \/\/ what follows is a poor man's crl extractor, for those lacking \/\/ a bouncycastle \"bcprov.jar\" in their classpath. \/\/ it's a very basic state-machine: look for a standard url scheme \/\/ (such as http), and then start looking for a terminator. after \/\/ running hexdump a few times on these things, it looks to me like \/\/ the utf-8 value \"65533\" seems to happen near where these things \/\/ terminate. (of course this stuff is asn.1 and not utf-8, but \/\/ i happen to like some of the functions available to the string \/\/ object). - juliusdavies@cucbc.com, may 10th, 2006 byte[] bytes = cert.getextensionvalue(crl_extension); linkedlist httpcrls = new linkedlist(); linkedlist ftpcrls = new linkedlist(); linkedlist othercrls = new linkedlist(); if (bytes == null) { \/\/ just return empty list return httpcrls; } else { string s; try { s = new string(bytes, \"utf-8\"); } catch (unsupportedencodingexception uee) { \/\/ we're screwed if this thing has more than one crl, because \/\/ the \"indeof( (char) 65533 )\" below isn't going to work. s = new string(bytes); } int pos = 0; while (pos >= 0) { int x = -1, y; int[] indexes = new int[4]; indexes[0] = s.indexof(\"http\", pos); indexes[1] = s.indexof(\"ldap\", pos); indexes[2] = s.indexof(\"file\", pos); indexes[3] = s.indexof(\"ftp\", pos); arrays.sort(indexes); for (int i = 0; i < indexes.length; i++) { if (indexes[i] >= 0) { x = indexes[i]; break; } } if (x >= 0) { y = s.indexof((char) 65533, x); string crl = y > x ? s.substring(x, y - 1) : s.substring(x); if (y > x && crl.endswith(\"0\")) { crl = crl.substring(0, crl.length() - 1); } string crltest = crl.trim().tolowercase(); if (crltest.startswith(\"http\")) { httpcrls.add(crl); } else if (crltest.startswith(\"ftp\")) { ftpcrls.add(crl); } else { othercrls.add(crl); } pos = y; } else { pos = -1; } } } httpcrls.addall(ftpcrls); httpcrls.addall(othercrls); return httpcrls; }","classification":"NONSATD","isFinished":true,"code_context_2":"public static list getcrls(x509extension cert) { \/\/ what follows is a poor man's crl extractor, for those lacking \/\/ a bouncycastle \"bcprov.jar\" in their classpath. \/\/ it's a very basic state-machine: look for a standard url scheme \/\/ (such as http), and then start looking for a terminator. after \/\/ running hexdump a few times on these things, it looks to me like \/\/ the utf-8 value \"65533\" seems to happen near where these things \/\/ terminate. (of course this stuff is asn.1 and not utf-8, but \/\/ i happen to like some of the functions available to the string \/\/ object). - juliusdavies@cucbc.com, may 10th, 2006 byte[] bytes = cert.getextensionvalue(crl_extension); linkedlist httpcrls = new linkedlist();","code_context_10":"public static list getcrls(x509extension cert) { \/\/ what follows is a poor man's crl extractor, for those lacking \/\/ a bouncycastle \"bcprov.jar\" in their classpath. \/\/ it's a very basic state-machine: look for a standard url scheme \/\/ (such as http), and then start looking for a terminator. after \/\/ running hexdump a few times on these things, it looks to me like \/\/ the utf-8 value \"65533\" seems to happen near where these things \/\/ terminate. (of course this stuff is asn.1 and not utf-8, but \/\/ i happen to like some of the functions available to the string \/\/ object). - juliusdavies@cucbc.com, may 10th, 2006 byte[] bytes = cert.getextensionvalue(crl_extension); linkedlist httpcrls = new linkedlist(); linkedlist ftpcrls = new linkedlist(); linkedlist othercrls = new linkedlist(); if (bytes == null) { \/\/ just return empty list return httpcrls; } else { string s; try {","code_context_20":"public static list getcrls(x509extension cert) { \/\/ what follows is a poor man's crl extractor, for those lacking \/\/ a bouncycastle \"bcprov.jar\" in their classpath. \/\/ it's a very basic state-machine: look for a standard url scheme \/\/ (such as http), and then start looking for a terminator. after \/\/ running hexdump a few times on these things, it looks to me like \/\/ the utf-8 value \"65533\" seems to happen near where these things \/\/ terminate. (of course this stuff is asn.1 and not utf-8, but \/\/ i happen to like some of the functions available to the string \/\/ object). - juliusdavies@cucbc.com, may 10th, 2006 byte[] bytes = cert.getextensionvalue(crl_extension); linkedlist httpcrls = new linkedlist(); linkedlist ftpcrls = new linkedlist(); linkedlist othercrls = new linkedlist(); if (bytes == null) { \/\/ just return empty list return httpcrls; } else { string s; try { s = new string(bytes, \"utf-8\"); } catch (unsupportedencodingexception uee) { \/\/ we're screwed if this thing has more than one crl, because \/\/ the \"indeof( (char) 65533 )\" below isn't going to work. s = new string(bytes); } int pos = 0; while (pos >= 0) { int x = -1, y;","repo":"rcbj\/apigee-jwt-aad-timeapi-proxy"}
{"id":19563,"comment_id":1,"comment":"\/\/ just return empty list","code":"public static list getcrls(x509extension cert) { \/\/ what follows is a poor man's crl extractor, for those lacking \/\/ a bouncycastle \"bcprov.jar\" in their classpath. \/\/ it's a very basic state-machine: look for a standard url scheme \/\/ (such as http), and then start looking for a terminator. after \/\/ running hexdump a few times on these things, it looks to me like \/\/ the utf-8 value \"65533\" seems to happen near where these things \/\/ terminate. (of course this stuff is asn.1 and not utf-8, but \/\/ i happen to like some of the functions available to the string \/\/ object). - juliusdavies@cucbc.com, may 10th, 2006 byte[] bytes = cert.getextensionvalue(crl_extension); linkedlist httpcrls = new linkedlist(); linkedlist ftpcrls = new linkedlist(); linkedlist othercrls = new linkedlist(); if (bytes == null) { \/\/ just return empty list return httpcrls; } else { string s; try { s = new string(bytes, \"utf-8\"); } catch (unsupportedencodingexception uee) { \/\/ we're screwed if this thing has more than one crl, because \/\/ the \"indeof( (char) 65533 )\" below isn't going to work. s = new string(bytes); } int pos = 0; while (pos >= 0) { int x = -1, y; int[] indexes = new int[4]; indexes[0] = s.indexof(\"http\", pos); indexes[1] = s.indexof(\"ldap\", pos); indexes[2] = s.indexof(\"file\", pos); indexes[3] = s.indexof(\"ftp\", pos); arrays.sort(indexes); for (int i = 0; i < indexes.length; i++) { if (indexes[i] >= 0) { x = indexes[i]; break; } } if (x >= 0) { y = s.indexof((char) 65533, x); string crl = y > x ? s.substring(x, y - 1) : s.substring(x); if (y > x && crl.endswith(\"0\")) { crl = crl.substring(0, crl.length() - 1); } string crltest = crl.trim().tolowercase(); if (crltest.startswith(\"http\")) { httpcrls.add(crl); } else if (crltest.startswith(\"ftp\")) { ftpcrls.add(crl); } else { othercrls.add(crl); } pos = y; } else { pos = -1; } } } httpcrls.addall(ftpcrls); httpcrls.addall(othercrls); return httpcrls; }","classification":"NONSATD","isFinished":true,"code_context_2":"linkedlist othercrls = new linkedlist(); if (bytes == null) { \/\/ just return empty list return httpcrls; } else {","code_context_10":"\/\/ running hexdump a few times on these things, it looks to me like \/\/ the utf-8 value \"65533\" seems to happen near where these things \/\/ terminate. (of course this stuff is asn.1 and not utf-8, but \/\/ i happen to like some of the functions available to the string \/\/ object). - juliusdavies@cucbc.com, may 10th, 2006 byte[] bytes = cert.getextensionvalue(crl_extension); linkedlist httpcrls = new linkedlist(); linkedlist ftpcrls = new linkedlist(); linkedlist othercrls = new linkedlist(); if (bytes == null) { \/\/ just return empty list return httpcrls; } else { string s; try { s = new string(bytes, \"utf-8\"); } catch (unsupportedencodingexception uee) { \/\/ we're screwed if this thing has more than one crl, because \/\/ the \"indeof( (char) 65533 )\" below isn't going to work. s = new string(bytes);","code_context_20":"public static list getcrls(x509extension cert) { \/\/ what follows is a poor man's crl extractor, for those lacking \/\/ a bouncycastle \"bcprov.jar\" in their classpath. \/\/ it's a very basic state-machine: look for a standard url scheme \/\/ (such as http), and then start looking for a terminator. after \/\/ running hexdump a few times on these things, it looks to me like \/\/ the utf-8 value \"65533\" seems to happen near where these things \/\/ terminate. (of course this stuff is asn.1 and not utf-8, but \/\/ i happen to like some of the functions available to the string \/\/ object). - juliusdavies@cucbc.com, may 10th, 2006 byte[] bytes = cert.getextensionvalue(crl_extension); linkedlist httpcrls = new linkedlist(); linkedlist ftpcrls = new linkedlist(); linkedlist othercrls = new linkedlist(); if (bytes == null) { \/\/ just return empty list return httpcrls; } else { string s; try { s = new string(bytes, \"utf-8\"); } catch (unsupportedencodingexception uee) { \/\/ we're screwed if this thing has more than one crl, because \/\/ the \"indeof( (char) 65533 )\" below isn't going to work. s = new string(bytes); } int pos = 0; while (pos >= 0) { int x = -1, y; int[] indexes = new int[4]; indexes[0] = s.indexof(\"http\", pos); indexes[1] = s.indexof(\"ldap\", pos); indexes[2] = s.indexof(\"file\", pos); indexes[3] = s.indexof(\"ftp\", pos); arrays.sort(indexes);","repo":"rcbj\/apigee-jwt-aad-timeapi-proxy"}
{"id":19563,"comment_id":2,"comment":"\/\/ we're screwed if this thing has more than one crl, because \/\/ the \"indeof( (char) 65533 )\" below isn't going to work.","code":"public static list getcrls(x509extension cert) { \/\/ what follows is a poor man's crl extractor, for those lacking \/\/ a bouncycastle \"bcprov.jar\" in their classpath. \/\/ it's a very basic state-machine: look for a standard url scheme \/\/ (such as http), and then start looking for a terminator. after \/\/ running hexdump a few times on these things, it looks to me like \/\/ the utf-8 value \"65533\" seems to happen near where these things \/\/ terminate. (of course this stuff is asn.1 and not utf-8, but \/\/ i happen to like some of the functions available to the string \/\/ object). - juliusdavies@cucbc.com, may 10th, 2006 byte[] bytes = cert.getextensionvalue(crl_extension); linkedlist httpcrls = new linkedlist(); linkedlist ftpcrls = new linkedlist(); linkedlist othercrls = new linkedlist(); if (bytes == null) { \/\/ just return empty list return httpcrls; } else { string s; try { s = new string(bytes, \"utf-8\"); } catch (unsupportedencodingexception uee) { \/\/ we're screwed if this thing has more than one crl, because \/\/ the \"indeof( (char) 65533 )\" below isn't going to work. s = new string(bytes); } int pos = 0; while (pos >= 0) { int x = -1, y; int[] indexes = new int[4]; indexes[0] = s.indexof(\"http\", pos); indexes[1] = s.indexof(\"ldap\", pos); indexes[2] = s.indexof(\"file\", pos); indexes[3] = s.indexof(\"ftp\", pos); arrays.sort(indexes); for (int i = 0; i < indexes.length; i++) { if (indexes[i] >= 0) { x = indexes[i]; break; } } if (x >= 0) { y = s.indexof((char) 65533, x); string crl = y > x ? s.substring(x, y - 1) : s.substring(x); if (y > x && crl.endswith(\"0\")) { crl = crl.substring(0, crl.length() - 1); } string crltest = crl.trim().tolowercase(); if (crltest.startswith(\"http\")) { httpcrls.add(crl); } else if (crltest.startswith(\"ftp\")) { ftpcrls.add(crl); } else { othercrls.add(crl); } pos = y; } else { pos = -1; } } } httpcrls.addall(ftpcrls); httpcrls.addall(othercrls); return httpcrls; }","classification":"DEFECT","isFinished":true,"code_context_2":"} catch (unsupportedencodingexception uee) { \/\/ we're screwed if this thing has more than one crl, because \/\/ the \"indeof( (char) 65533 )\" below isn't going to work. s = new string(bytes); }","code_context_10":"linkedlist othercrls = new linkedlist(); if (bytes == null) { \/\/ just return empty list return httpcrls; } else { string s; try { s = new string(bytes, \"utf-8\"); } catch (unsupportedencodingexception uee) { \/\/ we're screwed if this thing has more than one crl, because \/\/ the \"indeof( (char) 65533 )\" below isn't going to work. s = new string(bytes); } int pos = 0; while (pos >= 0) { int x = -1, y; int[] indexes = new int[4]; indexes[0] = s.indexof(\"http\", pos); indexes[1] = s.indexof(\"ldap\", pos); indexes[2] = s.indexof(\"file\", pos); indexes[3] = s.indexof(\"ftp\", pos);","code_context_20":"\/\/ it's a very basic state-machine: look for a standard url scheme \/\/ (such as http), and then start looking for a terminator. after \/\/ running hexdump a few times on these things, it looks to me like \/\/ the utf-8 value \"65533\" seems to happen near where these things \/\/ terminate. (of course this stuff is asn.1 and not utf-8, but \/\/ i happen to like some of the functions available to the string \/\/ object). - juliusdavies@cucbc.com, may 10th, 2006 byte[] bytes = cert.getextensionvalue(crl_extension); linkedlist httpcrls = new linkedlist(); linkedlist ftpcrls = new linkedlist(); linkedlist othercrls = new linkedlist(); if (bytes == null) { \/\/ just return empty list return httpcrls; } else { string s; try { s = new string(bytes, \"utf-8\"); } catch (unsupportedencodingexception uee) { \/\/ we're screwed if this thing has more than one crl, because \/\/ the \"indeof( (char) 65533 )\" below isn't going to work. s = new string(bytes); } int pos = 0; while (pos >= 0) { int x = -1, y; int[] indexes = new int[4]; indexes[0] = s.indexof(\"http\", pos); indexes[1] = s.indexof(\"ldap\", pos); indexes[2] = s.indexof(\"file\", pos); indexes[3] = s.indexof(\"ftp\", pos); arrays.sort(indexes); for (int i = 0; i < indexes.length; i++) { if (indexes[i] >= 0) { x = indexes[i]; break; } } if (x >= 0) { y = s.indexof((char) 65533, x); string crl = y > x ? s.substring(x, y - 1) : s.substring(x);","repo":"rcbj\/apigee-jwt-aad-timeapi-proxy"}
{"id":11379,"comment_id":0,"comment":"\/\/ system.out.println(\"looking for \" + nm + \"; trying \" + d.name);","code":"public static int xcolorbyname(string nm) { for (int i=0; i<data.length; i++) { setting d = data[i]; \/\/ system.out.println(\"looking for \" + nm + \"; trying \" + d.name); if (nm.equalsignorecase(d.name)) { return d.value; } } \/\/ how sad... none of the 752 color names matched... throw new illegalargumentexception(\"unknown color \" + nm); }","classification":"NONSATD","isFinished":true,"code_context_2":"for (int i=0; i<data.length; i++) { setting d = data[i]; \/\/ system.out.println(\"looking for \" + nm + \"; trying \" + d.name); if (nm.equalsignorecase(d.name)) { return d.value;","code_context_10":"public static int xcolorbyname(string nm) { for (int i=0; i<data.length; i++) { setting d = data[i]; \/\/ system.out.println(\"looking for \" + nm + \"; trying \" + d.name); if (nm.equalsignorecase(d.name)) { return d.value; } } \/\/ how sad... none of the 752 color names matched... throw new illegalargumentexception(\"unknown color \" + nm); }","code_context_20":"public static int xcolorbyname(string nm) { for (int i=0; i<data.length; i++) { setting d = data[i]; \/\/ system.out.println(\"looking for \" + nm + \"; trying \" + d.name); if (nm.equalsignorecase(d.name)) { return d.value; } } \/\/ how sad... none of the 752 color names matched... throw new illegalargumentexception(\"unknown color \" + nm); }","repo":"oritelad\/libro-de-actividades"}
{"id":11379,"comment_id":1,"comment":"\/\/ how sad... none of the 752 color names matched...","code":"public static int xcolorbyname(string nm) { for (int i=0; i<data.length; i++) { setting d = data[i]; \/\/ system.out.println(\"looking for \" + nm + \"; trying \" + d.name); if (nm.equalsignorecase(d.name)) { return d.value; } } \/\/ how sad... none of the 752 color names matched... throw new illegalargumentexception(\"unknown color \" + nm); }","classification":"NONSATD","isFinished":true,"code_context_2":"} } \/\/ how sad... none of the 752 color names matched... throw new illegalargumentexception(\"unknown color \" + nm); }","code_context_10":"public static int xcolorbyname(string nm) { for (int i=0; i<data.length; i++) { setting d = data[i]; \/\/ system.out.println(\"looking for \" + nm + \"; trying \" + d.name); if (nm.equalsignorecase(d.name)) { return d.value; } } \/\/ how sad... none of the 752 color names matched... throw new illegalargumentexception(\"unknown color \" + nm); }","code_context_20":"public static int xcolorbyname(string nm) { for (int i=0; i<data.length; i++) { setting d = data[i]; \/\/ system.out.println(\"looking for \" + nm + \"; trying \" + d.name); if (nm.equalsignorecase(d.name)) { return d.value; } } \/\/ how sad... none of the 752 color names matched... throw new illegalargumentexception(\"unknown color \" + nm); }","repo":"oritelad\/libro-de-actividades"}
{"id":11380,"comment_id":0,"comment":"\/\/ system.out.println(\"looking for \" + nm + \"; trying \" + d.name);","code":"public static string xcolorbyvalue(int val) { for (int i=0; i<data.length; i++) { setting d = data[i]; \/\/ system.out.println(\"looking for \" + nm + \"; trying \" + d.name); if (val == d.value) { return d.name; } } \/\/ how sad... none of the 752 color names matched... return \"xcolor(\" + val + \")\"; }","classification":"NONSATD","isFinished":true,"code_context_2":"for (int i=0; i<data.length; i++) { setting d = data[i]; \/\/ system.out.println(\"looking for \" + nm + \"; trying \" + d.name); if (val == d.value) { return d.name;","code_context_10":"public static string xcolorbyvalue(int val) { for (int i=0; i<data.length; i++) { setting d = data[i]; \/\/ system.out.println(\"looking for \" + nm + \"; trying \" + d.name); if (val == d.value) { return d.name; } } \/\/ how sad... none of the 752 color names matched... return \"xcolor(\" + val + \")\"; }","code_context_20":"public static string xcolorbyvalue(int val) { for (int i=0; i<data.length; i++) { setting d = data[i]; \/\/ system.out.println(\"looking for \" + nm + \"; trying \" + d.name); if (val == d.value) { return d.name; } } \/\/ how sad... none of the 752 color names matched... return \"xcolor(\" + val + \")\"; }","repo":"oritelad\/libro-de-actividades"}
{"id":11380,"comment_id":1,"comment":"\/\/ how sad... none of the 752 color names matched...","code":"public static string xcolorbyvalue(int val) { for (int i=0; i<data.length; i++) { setting d = data[i]; \/\/ system.out.println(\"looking for \" + nm + \"; trying \" + d.name); if (val == d.value) { return d.name; } } \/\/ how sad... none of the 752 color names matched... return \"xcolor(\" + val + \")\"; }","classification":"NONSATD","isFinished":true,"code_context_2":"} } \/\/ how sad... none of the 752 color names matched... return \"xcolor(\" + val + \")\"; }","code_context_10":"public static string xcolorbyvalue(int val) { for (int i=0; i<data.length; i++) { setting d = data[i]; \/\/ system.out.println(\"looking for \" + nm + \"; trying \" + d.name); if (val == d.value) { return d.name; } } \/\/ how sad... none of the 752 color names matched... return \"xcolor(\" + val + \")\"; }","code_context_20":"public static string xcolorbyvalue(int val) { for (int i=0; i<data.length; i++) { setting d = data[i]; \/\/ system.out.println(\"looking for \" + nm + \"; trying \" + d.name); if (val == d.value) { return d.name; } } \/\/ how sad... none of the 752 color names matched... return \"xcolor(\" + val + \")\"; }","repo":"oritelad\/libro-de-actividades"}
{"id":11618,"comment_id":0,"comment":"\/\/-------------------------------------------------------------- \/\/ ifastsum \/\/--------------------------------------------------------------","code":"\/\/-------------------------------------------------------------- \/\/ ifastsum \/\/-------------------------------------------------------------- private static final boolean ishalfulp (final double x) { \/\/ todo: do we need to check for nan and infinity? return (0.0 != x) && (0l == doubles.significand(x)); }","classification":"NONSATD","isFinished":true,"code_context_2":"private static final boolean ishalfulp (final double x) { \/\/ todo: do we need to check for nan and infinity? return (0.0 != x) && (0l == doubles.significand(x)); }","code_context_10":"private static final boolean ishalfulp (final double x) { \/\/ todo: do we need to check for nan and infinity? return (0.0 != x) && (0l == doubles.significand(x)); }","code_context_20":"private static final boolean ishalfulp (final double x) { \/\/ todo: do we need to check for nan and infinity? return (0.0 != x) && (0l == doubles.significand(x)); }","repo":"palisades-lakes\/xfp-jmh"}
{"id":11618,"comment_id":1,"comment":"\/\/ todo: do we need to check for nan and infinity?","code":"private static final boolean ishalfulp (final double x) { \/\/ todo: do we need to check for nan and infinity? return (0.0 != x) && (0l == doubles.significand(x)); }","classification":"DESIGN","isFinished":true,"code_context_2":"private static final boolean ishalfulp (final double x) { \/\/ todo: do we need to check for nan and infinity? return (0.0 != x) && (0l == doubles.significand(x)); }","code_context_10":"private static final boolean ishalfulp (final double x) { \/\/ todo: do we need to check for nan and infinity? return (0.0 != x) && (0l == doubles.significand(x)); }","code_context_20":"private static final boolean ishalfulp (final double x) { \/\/ todo: do we need to check for nan and infinity? return (0.0 != x) && (0l == doubles.significand(x)); }","repo":"palisades-lakes\/xfp-jmh"}
{"id":11619,"comment_id":0,"comment":"\/\/--------------------------------------------------------------","code":"\/\/-------------------------------------------------------------- private static final double halfulp (final double x) { \/\/ todo: do we need to check for nan and infinity? \/\/ todo: compare to c++ implementation \/\/ todo: return zero when x is zero? if (0.0 == x) { return 0.0; } return 0.5 * math.ulp(x); }","classification":"NONSATD","isFinished":true,"code_context_2":"private static final double halfulp (final double x) { \/\/ todo: do we need to check for nan and infinity? \/\/ todo: compare to c++ implementation \/\/ todo: return zero when x is zero? if (0.0 == x) { return 0.0; } return 0.5 * math.ulp(x); }","code_context_10":"private static final double halfulp (final double x) { \/\/ todo: do we need to check for nan and infinity? \/\/ todo: compare to c++ implementation \/\/ todo: return zero when x is zero? if (0.0 == x) { return 0.0; } return 0.5 * math.ulp(x); }","code_context_20":"private static final double halfulp (final double x) { \/\/ todo: do we need to check for nan and infinity? \/\/ todo: compare to c++ implementation \/\/ todo: return zero when x is zero? if (0.0 == x) { return 0.0; } return 0.5 * math.ulp(x); }","repo":"palisades-lakes\/xfp-jmh"}
{"id":11619,"comment_id":1,"comment":"\/\/ todo: do we need to check for nan and infinity? \/\/ todo: compare to c++ implementation \/\/ todo: return zero when x is zero?","code":"private static final double halfulp (final double x) { \/\/ todo: do we need to check for nan and infinity? \/\/ todo: compare to c++ implementation \/\/ todo: return zero when x is zero? if (0.0 == x) { return 0.0; } return 0.5 * math.ulp(x); }","classification":"DESIGN","isFinished":true,"code_context_2":"private static final double halfulp (final double x) { \/\/ todo: do we need to check for nan and infinity? \/\/ todo: compare to c++ implementation \/\/ todo: return zero when x is zero? if (0.0 == x) { return 0.0; } return 0.5 * math.ulp(x); }","code_context_10":"private static final double halfulp (final double x) { \/\/ todo: do we need to check for nan and infinity? \/\/ todo: compare to c++ implementation \/\/ todo: return zero when x is zero? if (0.0 == x) { return 0.0; } return 0.5 * math.ulp(x); }","code_context_20":"private static final double halfulp (final double x) { \/\/ todo: do we need to check for nan and infinity? \/\/ todo: compare to c++ implementation \/\/ todo: return zero when x is zero? if (0.0 == x) { return 0.0; } return 0.5 * math.ulp(x); }","repo":"palisades-lakes\/xfp-jmh"}
{"id":11774,"comment_id":0,"comment":"\/\/ todo: should we need to set anything?","code":"@override protected void parsesynchronusly() throws ioexception { final optional<rdfformat> formatbymimetype = getcontenttype().flatmap(rio::getparserformatformimetype); final string base = getbase().map(iri::getiristring).orelse(null); final parserconfig parserconfig = getparserconfig(); \/\/ todo: should we need to set anything? final rdfloader loader = new rdfloader(parserconfig, rdf4jtermfactory.getvaluefactory()); final rdfhandler rdfhandler = makerdfhandler(); if (getsourcefile().ispresent()) { \/\/ note: while we could have used \/\/ loader.load(sourcepath.tofile() \/\/ if the path fs provider == filesystems.getdefault(), \/\/ that rdfloader method does not use absolute path \/\/ as the base uri, so to be consistent \/\/ we'll always do it with our own input stream \/\/ \/\/ that means we may have to guess format by extensions: final optional<rdfformat> formatbyfilename = getsourcefile().map(path::getfilename).map(path::tostring) .flatmap(rio::getparserformatforfilename); \/\/ todo: for the excited.. what about the extension after following \/\/ symlinks? final rdfformat format = formatbymimetype.orelse(formatbyfilename.orelse(null)); try (inputstream in = files.newinputstream(getsourcefile().get())) { loader.load(in, base, format, rdfhandler); } } else if (getsourceiri().ispresent()) { try { \/\/ todo: handle international iris properly \/\/ (unicode support for for hostname, path and query) final url url = new url(getsourceiri().get().getiristring()); \/\/ todo: this probably does not support https:\/\/ -> http:\/\/ \/\/ redirections loader.load(url, base, formatbymimetype.orelse(null), makerdfhandler()); } catch (final malformedurlexception ex) { throw new ioexception(\"can't handle source url: \" + getsourceiri().get(), ex); } } \/\/ must be getsourceinputstream then, this is guaranteed by \/\/ super.checksource(); loader.load(getsourceinputstream().get(), base, formatbymimetype.orelse(null), rdfhandler); }","classification":"DESIGN","isFinished":true,"code_context_2":"final string base = getbase().map(iri::getiristring).orelse(null); final parserconfig parserconfig = getparserconfig(); \/\/ todo: should we need to set anything? final rdfloader loader = new rdfloader(parserconfig, rdf4jtermfactory.getvaluefactory()); final rdfhandler rdfhandler = makerdfhandler();","code_context_10":"@override protected void parsesynchronusly() throws ioexception { final optional<rdfformat> formatbymimetype = getcontenttype().flatmap(rio::getparserformatformimetype); final string base = getbase().map(iri::getiristring).orelse(null); final parserconfig parserconfig = getparserconfig(); \/\/ todo: should we need to set anything? final rdfloader loader = new rdfloader(parserconfig, rdf4jtermfactory.getvaluefactory()); final rdfhandler rdfhandler = makerdfhandler(); if (getsourcefile().ispresent()) { \/\/ note: while we could have used \/\/ loader.load(sourcepath.tofile() \/\/ if the path fs provider == filesystems.getdefault(), \/\/ that rdfloader method does not use absolute path \/\/ as the base uri, so to be consistent \/\/ we'll always do it with our own input stream \/\/","code_context_20":"@override protected void parsesynchronusly() throws ioexception { final optional<rdfformat> formatbymimetype = getcontenttype().flatmap(rio::getparserformatformimetype); final string base = getbase().map(iri::getiristring).orelse(null); final parserconfig parserconfig = getparserconfig(); \/\/ todo: should we need to set anything? final rdfloader loader = new rdfloader(parserconfig, rdf4jtermfactory.getvaluefactory()); final rdfhandler rdfhandler = makerdfhandler(); if (getsourcefile().ispresent()) { \/\/ note: while we could have used \/\/ loader.load(sourcepath.tofile() \/\/ if the path fs provider == filesystems.getdefault(), \/\/ that rdfloader method does not use absolute path \/\/ as the base uri, so to be consistent \/\/ we'll always do it with our own input stream \/\/ \/\/ that means we may have to guess format by extensions: final optional<rdfformat> formatbyfilename = getsourcefile().map(path::getfilename).map(path::tostring) .flatmap(rio::getparserformatforfilename); \/\/ todo: for the excited.. what about the extension after following \/\/ symlinks? final rdfformat format = formatbymimetype.orelse(formatbyfilename.orelse(null)); try (inputstream in = files.newinputstream(getsourcefile().get())) { loader.load(in, base, format, rdfhandler); } } else if (getsourceiri().ispresent()) {","repo":"nikosnikolaidis\/commons-rdf"}
{"id":11774,"comment_id":1,"comment":"\/\/ note: while we could have used \/\/ loader.load(sourcepath.tofile() \/\/ if the path fs provider == filesystems.getdefault(), \/\/ that rdfloader method does not use absolute path \/\/ as the base uri, so to be consistent \/\/ we'll always do it with our own input stream \/\/ \/\/ that means we may have to guess format by extensions:","code":"@override protected void parsesynchronusly() throws ioexception { final optional<rdfformat> formatbymimetype = getcontenttype().flatmap(rio::getparserformatformimetype); final string base = getbase().map(iri::getiristring).orelse(null); final parserconfig parserconfig = getparserconfig(); \/\/ todo: should we need to set anything? final rdfloader loader = new rdfloader(parserconfig, rdf4jtermfactory.getvaluefactory()); final rdfhandler rdfhandler = makerdfhandler(); if (getsourcefile().ispresent()) { \/\/ note: while we could have used \/\/ loader.load(sourcepath.tofile() \/\/ if the path fs provider == filesystems.getdefault(), \/\/ that rdfloader method does not use absolute path \/\/ as the base uri, so to be consistent \/\/ we'll always do it with our own input stream \/\/ \/\/ that means we may have to guess format by extensions: final optional<rdfformat> formatbyfilename = getsourcefile().map(path::getfilename).map(path::tostring) .flatmap(rio::getparserformatforfilename); \/\/ todo: for the excited.. what about the extension after following \/\/ symlinks? final rdfformat format = formatbymimetype.orelse(formatbyfilename.orelse(null)); try (inputstream in = files.newinputstream(getsourcefile().get())) { loader.load(in, base, format, rdfhandler); } } else if (getsourceiri().ispresent()) { try { \/\/ todo: handle international iris properly \/\/ (unicode support for for hostname, path and query) final url url = new url(getsourceiri().get().getiristring()); \/\/ todo: this probably does not support https:\/\/ -> http:\/\/ \/\/ redirections loader.load(url, base, formatbymimetype.orelse(null), makerdfhandler()); } catch (final malformedurlexception ex) { throw new ioexception(\"can't handle source url: \" + getsourceiri().get(), ex); } } \/\/ must be getsourceinputstream then, this is guaranteed by \/\/ super.checksource(); loader.load(getsourceinputstream().get(), base, formatbymimetype.orelse(null), rdfhandler); }","classification":"NONSATD","isFinished":true,"code_context_2":"final rdfhandler rdfhandler = makerdfhandler(); if (getsourcefile().ispresent()) { \/\/ note: while we could have used \/\/ loader.load(sourcepath.tofile() \/\/ if the path fs provider == filesystems.getdefault(), \/\/ that rdfloader method does not use absolute path \/\/ as the base uri, so to be consistent \/\/ we'll always do it with our own input stream \/\/ \/\/ that means we may have to guess format by extensions: final optional<rdfformat> formatbyfilename = getsourcefile().map(path::getfilename).map(path::tostring) .flatmap(rio::getparserformatforfilename);","code_context_10":"@override protected void parsesynchronusly() throws ioexception { final optional<rdfformat> formatbymimetype = getcontenttype().flatmap(rio::getparserformatformimetype); final string base = getbase().map(iri::getiristring).orelse(null); final parserconfig parserconfig = getparserconfig(); \/\/ todo: should we need to set anything? final rdfloader loader = new rdfloader(parserconfig, rdf4jtermfactory.getvaluefactory()); final rdfhandler rdfhandler = makerdfhandler(); if (getsourcefile().ispresent()) { \/\/ note: while we could have used \/\/ loader.load(sourcepath.tofile() \/\/ if the path fs provider == filesystems.getdefault(), \/\/ that rdfloader method does not use absolute path \/\/ as the base uri, so to be consistent \/\/ we'll always do it with our own input stream \/\/ \/\/ that means we may have to guess format by extensions: final optional<rdfformat> formatbyfilename = getsourcefile().map(path::getfilename).map(path::tostring) .flatmap(rio::getparserformatforfilename); \/\/ todo: for the excited.. what about the extension after following \/\/ symlinks? final rdfformat format = formatbymimetype.orelse(formatbyfilename.orelse(null)); try (inputstream in = files.newinputstream(getsourcefile().get())) { loader.load(in, base, format, rdfhandler); } } else if (getsourceiri().ispresent()) { try {","code_context_20":"@override protected void parsesynchronusly() throws ioexception { final optional<rdfformat> formatbymimetype = getcontenttype().flatmap(rio::getparserformatformimetype); final string base = getbase().map(iri::getiristring).orelse(null); final parserconfig parserconfig = getparserconfig(); \/\/ todo: should we need to set anything? final rdfloader loader = new rdfloader(parserconfig, rdf4jtermfactory.getvaluefactory()); final rdfhandler rdfhandler = makerdfhandler(); if (getsourcefile().ispresent()) { \/\/ note: while we could have used \/\/ loader.load(sourcepath.tofile() \/\/ if the path fs provider == filesystems.getdefault(), \/\/ that rdfloader method does not use absolute path \/\/ as the base uri, so to be consistent \/\/ we'll always do it with our own input stream \/\/ \/\/ that means we may have to guess format by extensions: final optional<rdfformat> formatbyfilename = getsourcefile().map(path::getfilename).map(path::tostring) .flatmap(rio::getparserformatforfilename); \/\/ todo: for the excited.. what about the extension after following \/\/ symlinks? final rdfformat format = formatbymimetype.orelse(formatbyfilename.orelse(null)); try (inputstream in = files.newinputstream(getsourcefile().get())) { loader.load(in, base, format, rdfhandler); } } else if (getsourceiri().ispresent()) { try { \/\/ todo: handle international iris properly \/\/ (unicode support for for hostname, path and query) final url url = new url(getsourceiri().get().getiristring()); \/\/ todo: this probably does not support https:\/\/ -> http:\/\/ \/\/ redirections loader.load(url, base, formatbymimetype.orelse(null), makerdfhandler()); } catch (final malformedurlexception ex) { throw new ioexception(\"can't handle source url: \" + getsourceiri().get(), ex); } }","repo":"nikosnikolaidis\/commons-rdf"}
{"id":11774,"comment_id":2,"comment":"\/\/ todo: for the excited.. what about the extension after following \/\/ symlinks?","code":"@override protected void parsesynchronusly() throws ioexception { final optional<rdfformat> formatbymimetype = getcontenttype().flatmap(rio::getparserformatformimetype); final string base = getbase().map(iri::getiristring).orelse(null); final parserconfig parserconfig = getparserconfig(); \/\/ todo: should we need to set anything? final rdfloader loader = new rdfloader(parserconfig, rdf4jtermfactory.getvaluefactory()); final rdfhandler rdfhandler = makerdfhandler(); if (getsourcefile().ispresent()) { \/\/ note: while we could have used \/\/ loader.load(sourcepath.tofile() \/\/ if the path fs provider == filesystems.getdefault(), \/\/ that rdfloader method does not use absolute path \/\/ as the base uri, so to be consistent \/\/ we'll always do it with our own input stream \/\/ \/\/ that means we may have to guess format by extensions: final optional<rdfformat> formatbyfilename = getsourcefile().map(path::getfilename).map(path::tostring) .flatmap(rio::getparserformatforfilename); \/\/ todo: for the excited.. what about the extension after following \/\/ symlinks? final rdfformat format = formatbymimetype.orelse(formatbyfilename.orelse(null)); try (inputstream in = files.newinputstream(getsourcefile().get())) { loader.load(in, base, format, rdfhandler); } } else if (getsourceiri().ispresent()) { try { \/\/ todo: handle international iris properly \/\/ (unicode support for for hostname, path and query) final url url = new url(getsourceiri().get().getiristring()); \/\/ todo: this probably does not support https:\/\/ -> http:\/\/ \/\/ redirections loader.load(url, base, formatbymimetype.orelse(null), makerdfhandler()); } catch (final malformedurlexception ex) { throw new ioexception(\"can't handle source url: \" + getsourceiri().get(), ex); } } \/\/ must be getsourceinputstream then, this is guaranteed by \/\/ super.checksource(); loader.load(getsourceinputstream().get(), base, formatbymimetype.orelse(null), rdfhandler); }","classification":"DESIGN","isFinished":true,"code_context_2":"final optional<rdfformat> formatbyfilename = getsourcefile().map(path::getfilename).map(path::tostring) .flatmap(rio::getparserformatforfilename); \/\/ todo: for the excited.. what about the extension after following \/\/ symlinks? final rdfformat format = formatbymimetype.orelse(formatbyfilename.orelse(null)); try (inputstream in = files.newinputstream(getsourcefile().get())) {","code_context_10":"\/\/ note: while we could have used \/\/ loader.load(sourcepath.tofile() \/\/ if the path fs provider == filesystems.getdefault(), \/\/ that rdfloader method does not use absolute path \/\/ as the base uri, so to be consistent \/\/ we'll always do it with our own input stream \/\/ \/\/ that means we may have to guess format by extensions: final optional<rdfformat> formatbyfilename = getsourcefile().map(path::getfilename).map(path::tostring) .flatmap(rio::getparserformatforfilename); \/\/ todo: for the excited.. what about the extension after following \/\/ symlinks? final rdfformat format = formatbymimetype.orelse(formatbyfilename.orelse(null)); try (inputstream in = files.newinputstream(getsourcefile().get())) { loader.load(in, base, format, rdfhandler); } } else if (getsourceiri().ispresent()) { try { \/\/ todo: handle international iris properly \/\/ (unicode support for for hostname, path and query) final url url = new url(getsourceiri().get().getiristring()); \/\/ todo: this probably does not support https:\/\/ -> http:\/\/","code_context_20":"@override protected void parsesynchronusly() throws ioexception { final optional<rdfformat> formatbymimetype = getcontenttype().flatmap(rio::getparserformatformimetype); final string base = getbase().map(iri::getiristring).orelse(null); final parserconfig parserconfig = getparserconfig(); \/\/ todo: should we need to set anything? final rdfloader loader = new rdfloader(parserconfig, rdf4jtermfactory.getvaluefactory()); final rdfhandler rdfhandler = makerdfhandler(); if (getsourcefile().ispresent()) { \/\/ note: while we could have used \/\/ loader.load(sourcepath.tofile() \/\/ if the path fs provider == filesystems.getdefault(), \/\/ that rdfloader method does not use absolute path \/\/ as the base uri, so to be consistent \/\/ we'll always do it with our own input stream \/\/ \/\/ that means we may have to guess format by extensions: final optional<rdfformat> formatbyfilename = getsourcefile().map(path::getfilename).map(path::tostring) .flatmap(rio::getparserformatforfilename); \/\/ todo: for the excited.. what about the extension after following \/\/ symlinks? final rdfformat format = formatbymimetype.orelse(formatbyfilename.orelse(null)); try (inputstream in = files.newinputstream(getsourcefile().get())) { loader.load(in, base, format, rdfhandler); } } else if (getsourceiri().ispresent()) { try { \/\/ todo: handle international iris properly \/\/ (unicode support for for hostname, path and query) final url url = new url(getsourceiri().get().getiristring()); \/\/ todo: this probably does not support https:\/\/ -> http:\/\/ \/\/ redirections loader.load(url, base, formatbymimetype.orelse(null), makerdfhandler()); } catch (final malformedurlexception ex) { throw new ioexception(\"can't handle source url: \" + getsourceiri().get(), ex); } } \/\/ must be getsourceinputstream then, this is guaranteed by \/\/ super.checksource(); loader.load(getsourceinputstream().get(), base, formatbymimetype.orelse(null), rdfhandler); }","repo":"nikosnikolaidis\/commons-rdf"}
{"id":11774,"comment_id":3,"comment":"\/\/ todo: handle international iris properly \/\/ (unicode support for for hostname, path and query)","code":"@override protected void parsesynchronusly() throws ioexception { final optional<rdfformat> formatbymimetype = getcontenttype().flatmap(rio::getparserformatformimetype); final string base = getbase().map(iri::getiristring).orelse(null); final parserconfig parserconfig = getparserconfig(); \/\/ todo: should we need to set anything? final rdfloader loader = new rdfloader(parserconfig, rdf4jtermfactory.getvaluefactory()); final rdfhandler rdfhandler = makerdfhandler(); if (getsourcefile().ispresent()) { \/\/ note: while we could have used \/\/ loader.load(sourcepath.tofile() \/\/ if the path fs provider == filesystems.getdefault(), \/\/ that rdfloader method does not use absolute path \/\/ as the base uri, so to be consistent \/\/ we'll always do it with our own input stream \/\/ \/\/ that means we may have to guess format by extensions: final optional<rdfformat> formatbyfilename = getsourcefile().map(path::getfilename).map(path::tostring) .flatmap(rio::getparserformatforfilename); \/\/ todo: for the excited.. what about the extension after following \/\/ symlinks? final rdfformat format = formatbymimetype.orelse(formatbyfilename.orelse(null)); try (inputstream in = files.newinputstream(getsourcefile().get())) { loader.load(in, base, format, rdfhandler); } } else if (getsourceiri().ispresent()) { try { \/\/ todo: handle international iris properly \/\/ (unicode support for for hostname, path and query) final url url = new url(getsourceiri().get().getiristring()); \/\/ todo: this probably does not support https:\/\/ -> http:\/\/ \/\/ redirections loader.load(url, base, formatbymimetype.orelse(null), makerdfhandler()); } catch (final malformedurlexception ex) { throw new ioexception(\"can't handle source url: \" + getsourceiri().get(), ex); } } \/\/ must be getsourceinputstream then, this is guaranteed by \/\/ super.checksource(); loader.load(getsourceinputstream().get(), base, formatbymimetype.orelse(null), rdfhandler); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"} else if (getsourceiri().ispresent()) { try { \/\/ todo: handle international iris properly \/\/ (unicode support for for hostname, path and query) final url url = new url(getsourceiri().get().getiristring()); \/\/ todo: this probably does not support https:\/\/ -> http:\/\/","code_context_10":"final optional<rdfformat> formatbyfilename = getsourcefile().map(path::getfilename).map(path::tostring) .flatmap(rio::getparserformatforfilename); \/\/ todo: for the excited.. what about the extension after following \/\/ symlinks? final rdfformat format = formatbymimetype.orelse(formatbyfilename.orelse(null)); try (inputstream in = files.newinputstream(getsourcefile().get())) { loader.load(in, base, format, rdfhandler); } } else if (getsourceiri().ispresent()) { try { \/\/ todo: handle international iris properly \/\/ (unicode support for for hostname, path and query) final url url = new url(getsourceiri().get().getiristring()); \/\/ todo: this probably does not support https:\/\/ -> http:\/\/ \/\/ redirections loader.load(url, base, formatbymimetype.orelse(null), makerdfhandler()); } catch (final malformedurlexception ex) { throw new ioexception(\"can't handle source url: \" + getsourceiri().get(), ex); } } \/\/ must be getsourceinputstream then, this is guaranteed by \/\/ super.checksource();","code_context_20":"final rdfhandler rdfhandler = makerdfhandler(); if (getsourcefile().ispresent()) { \/\/ note: while we could have used \/\/ loader.load(sourcepath.tofile() \/\/ if the path fs provider == filesystems.getdefault(), \/\/ that rdfloader method does not use absolute path \/\/ as the base uri, so to be consistent \/\/ we'll always do it with our own input stream \/\/ \/\/ that means we may have to guess format by extensions: final optional<rdfformat> formatbyfilename = getsourcefile().map(path::getfilename).map(path::tostring) .flatmap(rio::getparserformatforfilename); \/\/ todo: for the excited.. what about the extension after following \/\/ symlinks? final rdfformat format = formatbymimetype.orelse(formatbyfilename.orelse(null)); try (inputstream in = files.newinputstream(getsourcefile().get())) { loader.load(in, base, format, rdfhandler); } } else if (getsourceiri().ispresent()) { try { \/\/ todo: handle international iris properly \/\/ (unicode support for for hostname, path and query) final url url = new url(getsourceiri().get().getiristring()); \/\/ todo: this probably does not support https:\/\/ -> http:\/\/ \/\/ redirections loader.load(url, base, formatbymimetype.orelse(null), makerdfhandler()); } catch (final malformedurlexception ex) { throw new ioexception(\"can't handle source url: \" + getsourceiri().get(), ex); } } \/\/ must be getsourceinputstream then, this is guaranteed by \/\/ super.checksource(); loader.load(getsourceinputstream().get(), base, formatbymimetype.orelse(null), rdfhandler); }","repo":"nikosnikolaidis\/commons-rdf"}
{"id":11774,"comment_id":4,"comment":"\/\/ todo: this probably does not support https:\/\/ -> http:\/\/ \/\/ redirections","code":"@override protected void parsesynchronusly() throws ioexception { final optional<rdfformat> formatbymimetype = getcontenttype().flatmap(rio::getparserformatformimetype); final string base = getbase().map(iri::getiristring).orelse(null); final parserconfig parserconfig = getparserconfig(); \/\/ todo: should we need to set anything? final rdfloader loader = new rdfloader(parserconfig, rdf4jtermfactory.getvaluefactory()); final rdfhandler rdfhandler = makerdfhandler(); if (getsourcefile().ispresent()) { \/\/ note: while we could have used \/\/ loader.load(sourcepath.tofile() \/\/ if the path fs provider == filesystems.getdefault(), \/\/ that rdfloader method does not use absolute path \/\/ as the base uri, so to be consistent \/\/ we'll always do it with our own input stream \/\/ \/\/ that means we may have to guess format by extensions: final optional<rdfformat> formatbyfilename = getsourcefile().map(path::getfilename).map(path::tostring) .flatmap(rio::getparserformatforfilename); \/\/ todo: for the excited.. what about the extension after following \/\/ symlinks? final rdfformat format = formatbymimetype.orelse(formatbyfilename.orelse(null)); try (inputstream in = files.newinputstream(getsourcefile().get())) { loader.load(in, base, format, rdfhandler); } } else if (getsourceiri().ispresent()) { try { \/\/ todo: handle international iris properly \/\/ (unicode support for for hostname, path and query) final url url = new url(getsourceiri().get().getiristring()); \/\/ todo: this probably does not support https:\/\/ -> http:\/\/ \/\/ redirections loader.load(url, base, formatbymimetype.orelse(null), makerdfhandler()); } catch (final malformedurlexception ex) { throw new ioexception(\"can't handle source url: \" + getsourceiri().get(), ex); } } \/\/ must be getsourceinputstream then, this is guaranteed by \/\/ super.checksource(); loader.load(getsourceinputstream().get(), base, formatbymimetype.orelse(null), rdfhandler); }","classification":"DESIGN","isFinished":true,"code_context_2":"\/\/ (unicode support for for hostname, path and query) final url url = new url(getsourceiri().get().getiristring()); \/\/ todo: this probably does not support https:\/\/ -> http:\/\/ \/\/ redirections loader.load(url, base, formatbymimetype.orelse(null), makerdfhandler()); } catch (final malformedurlexception ex) {","code_context_10":"\/\/ symlinks? final rdfformat format = formatbymimetype.orelse(formatbyfilename.orelse(null)); try (inputstream in = files.newinputstream(getsourcefile().get())) { loader.load(in, base, format, rdfhandler); } } else if (getsourceiri().ispresent()) { try { \/\/ todo: handle international iris properly \/\/ (unicode support for for hostname, path and query) final url url = new url(getsourceiri().get().getiristring()); \/\/ todo: this probably does not support https:\/\/ -> http:\/\/ \/\/ redirections loader.load(url, base, formatbymimetype.orelse(null), makerdfhandler()); } catch (final malformedurlexception ex) { throw new ioexception(\"can't handle source url: \" + getsourceiri().get(), ex); } } \/\/ must be getsourceinputstream then, this is guaranteed by \/\/ super.checksource(); loader.load(getsourceinputstream().get(), base, formatbymimetype.orelse(null), rdfhandler); }","code_context_20":"\/\/ loader.load(sourcepath.tofile() \/\/ if the path fs provider == filesystems.getdefault(), \/\/ that rdfloader method does not use absolute path \/\/ as the base uri, so to be consistent \/\/ we'll always do it with our own input stream \/\/ \/\/ that means we may have to guess format by extensions: final optional<rdfformat> formatbyfilename = getsourcefile().map(path::getfilename).map(path::tostring) .flatmap(rio::getparserformatforfilename); \/\/ todo: for the excited.. what about the extension after following \/\/ symlinks? final rdfformat format = formatbymimetype.orelse(formatbyfilename.orelse(null)); try (inputstream in = files.newinputstream(getsourcefile().get())) { loader.load(in, base, format, rdfhandler); } } else if (getsourceiri().ispresent()) { try { \/\/ todo: handle international iris properly \/\/ (unicode support for for hostname, path and query) final url url = new url(getsourceiri().get().getiristring()); \/\/ todo: this probably does not support https:\/\/ -> http:\/\/ \/\/ redirections loader.load(url, base, formatbymimetype.orelse(null), makerdfhandler()); } catch (final malformedurlexception ex) { throw new ioexception(\"can't handle source url: \" + getsourceiri().get(), ex); } } \/\/ must be getsourceinputstream then, this is guaranteed by \/\/ super.checksource(); loader.load(getsourceinputstream().get(), base, formatbymimetype.orelse(null), rdfhandler); }","repo":"nikosnikolaidis\/commons-rdf"}
{"id":11774,"comment_id":5,"comment":"\/\/ must be getsourceinputstream then, this is guaranteed by \/\/ super.checksource();","code":"@override protected void parsesynchronusly() throws ioexception { final optional<rdfformat> formatbymimetype = getcontenttype().flatmap(rio::getparserformatformimetype); final string base = getbase().map(iri::getiristring).orelse(null); final parserconfig parserconfig = getparserconfig(); \/\/ todo: should we need to set anything? final rdfloader loader = new rdfloader(parserconfig, rdf4jtermfactory.getvaluefactory()); final rdfhandler rdfhandler = makerdfhandler(); if (getsourcefile().ispresent()) { \/\/ note: while we could have used \/\/ loader.load(sourcepath.tofile() \/\/ if the path fs provider == filesystems.getdefault(), \/\/ that rdfloader method does not use absolute path \/\/ as the base uri, so to be consistent \/\/ we'll always do it with our own input stream \/\/ \/\/ that means we may have to guess format by extensions: final optional<rdfformat> formatbyfilename = getsourcefile().map(path::getfilename).map(path::tostring) .flatmap(rio::getparserformatforfilename); \/\/ todo: for the excited.. what about the extension after following \/\/ symlinks? final rdfformat format = formatbymimetype.orelse(formatbyfilename.orelse(null)); try (inputstream in = files.newinputstream(getsourcefile().get())) { loader.load(in, base, format, rdfhandler); } } else if (getsourceiri().ispresent()) { try { \/\/ todo: handle international iris properly \/\/ (unicode support for for hostname, path and query) final url url = new url(getsourceiri().get().getiristring()); \/\/ todo: this probably does not support https:\/\/ -> http:\/\/ \/\/ redirections loader.load(url, base, formatbymimetype.orelse(null), makerdfhandler()); } catch (final malformedurlexception ex) { throw new ioexception(\"can't handle source url: \" + getsourceiri().get(), ex); } } \/\/ must be getsourceinputstream then, this is guaranteed by \/\/ super.checksource(); loader.load(getsourceinputstream().get(), base, formatbymimetype.orelse(null), rdfhandler); }","classification":"NONSATD","isFinished":true,"code_context_2":"} } \/\/ must be getsourceinputstream then, this is guaranteed by \/\/ super.checksource(); loader.load(getsourceinputstream().get(), base, formatbymimetype.orelse(null), rdfhandler); }","code_context_10":"\/\/ todo: handle international iris properly \/\/ (unicode support for for hostname, path and query) final url url = new url(getsourceiri().get().getiristring()); \/\/ todo: this probably does not support https:\/\/ -> http:\/\/ \/\/ redirections loader.load(url, base, formatbymimetype.orelse(null), makerdfhandler()); } catch (final malformedurlexception ex) { throw new ioexception(\"can't handle source url: \" + getsourceiri().get(), ex); } } \/\/ must be getsourceinputstream then, this is guaranteed by \/\/ super.checksource(); loader.load(getsourceinputstream().get(), base, formatbymimetype.orelse(null), rdfhandler); }","code_context_20":"final optional<rdfformat> formatbyfilename = getsourcefile().map(path::getfilename).map(path::tostring) .flatmap(rio::getparserformatforfilename); \/\/ todo: for the excited.. what about the extension after following \/\/ symlinks? final rdfformat format = formatbymimetype.orelse(formatbyfilename.orelse(null)); try (inputstream in = files.newinputstream(getsourcefile().get())) { loader.load(in, base, format, rdfhandler); } } else if (getsourceiri().ispresent()) { try { \/\/ todo: handle international iris properly \/\/ (unicode support for for hostname, path and query) final url url = new url(getsourceiri().get().getiristring()); \/\/ todo: this probably does not support https:\/\/ -> http:\/\/ \/\/ redirections loader.load(url, base, formatbymimetype.orelse(null), makerdfhandler()); } catch (final malformedurlexception ex) { throw new ioexception(\"can't handle source url: \" + getsourceiri().get(), ex); } } \/\/ must be getsourceinputstream then, this is guaranteed by \/\/ super.checksource(); loader.load(getsourceinputstream().get(), base, formatbymimetype.orelse(null), rdfhandler); }","repo":"nikosnikolaidis\/commons-rdf"}
{"id":20076,"comment_id":0,"comment":"\/\/ the spec is wrong: it's lsb, then msb \/\/ int v = (data[pos] << 4) | data[pos+1];","code":"int denybble(byte[] data, int pos) { \/\/ the spec is wrong: it's lsb, then msb \/\/ int v = (data[pos] << 4) | data[pos+1]; int v = (data[pos + 1] << 4) | data[pos]; \/\/ some of the dark star stuff is 8-bit, so we have to make sure we're positive if (v < 0) v += 256; return v; }","classification":"DEFECT","isFinished":true,"code_context_2":"int denybble(byte[] data, int pos) { \/\/ the spec is wrong: it's lsb, then msb \/\/ int v = (data[pos] << 4) | data[pos+1]; int v = (data[pos + 1] << 4) | data[pos]; \/\/ some of the dark star stuff is 8-bit, so we have to make sure we're positive","code_context_10":"int denybble(byte[] data, int pos) { \/\/ the spec is wrong: it's lsb, then msb \/\/ int v = (data[pos] << 4) | data[pos+1]; int v = (data[pos + 1] << 4) | data[pos]; \/\/ some of the dark star stuff is 8-bit, so we have to make sure we're positive if (v < 0) v += 256; return v; }","code_context_20":"int denybble(byte[] data, int pos) { \/\/ the spec is wrong: it's lsb, then msb \/\/ int v = (data[pos] << 4) | data[pos+1]; int v = (data[pos + 1] << 4) | data[pos]; \/\/ some of the dark star stuff is 8-bit, so we have to make sure we're positive if (v < 0) v += 256; return v; }","repo":"oco27\/edisyn"}
{"id":20076,"comment_id":1,"comment":"\/\/ some of the dark star stuff is 8-bit, so we have to make sure we're positive","code":"int denybble(byte[] data, int pos) { \/\/ the spec is wrong: it's lsb, then msb \/\/ int v = (data[pos] << 4) | data[pos+1]; int v = (data[pos + 1] << 4) | data[pos]; \/\/ some of the dark star stuff is 8-bit, so we have to make sure we're positive if (v < 0) v += 256; return v; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ int v = (data[pos] << 4) | data[pos+1]; int v = (data[pos + 1] << 4) | data[pos]; \/\/ some of the dark star stuff is 8-bit, so we have to make sure we're positive if (v < 0) v += 256; return v;","code_context_10":"int denybble(byte[] data, int pos) { \/\/ the spec is wrong: it's lsb, then msb \/\/ int v = (data[pos] << 4) | data[pos+1]; int v = (data[pos + 1] << 4) | data[pos]; \/\/ some of the dark star stuff is 8-bit, so we have to make sure we're positive if (v < 0) v += 256; return v; }","code_context_20":"int denybble(byte[] data, int pos) { \/\/ the spec is wrong: it's lsb, then msb \/\/ int v = (data[pos] << 4) | data[pos+1]; int v = (data[pos + 1] << 4) | data[pos]; \/\/ some of the dark star stuff is 8-bit, so we have to make sure we're positive if (v < 0) v += 256; return v; }","repo":"oco27\/edisyn"}
{"id":20077,"comment_id":0,"comment":"\/\/ the spec is wrong: it's lsb, then msb","code":"void adddata(byte[] data, int pos, int val) { \/\/ the spec is wrong: it's lsb, then msb data[pos] = (byte)((val >> 0) & 0x0f); data[pos + 1] = (byte)((val >> 4) & 0x0f); \/\/data[pos + 1] = (byte)((val >> 0) & 0x0f); \/\/data[pos] = (byte)((val >> 4) & 0x0f); }","classification":"DEFECT","isFinished":true,"code_context_2":"void adddata(byte[] data, int pos, int val) { \/\/ the spec is wrong: it's lsb, then msb data[pos] = (byte)((val >> 0) & 0x0f); data[pos + 1] = (byte)((val >> 4) & 0x0f);","code_context_10":"void adddata(byte[] data, int pos, int val) { \/\/ the spec is wrong: it's lsb, then msb data[pos] = (byte)((val >> 0) & 0x0f); data[pos + 1] = (byte)((val >> 4) & 0x0f); \/\/data[pos + 1] = (byte)((val >> 0) & 0x0f); \/\/data[pos] = (byte)((val >> 4) & 0x0f); }","code_context_20":"void adddata(byte[] data, int pos, int val) { \/\/ the spec is wrong: it's lsb, then msb data[pos] = (byte)((val >> 0) & 0x0f); data[pos + 1] = (byte)((val >> 4) & 0x0f); \/\/data[pos + 1] = (byte)((val >> 0) & 0x0f); \/\/data[pos] = (byte)((val >> 4) & 0x0f); }","repo":"oco27\/edisyn"}
{"id":20077,"comment_id":1,"comment":"\/\/data[pos + 1] = (byte)((val >> 0) & 0x0f); \/\/data[pos] = (byte)((val >> 4) & 0x0f);","code":"void adddata(byte[] data, int pos, int val) { \/\/ the spec is wrong: it's lsb, then msb data[pos] = (byte)((val >> 0) & 0x0f); data[pos + 1] = (byte)((val >> 4) & 0x0f); \/\/data[pos + 1] = (byte)((val >> 0) & 0x0f); \/\/data[pos] = (byte)((val >> 4) & 0x0f); }","classification":"NONSATD","isFinished":true,"code_context_2":"data[pos] = (byte)((val >> 0) & 0x0f); data[pos + 1] = (byte)((val >> 4) & 0x0f); \/\/data[pos + 1] = (byte)((val >> 0) & 0x0f); \/\/data[pos] = (byte)((val >> 4) & 0x0f); }","code_context_10":"void adddata(byte[] data, int pos, int val) { \/\/ the spec is wrong: it's lsb, then msb data[pos] = (byte)((val >> 0) & 0x0f); data[pos + 1] = (byte)((val >> 4) & 0x0f); \/\/data[pos + 1] = (byte)((val >> 0) & 0x0f); \/\/data[pos] = (byte)((val >> 4) & 0x0f); }","code_context_20":"void adddata(byte[] data, int pos, int val) { \/\/ the spec is wrong: it's lsb, then msb data[pos] = (byte)((val >> 0) & 0x0f); data[pos + 1] = (byte)((val >> 4) & 0x0f); \/\/data[pos + 1] = (byte)((val >> 0) & 0x0f); \/\/data[pos] = (byte)((val >> 4) & 0x0f); }","repo":"oco27\/edisyn"}
{"id":11963,"comment_id":0,"comment":"\/\/ get a sorted copy of the series data. once we have this we can release locks.","code":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() ); } if(rangey != null) { axisy = new range<>( rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); \/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel); final bounds boundstext = textformeasuring.getlayoutbounds(); double offsety = 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight(); double offsetx = -0.87 * boundstext.getwidth(); gc.save(); \/\/ translate then rotate to rotate text around local origin rather than rotating around the canvas origin. \/\/ rotating and drawing at an offset results in a rotation around the origin. gc.translate(pxx + offsetx, rectchart.getmaxy() + offsety); gc.rotate(-30.0); gc.stroketext(textlabel, 0.0, 0.0); gc.restore(); } for(ty ticky : ticksy) { final double pxy = chartyfromdatay(axisy, ticky); gc.strokeline(rectchart.getminx() - pxticklength, pxy, rectchart.getminx(), pxy); final string textlabel = fnformaty.apply(ticky); textformeasuring.settext(textlabel); gc.stroketext(fnformaty.apply(ticky), 0.0, pxy + textformeasuring.getlayoutbounds().getheight()); } }","classification":"NONSATD","isFinished":true,"code_context_2":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>();","code_context_10":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return;","code_context_20":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>(","repo":"nathanawmk\/ICS-Security-Tools"}
{"id":11963,"comment_id":1,"comment":"\/\/make sure we have data before continuing.","code":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() ); } if(rangey != null) { axisy = new range<>( rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); \/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel); final bounds boundstext = textformeasuring.getlayoutbounds(); double offsety = 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight(); double offsetx = -0.87 * boundstext.getwidth(); gc.save(); \/\/ translate then rotate to rotate text around local origin rather than rotating around the canvas origin. \/\/ rotating and drawing at an offset results in a rotation around the origin. gc.translate(pxx + offsetx, rectchart.getmaxy() + offsety); gc.rotate(-30.0); gc.stroketext(textlabel, 0.0, 0.0); gc.restore(); } for(ty ticky : ticksy) { final double pxy = chartyfromdatay(axisy, ticky); gc.strokeline(rectchart.getminx() - pxticklength, pxy, rectchart.getminx(), pxy); final string textlabel = fnformaty.apply(ticky); textformeasuring.settext(textlabel); gc.stroketext(fnformaty.apply(ticky), 0.0, pxy + textformeasuring.getlayoutbounds().getheight()); } }","classification":"NONSATD","isFinished":true,"code_context_2":"data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return;","code_context_10":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit.","code_context_20":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() );","repo":"nathanawmk\/ICS-Security-Tools"}
{"id":11963,"comment_id":2,"comment":"\/\/ calculate the range on each axis.","code":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() ); } if(rangey != null) { axisy = new range<>( rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); \/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel); final bounds boundstext = textformeasuring.getlayoutbounds(); double offsety = 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight(); double offsetx = -0.87 * boundstext.getwidth(); gc.save(); \/\/ translate then rotate to rotate text around local origin rather than rotating around the canvas origin. \/\/ rotating and drawing at an offset results in a rotation around the origin. gc.translate(pxx + offsetx, rectchart.getmaxy() + offsety); gc.rotate(-30.0); gc.stroketext(textlabel, 0.0, 0.0); gc.restore(); } for(ty ticky : ticksy) { final double pxy = chartyfromdatay(axisy, ticky); gc.strokeline(rectchart.getminx() - pxticklength, pxy, rectchart.getminx(), pxy); final string textlabel = fnformaty.apply(ticky); textformeasuring.settext(textlabel); gc.stroketext(fnformaty.apply(ticky), 0.0, pxy + textformeasuring.getlayoutbounds().getheight()); } }","classification":"NONSATD","isFinished":true,"code_context_2":"return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy;","code_context_10":"seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>(","code_context_20":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() ); } if(rangey != null) { axisy = new range<>( rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else {","repo":"nathanawmk\/ICS-Security-Tools"}
{"id":11963,"comment_id":3,"comment":"\/\/todo: since we just sorted by x, we can optimize this a bit.","code":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() ); } if(rangey != null) { axisy = new range<>( rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); \/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel); final bounds boundstext = textformeasuring.getlayoutbounds(); double offsety = 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight(); double offsetx = -0.87 * boundstext.getwidth(); gc.save(); \/\/ translate then rotate to rotate text around local origin rather than rotating around the canvas origin. \/\/ rotating and drawing at an offset results in a rotation around the origin. gc.translate(pxx + offsetx, rectchart.getmaxy() + offsety); gc.rotate(-30.0); gc.stroketext(textlabel, 0.0, 0.0); gc.restore(); } for(ty ticky : ticksy) { final double pxy = chartyfromdatay(axisy, ticky); gc.strokeline(rectchart.getminx() - pxticklength, pxy, rectchart.getminx(), pxy); final string textlabel = fnformaty.apply(ticky); textformeasuring.settext(textlabel); gc.stroketext(fnformaty.apply(ticky), 0.0, pxy + textformeasuring.getlayoutbounds().getheight()); } }","classification":"DESIGN","isFinished":true,"code_context_2":"range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>(","code_context_10":"\/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() );","code_context_20":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() ); } if(rangey != null) { axisy = new range<>( rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get()","repo":"nathanawmk\/ICS-Security-Tools"}
{"id":11963,"comment_id":4,"comment":"\/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx;","code":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() ); } if(rangey != null) { axisy = new range<>( rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); \/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel); final bounds boundstext = textformeasuring.getlayoutbounds(); double offsety = 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight(); double offsetx = -0.87 * boundstext.getwidth(); gc.save(); \/\/ translate then rotate to rotate text around local origin rather than rotating around the canvas origin. \/\/ rotating and drawing at an offset results in a rotation around the origin. gc.translate(pxx + offsetx, rectchart.getmaxy() + offsety); gc.rotate(-30.0); gc.stroketext(textlabel, 0.0, 0.0); gc.restore(); } for(ty ticky : ticksy) { final double pxy = chartyfromdatay(axisy, ticky); gc.strokeline(rectchart.getminx() - pxticklength, pxy, rectchart.getminx(), pxy); final string textlabel = fnformaty.apply(ticky); textformeasuring.settext(textlabel); gc.stroketext(fnformaty.apply(ticky), 0.0, pxy + textformeasuring.getlayoutbounds().getheight()); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); \/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1));","code_context_10":"rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); \/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); }","code_context_20":"rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() ); } if(rangey != null) { axisy = new range<>( rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); \/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line }","repo":"nathanawmk\/ICS-Security-Tools"}
{"id":11963,"comment_id":5,"comment":"\/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label.","code":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() ); } if(rangey != null) { axisy = new range<>( rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); \/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel); final bounds boundstext = textformeasuring.getlayoutbounds(); double offsety = 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight(); double offsetx = -0.87 * boundstext.getwidth(); gc.save(); \/\/ translate then rotate to rotate text around local origin rather than rotating around the canvas origin. \/\/ rotating and drawing at an offset results in a rotation around the origin. gc.translate(pxx + offsetx, rectchart.getmaxy() + offsety); gc.rotate(-30.0); gc.stroketext(textlabel, 0.0, 0.0); gc.restore(); } for(ty ticky : ticksy) { final double pxy = chartyfromdatay(axisy, ticky); gc.strokeline(rectchart.getminx() - pxticklength, pxy, rectchart.getminx(), pxy); final string textlabel = fnformaty.apply(ticky); textformeasuring.settext(textlabel); gc.stroketext(fnformaty.apply(ticky), 0.0, pxy + textformeasuring.getlayoutbounds().getheight()); } }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0;","code_context_10":"} else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); \/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline.","code_context_20":"axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() ); } if(rangey != null) { axisy = new range<>( rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); \/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return;","repo":"nathanawmk\/ICS-Security-Tools"}
{"id":11963,"comment_id":6,"comment":"\/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height}","code":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() ); } if(rangey != null) { axisy = new range<>( rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); \/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel); final bounds boundstext = textformeasuring.getlayoutbounds(); double offsety = 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight(); double offsetx = -0.87 * boundstext.getwidth(); gc.save(); \/\/ translate then rotate to rotate text around local origin rather than rotating around the canvas origin. \/\/ rotating and drawing at an offset results in a rotation around the origin. gc.translate(pxx + offsetx, rectchart.getmaxy() + offsety); gc.rotate(-30.0); gc.stroketext(textlabel, 0.0, 0.0); gc.restore(); } for(ty ticky : ticksy) { final double pxy = chartyfromdatay(axisy, ticky); gc.strokeline(rectchart.getminx() - pxticklength, pxy, rectchart.getminx(), pxy); final string textlabel = fnformaty.apply(ticky); textformeasuring.settext(textlabel); gc.stroketext(fnformaty.apply(ticky), 0.0, pxy + textformeasuring.getlayoutbounds().getheight()); } }","classification":"NONSATD","isFinished":true,"code_context_2":"double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds();","code_context_10":"\/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength);","code_context_20":"axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); \/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value);","repo":"nathanawmk\/ICS-Security-Tools"}
{"id":11963,"comment_id":7,"comment":"\/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line","code":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() ); } if(rangey != null) { axisy = new range<>( rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); \/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel); final bounds boundstext = textformeasuring.getlayoutbounds(); double offsety = 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight(); double offsetx = -0.87 * boundstext.getwidth(); gc.save(); \/\/ translate then rotate to rotate text around local origin rather than rotating around the canvas origin. \/\/ rotating and drawing at an offset results in a rotation around the origin. gc.translate(pxx + offsetx, rectchart.getmaxy() + offsety); gc.rotate(-30.0); gc.stroketext(textlabel, 0.0, 0.0); gc.restore(); } for(ty ticky : ticksy) { final double pxy = chartyfromdatay(axisy, ticky); gc.strokeline(rectchart.getminx() - pxticklength, pxy, rectchart.getminx(), pxy); final string textlabel = fnformaty.apply(ticky); textformeasuring.settext(textlabel); gc.stroketext(fnformaty.apply(ticky), 0.0, pxy + textformeasuring.getlayoutbounds().getheight()); } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight);","code_context_10":"pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null;","code_context_20":"\/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y));","repo":"nathanawmk\/ICS-Security-Tools"}
{"id":11963,"comment_id":8,"comment":"\/\/ render series data, build tooltip cache","code":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() ); } if(rangey != null) { axisy = new range<>( rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); \/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel); final bounds boundstext = textformeasuring.getlayoutbounds(); double offsety = 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight(); double offsetx = -0.87 * boundstext.getwidth(); gc.save(); \/\/ translate then rotate to rotate text around local origin rather than rotating around the canvas origin. \/\/ rotating and drawing at an offset results in a rotation around the origin. gc.translate(pxx + offsetx, rectchart.getmaxy() + offsety); gc.rotate(-30.0); gc.stroketext(textlabel, 0.0, 0.0); gc.restore(); } for(ty ticky : ticksy) { final double pxy = chartyfromdatay(axisy, ticky); gc.strokeline(rectchart.getminx() - pxticklength, pxy, rectchart.getminx(), pxy); final string textlabel = fnformaty.apply(ticky); textformeasuring.settext(textlabel); gc.stroketext(fnformaty.apply(ticky), 0.0, pxy + textformeasuring.getlayoutbounds().getheight()); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) {","code_context_10":"textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis.","code_context_20":"for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() );","repo":"nathanawmk\/ICS-Security-Tools"}
{"id":11963,"comment_id":9,"comment":"\/\/todo: make this customizable","code":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() ); } if(rangey != null) { axisy = new range<>( rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); \/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel); final bounds boundstext = textformeasuring.getlayoutbounds(); double offsety = 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight(); double offsetx = -0.87 * boundstext.getwidth(); gc.save(); \/\/ translate then rotate to rotate text around local origin rather than rotating around the canvas origin. \/\/ rotating and drawing at an offset results in a rotation around the origin. gc.translate(pxx + offsetx, rectchart.getmaxy() + offsety); gc.rotate(-30.0); gc.stroketext(textlabel, 0.0, 0.0); gc.restore(); } for(ty ticky : ticksy) { final double pxy = chartyfromdatay(axisy, ticky); gc.strokeline(rectchart.getminx() - pxticklength, pxy, rectchart.getminx(), pxy); final string textlabel = fnformaty.apply(ticky); textformeasuring.settext(textlabel); gc.stroketext(fnformaty.apply(ticky), 0.0, pxy + textformeasuring.getlayoutbounds().getheight()); } }","classification":"DESIGN","isFinished":true,"code_context_2":"point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) {","code_context_10":"final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value,","code_context_20":"double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2);","repo":"nathanawmk\/ICS-Security-Tools"}
{"id":11963,"comment_id":10,"comment":"\/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis.","code":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() ); } if(rangey != null) { axisy = new range<>( rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); \/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel); final bounds boundstext = textformeasuring.getlayoutbounds(); double offsety = 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight(); double offsetx = -0.87 * boundstext.getwidth(); gc.save(); \/\/ translate then rotate to rotate text around local origin rather than rotating around the canvas origin. \/\/ rotating and drawing at an offset results in a rotation around the origin. gc.translate(pxx + offsetx, rectchart.getmaxy() + offsety); gc.rotate(-30.0); gc.stroketext(textlabel, 0.0, 0.0); gc.restore(); } for(ty ticky : ticksy) { final double pxy = chartyfromdatay(axisy, ticky); gc.strokeline(rectchart.getminx() - pxticklength, pxy, rectchart.getminx(), pxy); final string textlabel = fnformaty.apply(ticky); textformeasuring.settext(textlabel); gc.stroketext(fnformaty.apply(ticky), 0.0, pxy + textformeasuring.getlayoutbounds().getheight()); } }","classification":"NONSATD","isFinished":true,"code_context_2":"tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x),","code_context_10":"\/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() );","code_context_20":"textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area","repo":"nathanawmk\/ICS-Security-Tools"}
{"id":11963,"comment_id":11,"comment":"\/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area","code":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() ); } if(rangey != null) { axisy = new range<>( rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); \/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel); final bounds boundstext = textformeasuring.getlayoutbounds(); double offsety = 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight(); double offsetx = -0.87 * boundstext.getwidth(); gc.save(); \/\/ translate then rotate to rotate text around local origin rather than rotating around the canvas origin. \/\/ rotating and drawing at an offset results in a rotation around the origin. gc.translate(pxx + offsetx, rectchart.getmaxy() + offsety); gc.rotate(-30.0); gc.stroketext(textlabel, 0.0, 0.0); gc.restore(); } for(ty ticky : ticksy) { final double pxy = chartyfromdatay(axisy, ticky); gc.strokeline(rectchart.getminx() - pxticklength, pxy, rectchart.getminx(), pxy); final string textlabel = fnformaty.apply(ticky); textformeasuring.settext(textlabel); gc.stroketext(fnformaty.apply(ticky), 0.0, pxy + textformeasuring.getlayoutbounds().getheight()); } }","classification":"NONSATD","isFinished":true,"code_context_2":"} } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight());","code_context_10":"entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display.","code_context_20":"ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel);","repo":"nathanawmk\/ICS-Security-Tools"}
{"id":11963,"comment_id":12,"comment":"\/\/draw the axes","code":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() ); } if(rangey != null) { axisy = new range<>( rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); \/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel); final bounds boundstext = textformeasuring.getlayoutbounds(); double offsety = 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight(); double offsetx = -0.87 * boundstext.getwidth(); gc.save(); \/\/ translate then rotate to rotate text around local origin rather than rotating around the canvas origin. \/\/ rotating and drawing at an offset results in a rotation around the origin. gc.translate(pxx + offsetx, rectchart.getmaxy() + offsety); gc.rotate(-30.0); gc.stroketext(textlabel, 0.0, 0.0); gc.restore(); } for(ty ticky : ticksy) { final double pxy = chartyfromdatay(axisy, ticky); gc.strokeline(rectchart.getminx() - pxticklength, pxy, rectchart.getminx(), pxy); final string textlabel = fnformaty.apply(ticky); textformeasuring.settext(textlabel); gc.stroketext(fnformaty.apply(ticky), 0.0, pxy + textformeasuring.getlayoutbounds().getheight()); } }","classification":"NONSATD","isFinished":true,"code_context_2":"gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5);","code_context_10":"gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx);","code_context_20":"chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel); final bounds boundstext = textformeasuring.getlayoutbounds(); double offsety = 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight(); double offsetx = -0.87 * boundstext.getwidth();","repo":"nathanawmk\/ICS-Security-Tools"}
{"id":11963,"comment_id":13,"comment":"\/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display.","code":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() ); } if(rangey != null) { axisy = new range<>( rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); \/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel); final bounds boundstext = textformeasuring.getlayoutbounds(); double offsety = 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight(); double offsetx = -0.87 * boundstext.getwidth(); gc.save(); \/\/ translate then rotate to rotate text around local origin rather than rotating around the canvas origin. \/\/ rotating and drawing at an offset results in a rotation around the origin. gc.translate(pxx + offsetx, rectchart.getmaxy() + offsety); gc.rotate(-30.0); gc.stroketext(textlabel, 0.0, 0.0); gc.restore(); } for(ty ticky : ticksy) { final double pxy = chartyfromdatay(axisy, ticky); gc.strokeline(rectchart.getminx() - pxticklength, pxy, rectchart.getminx(), pxy); final string textlabel = fnformaty.apply(ticky); textformeasuring.settext(textlabel); gc.stroketext(fnformaty.apply(ticky), 0.0, pxy + textformeasuring.getlayoutbounds().getheight()); } }","classification":"NONSATD","isFinished":true,"code_context_2":"font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) {","code_context_10":"\/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel);","code_context_20":"); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel); final bounds boundstext = textformeasuring.getlayoutbounds(); double offsety = 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight(); double offsetx = -0.87 * boundstext.getwidth(); gc.save(); \/\/ translate then rotate to rotate text around local origin rather than rotating around the canvas origin. \/\/ rotating and drawing at an offset results in a rotation around the origin. gc.translate(pxx + offsetx, rectchart.getmaxy() + offsety); gc.rotate(-30.0); gc.stroketext(textlabel, 0.0, 0.0); gc.restore();","repo":"nathanawmk\/ICS-Security-Tools"}
{"id":11963,"comment_id":14,"comment":"\/\/ translate then rotate to rotate text around local origin rather than rotating around the canvas origin. \/\/ rotating and drawing at an offset results in a rotation around the origin.","code":"protected void paint(graphicscontext gc) { \/\/ get a sorted copy of the series data. once we have this we can release locks. rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } \/\/make sure we have data before continuing. if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } \/\/ calculate the range on each axis. range<tx> axisx; range<ty> axisy; \/\/todo: since we just sorted by x, we can optimize this a bit. if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() ); } if(rangey != null) { axisy = new range<>( rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); \/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx; final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); \/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label. double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { \/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height} textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); \/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); \/\/ render series data, build tooltip cache renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); \/\/todo: make this customizable gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); \/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis. point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } \/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); \/\/draw the axes gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel); final bounds boundstext = textformeasuring.getlayoutbounds(); double offsety = 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight(); double offsetx = -0.87 * boundstext.getwidth(); gc.save(); \/\/ translate then rotate to rotate text around local origin rather than rotating around the canvas origin. \/\/ rotating and drawing at an offset results in a rotation around the origin. gc.translate(pxx + offsetx, rectchart.getmaxy() + offsety); gc.rotate(-30.0); gc.stroketext(textlabel, 0.0, 0.0); gc.restore(); } for(ty ticky : ticksy) { final double pxy = chartyfromdatay(axisy, ticky); gc.strokeline(rectchart.getminx() - pxticklength, pxy, rectchart.getminx(), pxy); final string textlabel = fnformaty.apply(ticky); textformeasuring.settext(textlabel); gc.stroketext(fnformaty.apply(ticky), 0.0, pxy + textformeasuring.getlayoutbounds().getheight()); } }","classification":"NONSATD","isFinished":true,"code_context_2":"double offsetx = -0.87 * boundstext.getwidth(); gc.save(); \/\/ translate then rotate to rotate text around local origin rather than rotating around the canvas origin. \/\/ rotating and drawing at an offset results in a rotation around the origin. gc.translate(pxx + offsetx, rectchart.getmaxy() + offsety); gc.rotate(-30.0);","code_context_10":"continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel); final bounds boundstext = textformeasuring.getlayoutbounds(); double offsety = 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight(); double offsetx = -0.87 * boundstext.getwidth(); gc.save(); \/\/ translate then rotate to rotate text around local origin rather than rotating around the canvas origin. \/\/ rotating and drawing at an offset results in a rotation around the origin. gc.translate(pxx + offsetx, rectchart.getmaxy() + offsety); gc.rotate(-30.0); gc.stroketext(textlabel, 0.0, 0.0); gc.restore(); } for(ty ticky : ticksy) { final double pxy = chartyfromdatay(axisy, ticky); gc.strokeline(rectchart.getminx() - pxticklength, pxy, rectchart.getminx(), pxy); final string textlabel = fnformaty.apply(ticky); textformeasuring.settext(textlabel);","code_context_20":"gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); \/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display. double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel); final bounds boundstext = textformeasuring.getlayoutbounds(); double offsety = 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight(); double offsetx = -0.87 * boundstext.getwidth(); gc.save(); \/\/ translate then rotate to rotate text around local origin rather than rotating around the canvas origin. \/\/ rotating and drawing at an offset results in a rotation around the origin. gc.translate(pxx + offsetx, rectchart.getmaxy() + offsety); gc.rotate(-30.0); gc.stroketext(textlabel, 0.0, 0.0); gc.restore(); } for(ty ticky : ticksy) { final double pxy = chartyfromdatay(axisy, ticky); gc.strokeline(rectchart.getminx() - pxticklength, pxy, rectchart.getminx(), pxy); final string textlabel = fnformaty.apply(ticky); textformeasuring.settext(textlabel); gc.stroketext(fnformaty.apply(ticky), 0.0, pxy + textformeasuring.getlayoutbounds().getheight()); } }","repo":"nathanawmk\/ICS-Security-Tools"}
{"id":12044,"comment_id":0,"comment":"\/\/ sadly setmaxheight() isn't working with textflow \/\/ so, we have to clip notification text manually","code":"private void createview() { fonticon closebtn = controls.fonticon(material2al.close, \"close-icon\"); closebtn.setcursor(cursor.hand); closebtn.setonmouseclicked(e -> close()); gridpane.setvalignment(closebtn, vpos.top); gridpane.sethalignment(closebtn, hpos.right); textflow textflow = containers.create(textflow::new, \"text\"); \/\/ sadly setmaxheight() isn't working with textflow \/\/ so, we have to clip notification text manually text text = new text(notification.getclippedtext(toast.max_message_len)); textflow.getchildren().addall(text); hyperlink expandbtn = new hyperlink(t(action_more)); expandbtn.setonaction(e -> expand()); if (expandhandler == null) { expandbtn.setmanaged(false); } add(textflow, 0, 0); add(closebtn, 1, 0); add(expandbtn, 0, 2, remaining, 1); getcolumnconstraints().addall(hgrow_always, hgrow_never); getrowconstraints().addall(vgrow_always, vgrow_never); vbox.setvgrow(this, priority.never); getstyleclass().addall(\"toast\", notification.gettype().name().tolowercase()); }","classification":"NONSATD","isFinished":true,"code_context_2":"gridpane.sethalignment(closebtn, hpos.right); textflow textflow = containers.create(textflow::new, \"text\"); \/\/ sadly setmaxheight() isn't working with textflow \/\/ so, we have to clip notification text manually text text = new text(notification.getclippedtext(toast.max_message_len)); textflow.getchildren().addall(text);","code_context_10":"private void createview() { fonticon closebtn = controls.fonticon(material2al.close, \"close-icon\"); closebtn.setcursor(cursor.hand); closebtn.setonmouseclicked(e -> close()); gridpane.setvalignment(closebtn, vpos.top); gridpane.sethalignment(closebtn, hpos.right); textflow textflow = containers.create(textflow::new, \"text\"); \/\/ sadly setmaxheight() isn't working with textflow \/\/ so, we have to clip notification text manually text text = new text(notification.getclippedtext(toast.max_message_len)); textflow.getchildren().addall(text); hyperlink expandbtn = new hyperlink(t(action_more)); expandbtn.setonaction(e -> expand()); if (expandhandler == null) { expandbtn.setmanaged(false); } add(textflow, 0, 0); add(closebtn, 1, 0); add(expandbtn, 0, 2, remaining, 1); getcolumnconstraints().addall(hgrow_always, hgrow_never); getrowconstraints().addall(vgrow_always, vgrow_never);","code_context_20":"private void createview() { fonticon closebtn = controls.fonticon(material2al.close, \"close-icon\"); closebtn.setcursor(cursor.hand); closebtn.setonmouseclicked(e -> close()); gridpane.setvalignment(closebtn, vpos.top); gridpane.sethalignment(closebtn, hpos.right); textflow textflow = containers.create(textflow::new, \"text\"); \/\/ sadly setmaxheight() isn't working with textflow \/\/ so, we have to clip notification text manually text text = new text(notification.getclippedtext(toast.max_message_len)); textflow.getchildren().addall(text); hyperlink expandbtn = new hyperlink(t(action_more)); expandbtn.setonaction(e -> expand()); if (expandhandler == null) { expandbtn.setmanaged(false); } add(textflow, 0, 0); add(closebtn, 1, 0); add(expandbtn, 0, 2, remaining, 1); getcolumnconstraints().addall(hgrow_always, hgrow_never); getrowconstraints().addall(vgrow_always, vgrow_never); vbox.setvgrow(this, priority.never); getstyleclass().addall(\"toast\", notification.gettype().name().tolowercase()); }","repo":"mkpaz\/telek"}
{"id":12086,"comment_id":0,"comment":"\/\/ todo code application logic here \/\/ cria o objeto scanner","code":"public static void main(string[] args) { \/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"public static void main(string[] args) { \/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados","code_context_10":"public static void main(string[] args) { \/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado );","code_context_20":"public static void main(string[] args) { \/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","repo":"pedro-filho-81\/LivrosDeJava"}
{"id":12086,"comment_id":1,"comment":"\/\/ entrada de dados","code":"public static void main(string[] args) { \/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero","code_context_10":"public static void main(string[] args) { \/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","code_context_20":"public static void main(string[] args) { \/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","repo":"pedro-filho-81\/LivrosDeJava"}
{"id":12086,"comment_id":2,"comment":"\/\/ primeiro n\u00famero","code":"public static void main(string[] args) { \/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero","code_context_10":"public static void main(string[] args) { \/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","code_context_20":"public static void main(string[] args) { \/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","repo":"pedro-filho-81\/LivrosDeJava"}
{"id":12086,"comment_id":3,"comment":"\/\/ segundo n\u00famero","code":"public static void main(string[] args) { \/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","classification":"NONSATD","isFinished":true,"code_context_2":"system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor","code_context_10":"public static void main(string[] args) { \/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","code_context_20":"public static void main(string[] args) { \/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","repo":"pedro-filho-81\/LivrosDeJava"}
{"id":12086,"comment_id":4,"comment":"\/\/ terceiro n\u00famero","code":"public static void main(string[] args) { \/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","classification":"NONSATD","isFinished":true,"code_context_2":"double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 );","code_context_10":"public static void main(string[] args) { \/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","code_context_20":"public static void main(string[] args) { \/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","repo":"pedro-filho-81\/LivrosDeJava"}
{"id":12086,"comment_id":5,"comment":"\/\/ detremina o maior valor","code":"public static void main(string[] args) { \/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","classification":"NONSATD","isFinished":true,"code_context_2":"double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado","code_context_10":"public static void main(string[] args) { \/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","code_context_20":"public static void main(string[] args) { \/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","repo":"pedro-filho-81\/LivrosDeJava"}
{"id":12086,"comment_id":6,"comment":"\/\/ imprime resultado","code":"public static void main(string[] args) { \/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","code_context_10":"\/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","code_context_20":"public static void main(string[] args) { \/\/ todo code application logic here \/\/ cria o objeto scanner scanner input = new scanner(system.in); \/\/ entrada de dados system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); \/\/ primeiro n\u00famero double numero2 = input.nextdouble(); \/\/ segundo n\u00famero double numero3 = input.nextdouble(); \/\/ terceiro n\u00famero \/\/ detremina o maior valor double resultado = maiorvalor( numero1, numero2, numero3 ); \/\/ imprime resultado system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","repo":"pedro-filho-81\/LivrosDeJava"}
{"id":20687,"comment_id":0,"comment":"\/\/ todo: this test fails if run during standard time instead of dst. the time is off by one hour.","code":"\/\/ todo: this test fails if run during standard time instead of dst. the time is off by one hour. @test public void fetchexistingaggregatebyid_populatesvalues() { try(photontransaction transaction = photon.begintransaction()) { photontesttable photontesttable = transaction.query(photontesttable.class).fetchbyid(1); \/\/ the database does not store a time zone, so we assume the date is in the system's time zone. but to make these tests \/\/ compare epoch times but still work with any system time zone, we have to offset the epoch to the system's time zone. int currentutcoffset = timezone.getdefault().getoffset(new date().gettime()); assertnotnull(photontesttable); assertequals(1, photontesttable.getid()); assertequals(uuid.fromstring(\"8ed1e1bd-253e-4469-b4cb-71e1217825b7\"), photontesttable.getuuidcolumn()); assertequals(zoneddatetime.ofinstant(instant.ofepochmilli(1489915698000l - currentutcoffset), zoneid.systemdefault()), photontesttable.getdatecolumn()); assertequals(\"test string\", photontesttable.getvarcharcolumn()); } }","classification":"DEFECT","isFinished":true,"code_context_2":"@test public void fetchexistingaggregatebyid_populatesvalues() { try(photontransaction transaction = photon.begintransaction()) { photontesttable photontesttable = transaction.query(photontesttable.class).fetchbyid(1); \/\/ the database does not store a time zone, so we assume the date is in the system's time zone. but to make these tests \/\/ compare epoch times but still work with any system time zone, we have to offset the epoch to the system's time zone. int currentutcoffset = timezone.getdefault().getoffset(new date().gettime()); assertnotnull(photontesttable); assertequals(1, photontesttable.getid()); assertequals(uuid.fromstring(\"8ed1e1bd-253e-4469-b4cb-71e1217825b7\"), photontesttable.getuuidcolumn()); assertequals(zoneddatetime.ofinstant(instant.ofepochmilli(1489915698000l - currentutcoffset), zoneid.systemdefault()), photontesttable.getdatecolumn()); assertequals(\"test string\", photontesttable.getvarcharcolumn()); } }","code_context_10":"@test public void fetchexistingaggregatebyid_populatesvalues() { try(photontransaction transaction = photon.begintransaction()) { photontesttable photontesttable = transaction.query(photontesttable.class).fetchbyid(1); \/\/ the database does not store a time zone, so we assume the date is in the system's time zone. but to make these tests \/\/ compare epoch times but still work with any system time zone, we have to offset the epoch to the system's time zone. int currentutcoffset = timezone.getdefault().getoffset(new date().gettime()); assertnotnull(photontesttable); assertequals(1, photontesttable.getid()); assertequals(uuid.fromstring(\"8ed1e1bd-253e-4469-b4cb-71e1217825b7\"), photontesttable.getuuidcolumn()); assertequals(zoneddatetime.ofinstant(instant.ofepochmilli(1489915698000l - currentutcoffset), zoneid.systemdefault()), photontesttable.getdatecolumn()); assertequals(\"test string\", photontesttable.getvarcharcolumn()); } }","code_context_20":"@test public void fetchexistingaggregatebyid_populatesvalues() { try(photontransaction transaction = photon.begintransaction()) { photontesttable photontesttable = transaction.query(photontesttable.class).fetchbyid(1); \/\/ the database does not store a time zone, so we assume the date is in the system's time zone. but to make these tests \/\/ compare epoch times but still work with any system time zone, we have to offset the epoch to the system's time zone. int currentutcoffset = timezone.getdefault().getoffset(new date().gettime()); assertnotnull(photontesttable); assertequals(1, photontesttable.getid()); assertequals(uuid.fromstring(\"8ed1e1bd-253e-4469-b4cb-71e1217825b7\"), photontesttable.getuuidcolumn()); assertequals(zoneddatetime.ofinstant(instant.ofepochmilli(1489915698000l - currentutcoffset), zoneid.systemdefault()), photontesttable.getdatecolumn()); assertequals(\"test string\", photontesttable.getvarcharcolumn()); } }","repo":"molcikas\/photon"}
{"id":20687,"comment_id":1,"comment":"\/\/ the database does not store a time zone, so we assume the date is in the system's time zone. but to make these tests \/\/ compare epoch times but still work with any system time zone, we have to offset the epoch to the system's time zone.","code":"@test public void fetchexistingaggregatebyid_populatesvalues() { try(photontransaction transaction = photon.begintransaction()) { photontesttable photontesttable = transaction.query(photontesttable.class).fetchbyid(1); \/\/ the database does not store a time zone, so we assume the date is in the system's time zone. but to make these tests \/\/ compare epoch times but still work with any system time zone, we have to offset the epoch to the system's time zone. int currentutcoffset = timezone.getdefault().getoffset(new date().gettime()); assertnotnull(photontesttable); assertequals(1, photontesttable.getid()); assertequals(uuid.fromstring(\"8ed1e1bd-253e-4469-b4cb-71e1217825b7\"), photontesttable.getuuidcolumn()); assertequals(zoneddatetime.ofinstant(instant.ofepochmilli(1489915698000l - currentutcoffset), zoneid.systemdefault()), photontesttable.getdatecolumn()); assertequals(\"test string\", photontesttable.getvarcharcolumn()); } }","classification":"NONSATD","isFinished":true,"code_context_2":"{ photontesttable photontesttable = transaction.query(photontesttable.class).fetchbyid(1); \/\/ the database does not store a time zone, so we assume the date is in the system's time zone. but to make these tests \/\/ compare epoch times but still work with any system time zone, we have to offset the epoch to the system's time zone. int currentutcoffset = timezone.getdefault().getoffset(new date().gettime()); assertnotnull(photontesttable);","code_context_10":"@test public void fetchexistingaggregatebyid_populatesvalues() { try(photontransaction transaction = photon.begintransaction()) { photontesttable photontesttable = transaction.query(photontesttable.class).fetchbyid(1); \/\/ the database does not store a time zone, so we assume the date is in the system's time zone. but to make these tests \/\/ compare epoch times but still work with any system time zone, we have to offset the epoch to the system's time zone. int currentutcoffset = timezone.getdefault().getoffset(new date().gettime()); assertnotnull(photontesttable); assertequals(1, photontesttable.getid()); assertequals(uuid.fromstring(\"8ed1e1bd-253e-4469-b4cb-71e1217825b7\"), photontesttable.getuuidcolumn()); assertequals(zoneddatetime.ofinstant(instant.ofepochmilli(1489915698000l - currentutcoffset), zoneid.systemdefault()), photontesttable.getdatecolumn()); assertequals(\"test string\", photontesttable.getvarcharcolumn()); } }","code_context_20":"@test public void fetchexistingaggregatebyid_populatesvalues() { try(photontransaction transaction = photon.begintransaction()) { photontesttable photontesttable = transaction.query(photontesttable.class).fetchbyid(1); \/\/ the database does not store a time zone, so we assume the date is in the system's time zone. but to make these tests \/\/ compare epoch times but still work with any system time zone, we have to offset the epoch to the system's time zone. int currentutcoffset = timezone.getdefault().getoffset(new date().gettime()); assertnotnull(photontesttable); assertequals(1, photontesttable.getid()); assertequals(uuid.fromstring(\"8ed1e1bd-253e-4469-b4cb-71e1217825b7\"), photontesttable.getuuidcolumn()); assertequals(zoneddatetime.ofinstant(instant.ofepochmilli(1489915698000l - currentutcoffset), zoneid.systemdefault()), photontesttable.getdatecolumn()); assertequals(\"test string\", photontesttable.getvarcharcolumn()); } }","repo":"molcikas\/photon"}
{"id":12596,"comment_id":0,"comment":"\/** this does not get the correct result and rerquires a kludge which could fail anytime * * @param image * @param threshold * @return *\/","code":"\/** this does not get the correct result and rerquires a kludge which could fail anytime * * @param image * @param threshold * @return *\/ public static bufferedimage boofcvbinarization(bufferedimage image, int threshold) { grayu8 input8 = convertbufferedimage.convertfrom(image,(grayu8)null); grayf32 input32 = convertbufferedimage.convertfromsingle(image, null, grayf32.class); grayu8 binary8 = new grayu8(input8.getwidth(), input8.getheight()); \/\/ grayf32 binary32 = new grayf32(input8.getwidth(), input8.getheight()); boolean down = false; thresholdimageops.threshold(input8, binary8, threshold, down); \/\/ gthresholdimageops.threshold(input32, binary8, threshold, down); bufferedimage outputimage = null; \/\/ outputimage = convertbufferedimage.convertto(binary8, null); boolean invert = false; outputimage = visualizebinarydata.renderbinary(binary8, invert, null); \/\/ \/\/ outputimage = imageutil.removealpha(outputimage); \/\/ outputimage = imageutil.convertrgb(outputimage, \/\/ new int[] {0x0d0d0d}, new int[] {0xffffff}); return outputimage; }","classification":"DEFECT","isFinished":true,"code_context_2":"public static bufferedimage boofcvbinarization(bufferedimage image, int threshold) { grayu8 input8 = convertbufferedimage.convertfrom(image,(grayu8)null); grayf32 input32 = convertbufferedimage.convertfromsingle(image, null, grayf32.class); grayu8 binary8 = new grayu8(input8.getwidth(), input8.getheight()); \/\/ grayf32 binary32 = new grayf32(input8.getwidth(), input8.getheight()); boolean down = false; thresholdimageops.threshold(input8, binary8, threshold, down); \/\/ gthresholdimageops.threshold(input32, binary8, threshold, down); bufferedimage outputimage = null; \/\/ outputimage = convertbufferedimage.convertto(binary8, null); boolean invert = false; outputimage = visualizebinarydata.renderbinary(binary8, invert, null); \/\/ \/\/ outputimage = imageutil.removealpha(outputimage); \/\/ outputimage = imageutil.convertrgb(outputimage, \/\/ new int[] {0x0d0d0d}, new int[] {0xffffff}); return outputimage; }","code_context_10":"public static bufferedimage boofcvbinarization(bufferedimage image, int threshold) { grayu8 input8 = convertbufferedimage.convertfrom(image,(grayu8)null); grayf32 input32 = convertbufferedimage.convertfromsingle(image, null, grayf32.class); grayu8 binary8 = new grayu8(input8.getwidth(), input8.getheight()); \/\/ grayf32 binary32 = new grayf32(input8.getwidth(), input8.getheight()); boolean down = false; thresholdimageops.threshold(input8, binary8, threshold, down); \/\/ gthresholdimageops.threshold(input32, binary8, threshold, down); bufferedimage outputimage = null; \/\/ outputimage = convertbufferedimage.convertto(binary8, null); boolean invert = false; outputimage = visualizebinarydata.renderbinary(binary8, invert, null); \/\/ \/\/ outputimage = imageutil.removealpha(outputimage); \/\/ outputimage = imageutil.convertrgb(outputimage, \/\/ new int[] {0x0d0d0d}, new int[] {0xffffff}); return outputimage; }","code_context_20":"public static bufferedimage boofcvbinarization(bufferedimage image, int threshold) { grayu8 input8 = convertbufferedimage.convertfrom(image,(grayu8)null); grayf32 input32 = convertbufferedimage.convertfromsingle(image, null, grayf32.class); grayu8 binary8 = new grayu8(input8.getwidth(), input8.getheight()); \/\/ grayf32 binary32 = new grayf32(input8.getwidth(), input8.getheight()); boolean down = false; thresholdimageops.threshold(input8, binary8, threshold, down); \/\/ gthresholdimageops.threshold(input32, binary8, threshold, down); bufferedimage outputimage = null; \/\/ outputimage = convertbufferedimage.convertto(binary8, null); boolean invert = false; outputimage = visualizebinarydata.renderbinary(binary8, invert, null); \/\/ \/\/ outputimage = imageutil.removealpha(outputimage); \/\/ outputimage = imageutil.convertrgb(outputimage, \/\/ new int[] {0x0d0d0d}, new int[] {0xffffff}); return outputimage; }","repo":"nuest\/ami3"}
{"id":12596,"comment_id":1,"comment":"\/\/ grayf32 binary32 = new grayf32(input8.getwidth(), input8.getheight());","code":"public static bufferedimage boofcvbinarization(bufferedimage image, int threshold) { grayu8 input8 = convertbufferedimage.convertfrom(image,(grayu8)null); grayf32 input32 = convertbufferedimage.convertfromsingle(image, null, grayf32.class); grayu8 binary8 = new grayu8(input8.getwidth(), input8.getheight()); \/\/ grayf32 binary32 = new grayf32(input8.getwidth(), input8.getheight()); boolean down = false; thresholdimageops.threshold(input8, binary8, threshold, down); \/\/ gthresholdimageops.threshold(input32, binary8, threshold, down); bufferedimage outputimage = null; \/\/ outputimage = convertbufferedimage.convertto(binary8, null); boolean invert = false; outputimage = visualizebinarydata.renderbinary(binary8, invert, null); \/\/ \/\/ outputimage = imageutil.removealpha(outputimage); \/\/ outputimage = imageutil.convertrgb(outputimage, \/\/ new int[] {0x0d0d0d}, new int[] {0xffffff}); return outputimage; }","classification":"NONSATD","isFinished":true,"code_context_2":"grayf32 input32 = convertbufferedimage.convertfromsingle(image, null, grayf32.class); grayu8 binary8 = new grayu8(input8.getwidth(), input8.getheight()); \/\/ grayf32 binary32 = new grayf32(input8.getwidth(), input8.getheight()); boolean down = false; thresholdimageops.threshold(input8, binary8, threshold, down);","code_context_10":"public static bufferedimage boofcvbinarization(bufferedimage image, int threshold) { grayu8 input8 = convertbufferedimage.convertfrom(image,(grayu8)null); grayf32 input32 = convertbufferedimage.convertfromsingle(image, null, grayf32.class); grayu8 binary8 = new grayu8(input8.getwidth(), input8.getheight()); \/\/ grayf32 binary32 = new grayf32(input8.getwidth(), input8.getheight()); boolean down = false; thresholdimageops.threshold(input8, binary8, threshold, down); \/\/ gthresholdimageops.threshold(input32, binary8, threshold, down); bufferedimage outputimage = null; \/\/ outputimage = convertbufferedimage.convertto(binary8, null); boolean invert = false; outputimage = visualizebinarydata.renderbinary(binary8, invert, null); \/\/ \/\/ outputimage = imageutil.removealpha(outputimage); \/\/ outputimage = imageutil.convertrgb(outputimage,","code_context_20":"public static bufferedimage boofcvbinarization(bufferedimage image, int threshold) { grayu8 input8 = convertbufferedimage.convertfrom(image,(grayu8)null); grayf32 input32 = convertbufferedimage.convertfromsingle(image, null, grayf32.class); grayu8 binary8 = new grayu8(input8.getwidth(), input8.getheight()); \/\/ grayf32 binary32 = new grayf32(input8.getwidth(), input8.getheight()); boolean down = false; thresholdimageops.threshold(input8, binary8, threshold, down); \/\/ gthresholdimageops.threshold(input32, binary8, threshold, down); bufferedimage outputimage = null; \/\/ outputimage = convertbufferedimage.convertto(binary8, null); boolean invert = false; outputimage = visualizebinarydata.renderbinary(binary8, invert, null); \/\/ \/\/ outputimage = imageutil.removealpha(outputimage); \/\/ outputimage = imageutil.convertrgb(outputimage, \/\/ new int[] {0x0d0d0d}, new int[] {0xffffff}); return outputimage; }","repo":"nuest\/ami3"}
{"id":12596,"comment_id":2,"comment":"\/\/ gthresholdimageops.threshold(input32, binary8, threshold, down);","code":"public static bufferedimage boofcvbinarization(bufferedimage image, int threshold) { grayu8 input8 = convertbufferedimage.convertfrom(image,(grayu8)null); grayf32 input32 = convertbufferedimage.convertfromsingle(image, null, grayf32.class); grayu8 binary8 = new grayu8(input8.getwidth(), input8.getheight()); \/\/ grayf32 binary32 = new grayf32(input8.getwidth(), input8.getheight()); boolean down = false; thresholdimageops.threshold(input8, binary8, threshold, down); \/\/ gthresholdimageops.threshold(input32, binary8, threshold, down); bufferedimage outputimage = null; \/\/ outputimage = convertbufferedimage.convertto(binary8, null); boolean invert = false; outputimage = visualizebinarydata.renderbinary(binary8, invert, null); \/\/ \/\/ outputimage = imageutil.removealpha(outputimage); \/\/ outputimage = imageutil.convertrgb(outputimage, \/\/ new int[] {0x0d0d0d}, new int[] {0xffffff}); return outputimage; }","classification":"NONSATD","isFinished":true,"code_context_2":"boolean down = false; thresholdimageops.threshold(input8, binary8, threshold, down); \/\/ gthresholdimageops.threshold(input32, binary8, threshold, down); bufferedimage outputimage = null; \/\/ outputimage = convertbufferedimage.convertto(binary8, null);","code_context_10":"public static bufferedimage boofcvbinarization(bufferedimage image, int threshold) { grayu8 input8 = convertbufferedimage.convertfrom(image,(grayu8)null); grayf32 input32 = convertbufferedimage.convertfromsingle(image, null, grayf32.class); grayu8 binary8 = new grayu8(input8.getwidth(), input8.getheight()); \/\/ grayf32 binary32 = new grayf32(input8.getwidth(), input8.getheight()); boolean down = false; thresholdimageops.threshold(input8, binary8, threshold, down); \/\/ gthresholdimageops.threshold(input32, binary8, threshold, down); bufferedimage outputimage = null; \/\/ outputimage = convertbufferedimage.convertto(binary8, null); boolean invert = false; outputimage = visualizebinarydata.renderbinary(binary8, invert, null); \/\/ \/\/ outputimage = imageutil.removealpha(outputimage); \/\/ outputimage = imageutil.convertrgb(outputimage, \/\/ new int[] {0x0d0d0d}, new int[] {0xffffff}); return outputimage; }","code_context_20":"public static bufferedimage boofcvbinarization(bufferedimage image, int threshold) { grayu8 input8 = convertbufferedimage.convertfrom(image,(grayu8)null); grayf32 input32 = convertbufferedimage.convertfromsingle(image, null, grayf32.class); grayu8 binary8 = new grayu8(input8.getwidth(), input8.getheight()); \/\/ grayf32 binary32 = new grayf32(input8.getwidth(), input8.getheight()); boolean down = false; thresholdimageops.threshold(input8, binary8, threshold, down); \/\/ gthresholdimageops.threshold(input32, binary8, threshold, down); bufferedimage outputimage = null; \/\/ outputimage = convertbufferedimage.convertto(binary8, null); boolean invert = false; outputimage = visualizebinarydata.renderbinary(binary8, invert, null); \/\/ \/\/ outputimage = imageutil.removealpha(outputimage); \/\/ outputimage = imageutil.convertrgb(outputimage, \/\/ new int[] {0x0d0d0d}, new int[] {0xffffff}); return outputimage; }","repo":"nuest\/ami3"}
{"id":12596,"comment_id":3,"comment":"\/\/ outputimage = convertbufferedimage.convertto(binary8, null);","code":"public static bufferedimage boofcvbinarization(bufferedimage image, int threshold) { grayu8 input8 = convertbufferedimage.convertfrom(image,(grayu8)null); grayf32 input32 = convertbufferedimage.convertfromsingle(image, null, grayf32.class); grayu8 binary8 = new grayu8(input8.getwidth(), input8.getheight()); \/\/ grayf32 binary32 = new grayf32(input8.getwidth(), input8.getheight()); boolean down = false; thresholdimageops.threshold(input8, binary8, threshold, down); \/\/ gthresholdimageops.threshold(input32, binary8, threshold, down); bufferedimage outputimage = null; \/\/ outputimage = convertbufferedimage.convertto(binary8, null); boolean invert = false; outputimage = visualizebinarydata.renderbinary(binary8, invert, null); \/\/ \/\/ outputimage = imageutil.removealpha(outputimage); \/\/ outputimage = imageutil.convertrgb(outputimage, \/\/ new int[] {0x0d0d0d}, new int[] {0xffffff}); return outputimage; }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ gthresholdimageops.threshold(input32, binary8, threshold, down); bufferedimage outputimage = null; \/\/ outputimage = convertbufferedimage.convertto(binary8, null); boolean invert = false; outputimage = visualizebinarydata.renderbinary(binary8, invert, null);","code_context_10":"public static bufferedimage boofcvbinarization(bufferedimage image, int threshold) { grayu8 input8 = convertbufferedimage.convertfrom(image,(grayu8)null); grayf32 input32 = convertbufferedimage.convertfromsingle(image, null, grayf32.class); grayu8 binary8 = new grayu8(input8.getwidth(), input8.getheight()); \/\/ grayf32 binary32 = new grayf32(input8.getwidth(), input8.getheight()); boolean down = false; thresholdimageops.threshold(input8, binary8, threshold, down); \/\/ gthresholdimageops.threshold(input32, binary8, threshold, down); bufferedimage outputimage = null; \/\/ outputimage = convertbufferedimage.convertto(binary8, null); boolean invert = false; outputimage = visualizebinarydata.renderbinary(binary8, invert, null); \/\/ \/\/ outputimage = imageutil.removealpha(outputimage); \/\/ outputimage = imageutil.convertrgb(outputimage, \/\/ new int[] {0x0d0d0d}, new int[] {0xffffff}); return outputimage; }","code_context_20":"public static bufferedimage boofcvbinarization(bufferedimage image, int threshold) { grayu8 input8 = convertbufferedimage.convertfrom(image,(grayu8)null); grayf32 input32 = convertbufferedimage.convertfromsingle(image, null, grayf32.class); grayu8 binary8 = new grayu8(input8.getwidth(), input8.getheight()); \/\/ grayf32 binary32 = new grayf32(input8.getwidth(), input8.getheight()); boolean down = false; thresholdimageops.threshold(input8, binary8, threshold, down); \/\/ gthresholdimageops.threshold(input32, binary8, threshold, down); bufferedimage outputimage = null; \/\/ outputimage = convertbufferedimage.convertto(binary8, null); boolean invert = false; outputimage = visualizebinarydata.renderbinary(binary8, invert, null); \/\/ \/\/ outputimage = imageutil.removealpha(outputimage); \/\/ outputimage = imageutil.convertrgb(outputimage, \/\/ new int[] {0x0d0d0d}, new int[] {0xffffff}); return outputimage; }","repo":"nuest\/ami3"}
{"id":12596,"comment_id":4,"comment":"\/\/ \/\/ outputimage = imageutil.removealpha(outputimage); \/\/ outputimage = imageutil.convertrgb(outputimage, \/\/ new int[] {0x0d0d0d}, new int[] {0xffffff});","code":"public static bufferedimage boofcvbinarization(bufferedimage image, int threshold) { grayu8 input8 = convertbufferedimage.convertfrom(image,(grayu8)null); grayf32 input32 = convertbufferedimage.convertfromsingle(image, null, grayf32.class); grayu8 binary8 = new grayu8(input8.getwidth(), input8.getheight()); \/\/ grayf32 binary32 = new grayf32(input8.getwidth(), input8.getheight()); boolean down = false; thresholdimageops.threshold(input8, binary8, threshold, down); \/\/ gthresholdimageops.threshold(input32, binary8, threshold, down); bufferedimage outputimage = null; \/\/ outputimage = convertbufferedimage.convertto(binary8, null); boolean invert = false; outputimage = visualizebinarydata.renderbinary(binary8, invert, null); \/\/ \/\/ outputimage = imageutil.removealpha(outputimage); \/\/ outputimage = imageutil.convertrgb(outputimage, \/\/ new int[] {0x0d0d0d}, new int[] {0xffffff}); return outputimage; }","classification":"NONSATD","isFinished":true,"code_context_2":"grayf32 input32 = convertbufferedimage.convertfromsingle(image, null, grayf32.class); grayu8 binary8 = new grayu8(input8.getwidth(), input8.getheight()); \/\/ grayf32 binary32 = new grayf32(input8.getwidth(), input8.getheight()); boolean down = false; thresholdimageops.threshold(input8, binary8, threshold, down); \/\/ gthresholdimageops.threshold(input32, binary8, threshold, down); bufferedimage outputimage = null; \/\/ outputimage = convertbufferedimage.convertto(binary8, null);","code_context_10":"public static bufferedimage boofcvbinarization(bufferedimage image, int threshold) { grayu8 input8 = convertbufferedimage.convertfrom(image,(grayu8)null); grayf32 input32 = convertbufferedimage.convertfromsingle(image, null, grayf32.class); grayu8 binary8 = new grayu8(input8.getwidth(), input8.getheight()); \/\/ grayf32 binary32 = new grayf32(input8.getwidth(), input8.getheight()); boolean down = false; thresholdimageops.threshold(input8, binary8, threshold, down); \/\/ gthresholdimageops.threshold(input32, binary8, threshold, down); bufferedimage outputimage = null; \/\/ outputimage = convertbufferedimage.convertto(binary8, null); boolean invert = false; outputimage = visualizebinarydata.renderbinary(binary8, invert, null); \/\/ \/\/ outputimage = imageutil.removealpha(outputimage); \/\/ outputimage = imageutil.convertrgb(outputimage, \/\/ new int[] {0x0d0d0d}, new int[] {0xffffff}); return outputimage; }","code_context_20":"public static bufferedimage boofcvbinarization(bufferedimage image, int threshold) { grayu8 input8 = convertbufferedimage.convertfrom(image,(grayu8)null); grayf32 input32 = convertbufferedimage.convertfromsingle(image, null, grayf32.class); grayu8 binary8 = new grayu8(input8.getwidth(), input8.getheight()); \/\/ grayf32 binary32 = new grayf32(input8.getwidth(), input8.getheight()); boolean down = false; thresholdimageops.threshold(input8, binary8, threshold, down); \/\/ gthresholdimageops.threshold(input32, binary8, threshold, down); bufferedimage outputimage = null; \/\/ outputimage = convertbufferedimage.convertto(binary8, null); boolean invert = false; outputimage = visualizebinarydata.renderbinary(binary8, invert, null); \/\/ \/\/ outputimage = imageutil.removealpha(outputimage); \/\/ outputimage = imageutil.convertrgb(outputimage, \/\/ new int[] {0x0d0d0d}, new int[] {0xffffff}); return outputimage; }","repo":"nuest\/ami3"}
{"id":20812,"comment_id":0,"comment":"\/\/todo: note that not all reads actually cover a given var","code":"static int examinevar(final int var, final arraylist<read> list, final intlist collection, final int[] rvector, linkedhashmap<integer, arraylist<read>> map){ collection.clear(); for(read r : list){ final readkey rk=(readkey) r.obj; final intlist vars=rk.vars; for(int i=0; i<vars.size; i++){ final int v2=vars.get(i); if(v2!=var){ collection.add(v2); } } } collection.sort(); final int varcount=list.size(); int lastvar2=-1, bestvar2=-1; int sharedcount=0, bestsharedcount=0, bestdifferent=999; for(int i=0; i<collection.size; i++){\/\/todo: note that not all reads actually cover a given var int currentvar2=collection.get(i); if(currentvar2==lastvar2){sharedcount++;} else{ if(sharedcount>bestsharedcount){ final int different1=(sharedcount==varcount ? 0 : countdifferentalleles(lastvar2, list)); if(different1*8<varcount){ arraylist<read> list2=map.get(lastvar2); final int varcount2=(list2==null ? 0 : list2.size()); final int different2=(sharedcount==varcount2 ? 0 : countdifferentalleles(var, list2)); if(different2*8<varcount2){ bestvar2=lastvar2; bestsharedcount=sharedcount; bestdifferent=tools.max(different1, different2); } } } sharedcount=1; } lastvar2=currentvar2; } if(sharedcount>bestsharedcount){ final int different1=(sharedcount==varcount ? 0 : countdifferentalleles(lastvar2, list)); if(different1*8<varcount){ arraylist<read> list2=map.get(lastvar2); final int varcount2=(list2==null ? 0 : list2.size()); final int different2=(sharedcount==varcount2 ? 0 : countdifferentalleles(var, list2)); if(different2*8<varcount2){ bestvar2=lastvar2; bestsharedcount=sharedcount; bestdifferent=tools.max(different1, different2); } } } rvector[0]=var; rvector[1]=list.size(); rvector[2]=bestvar2; rvector[3]=sharedcount; rvector[4]=bestdifferent; return bestvar2; }","classification":"DESIGN","isFinished":true,"code_context_2":"int lastvar2=-1, bestvar2=-1; int sharedcount=0, bestsharedcount=0, bestdifferent=999; for(int i=0; i<collection.size; i++){\/\/todo: note that not all reads actually cover a given var int currentvar2=collection.get(i); if(currentvar2==lastvar2){sharedcount++;}","code_context_10":"final int v2=vars.get(i); if(v2!=var){ collection.add(v2); } } } collection.sort(); final int varcount=list.size(); int lastvar2=-1, bestvar2=-1; int sharedcount=0, bestsharedcount=0, bestdifferent=999; for(int i=0; i<collection.size; i++){\/\/todo: note that not all reads actually cover a given var int currentvar2=collection.get(i); if(currentvar2==lastvar2){sharedcount++;} else{ if(sharedcount>bestsharedcount){ final int different1=(sharedcount==varcount ? 0 : countdifferentalleles(lastvar2, list)); if(different1*8<varcount){ arraylist<read> list2=map.get(lastvar2); final int varcount2=(list2==null ? 0 : list2.size()); final int different2=(sharedcount==varcount2 ? 0 : countdifferentalleles(var, list2)); if(different2*8<varcount2){","code_context_20":"static int examinevar(final int var, final arraylist<read> list, final intlist collection, final int[] rvector, linkedhashmap<integer, arraylist<read>> map){ collection.clear(); for(read r : list){ final readkey rk=(readkey) r.obj; final intlist vars=rk.vars; for(int i=0; i<vars.size; i++){ final int v2=vars.get(i); if(v2!=var){ collection.add(v2); } } } collection.sort(); final int varcount=list.size(); int lastvar2=-1, bestvar2=-1; int sharedcount=0, bestsharedcount=0, bestdifferent=999; for(int i=0; i<collection.size; i++){\/\/todo: note that not all reads actually cover a given var int currentvar2=collection.get(i); if(currentvar2==lastvar2){sharedcount++;} else{ if(sharedcount>bestsharedcount){ final int different1=(sharedcount==varcount ? 0 : countdifferentalleles(lastvar2, list)); if(different1*8<varcount){ arraylist<read> list2=map.get(lastvar2); final int varcount2=(list2==null ? 0 : list2.size()); final int different2=(sharedcount==varcount2 ? 0 : countdifferentalleles(var, list2)); if(different2*8<varcount2){ bestvar2=lastvar2; bestsharedcount=sharedcount; bestdifferent=tools.max(different1, different2); } } } sharedcount=1; } lastvar2=currentvar2; }","repo":"nedru004\/LibraryAnalysis2"}
{"id":12626,"comment_id":0,"comment":"\/** * block developer application * @param appid the id of the application to be blocked * @return a boolean value that indicates whether the update is successful *\/","code":"\/** * block developer application * @param appid the id of the application to be blocked * @return a boolean value that indicates whether the update is successful *\/ @requestmapping(path = \"\/0\/admin\/applications\/{appid}\/block\", method = requestmethod.post) public responseentity<boolean> updatedeveloperapplication( @pathvariable string appid ) { \/\/ let's get the user from principal and validate the userid against it. user user = userservice.findauthenticateduser(); if (user == null) return new responseentity<>(httpstatus.forbidden); \/\/ todo check and ensure user is moderator role application application = applicationservice.findapplication(appid); if (application == null){ logger.debug(\"application not found pre condition failed\"); return new responseentity<>(httpstatus.precondition_failed); } \/\/ todo what if application was already blocked? boolean result = applicationservice.blockapplication(application); return new responseentity<>(result, httpstatus.ok); }","classification":"NONSATD","isFinished":true,"code_context_2":"@requestmapping(path = \"\/0\/admin\/applications\/{appid}\/block\", method = requestmethod.post) public responseentity<boolean> updatedeveloperapplication( @pathvariable string appid ) { \/\/ let's get the user from principal and validate the userid against it. user user = userservice.findauthenticateduser(); if (user == null) return new responseentity<>(httpstatus.forbidden); \/\/ todo check and ensure user is moderator role application application = applicationservice.findapplication(appid); if (application == null){ logger.debug(\"application not found pre condition failed\"); return new responseentity<>(httpstatus.precondition_failed); } \/\/ todo what if application was already blocked? boolean result = applicationservice.blockapplication(application); return new responseentity<>(result, httpstatus.ok); }","code_context_10":"@requestmapping(path = \"\/0\/admin\/applications\/{appid}\/block\", method = requestmethod.post) public responseentity<boolean> updatedeveloperapplication( @pathvariable string appid ) { \/\/ let's get the user from principal and validate the userid against it. user user = userservice.findauthenticateduser(); if (user == null) return new responseentity<>(httpstatus.forbidden); \/\/ todo check and ensure user is moderator role application application = applicationservice.findapplication(appid); if (application == null){ logger.debug(\"application not found pre condition failed\"); return new responseentity<>(httpstatus.precondition_failed); } \/\/ todo what if application was already blocked? boolean result = applicationservice.blockapplication(application); return new responseentity<>(result, httpstatus.ok); }","code_context_20":"@requestmapping(path = \"\/0\/admin\/applications\/{appid}\/block\", method = requestmethod.post) public responseentity<boolean> updatedeveloperapplication( @pathvariable string appid ) { \/\/ let's get the user from principal and validate the userid against it. user user = userservice.findauthenticateduser(); if (user == null) return new responseentity<>(httpstatus.forbidden); \/\/ todo check and ensure user is moderator role application application = applicationservice.findapplication(appid); if (application == null){ logger.debug(\"application not found pre condition failed\"); return new responseentity<>(httpstatus.precondition_failed); } \/\/ todo what if application was already blocked? boolean result = applicationservice.blockapplication(application); return new responseentity<>(result, httpstatus.ok); }","repo":"niuyiming\/alpha-umi"}
{"id":12626,"comment_id":1,"comment":"\/\/ let's get the user from principal and validate the userid against it.","code":"@requestmapping(path = \"\/0\/admin\/applications\/{appid}\/block\", method = requestmethod.post) public responseentity<boolean> updatedeveloperapplication( @pathvariable string appid ) { \/\/ let's get the user from principal and validate the userid against it. user user = userservice.findauthenticateduser(); if (user == null) return new responseentity<>(httpstatus.forbidden); \/\/ todo check and ensure user is moderator role application application = applicationservice.findapplication(appid); if (application == null){ logger.debug(\"application not found pre condition failed\"); return new responseentity<>(httpstatus.precondition_failed); } \/\/ todo what if application was already blocked? boolean result = applicationservice.blockapplication(application); return new responseentity<>(result, httpstatus.ok); }","classification":"NONSATD","isFinished":true,"code_context_2":"@pathvariable string appid ) { \/\/ let's get the user from principal and validate the userid against it. user user = userservice.findauthenticateduser(); if (user == null)","code_context_10":"@requestmapping(path = \"\/0\/admin\/applications\/{appid}\/block\", method = requestmethod.post) public responseentity<boolean> updatedeveloperapplication( @pathvariable string appid ) { \/\/ let's get the user from principal and validate the userid against it. user user = userservice.findauthenticateduser(); if (user == null) return new responseentity<>(httpstatus.forbidden); \/\/ todo check and ensure user is moderator role application application = applicationservice.findapplication(appid); if (application == null){ logger.debug(\"application not found pre condition failed\"); return new responseentity<>(httpstatus.precondition_failed); } \/\/ todo what if application was already blocked?","code_context_20":"@requestmapping(path = \"\/0\/admin\/applications\/{appid}\/block\", method = requestmethod.post) public responseentity<boolean> updatedeveloperapplication( @pathvariable string appid ) { \/\/ let's get the user from principal and validate the userid against it. user user = userservice.findauthenticateduser(); if (user == null) return new responseentity<>(httpstatus.forbidden); \/\/ todo check and ensure user is moderator role application application = applicationservice.findapplication(appid); if (application == null){ logger.debug(\"application not found pre condition failed\"); return new responseentity<>(httpstatus.precondition_failed); } \/\/ todo what if application was already blocked? boolean result = applicationservice.blockapplication(application); return new responseentity<>(result, httpstatus.ok); }","repo":"niuyiming\/alpha-umi"}
{"id":12626,"comment_id":2,"comment":"\/\/ todo check and ensure user is moderator role","code":"@requestmapping(path = \"\/0\/admin\/applications\/{appid}\/block\", method = requestmethod.post) public responseentity<boolean> updatedeveloperapplication( @pathvariable string appid ) { \/\/ let's get the user from principal and validate the userid against it. user user = userservice.findauthenticateduser(); if (user == null) return new responseentity<>(httpstatus.forbidden); \/\/ todo check and ensure user is moderator role application application = applicationservice.findapplication(appid); if (application == null){ logger.debug(\"application not found pre condition failed\"); return new responseentity<>(httpstatus.precondition_failed); } \/\/ todo what if application was already blocked? boolean result = applicationservice.blockapplication(application); return new responseentity<>(result, httpstatus.ok); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"if (user == null) return new responseentity<>(httpstatus.forbidden); \/\/ todo check and ensure user is moderator role application application = applicationservice.findapplication(appid); if (application == null){","code_context_10":"@requestmapping(path = \"\/0\/admin\/applications\/{appid}\/block\", method = requestmethod.post) public responseentity<boolean> updatedeveloperapplication( @pathvariable string appid ) { \/\/ let's get the user from principal and validate the userid against it. user user = userservice.findauthenticateduser(); if (user == null) return new responseentity<>(httpstatus.forbidden); \/\/ todo check and ensure user is moderator role application application = applicationservice.findapplication(appid); if (application == null){ logger.debug(\"application not found pre condition failed\"); return new responseentity<>(httpstatus.precondition_failed); } \/\/ todo what if application was already blocked? boolean result = applicationservice.blockapplication(application); return new responseentity<>(result, httpstatus.ok); }","code_context_20":"@requestmapping(path = \"\/0\/admin\/applications\/{appid}\/block\", method = requestmethod.post) public responseentity<boolean> updatedeveloperapplication( @pathvariable string appid ) { \/\/ let's get the user from principal and validate the userid against it. user user = userservice.findauthenticateduser(); if (user == null) return new responseentity<>(httpstatus.forbidden); \/\/ todo check and ensure user is moderator role application application = applicationservice.findapplication(appid); if (application == null){ logger.debug(\"application not found pre condition failed\"); return new responseentity<>(httpstatus.precondition_failed); } \/\/ todo what if application was already blocked? boolean result = applicationservice.blockapplication(application); return new responseentity<>(result, httpstatus.ok); }","repo":"niuyiming\/alpha-umi"}
{"id":12626,"comment_id":3,"comment":"\/\/ todo what if application was already blocked?","code":"@requestmapping(path = \"\/0\/admin\/applications\/{appid}\/block\", method = requestmethod.post) public responseentity<boolean> updatedeveloperapplication( @pathvariable string appid ) { \/\/ let's get the user from principal and validate the userid against it. user user = userservice.findauthenticateduser(); if (user == null) return new responseentity<>(httpstatus.forbidden); \/\/ todo check and ensure user is moderator role application application = applicationservice.findapplication(appid); if (application == null){ logger.debug(\"application not found pre condition failed\"); return new responseentity<>(httpstatus.precondition_failed); } \/\/ todo what if application was already blocked? boolean result = applicationservice.blockapplication(application); return new responseentity<>(result, httpstatus.ok); }","classification":"DESIGN","isFinished":true,"code_context_2":"return new responseentity<>(httpstatus.precondition_failed); } \/\/ todo what if application was already blocked? boolean result = applicationservice.blockapplication(application); return new responseentity<>(result, httpstatus.ok);","code_context_10":"\/\/ let's get the user from principal and validate the userid against it. user user = userservice.findauthenticateduser(); if (user == null) return new responseentity<>(httpstatus.forbidden); \/\/ todo check and ensure user is moderator role application application = applicationservice.findapplication(appid); if (application == null){ logger.debug(\"application not found pre condition failed\"); return new responseentity<>(httpstatus.precondition_failed); } \/\/ todo what if application was already blocked? boolean result = applicationservice.blockapplication(application); return new responseentity<>(result, httpstatus.ok); }","code_context_20":"@requestmapping(path = \"\/0\/admin\/applications\/{appid}\/block\", method = requestmethod.post) public responseentity<boolean> updatedeveloperapplication( @pathvariable string appid ) { \/\/ let's get the user from principal and validate the userid against it. user user = userservice.findauthenticateduser(); if (user == null) return new responseentity<>(httpstatus.forbidden); \/\/ todo check and ensure user is moderator role application application = applicationservice.findapplication(appid); if (application == null){ logger.debug(\"application not found pre condition failed\"); return new responseentity<>(httpstatus.precondition_failed); } \/\/ todo what if application was already blocked? boolean result = applicationservice.blockapplication(application); return new responseentity<>(result, httpstatus.ok); }","repo":"niuyiming\/alpha-umi"}
{"id":13141,"comment_id":0,"comment":"\/\/ todo(b\/199889259): consider optimizing this for fastinit mode.","code":"private boolean useswitchingprovider() { if (!isfastinit) { return false; } switch (binding.kind()) { case bound_instance: case component: case component_dependency: case delegate: case members_injector: \/\/ todo(b\/199889259): consider optimizing this for fastinit mode. \/\/ these binding kinds avoid switchingprovider when the backing instance already exists, \/\/ e.g. a component provider can use factoryinstance.create(this). return false; case multibound_set: case multibound_map: case optional: \/\/ these binding kinds avoid switchingprovider when their are no dependencies, \/\/ e.g. a multibound set with no dependency can use a singleton, setfactory.empty(). return !binding.dependencies().isempty(); case injection: case provision: case assisted_injection: case assisted_factory: case component_provision: case subcomponent_creator: case production: case component_production: case members_injection: return true; } throw new assertionerror(string.format(\"no such binding kind: %s\", binding.kind())); }","classification":"DESIGN","isFinished":true,"code_context_2":"case component_dependency: case delegate: case members_injector: \/\/ todo(b\/199889259): consider optimizing this for fastinit mode. \/\/ these binding kinds avoid switchingprovider when the backing instance already exists, \/\/ e.g. a component provider can use factoryinstance.create(this).","code_context_10":"private boolean useswitchingprovider() { if (!isfastinit) { return false; } switch (binding.kind()) { case bound_instance: case component: case component_dependency: case delegate: case members_injector: \/\/ todo(b\/199889259): consider optimizing this for fastinit mode. \/\/ these binding kinds avoid switchingprovider when the backing instance already exists, \/\/ e.g. a component provider can use factoryinstance.create(this). return false; case multibound_set: case multibound_map: case optional: \/\/ these binding kinds avoid switchingprovider when their are no dependencies, \/\/ e.g. a multibound set with no dependency can use a singleton, setfactory.empty(). return !binding.dependencies().isempty(); case injection:","code_context_20":"private boolean useswitchingprovider() { if (!isfastinit) { return false; } switch (binding.kind()) { case bound_instance: case component: case component_dependency: case delegate: case members_injector: \/\/ todo(b\/199889259): consider optimizing this for fastinit mode. \/\/ these binding kinds avoid switchingprovider when the backing instance already exists, \/\/ e.g. a component provider can use factoryinstance.create(this). return false; case multibound_set: case multibound_map: case optional: \/\/ these binding kinds avoid switchingprovider when their are no dependencies, \/\/ e.g. a multibound set with no dependency can use a singleton, setfactory.empty(). return !binding.dependencies().isempty(); case injection: case provision: case assisted_injection: case assisted_factory: case component_provision: case subcomponent_creator: case production: case component_production: case members_injection: return true; }","repo":"priamm\/dagger"}
{"id":13141,"comment_id":1,"comment":"\/\/ these binding kinds avoid switchingprovider when the backing instance already exists, \/\/ e.g. a component provider can use factoryinstance.create(this).","code":"private boolean useswitchingprovider() { if (!isfastinit) { return false; } switch (binding.kind()) { case bound_instance: case component: case component_dependency: case delegate: case members_injector: \/\/ todo(b\/199889259): consider optimizing this for fastinit mode. \/\/ these binding kinds avoid switchingprovider when the backing instance already exists, \/\/ e.g. a component provider can use factoryinstance.create(this). return false; case multibound_set: case multibound_map: case optional: \/\/ these binding kinds avoid switchingprovider when their are no dependencies, \/\/ e.g. a multibound set with no dependency can use a singleton, setfactory.empty(). return !binding.dependencies().isempty(); case injection: case provision: case assisted_injection: case assisted_factory: case component_provision: case subcomponent_creator: case production: case component_production: case members_injection: return true; } throw new assertionerror(string.format(\"no such binding kind: %s\", binding.kind())); }","classification":"NONSATD","isFinished":true,"code_context_2":"case delegate: case members_injector: \/\/ todo(b\/199889259): consider optimizing this for fastinit mode. \/\/ these binding kinds avoid switchingprovider when the backing instance already exists, \/\/ e.g. a component provider can use factoryinstance.create(this). return false; case multibound_set:","code_context_10":"private boolean useswitchingprovider() { if (!isfastinit) { return false; } switch (binding.kind()) { case bound_instance: case component: case component_dependency: case delegate: case members_injector: \/\/ todo(b\/199889259): consider optimizing this for fastinit mode. \/\/ these binding kinds avoid switchingprovider when the backing instance already exists, \/\/ e.g. a component provider can use factoryinstance.create(this). return false; case multibound_set: case multibound_map: case optional: \/\/ these binding kinds avoid switchingprovider when their are no dependencies, \/\/ e.g. a multibound set with no dependency can use a singleton, setfactory.empty(). return !binding.dependencies().isempty(); case injection: case provision: case assisted_injection:","code_context_20":"private boolean useswitchingprovider() { if (!isfastinit) { return false; } switch (binding.kind()) { case bound_instance: case component: case component_dependency: case delegate: case members_injector: \/\/ todo(b\/199889259): consider optimizing this for fastinit mode. \/\/ these binding kinds avoid switchingprovider when the backing instance already exists, \/\/ e.g. a component provider can use factoryinstance.create(this). return false; case multibound_set: case multibound_map: case optional: \/\/ these binding kinds avoid switchingprovider when their are no dependencies, \/\/ e.g. a multibound set with no dependency can use a singleton, setfactory.empty(). return !binding.dependencies().isempty(); case injection: case provision: case assisted_injection: case assisted_factory: case component_provision: case subcomponent_creator: case production: case component_production: case members_injection: return true; } throw new assertionerror(string.format(\"no such binding kind: %s\", binding.kind())); }","repo":"priamm\/dagger"}
{"id":13141,"comment_id":2,"comment":"\/\/ these binding kinds avoid switchingprovider when their are no dependencies, \/\/ e.g. a multibound set with no dependency can use a singleton, setfactory.empty().","code":"private boolean useswitchingprovider() { if (!isfastinit) { return false; } switch (binding.kind()) { case bound_instance: case component: case component_dependency: case delegate: case members_injector: \/\/ todo(b\/199889259): consider optimizing this for fastinit mode. \/\/ these binding kinds avoid switchingprovider when the backing instance already exists, \/\/ e.g. a component provider can use factoryinstance.create(this). return false; case multibound_set: case multibound_map: case optional: \/\/ these binding kinds avoid switchingprovider when their are no dependencies, \/\/ e.g. a multibound set with no dependency can use a singleton, setfactory.empty(). return !binding.dependencies().isempty(); case injection: case provision: case assisted_injection: case assisted_factory: case component_provision: case subcomponent_creator: case production: case component_production: case members_injection: return true; } throw new assertionerror(string.format(\"no such binding kind: %s\", binding.kind())); }","classification":"NONSATD","isFinished":true,"code_context_2":"case multibound_map: case optional: \/\/ these binding kinds avoid switchingprovider when their are no dependencies, \/\/ e.g. a multibound set with no dependency can use a singleton, setfactory.empty(). return !binding.dependencies().isempty(); case injection:","code_context_10":"case component: case component_dependency: case delegate: case members_injector: \/\/ todo(b\/199889259): consider optimizing this for fastinit mode. \/\/ these binding kinds avoid switchingprovider when the backing instance already exists, \/\/ e.g. a component provider can use factoryinstance.create(this). return false; case multibound_set: case multibound_map: case optional: \/\/ these binding kinds avoid switchingprovider when their are no dependencies, \/\/ e.g. a multibound set with no dependency can use a singleton, setfactory.empty(). return !binding.dependencies().isempty(); case injection: case provision: case assisted_injection: case assisted_factory: case component_provision: case subcomponent_creator: case production: case component_production: case members_injection:","code_context_20":"private boolean useswitchingprovider() { if (!isfastinit) { return false; } switch (binding.kind()) { case bound_instance: case component: case component_dependency: case delegate: case members_injector: \/\/ todo(b\/199889259): consider optimizing this for fastinit mode. \/\/ these binding kinds avoid switchingprovider when the backing instance already exists, \/\/ e.g. a component provider can use factoryinstance.create(this). return false; case multibound_set: case multibound_map: case optional: \/\/ these binding kinds avoid switchingprovider when their are no dependencies, \/\/ e.g. a multibound set with no dependency can use a singleton, setfactory.empty(). return !binding.dependencies().isempty(); case injection: case provision: case assisted_injection: case assisted_factory: case component_provision: case subcomponent_creator: case production: case component_production: case members_injection: return true; } throw new assertionerror(string.format(\"no such binding kind: %s\", binding.kind())); }","repo":"priamm\/dagger"}
{"id":13305,"comment_id":0,"comment":"\/\/todo : need to implement. first need to figure out a way to hide the credentials dialog.","code":"@test public void openprivaterepository() { \/\/todo : need to implement. first need to figure out a way to hide the credentials dialog. }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"@test public void openprivaterepository() { \/\/todo : need to implement. first need to figure out a way to hide the credentials dialog. }","code_context_10":"@test public void openprivaterepository() { \/\/todo : need to implement. first need to figure out a way to hide the credentials dialog. }","code_context_20":"@test public void openprivaterepository() { \/\/todo : need to implement. first need to figure out a way to hide the credentials dialog. }","repo":"mvm-sap\/ADT_Frontend"}
{"id":13339,"comment_id":0,"comment":"\/** * validates the data on entering the corresponding parse tree node. * * @throws datamodelexception a violation of data model rules *\/","code":"\/** * validates the data on entering the corresponding parse tree node. * * @throws datamodelexception a violation of data model rules *\/ @override public void validatedataonentry() throws datamodelexception { \/\/ todo auto-generated method stub, to be implemented by parser }","classification":"NONSATD","isFinished":true,"code_context_2":"@override public void validatedataonentry() throws datamodelexception { \/\/ todo auto-generated method stub, to be implemented by parser }","code_context_10":"@override public void validatedataonentry() throws datamodelexception { \/\/ todo auto-generated method stub, to be implemented by parser }","code_context_20":"@override public void validatedataonentry() throws datamodelexception { \/\/ todo auto-generated method stub, to be implemented by parser }","repo":"onekeynet\/OConf"}
{"id":13339,"comment_id":1,"comment":"\/\/ todo auto-generated method stub, to be implemented by parser","code":"@override public void validatedataonentry() throws datamodelexception { \/\/ todo auto-generated method stub, to be implemented by parser }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"public void validatedataonentry() throws datamodelexception { \/\/ todo auto-generated method stub, to be implemented by parser }","code_context_10":"@override public void validatedataonentry() throws datamodelexception { \/\/ todo auto-generated method stub, to be implemented by parser }","code_context_20":"@override public void validatedataonentry() throws datamodelexception { \/\/ todo auto-generated method stub, to be implemented by parser }","repo":"onekeynet\/OConf"}
{"id":13382,"comment_id":0,"comment":"\/\/ todo change the file location\/name according to your needs","code":"private boolean writeresponsebodytodisk(responsebody body) { try { \/\/ todo change the file location\/name according to your needs file futurestudioiconfile = new file(motasavefilepath); inputstream inputstream = null; outputstream outputstream = null; try { byte[] filereader = new byte[1024]; long filesize = body.contentlength(); long filesizedownloaded = 0; inputstream = body.bytestream(); outputstream = new fileoutputstream(futurestudioiconfile); while (true) { int read = inputstream.read(filereader); if (read == -1) { break; } outputstream.write(filereader, 0, read); filesizedownloaded += read; } outputstream.flush(); return true; } catch (ioexception e) { return false; } finally { if (inputstream != null) { inputstream.close(); } if (outputstream != null) { outputstream.close(); } } } catch (ioexception e) { return false; } }","classification":"DESIGN","isFinished":true,"code_context_2":"private boolean writeresponsebodytodisk(responsebody body) { try { \/\/ todo change the file location\/name according to your needs file futurestudioiconfile = new file(motasavefilepath); inputstream inputstream = null;","code_context_10":"private boolean writeresponsebodytodisk(responsebody body) { try { \/\/ todo change the file location\/name according to your needs file futurestudioiconfile = new file(motasavefilepath); inputstream inputstream = null; outputstream outputstream = null; try { byte[] filereader = new byte[1024]; long filesize = body.contentlength(); long filesizedownloaded = 0; inputstream = body.bytestream(); outputstream = new fileoutputstream(futurestudioiconfile); while (true) {","code_context_20":"private boolean writeresponsebodytodisk(responsebody body) { try { \/\/ todo change the file location\/name according to your needs file futurestudioiconfile = new file(motasavefilepath); inputstream inputstream = null; outputstream outputstream = null; try { byte[] filereader = new byte[1024]; long filesize = body.contentlength(); long filesizedownloaded = 0; inputstream = body.bytestream(); outputstream = new fileoutputstream(futurestudioiconfile); while (true) { int read = inputstream.read(filereader); if (read == -1) { break; } outputstream.write(filereader, 0, read); filesizedownloaded += read; } outputstream.flush(); return true; } catch (ioexception e) {","repo":"qiaolw\/AndroidTest"}
{"id":21838,"comment_id":0,"comment":"\/\/ group by session if info is available \/\/ todo make this an option","code":"@override public void operate(opcontext context) throws processingexception { final tabledatasource table = (tabledatasource)context.get(tableinput); int ipatidx = super.getcolumnindex(table, systemtiertype.ipatarget.getname()); if(ipatidx < 0) { throw new processingexception(null, \"table has no \" + systemtiertype.ipatarget.getname() + \" column.\"); } int ipaaidx = super.getcolumnindex(table, systemtiertype.ipaactual.getname()); if(ipaaidx < 0) { throw new processingexception(null, \"table has no \" + systemtiertype.ipaactual.getname() + \" column.\"); } \/\/ group by session if info is available \/\/ todo make this an option int sessionidx = super.getcolumnindex(table, \"session\"); boolean ignorediacritics = isignorediacritics(); if(context.containskey(\"ignorediacritics\")) { ignorediacritics = (boolean)context.get(\"ignorediacritics\"); } final map<groupkey, ipaternarytree<list<ipatranscript>>> tokencounts = new linkedhashmap<>(); for(int row = 0; row < table.getrowcount(); row++) { checkcanceled(); final object groupval = (sessionidx >= 0 ? table.getvalueat(row, sessionidx) : \"*\"); final groupkey groupkey = new groupkey(groupval, ignorediacritics); ipaternarytree<list<ipatranscript>> tokencount = tokencounts.get(groupkey); if(tokencount == null) { tokencount = new ipaternarytree<>(); tokencounts.put(groupkey, tokencount); } ipatranscript ipat = ipatranscript.class.cast(table.getvalueat(row, ipatidx)); ipatranscript ipaa = ipatranscript.class.cast(table.getvalueat(row, ipaaidx)); if(ignorediacritics) { ipat = ipat.removepunctuation().stripdiacritics(); ipaa = ipaa.removepunctuation().stripdiacritics(); } list<ipatranscript> productions = tokencount.get(ipat); if(productions == null) { productions = new arraylist<>(); tokencount.put(ipat, productions); } productions.add(ipaa); } final defaulttabledatasource outputtable = new defaulttabledatasource(); for(groupkey groupkey:tokencounts.keyset()) { final object[] rowdata = new object[7]; \/\/ produce table int numrepatedwords = 0; int numallcorrect = 0; int numoneormorecorrect = 0; int numsameerror = 0; int numdifferenterrors = 0; float sumofavgdistances = 0; final ipaternarytree<list<ipatranscript>> tokencount = tokencounts.get(groupkey); final list<ipatranscript> repeatedtokens = tokencount.keyset().stream() .filter( (ipa) -> tokencount.get(ipa).size() > 1 ) .collect(collectors.tolist()); numrepatedwords = repeatedtokens.size(); for(ipatranscript ipa:repeatedtokens) { checkcanceled(); int numcorrect = 0; final list<ipatranscript> productions = tokencount.get(ipa); final set<ipatranscript> distinctproductions = new linkedhashset<>(productions); for(ipatranscript production:tokencount.get(ipa)) { if(tableutils.checkequals(ipa, production, false, ignorediacritics)) { ++numcorrect; } } if(numcorrect == productions.size()) { ++numallcorrect; } else { if(numcorrect > 0 && numcorrect < productions.size()) { ++numoneormorecorrect; } distinctproductions.remove(ipa); if(distinctproductions.size() == 1) { ++numsameerror; } else { ++numdifferenterrors; } int totaldistance = 0; for(ipatranscript production:productions) { totaldistance += levenshteindistance.distance(ipa, production); } float avg = ((float)totaldistance)\/((float)productions.size()); sumofavgdistances += avg; } } \/\/ append row to table rowdata[0] = groupkey.key; rowdata[1] = numrepatedwords; rowdata[2] = numallcorrect; rowdata[3] = numoneormorecorrect; rowdata[4] = numsameerror; rowdata[5] = numdifferenterrors; rowdata[6] = sumofavgdistances \/ numrepatedwords; outputtable.addrow(rowdata); } outputtable.setcolumntitle(0, \"session\"); outputtable.setcolumntitle(1, \"# repeated ipa target\"); outputtable.setcolumntitle(2, \"# all correct\"); outputtable.setcolumntitle(3, \"# one or more correct\"); outputtable.setcolumntitle(4, \"# same error\"); outputtable.setcolumntitle(5, \"# different errors\"); outputtable.setcolumntitle(6, \"avg distance\"); context.put(tableoutput, outputtable); }","classification":"DESIGN","isFinished":true,"code_context_2":"throw new processingexception(null, \"table has no \" + systemtiertype.ipaactual.getname() + \" column.\"); } \/\/ group by session if info is available \/\/ todo make this an option int sessionidx = super.getcolumnindex(table, \"session\"); boolean ignorediacritics = isignorediacritics();","code_context_10":"public void operate(opcontext context) throws processingexception { final tabledatasource table = (tabledatasource)context.get(tableinput); int ipatidx = super.getcolumnindex(table, systemtiertype.ipatarget.getname()); if(ipatidx < 0) { throw new processingexception(null, \"table has no \" + systemtiertype.ipatarget.getname() + \" column.\"); } int ipaaidx = super.getcolumnindex(table, systemtiertype.ipaactual.getname()); if(ipaaidx < 0) { throw new processingexception(null, \"table has no \" + systemtiertype.ipaactual.getname() + \" column.\"); } \/\/ group by session if info is available \/\/ todo make this an option int sessionidx = super.getcolumnindex(table, \"session\"); boolean ignorediacritics = isignorediacritics(); if(context.containskey(\"ignorediacritics\")) { ignorediacritics = (boolean)context.get(\"ignorediacritics\"); } final map<groupkey, ipaternarytree<list<ipatranscript>>> tokencounts = new linkedhashmap<>(); for(int row = 0; row < table.getrowcount(); row++) { checkcanceled(); final object groupval =","code_context_20":"@override public void operate(opcontext context) throws processingexception { final tabledatasource table = (tabledatasource)context.get(tableinput); int ipatidx = super.getcolumnindex(table, systemtiertype.ipatarget.getname()); if(ipatidx < 0) { throw new processingexception(null, \"table has no \" + systemtiertype.ipatarget.getname() + \" column.\"); } int ipaaidx = super.getcolumnindex(table, systemtiertype.ipaactual.getname()); if(ipaaidx < 0) { throw new processingexception(null, \"table has no \" + systemtiertype.ipaactual.getname() + \" column.\"); } \/\/ group by session if info is available \/\/ todo make this an option int sessionidx = super.getcolumnindex(table, \"session\"); boolean ignorediacritics = isignorediacritics(); if(context.containskey(\"ignorediacritics\")) { ignorediacritics = (boolean)context.get(\"ignorediacritics\"); } final map<groupkey, ipaternarytree<list<ipatranscript>>> tokencounts = new linkedhashmap<>(); for(int row = 0; row < table.getrowcount(); row++) { checkcanceled(); final object groupval = (sessionidx >= 0 ? table.getvalueat(row, sessionidx) : \"*\"); final groupkey groupkey = new groupkey(groupval, ignorediacritics); ipaternarytree<list<ipatranscript>> tokencount = tokencounts.get(groupkey); if(tokencount == null) { tokencount = new ipaternarytree<>(); tokencounts.put(groupkey, tokencount); } ipatranscript ipat = ipatranscript.class.cast(table.getvalueat(row, ipatidx));","repo":"phon-ca\/phon"}
{"id":21838,"comment_id":1,"comment":"\/\/ produce table","code":"@override public void operate(opcontext context) throws processingexception { final tabledatasource table = (tabledatasource)context.get(tableinput); int ipatidx = super.getcolumnindex(table, systemtiertype.ipatarget.getname()); if(ipatidx < 0) { throw new processingexception(null, \"table has no \" + systemtiertype.ipatarget.getname() + \" column.\"); } int ipaaidx = super.getcolumnindex(table, systemtiertype.ipaactual.getname()); if(ipaaidx < 0) { throw new processingexception(null, \"table has no \" + systemtiertype.ipaactual.getname() + \" column.\"); } \/\/ group by session if info is available \/\/ todo make this an option int sessionidx = super.getcolumnindex(table, \"session\"); boolean ignorediacritics = isignorediacritics(); if(context.containskey(\"ignorediacritics\")) { ignorediacritics = (boolean)context.get(\"ignorediacritics\"); } final map<groupkey, ipaternarytree<list<ipatranscript>>> tokencounts = new linkedhashmap<>(); for(int row = 0; row < table.getrowcount(); row++) { checkcanceled(); final object groupval = (sessionidx >= 0 ? table.getvalueat(row, sessionidx) : \"*\"); final groupkey groupkey = new groupkey(groupval, ignorediacritics); ipaternarytree<list<ipatranscript>> tokencount = tokencounts.get(groupkey); if(tokencount == null) { tokencount = new ipaternarytree<>(); tokencounts.put(groupkey, tokencount); } ipatranscript ipat = ipatranscript.class.cast(table.getvalueat(row, ipatidx)); ipatranscript ipaa = ipatranscript.class.cast(table.getvalueat(row, ipaaidx)); if(ignorediacritics) { ipat = ipat.removepunctuation().stripdiacritics(); ipaa = ipaa.removepunctuation().stripdiacritics(); } list<ipatranscript> productions = tokencount.get(ipat); if(productions == null) { productions = new arraylist<>(); tokencount.put(ipat, productions); } productions.add(ipaa); } final defaulttabledatasource outputtable = new defaulttabledatasource(); for(groupkey groupkey:tokencounts.keyset()) { final object[] rowdata = new object[7]; \/\/ produce table int numrepatedwords = 0; int numallcorrect = 0; int numoneormorecorrect = 0; int numsameerror = 0; int numdifferenterrors = 0; float sumofavgdistances = 0; final ipaternarytree<list<ipatranscript>> tokencount = tokencounts.get(groupkey); final list<ipatranscript> repeatedtokens = tokencount.keyset().stream() .filter( (ipa) -> tokencount.get(ipa).size() > 1 ) .collect(collectors.tolist()); numrepatedwords = repeatedtokens.size(); for(ipatranscript ipa:repeatedtokens) { checkcanceled(); int numcorrect = 0; final list<ipatranscript> productions = tokencount.get(ipa); final set<ipatranscript> distinctproductions = new linkedhashset<>(productions); for(ipatranscript production:tokencount.get(ipa)) { if(tableutils.checkequals(ipa, production, false, ignorediacritics)) { ++numcorrect; } } if(numcorrect == productions.size()) { ++numallcorrect; } else { if(numcorrect > 0 && numcorrect < productions.size()) { ++numoneormorecorrect; } distinctproductions.remove(ipa); if(distinctproductions.size() == 1) { ++numsameerror; } else { ++numdifferenterrors; } int totaldistance = 0; for(ipatranscript production:productions) { totaldistance += levenshteindistance.distance(ipa, production); } float avg = ((float)totaldistance)\/((float)productions.size()); sumofavgdistances += avg; } } \/\/ append row to table rowdata[0] = groupkey.key; rowdata[1] = numrepatedwords; rowdata[2] = numallcorrect; rowdata[3] = numoneormorecorrect; rowdata[4] = numsameerror; rowdata[5] = numdifferenterrors; rowdata[6] = sumofavgdistances \/ numrepatedwords; outputtable.addrow(rowdata); } outputtable.setcolumntitle(0, \"session\"); outputtable.setcolumntitle(1, \"# repeated ipa target\"); outputtable.setcolumntitle(2, \"# all correct\"); outputtable.setcolumntitle(3, \"# one or more correct\"); outputtable.setcolumntitle(4, \"# same error\"); outputtable.setcolumntitle(5, \"# different errors\"); outputtable.setcolumntitle(6, \"avg distance\"); context.put(tableoutput, outputtable); }","classification":"NONSATD","isFinished":true,"code_context_2":"for(groupkey groupkey:tokencounts.keyset()) { final object[] rowdata = new object[7]; \/\/ produce table int numrepatedwords = 0; int numallcorrect = 0;","code_context_10":"list<ipatranscript> productions = tokencount.get(ipat); if(productions == null) { productions = new arraylist<>(); tokencount.put(ipat, productions); } productions.add(ipaa); } final defaulttabledatasource outputtable = new defaulttabledatasource(); for(groupkey groupkey:tokencounts.keyset()) { final object[] rowdata = new object[7]; \/\/ produce table int numrepatedwords = 0; int numallcorrect = 0; int numoneormorecorrect = 0; int numsameerror = 0; int numdifferenterrors = 0; float sumofavgdistances = 0; final ipaternarytree<list<ipatranscript>> tokencount = tokencounts.get(groupkey); final list<ipatranscript> repeatedtokens = tokencount.keyset().stream() .filter( (ipa) -> tokencount.get(ipa).size() > 1 )","code_context_20":"tokencounts.put(groupkey, tokencount); } ipatranscript ipat = ipatranscript.class.cast(table.getvalueat(row, ipatidx)); ipatranscript ipaa = ipatranscript.class.cast(table.getvalueat(row, ipaaidx)); if(ignorediacritics) { ipat = ipat.removepunctuation().stripdiacritics(); ipaa = ipaa.removepunctuation().stripdiacritics(); } list<ipatranscript> productions = tokencount.get(ipat); if(productions == null) { productions = new arraylist<>(); tokencount.put(ipat, productions); } productions.add(ipaa); } final defaulttabledatasource outputtable = new defaulttabledatasource(); for(groupkey groupkey:tokencounts.keyset()) { final object[] rowdata = new object[7]; \/\/ produce table int numrepatedwords = 0; int numallcorrect = 0; int numoneormorecorrect = 0; int numsameerror = 0; int numdifferenterrors = 0; float sumofavgdistances = 0; final ipaternarytree<list<ipatranscript>> tokencount = tokencounts.get(groupkey); final list<ipatranscript> repeatedtokens = tokencount.keyset().stream() .filter( (ipa) -> tokencount.get(ipa).size() > 1 ) .collect(collectors.tolist()); numrepatedwords = repeatedtokens.size(); for(ipatranscript ipa:repeatedtokens) { checkcanceled(); int numcorrect = 0; final list<ipatranscript> productions = tokencount.get(ipa); final set<ipatranscript> distinctproductions = new linkedhashset<>(productions); for(ipatranscript production:tokencount.get(ipa)) { if(tableutils.checkequals(ipa, production, false, ignorediacritics)) { ++numcorrect;","repo":"phon-ca\/phon"}
{"id":21838,"comment_id":2,"comment":"\/\/ append row to table","code":"@override public void operate(opcontext context) throws processingexception { final tabledatasource table = (tabledatasource)context.get(tableinput); int ipatidx = super.getcolumnindex(table, systemtiertype.ipatarget.getname()); if(ipatidx < 0) { throw new processingexception(null, \"table has no \" + systemtiertype.ipatarget.getname() + \" column.\"); } int ipaaidx = super.getcolumnindex(table, systemtiertype.ipaactual.getname()); if(ipaaidx < 0) { throw new processingexception(null, \"table has no \" + systemtiertype.ipaactual.getname() + \" column.\"); } \/\/ group by session if info is available \/\/ todo make this an option int sessionidx = super.getcolumnindex(table, \"session\"); boolean ignorediacritics = isignorediacritics(); if(context.containskey(\"ignorediacritics\")) { ignorediacritics = (boolean)context.get(\"ignorediacritics\"); } final map<groupkey, ipaternarytree<list<ipatranscript>>> tokencounts = new linkedhashmap<>(); for(int row = 0; row < table.getrowcount(); row++) { checkcanceled(); final object groupval = (sessionidx >= 0 ? table.getvalueat(row, sessionidx) : \"*\"); final groupkey groupkey = new groupkey(groupval, ignorediacritics); ipaternarytree<list<ipatranscript>> tokencount = tokencounts.get(groupkey); if(tokencount == null) { tokencount = new ipaternarytree<>(); tokencounts.put(groupkey, tokencount); } ipatranscript ipat = ipatranscript.class.cast(table.getvalueat(row, ipatidx)); ipatranscript ipaa = ipatranscript.class.cast(table.getvalueat(row, ipaaidx)); if(ignorediacritics) { ipat = ipat.removepunctuation().stripdiacritics(); ipaa = ipaa.removepunctuation().stripdiacritics(); } list<ipatranscript> productions = tokencount.get(ipat); if(productions == null) { productions = new arraylist<>(); tokencount.put(ipat, productions); } productions.add(ipaa); } final defaulttabledatasource outputtable = new defaulttabledatasource(); for(groupkey groupkey:tokencounts.keyset()) { final object[] rowdata = new object[7]; \/\/ produce table int numrepatedwords = 0; int numallcorrect = 0; int numoneormorecorrect = 0; int numsameerror = 0; int numdifferenterrors = 0; float sumofavgdistances = 0; final ipaternarytree<list<ipatranscript>> tokencount = tokencounts.get(groupkey); final list<ipatranscript> repeatedtokens = tokencount.keyset().stream() .filter( (ipa) -> tokencount.get(ipa).size() > 1 ) .collect(collectors.tolist()); numrepatedwords = repeatedtokens.size(); for(ipatranscript ipa:repeatedtokens) { checkcanceled(); int numcorrect = 0; final list<ipatranscript> productions = tokencount.get(ipa); final set<ipatranscript> distinctproductions = new linkedhashset<>(productions); for(ipatranscript production:tokencount.get(ipa)) { if(tableutils.checkequals(ipa, production, false, ignorediacritics)) { ++numcorrect; } } if(numcorrect == productions.size()) { ++numallcorrect; } else { if(numcorrect > 0 && numcorrect < productions.size()) { ++numoneormorecorrect; } distinctproductions.remove(ipa); if(distinctproductions.size() == 1) { ++numsameerror; } else { ++numdifferenterrors; } int totaldistance = 0; for(ipatranscript production:productions) { totaldistance += levenshteindistance.distance(ipa, production); } float avg = ((float)totaldistance)\/((float)productions.size()); sumofavgdistances += avg; } } \/\/ append row to table rowdata[0] = groupkey.key; rowdata[1] = numrepatedwords; rowdata[2] = numallcorrect; rowdata[3] = numoneormorecorrect; rowdata[4] = numsameerror; rowdata[5] = numdifferenterrors; rowdata[6] = sumofavgdistances \/ numrepatedwords; outputtable.addrow(rowdata); } outputtable.setcolumntitle(0, \"session\"); outputtable.setcolumntitle(1, \"# repeated ipa target\"); outputtable.setcolumntitle(2, \"# all correct\"); outputtable.setcolumntitle(3, \"# one or more correct\"); outputtable.setcolumntitle(4, \"# same error\"); outputtable.setcolumntitle(5, \"# different errors\"); outputtable.setcolumntitle(6, \"avg distance\"); context.put(tableoutput, outputtable); }","classification":"NONSATD","isFinished":true,"code_context_2":"} } \/\/ append row to table rowdata[0] = groupkey.key; rowdata[1] = numrepatedwords;","code_context_10":"++numdifferenterrors; } int totaldistance = 0; for(ipatranscript production:productions) { totaldistance += levenshteindistance.distance(ipa, production); } float avg = ((float)totaldistance)\/((float)productions.size()); sumofavgdistances += avg; } } \/\/ append row to table rowdata[0] = groupkey.key; rowdata[1] = numrepatedwords; rowdata[2] = numallcorrect; rowdata[3] = numoneormorecorrect; rowdata[4] = numsameerror; rowdata[5] = numdifferenterrors; rowdata[6] = sumofavgdistances \/ numrepatedwords; outputtable.addrow(rowdata); } outputtable.setcolumntitle(0, \"session\");","code_context_20":"if(numcorrect == productions.size()) { ++numallcorrect; } else { if(numcorrect > 0 && numcorrect < productions.size()) { ++numoneormorecorrect; } distinctproductions.remove(ipa); if(distinctproductions.size() == 1) { ++numsameerror; } else { ++numdifferenterrors; } int totaldistance = 0; for(ipatranscript production:productions) { totaldistance += levenshteindistance.distance(ipa, production); } float avg = ((float)totaldistance)\/((float)productions.size()); sumofavgdistances += avg; } } \/\/ append row to table rowdata[0] = groupkey.key; rowdata[1] = numrepatedwords; rowdata[2] = numallcorrect; rowdata[3] = numoneormorecorrect; rowdata[4] = numsameerror; rowdata[5] = numdifferenterrors; rowdata[6] = sumofavgdistances \/ numrepatedwords; outputtable.addrow(rowdata); } outputtable.setcolumntitle(0, \"session\"); outputtable.setcolumntitle(1, \"# repeated ipa target\"); outputtable.setcolumntitle(2, \"# all correct\"); outputtable.setcolumntitle(3, \"# one or more correct\"); outputtable.setcolumntitle(4, \"# same error\"); outputtable.setcolumntitle(5, \"# different errors\"); outputtable.setcolumntitle(6, \"avg distance\"); context.put(tableoutput, outputtable); }","repo":"phon-ca\/phon"}
{"id":30178,"comment_id":0,"comment":"\/\/#if polish.midp || polish.usepolishgui \/** * wraps the given string so it fits on the specified lines. * first of al it is splitted at the line-breaks ('\\n'), subsequently the substrings * are splitted when they do not fit on a single line. * * @param value the string which should be splitted * @param font the font which is used to display the font * @param firstlinewidth the allowed width for the first line * @param linewidth the allowed width for all other lines, linewidth >= firstlinewidth * @return the array containing the substrings * @deprecated please use wrap instead * @see #wrap(string, font, int, int) *\/","code":"\/\/#if polish.midp || polish.usepolishgui \/** * wraps the given string so it fits on the specified lines. * first of al it is splitted at the line-breaks ('\\n'), subsequently the substrings * are splitted when they do not fit on a single line. * * @param value the string which should be splitted * @param font the font which is used to display the font * @param firstlinewidth the allowed width for the first line * @param linewidth the allowed width for all other lines, linewidth >= firstlinewidth * @return the array containing the substrings * @deprecated please use wrap instead * @see #wrap(string, font, int, int) *\/ public static string[] split( string value, font font, int firstlinewidth, int linewidth ) { return wrap(value, font, firstlinewidth, linewidth); }","classification":"NONSATD","isFinished":true,"code_context_2":"public static string[] split( string value, font font, int firstlinewidth, int linewidth ) { return wrap(value, font, firstlinewidth, linewidth); }","code_context_10":"public static string[] split( string value, font font, int firstlinewidth, int linewidth ) { return wrap(value, font, firstlinewidth, linewidth); }","code_context_20":"public static string[] split( string value, font font, int firstlinewidth, int linewidth ) { return wrap(value, font, firstlinewidth, linewidth); }","repo":"mobabel\/MoMeGo"}
{"id":13831,"comment_id":0,"comment":"\/** * removes transitions to or from a missing activity, probably due to the activity not being imported. *\/","code":"\/** * removes transitions to or from a missing activity, probably due to the activity not being imported. *\/ private void removedanglingtransitions(abstractworkflow workflow) { if (workflow.gettransitions() == null || workflow.gettransitions().isempty()) { return; } set<string> activityids = new hashset<>(); for (activity activity : workflow.getactivities()) { activityids.add(activity.getid()); \/\/ transitions from boundary event timers should be included as well \/\/ todo: make generic list<timer> activitytimers = activity.gettimers(); if (activitytimers != null) { for (timer timer : activitytimers) { if (timer instanceof boundaryeventtimer) { boundaryevent boundaryevent = ((boundaryeventtimer) timer).boundaryevent; activityids.add(boundaryevent.getboundaryid()); activityids.addall(boundaryevent.gettotransitionids()); } } } } listiterator<transition> transitioniterator = workflow.gettransitions().listiterator(); while(transitioniterator.hasnext()){ transition transition = transitioniterator.next(); if (!activityids.contains(transition.getfromid()) || !activityids.contains(transition.gettoid())) { transitioniterator.remove(); } } }","classification":"NONSATD","isFinished":true,"code_context_2":"private void removedanglingtransitions(abstractworkflow workflow) { if (workflow.gettransitions() == null || workflow.gettransitions().isempty()) { return; } set<string> activityids = new hashset<>(); for (activity activity : workflow.getactivities()) { activityids.add(activity.getid()); \/\/ transitions from boundary event timers should be included as well \/\/ todo: make generic list<timer> activitytimers = activity.gettimers(); if (activitytimers != null) { for (timer timer : activitytimers) { if (timer instanceof boundaryeventtimer) { boundaryevent boundaryevent = ((boundaryeventtimer) timer).boundaryevent; activityids.add(boundaryevent.getboundaryid()); activityids.addall(boundaryevent.gettotransitionids()); } } } } listiterator<transition> transitioniterator = workflow.gettransitions().listiterator(); while(transitioniterator.hasnext()){ transition transition = transitioniterator.next(); if (!activityids.contains(transition.getfromid()) || !activityids.contains(transition.gettoid())) { transitioniterator.remove(); } } }","code_context_10":"private void removedanglingtransitions(abstractworkflow workflow) { if (workflow.gettransitions() == null || workflow.gettransitions().isempty()) { return; } set<string> activityids = new hashset<>(); for (activity activity : workflow.getactivities()) { activityids.add(activity.getid()); \/\/ transitions from boundary event timers should be included as well \/\/ todo: make generic list<timer> activitytimers = activity.gettimers(); if (activitytimers != null) { for (timer timer : activitytimers) { if (timer instanceof boundaryeventtimer) { boundaryevent boundaryevent = ((boundaryeventtimer) timer).boundaryevent; activityids.add(boundaryevent.getboundaryid()); activityids.addall(boundaryevent.gettotransitionids()); } } } } listiterator<transition> transitioniterator = workflow.gettransitions().listiterator(); while(transitioniterator.hasnext()){ transition transition = transitioniterator.next(); if (!activityids.contains(transition.getfromid()) || !activityids.contains(transition.gettoid())) { transitioniterator.remove(); } } }","code_context_20":"private void removedanglingtransitions(abstractworkflow workflow) { if (workflow.gettransitions() == null || workflow.gettransitions().isempty()) { return; } set<string> activityids = new hashset<>(); for (activity activity : workflow.getactivities()) { activityids.add(activity.getid()); \/\/ transitions from boundary event timers should be included as well \/\/ todo: make generic list<timer> activitytimers = activity.gettimers(); if (activitytimers != null) { for (timer timer : activitytimers) { if (timer instanceof boundaryeventtimer) { boundaryevent boundaryevent = ((boundaryeventtimer) timer).boundaryevent; activityids.add(boundaryevent.getboundaryid()); activityids.addall(boundaryevent.gettotransitionids()); } } } } listiterator<transition> transitioniterator = workflow.gettransitions().listiterator(); while(transitioniterator.hasnext()){ transition transition = transitioniterator.next(); if (!activityids.contains(transition.getfromid()) || !activityids.contains(transition.gettoid())) { transitioniterator.remove(); } } }","repo":"pharod\/effektif"}
{"id":13831,"comment_id":1,"comment":"\/\/ transitions from boundary event timers should be included as well \/\/ todo: make generic","code":"private void removedanglingtransitions(abstractworkflow workflow) { if (workflow.gettransitions() == null || workflow.gettransitions().isempty()) { return; } set<string> activityids = new hashset<>(); for (activity activity : workflow.getactivities()) { activityids.add(activity.getid()); \/\/ transitions from boundary event timers should be included as well \/\/ todo: make generic list<timer> activitytimers = activity.gettimers(); if (activitytimers != null) { for (timer timer : activitytimers) { if (timer instanceof boundaryeventtimer) { boundaryevent boundaryevent = ((boundaryeventtimer) timer).boundaryevent; activityids.add(boundaryevent.getboundaryid()); activityids.addall(boundaryevent.gettotransitionids()); } } } } listiterator<transition> transitioniterator = workflow.gettransitions().listiterator(); while(transitioniterator.hasnext()){ transition transition = transitioniterator.next(); if (!activityids.contains(transition.getfromid()) || !activityids.contains(transition.gettoid())) { transitioniterator.remove(); } } }","classification":"DESIGN","isFinished":true,"code_context_2":"for (activity activity : workflow.getactivities()) { activityids.add(activity.getid()); \/\/ transitions from boundary event timers should be included as well \/\/ todo: make generic list<timer> activitytimers = activity.gettimers(); if (activitytimers != null) {","code_context_10":"private void removedanglingtransitions(abstractworkflow workflow) { if (workflow.gettransitions() == null || workflow.gettransitions().isempty()) { return; } set<string> activityids = new hashset<>(); for (activity activity : workflow.getactivities()) { activityids.add(activity.getid()); \/\/ transitions from boundary event timers should be included as well \/\/ todo: make generic list<timer> activitytimers = activity.gettimers(); if (activitytimers != null) { for (timer timer : activitytimers) { if (timer instanceof boundaryeventtimer) { boundaryevent boundaryevent = ((boundaryeventtimer) timer).boundaryevent; activityids.add(boundaryevent.getboundaryid()); activityids.addall(boundaryevent.gettotransitionids()); } } }","code_context_20":"private void removedanglingtransitions(abstractworkflow workflow) { if (workflow.gettransitions() == null || workflow.gettransitions().isempty()) { return; } set<string> activityids = new hashset<>(); for (activity activity : workflow.getactivities()) { activityids.add(activity.getid()); \/\/ transitions from boundary event timers should be included as well \/\/ todo: make generic list<timer> activitytimers = activity.gettimers(); if (activitytimers != null) { for (timer timer : activitytimers) { if (timer instanceof boundaryeventtimer) { boundaryevent boundaryevent = ((boundaryeventtimer) timer).boundaryevent; activityids.add(boundaryevent.getboundaryid()); activityids.addall(boundaryevent.gettotransitionids()); } } } } listiterator<transition> transitioniterator = workflow.gettransitions().listiterator(); while(transitioniterator.hasnext()){ transition transition = transitioniterator.next(); if (!activityids.contains(transition.getfromid()) || !activityids.contains(transition.gettoid())) { transitioniterator.remove(); } } }","repo":"pharod\/effektif"}
{"id":14220,"comment_id":0,"comment":"\/\/log.debug(\"s: '\" + uri + \"' \" + qname); \/\/ ----- <xfml> -----------------------------------------------------------","code":"@override public void startelement (string uri, string name, string qname, attributes atts) throws saxexception { try { \/\/log.debug(\"s: '\" + uri + \"' \" + qname); \/\/ ----- <xfml> ----------------------------------------------------------- if (el_xfml.equals(qname)) { string version = atts.getvalue(\"version\"); if (version == null) log.warn(\"no version attribute on 'xfml' element\"); if (!\"1.0\".equals(version)) log.warn(\"unsupported xfml version: \" + version); string mapurl = atts.getvalue(\"url\"); if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> -------------------------------------------------------- else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname)) keep_content = true; } catch (runtimeexception e) { e.printstacktrace(); throw e; } }","classification":"NONSATD","isFinished":true,"code_context_2":"public void startelement (string uri, string name, string qname, attributes atts) throws saxexception { try { \/\/log.debug(\"s: '\" + uri + \"' \" + qname); \/\/ ----- <xfml> ----------------------------------------------------------- if (el_xfml.equals(qname)) { string version = atts.getvalue(\"version\");","code_context_10":"@override public void startelement (string uri, string name, string qname, attributes atts) throws saxexception { try { \/\/log.debug(\"s: '\" + uri + \"' \" + qname); \/\/ ----- <xfml> ----------------------------------------------------------- if (el_xfml.equals(qname)) { string version = atts.getvalue(\"version\"); if (version == null) log.warn(\"no version attribute on 'xfml' element\"); if (!\"1.0\".equals(version)) log.warn(\"unsupported xfml version: \" + version); string mapurl = atts.getvalue(\"url\"); if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else {","code_context_20":"@override public void startelement (string uri, string name, string qname, attributes atts) throws saxexception { try { \/\/log.debug(\"s: '\" + uri + \"' \" + qname); \/\/ ----- <xfml> ----------------------------------------------------------- if (el_xfml.equals(qname)) { string version = atts.getvalue(\"version\"); if (version == null) log.warn(\"no version attribute on 'xfml' element\"); if (!\"1.0\".equals(version)) log.warn(\"unsupported xfml version: \" + version); string mapurl = atts.getvalue(\"url\"); if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl);","repo":"ontopia\/ontopia"}
{"id":14220,"comment_id":1,"comment":"\/\/ add this document to the list of processed documents.","code":"@override public void startelement (string uri, string name, string qname, attributes atts) throws saxexception { try { \/\/log.debug(\"s: '\" + uri + \"' \" + qname); \/\/ ----- <xfml> ----------------------------------------------------------- if (el_xfml.equals(qname)) { string version = atts.getvalue(\"version\"); if (version == null) log.warn(\"no version attribute on 'xfml' element\"); if (!\"1.0\".equals(version)) log.warn(\"unsupported xfml version: \" + version); string mapurl = atts.getvalue(\"url\"); if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> -------------------------------------------------------- else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname)) keep_content = true; } catch (runtimeexception e) { e.printstacktrace(); throw e; } }","classification":"NONSATD","isFinished":true,"code_context_2":"((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) {","code_context_10":"string mapurl = atts.getvalue(\"url\"); if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\");","code_context_20":"public void startelement (string uri, string name, string qname, attributes atts) throws saxexception { try { \/\/log.debug(\"s: '\" + uri + \"' \" + qname); \/\/ ----- <xfml> ----------------------------------------------------------- if (el_xfml.equals(qname)) { string version = atts.getvalue(\"version\"); if (version == null) log.warn(\"no version attribute on 'xfml' element\"); if (!\"1.0\".equals(version)) log.warn(\"unsupported xfml version: \" + version); string mapurl = atts.getvalue(\"url\"); if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic();","repo":"ontopia\/ontopia"}
{"id":14220,"comment_id":2,"comment":"\/\/ fixme: what to do about language?","code":"@override public void startelement (string uri, string name, string qname, attributes atts) throws saxexception { try { \/\/log.debug(\"s: '\" + uri + \"' \" + qname); \/\/ ----- <xfml> ----------------------------------------------------------- if (el_xfml.equals(qname)) { string version = atts.getvalue(\"version\"); if (version == null) log.warn(\"no version attribute on 'xfml' element\"); if (!\"1.0\".equals(version)) log.warn(\"unsupported xfml version: \" + version); string mapurl = atts.getvalue(\"url\"); if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> -------------------------------------------------------- else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname)) keep_content = true; } catch (runtimeexception e) { e.printstacktrace(); throw e; } }","classification":"DEFECT","isFinished":true,"code_context_2":"} } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ----------------------------------------------------------","code_context_10":"topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ----------------------------------------------------------","code_context_20":"if (version == null) log.warn(\"no version attribute on 'xfml' element\"); if (!\"1.0\".equals(version)) log.warn(\"unsupported xfml version: \" + version); string mapurl = atts.getvalue(\"url\"); if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid);","repo":"ontopia\/ontopia"}
{"id":14220,"comment_id":3,"comment":"\/\/ ----- <facet> ----------------------------------------------------------","code":"@override public void startelement (string uri, string name, string qname, attributes atts) throws saxexception { try { \/\/log.debug(\"s: '\" + uri + \"' \" + qname); \/\/ ----- <xfml> ----------------------------------------------------------- if (el_xfml.equals(qname)) { string version = atts.getvalue(\"version\"); if (version == null) log.warn(\"no version attribute on 'xfml' element\"); if (!\"1.0\".equals(version)) log.warn(\"unsupported xfml version: \" + version); string mapurl = atts.getvalue(\"url\"); if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> -------------------------------------------------------- else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname)) keep_content = true; } catch (runtimeexception e) { e.printstacktrace(); throw e; } }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\");","code_context_10":"((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\");","code_context_20":"if (!\"1.0\".equals(version)) log.warn(\"unsupported xfml version: \" + version); string mapurl = atts.getvalue(\"url\"); if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); }","repo":"ontopia\/ontopia"}
{"id":14220,"comment_id":4,"comment":"\/\/ fixme: complain if no id","code":"@override public void startelement (string uri, string name, string qname, attributes atts) throws saxexception { try { \/\/log.debug(\"s: '\" + uri + \"' \" + qname); \/\/ ----- <xfml> ----------------------------------------------------------- if (el_xfml.equals(qname)) { string version = atts.getvalue(\"version\"); if (version == null) log.warn(\"no version attribute on 'xfml' element\"); if (!\"1.0\".equals(version)) log.warn(\"unsupported xfml version: \" + version); string mapurl = atts.getvalue(\"url\"); if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> -------------------------------------------------------- else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname)) keep_content = true; } catch (runtimeexception e) { e.printstacktrace(); throw e; } }","classification":"DEFECT","isFinished":true,"code_context_2":"else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id);","code_context_10":"processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id);","code_context_20":"if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\");","repo":"ontopia\/ontopia"}
{"id":14220,"comment_id":5,"comment":"\/\/ ----- <topic> ----------------------------------------------------------","code":"@override public void startelement (string uri, string name, string qname, attributes atts) throws saxexception { try { \/\/log.debug(\"s: '\" + uri + \"' \" + qname); \/\/ ----- <xfml> ----------------------------------------------------------- if (el_xfml.equals(qname)) { string version = atts.getvalue(\"version\"); if (version == null) log.warn(\"no version attribute on 'xfml' element\"); if (!\"1.0\".equals(version)) log.warn(\"unsupported xfml version: \" + version); string mapurl = atts.getvalue(\"url\"); if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> -------------------------------------------------------- else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname)) keep_content = true; } catch (runtimeexception e) { e.printstacktrace(); throw e; } }","classification":"NONSATD","isFinished":true,"code_context_2":"keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\");","code_context_10":"\/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid);","code_context_20":"topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------","repo":"ontopia\/ontopia"}
{"id":14220,"comment_id":6,"comment":"\/\/ fixme: complain if no id","code":"@override public void startelement (string uri, string name, string qname, attributes atts) throws saxexception { try { \/\/log.debug(\"s: '\" + uri + \"' \" + qname); \/\/ ----- <xfml> ----------------------------------------------------------- if (el_xfml.equals(qname)) { string version = atts.getvalue(\"version\"); if (version == null) log.warn(\"no version attribute on 'xfml' element\"); if (!\"1.0\".equals(version)) log.warn(\"unsupported xfml version: \" + version); string mapurl = atts.getvalue(\"url\"); if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> -------------------------------------------------------- else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname)) keep_content = true; } catch (runtimeexception e) { e.printstacktrace(); throw e; } }","classification":"DEFECT","isFinished":true,"code_context_2":"else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id);","code_context_10":"processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id);","code_context_20":"if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\");","repo":"ontopia\/ontopia"}
{"id":14220,"comment_id":7,"comment":"\/\/ fixme: complain if no refs","code":"@override public void startelement (string uri, string name, string qname, attributes atts) throws saxexception { try { \/\/log.debug(\"s: '\" + uri + \"' \" + qname); \/\/ ----- <xfml> ----------------------------------------------------------- if (el_xfml.equals(qname)) { string version = atts.getvalue(\"version\"); if (version == null) log.warn(\"no version attribute on 'xfml' element\"); if (!\"1.0\".equals(version)) log.warn(\"unsupported xfml version: \" + version); string mapurl = atts.getvalue(\"url\"); if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> -------------------------------------------------------- else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname)) keep_content = true; } catch (runtimeexception e) { e.printstacktrace(); throw e; } }","classification":"DEFECT","isFinished":true,"code_context_2":"if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic);","code_context_10":"} \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); }","code_context_20":"} \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ----------------------------------------------------","repo":"ontopia\/ontopia"}
{"id":14220,"comment_id":8,"comment":"\/\/ ----- <page> -----------------------------------------------------------","code":"@override public void startelement (string uri, string name, string qname, attributes atts) throws saxexception { try { \/\/log.debug(\"s: '\" + uri + \"' \" + qname); \/\/ ----- <xfml> ----------------------------------------------------------- if (el_xfml.equals(qname)) { string version = atts.getvalue(\"version\"); if (version == null) log.warn(\"no version attribute on 'xfml' element\"); if (!\"1.0\".equals(version)) log.warn(\"unsupported xfml version: \" + version); string mapurl = atts.getvalue(\"url\"); if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> -------------------------------------------------------- else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname)) keep_content = true; } catch (runtimeexception e) { e.printstacktrace(); throw e; } }","classification":"NONSATD","isFinished":true,"code_context_2":"parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\");","code_context_10":"\/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none","code_context_20":"else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> -------------------------------------------------------- else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname))","repo":"ontopia\/ontopia"}
{"id":14220,"comment_id":9,"comment":"\/\/ fixme: complain if no url","code":"@override public void startelement (string uri, string name, string qname, attributes atts) throws saxexception { try { \/\/log.debug(\"s: '\" + uri + \"' \" + qname); \/\/ ----- <xfml> ----------------------------------------------------------- if (el_xfml.equals(qname)) { string version = atts.getvalue(\"version\"); if (version == null) log.warn(\"no version attribute on 'xfml' element\"); if (!\"1.0\".equals(version)) log.warn(\"unsupported xfml version: \" + version); string mapurl = atts.getvalue(\"url\"); if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> -------------------------------------------------------- else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname)) keep_content = true; } catch (runtimeexception e) { e.printstacktrace(); throw e; } }","classification":"DEFECT","isFinished":true,"code_context_2":"else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url));","code_context_10":"string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); }","code_context_20":"current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> -------------------------------------------------------- else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname)) keep_content = true; } catch (runtimeexception e) { e.printstacktrace();","repo":"ontopia\/ontopia"}
{"id":14220,"comment_id":10,"comment":"\/\/ ----- <occurrence>------------------------------------------------------","code":"@override public void startelement (string uri, string name, string qname, attributes atts) throws saxexception { try { \/\/log.debug(\"s: '\" + uri + \"' \" + qname); \/\/ ----- <xfml> ----------------------------------------------------------- if (el_xfml.equals(qname)) { string version = atts.getvalue(\"version\"); if (version == null) log.warn(\"no version attribute on 'xfml' element\"); if (!\"1.0\".equals(version)) log.warn(\"unsupported xfml version: \" + version); string mapurl = atts.getvalue(\"url\"); if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> -------------------------------------------------------- else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname)) keep_content = true; } catch (runtimeexception e) { e.printstacktrace(); throw e; } }","classification":"NONSATD","isFinished":true,"code_context_2":"current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\");","code_context_10":"topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ----------------------------------------------------------","code_context_20":"\/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> -------------------------------------------------------- else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname)) keep_content = true; } catch (runtimeexception e) { e.printstacktrace(); throw e; } }","repo":"ontopia\/ontopia"}
{"id":14220,"comment_id":11,"comment":"\/\/ fixme: complain if none","code":"@override public void startelement (string uri, string name, string qname, attributes atts) throws saxexception { try { \/\/log.debug(\"s: '\" + uri + \"' \" + qname); \/\/ ----- <xfml> ----------------------------------------------------------- if (el_xfml.equals(qname)) { string version = atts.getvalue(\"version\"); if (version == null) log.warn(\"no version attribute on 'xfml' element\"); if (!\"1.0\".equals(version)) log.warn(\"unsupported xfml version: \" + version); string mapurl = atts.getvalue(\"url\"); if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> -------------------------------------------------------- else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname)) keep_content = true; } catch (runtimeexception e) { e.printstacktrace(); throw e; } }","classification":"DESIGN","isFinished":true,"code_context_2":"else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic);","code_context_10":"\/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> -------------------------------------------------------- else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname))","code_context_20":"\/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> -------------------------------------------------------- else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname)) keep_content = true; } catch (runtimeexception e) { e.printstacktrace(); throw e; } }","repo":"ontopia\/ontopia"}
{"id":14220,"comment_id":12,"comment":"\/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> --------------------------------------------------------","code":"@override public void startelement (string uri, string name, string qname, attributes atts) throws saxexception { try { \/\/log.debug(\"s: '\" + uri + \"' \" + qname); \/\/ ----- <xfml> ----------------------------------------------------------- if (el_xfml.equals(qname)) { string version = atts.getvalue(\"version\"); if (version == null) log.warn(\"no version attribute on 'xfml' element\"); if (!\"1.0\".equals(version)) log.warn(\"unsupported xfml version: \" + version); string mapurl = atts.getvalue(\"url\"); if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; \/\/ add this document to the list of processed documents. processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } \/\/ fixme: what to do about language? } \/\/ ----- <facet> ---------------------------------------------------------- else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } \/\/ ----- <topic> ---------------------------------------------------------- else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); \/\/ fixme: complain if no id current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> -------------------------------------------------------- else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname)) keep_content = true; } catch (runtimeexception e) { e.printstacktrace(); throw e; } }","classification":"NONSATD","isFinished":true,"code_context_2":"occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> -------------------------------------------------------- else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname))","code_context_10":"current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> -------------------------------------------------------- else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname)) keep_content = true; } catch (runtimeexception e) { e.printstacktrace(); throw e; } }","code_context_20":"if (parentid == null) parentid = atts.getvalue(\"facetid\"); \/\/ fixme: complain if no refs topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } \/\/ ----- <page> ----------------------------------------------------------- else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); \/\/ fixme: complain if no url current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } \/\/ ----- <occurrence>------------------------------------------------------ else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); \/\/ fixme: complain if none topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } \/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> -------------------------------------------------------- else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname)) keep_content = true; } catch (runtimeexception e) { e.printstacktrace(); throw e; } }","repo":"ontopia\/ontopia"}
{"id":22550,"comment_id":0,"comment":"\/** * remove element from the queue * @return element *\/","code":"\/** * remove element from the queue * @return element *\/ public t dequeue(){ \/\/todo resolve queue with single element t result = current.get(); current = current.next(); return result; }","classification":"NONSATD","isFinished":true,"code_context_2":"public t dequeue(){ \/\/todo resolve queue with single element t result = current.get(); current = current.next(); return result; }","code_context_10":"public t dequeue(){ \/\/todo resolve queue with single element t result = current.get(); current = current.next(); return result; }","code_context_20":"public t dequeue(){ \/\/todo resolve queue with single element t result = current.get(); current = current.next(); return result; }","repo":"pcordemans\/exampleAlgorithms"}
{"id":22550,"comment_id":1,"comment":"\/\/todo resolve queue with single element","code":"public t dequeue(){ \/\/todo resolve queue with single element t result = current.get(); current = current.next(); return result; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"public t dequeue(){ \/\/todo resolve queue with single element t result = current.get(); current = current.next();","code_context_10":"public t dequeue(){ \/\/todo resolve queue with single element t result = current.get(); current = current.next(); return result; }","code_context_20":"public t dequeue(){ \/\/todo resolve queue with single element t result = current.get(); current = current.next(); return result; }","repo":"pcordemans\/exampleAlgorithms"}
{"id":22632,"comment_id":0,"comment":"\/\/ if(new file(item.second).isabsolute()){","code":"public void copyresourcestocacheifrequired1(activity activity){ if( contextcompat.checkselfpermission(activity, manifest.permission.write_external_storage) != packagemanager.permission_granted ) return; string sigfilepath = resfolderpath + \"\/sarvamoola\/aitareya.txt\"; file sigfile = new file(sigfilepath); if(!sigfile.exists()) { for (pair<string, string> item : mfilestocopy) { string filename ; if(item.first.indexof('\/')!= -1) filename = item.first.substring(item.first.lastindexof(\"\/\")+1); else filename = item.first; string desturl = resfolderpath; if(!item.second.isempty()) { \/\/ if(new file(item.second).isabsolute()){ if(file.separator.equals(item.second.substring(0,1))){ \/\/ shortcut to check isabsolute() \/\/ its an absolute url. set the desturl to empty so that item.second is taken as is desturl = \"\"; } desturl = desturl + item.second + '\/'; } desturl = desturl + filename; copyfile(item.first, desturl); } } }","classification":"NONSATD","isFinished":true,"code_context_2":"string desturl = resfolderpath; if(!item.second.isempty()) { \/\/ if(new file(item.second).isabsolute()){ if(file.separator.equals(item.second.substring(0,1))){ \/\/ shortcut to check isabsolute() \/\/ its an absolute url. set the desturl to empty so that item.second is taken as is","code_context_10":"if(!sigfile.exists()) { for (pair<string, string> item : mfilestocopy) { string filename ; if(item.first.indexof('\/')!= -1) filename = item.first.substring(item.first.lastindexof(\"\/\")+1); else filename = item.first; string desturl = resfolderpath; if(!item.second.isempty()) { \/\/ if(new file(item.second).isabsolute()){ if(file.separator.equals(item.second.substring(0,1))){ \/\/ shortcut to check isabsolute() \/\/ its an absolute url. set the desturl to empty so that item.second is taken as is desturl = \"\"; } desturl = desturl + item.second + '\/'; } desturl = desturl + filename; copyfile(item.first, desturl); } }","code_context_20":"public void copyresourcestocacheifrequired1(activity activity){ if( contextcompat.checkselfpermission(activity, manifest.permission.write_external_storage) != packagemanager.permission_granted ) return; string sigfilepath = resfolderpath + \"\/sarvamoola\/aitareya.txt\"; file sigfile = new file(sigfilepath); if(!sigfile.exists()) { for (pair<string, string> item : mfilestocopy) { string filename ; if(item.first.indexof('\/')!= -1) filename = item.first.substring(item.first.lastindexof(\"\/\")+1); else filename = item.first; string desturl = resfolderpath; if(!item.second.isempty()) { \/\/ if(new file(item.second).isabsolute()){ if(file.separator.equals(item.second.substring(0,1))){ \/\/ shortcut to check isabsolute() \/\/ its an absolute url. set the desturl to empty so that item.second is taken as is desturl = \"\"; } desturl = desturl + item.second + '\/'; } desturl = desturl + filename; copyfile(item.first, desturl); } } }","repo":"openmuthu\/jaya"}
{"id":22632,"comment_id":1,"comment":"\/\/ shortcut to check isabsolute()","code":"public void copyresourcestocacheifrequired1(activity activity){ if( contextcompat.checkselfpermission(activity, manifest.permission.write_external_storage) != packagemanager.permission_granted ) return; string sigfilepath = resfolderpath + \"\/sarvamoola\/aitareya.txt\"; file sigfile = new file(sigfilepath); if(!sigfile.exists()) { for (pair<string, string> item : mfilestocopy) { string filename ; if(item.first.indexof('\/')!= -1) filename = item.first.substring(item.first.lastindexof(\"\/\")+1); else filename = item.first; string desturl = resfolderpath; if(!item.second.isempty()) { \/\/ if(new file(item.second).isabsolute()){ if(file.separator.equals(item.second.substring(0,1))){ \/\/ shortcut to check isabsolute() \/\/ its an absolute url. set the desturl to empty so that item.second is taken as is desturl = \"\"; } desturl = desturl + item.second + '\/'; } desturl = desturl + filename; copyfile(item.first, desturl); } } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"if(!item.second.isempty()) { \/\/ if(new file(item.second).isabsolute()){ if(file.separator.equals(item.second.substring(0,1))){ \/\/ shortcut to check isabsolute() \/\/ its an absolute url. set the desturl to empty so that item.second is taken as is desturl = \"\";","code_context_10":"{ for (pair<string, string> item : mfilestocopy) { string filename ; if(item.first.indexof('\/')!= -1) filename = item.first.substring(item.first.lastindexof(\"\/\")+1); else filename = item.first; string desturl = resfolderpath; if(!item.second.isempty()) { \/\/ if(new file(item.second).isabsolute()){ if(file.separator.equals(item.second.substring(0,1))){ \/\/ shortcut to check isabsolute() \/\/ its an absolute url. set the desturl to empty so that item.second is taken as is desturl = \"\"; } desturl = desturl + item.second + '\/'; } desturl = desturl + filename; copyfile(item.first, desturl); } } }","code_context_20":"public void copyresourcestocacheifrequired1(activity activity){ if( contextcompat.checkselfpermission(activity, manifest.permission.write_external_storage) != packagemanager.permission_granted ) return; string sigfilepath = resfolderpath + \"\/sarvamoola\/aitareya.txt\"; file sigfile = new file(sigfilepath); if(!sigfile.exists()) { for (pair<string, string> item : mfilestocopy) { string filename ; if(item.first.indexof('\/')!= -1) filename = item.first.substring(item.first.lastindexof(\"\/\")+1); else filename = item.first; string desturl = resfolderpath; if(!item.second.isempty()) { \/\/ if(new file(item.second).isabsolute()){ if(file.separator.equals(item.second.substring(0,1))){ \/\/ shortcut to check isabsolute() \/\/ its an absolute url. set the desturl to empty so that item.second is taken as is desturl = \"\"; } desturl = desturl + item.second + '\/'; } desturl = desturl + filename; copyfile(item.first, desturl); } } }","repo":"openmuthu\/jaya"}
{"id":22632,"comment_id":2,"comment":"\/\/ its an absolute url. set the desturl to empty so that item.second is taken as is","code":"public void copyresourcestocacheifrequired1(activity activity){ if( contextcompat.checkselfpermission(activity, manifest.permission.write_external_storage) != packagemanager.permission_granted ) return; string sigfilepath = resfolderpath + \"\/sarvamoola\/aitareya.txt\"; file sigfile = new file(sigfilepath); if(!sigfile.exists()) { for (pair<string, string> item : mfilestocopy) { string filename ; if(item.first.indexof('\/')!= -1) filename = item.first.substring(item.first.lastindexof(\"\/\")+1); else filename = item.first; string desturl = resfolderpath; if(!item.second.isempty()) { \/\/ if(new file(item.second).isabsolute()){ if(file.separator.equals(item.second.substring(0,1))){ \/\/ shortcut to check isabsolute() \/\/ its an absolute url. set the desturl to empty so that item.second is taken as is desturl = \"\"; } desturl = desturl + item.second + '\/'; } desturl = desturl + filename; copyfile(item.first, desturl); } } }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ if(new file(item.second).isabsolute()){ if(file.separator.equals(item.second.substring(0,1))){ \/\/ shortcut to check isabsolute() \/\/ its an absolute url. set the desturl to empty so that item.second is taken as is desturl = \"\"; }","code_context_10":"for (pair<string, string> item : mfilestocopy) { string filename ; if(item.first.indexof('\/')!= -1) filename = item.first.substring(item.first.lastindexof(\"\/\")+1); else filename = item.first; string desturl = resfolderpath; if(!item.second.isempty()) { \/\/ if(new file(item.second).isabsolute()){ if(file.separator.equals(item.second.substring(0,1))){ \/\/ shortcut to check isabsolute() \/\/ its an absolute url. set the desturl to empty so that item.second is taken as is desturl = \"\"; } desturl = desturl + item.second + '\/'; } desturl = desturl + filename; copyfile(item.first, desturl); } } }","code_context_20":"public void copyresourcestocacheifrequired1(activity activity){ if( contextcompat.checkselfpermission(activity, manifest.permission.write_external_storage) != packagemanager.permission_granted ) return; string sigfilepath = resfolderpath + \"\/sarvamoola\/aitareya.txt\"; file sigfile = new file(sigfilepath); if(!sigfile.exists()) { for (pair<string, string> item : mfilestocopy) { string filename ; if(item.first.indexof('\/')!= -1) filename = item.first.substring(item.first.lastindexof(\"\/\")+1); else filename = item.first; string desturl = resfolderpath; if(!item.second.isempty()) { \/\/ if(new file(item.second).isabsolute()){ if(file.separator.equals(item.second.substring(0,1))){ \/\/ shortcut to check isabsolute() \/\/ its an absolute url. set the desturl to empty so that item.second is taken as is desturl = \"\"; } desturl = desturl + item.second + '\/'; } desturl = desturl + filename; copyfile(item.first, desturl); } } }","repo":"openmuthu\/jaya"}
{"id":14534,"comment_id":0,"comment":"\/\/ todo: handle pinprotocol != 1 somehow","code":"public rawmessage handlecborrequest(channelid channelid, byte[] payload) { if (payload.length == 0) { return rawmessage.error(channelid, hiderror.invalid_len); } ctap2method method = ctap2method.from(payload[0]); byte[] params = new byte[payload.length - 1]; system.arraycopy(payload, 1, params, 0, payload.length - 1); try { log.debug(\"received cbor request with method {} and body {}\", method, cbordecoder.decode(params)); } catch (cborexception e) { log.error(\"unable to deserialize cbor parameters\", e); return failure(channelid, ctap2responsecode.invalid_cbor); } try { switch (method) { case get_assertion: getassertionrequest gar = getassertionrequest.frombytes(params); byte[] assertion = authenticator.getassertion(gar) .handleerror(err -> aspayload(err, collections.emptylist())) .elseget(value -> aspayload(ctap2responsecode.ok, value.ascbormap())); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(assertion) .build(); case get_info: getinforesponse response = authenticator.getinfo(); log.trace(\"authenticator supports options {}\", response); byte[] info = aspayload(ctap2responsecode.ok, response.ascbormap()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(info) .build(); case make_credential: makecredentialrequest request = makecredentialrequest.frombytes(params); result<makecredentialresponse, ctap2responsecode> result = authenticator.makecredential(request.clientdatahash(), request.relayingpartyid(), request.userid(), request.supportedalgorithmids(), request.pinauth()); byte[] credential = result .handleerror(err -> aspayload(err, collections.emptylist())) .elseget(value -> aspayload(ctap2responsecode.ok, value.ascbormap())); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(credential) .build(); case client_pin: map pinparams = (map) cbordecoder.decode(params).get(0); unsignedinteger pinprotocol = (unsignedinteger) pinparams.get(new unsignedinteger(0x01)); \/\/ todo: handle pinprotocol != 1 somehow unsignedinteger subcommand = (unsignedinteger) pinparams.get(new unsignedinteger(0x02)); switch(subcommand.getvalue().intvalue()) { case 0x01: \/\/ get retries list<dataitem> retries = pinrequesthandler.getretries(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, retries)) .build(); case 0x02: \/\/ get key list<dataitem> key = pinrequesthandler.getkeyagreementkey(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, key)) .build(); case 0x03: \/\/ set pin map hostcosekey = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc = (bytestring) pinparams.get(new unsignedinteger(0x05)); ctap2responsecode code = pinrequesthandler.setpin(hostcosekey, newpinenc.getbytes(), pinauth.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code, collections.emptylist())) .build(); case 0x04: \/\/ change pin map hostcosekey2 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth2 = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc2 = (bytestring) pinparams.get(new unsignedinteger(0x05)); bytestring pinhashenc = (bytestring) pinparams.get(new unsignedinteger(0x06)); ctap2responsecode code2 = pinrequesthandler.changepin(hostcosekey2, pinhashenc.getbytes(), newpinenc2.getbytes(), pinauth2.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code2, collections.emptylist())) .build(); case 0x05: \/\/ get pin token map hostcosekey3 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinhashenc2 = (bytestring) pinparams.get(new unsignedinteger(0x06)); result<list<dataitem>, ctap2responsecode> pintoken = pinrequesthandler.getpintoken(hostcosekey3, pinhashenc2.getbytes()); byte[] pintokenpayload = pintoken.handleerror(err -> aspayload(err, collections.emptylist())) .elseget(val -> aspayload(ctap2responsecode.ok, val)); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(pintokenpayload) .build(); } break; case reset: case get_next_assertion: default: return rawmessage.error(channelid, hiderror.invalid_cmd); } } catch (cborexception e) { log.error(\"unable to deserialize cbor\", e); } return failure(channelid, ctap2responsecode.invalid_cbor); }","classification":"DESIGN","isFinished":true,"code_context_2":"map pinparams = (map) cbordecoder.decode(params).get(0); unsignedinteger pinprotocol = (unsignedinteger) pinparams.get(new unsignedinteger(0x01)); \/\/ todo: handle pinprotocol != 1 somehow unsignedinteger subcommand = (unsignedinteger) pinparams.get(new unsignedinteger(0x02)); switch(subcommand.getvalue().intvalue()) {","code_context_10":".handleerror(err -> aspayload(err, collections.emptylist())) .elseget(value -> aspayload(ctap2responsecode.ok, value.ascbormap())); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(credential) .build(); case client_pin: map pinparams = (map) cbordecoder.decode(params).get(0); unsignedinteger pinprotocol = (unsignedinteger) pinparams.get(new unsignedinteger(0x01)); \/\/ todo: handle pinprotocol != 1 somehow unsignedinteger subcommand = (unsignedinteger) pinparams.get(new unsignedinteger(0x02)); switch(subcommand.getvalue().intvalue()) { case 0x01: \/\/ get retries list<dataitem> retries = pinrequesthandler.getretries(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, retries)) .build(); case 0x02: \/\/ get key","code_context_20":"return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(info) .build(); case make_credential: makecredentialrequest request = makecredentialrequest.frombytes(params); result<makecredentialresponse, ctap2responsecode> result = authenticator.makecredential(request.clientdatahash(), request.relayingpartyid(), request.userid(), request.supportedalgorithmids(), request.pinauth()); byte[] credential = result .handleerror(err -> aspayload(err, collections.emptylist())) .elseget(value -> aspayload(ctap2responsecode.ok, value.ascbormap())); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(credential) .build(); case client_pin: map pinparams = (map) cbordecoder.decode(params).get(0); unsignedinteger pinprotocol = (unsignedinteger) pinparams.get(new unsignedinteger(0x01)); \/\/ todo: handle pinprotocol != 1 somehow unsignedinteger subcommand = (unsignedinteger) pinparams.get(new unsignedinteger(0x02)); switch(subcommand.getvalue().intvalue()) { case 0x01: \/\/ get retries list<dataitem> retries = pinrequesthandler.getretries(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, retries)) .build(); case 0x02: \/\/ get key list<dataitem> key = pinrequesthandler.getkeyagreementkey(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, key)) .build(); case 0x03: \/\/ set pin map hostcosekey = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc = (bytestring) pinparams.get(new unsignedinteger(0x05));","repo":"mphi-rc\/pi-zero-security-key"}
{"id":14534,"comment_id":1,"comment":"\/\/ get retries","code":"public rawmessage handlecborrequest(channelid channelid, byte[] payload) { if (payload.length == 0) { return rawmessage.error(channelid, hiderror.invalid_len); } ctap2method method = ctap2method.from(payload[0]); byte[] params = new byte[payload.length - 1]; system.arraycopy(payload, 1, params, 0, payload.length - 1); try { log.debug(\"received cbor request with method {} and body {}\", method, cbordecoder.decode(params)); } catch (cborexception e) { log.error(\"unable to deserialize cbor parameters\", e); return failure(channelid, ctap2responsecode.invalid_cbor); } try { switch (method) { case get_assertion: getassertionrequest gar = getassertionrequest.frombytes(params); byte[] assertion = authenticator.getassertion(gar) .handleerror(err -> aspayload(err, collections.emptylist())) .elseget(value -> aspayload(ctap2responsecode.ok, value.ascbormap())); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(assertion) .build(); case get_info: getinforesponse response = authenticator.getinfo(); log.trace(\"authenticator supports options {}\", response); byte[] info = aspayload(ctap2responsecode.ok, response.ascbormap()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(info) .build(); case make_credential: makecredentialrequest request = makecredentialrequest.frombytes(params); result<makecredentialresponse, ctap2responsecode> result = authenticator.makecredential(request.clientdatahash(), request.relayingpartyid(), request.userid(), request.supportedalgorithmids(), request.pinauth()); byte[] credential = result .handleerror(err -> aspayload(err, collections.emptylist())) .elseget(value -> aspayload(ctap2responsecode.ok, value.ascbormap())); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(credential) .build(); case client_pin: map pinparams = (map) cbordecoder.decode(params).get(0); unsignedinteger pinprotocol = (unsignedinteger) pinparams.get(new unsignedinteger(0x01)); \/\/ todo: handle pinprotocol != 1 somehow unsignedinteger subcommand = (unsignedinteger) pinparams.get(new unsignedinteger(0x02)); switch(subcommand.getvalue().intvalue()) { case 0x01: \/\/ get retries list<dataitem> retries = pinrequesthandler.getretries(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, retries)) .build(); case 0x02: \/\/ get key list<dataitem> key = pinrequesthandler.getkeyagreementkey(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, key)) .build(); case 0x03: \/\/ set pin map hostcosekey = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc = (bytestring) pinparams.get(new unsignedinteger(0x05)); ctap2responsecode code = pinrequesthandler.setpin(hostcosekey, newpinenc.getbytes(), pinauth.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code, collections.emptylist())) .build(); case 0x04: \/\/ change pin map hostcosekey2 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth2 = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc2 = (bytestring) pinparams.get(new unsignedinteger(0x05)); bytestring pinhashenc = (bytestring) pinparams.get(new unsignedinteger(0x06)); ctap2responsecode code2 = pinrequesthandler.changepin(hostcosekey2, pinhashenc.getbytes(), newpinenc2.getbytes(), pinauth2.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code2, collections.emptylist())) .build(); case 0x05: \/\/ get pin token map hostcosekey3 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinhashenc2 = (bytestring) pinparams.get(new unsignedinteger(0x06)); result<list<dataitem>, ctap2responsecode> pintoken = pinrequesthandler.getpintoken(hostcosekey3, pinhashenc2.getbytes()); byte[] pintokenpayload = pintoken.handleerror(err -> aspayload(err, collections.emptylist())) .elseget(val -> aspayload(ctap2responsecode.ok, val)); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(pintokenpayload) .build(); } break; case reset: case get_next_assertion: default: return rawmessage.error(channelid, hiderror.invalid_cmd); } } catch (cborexception e) { log.error(\"unable to deserialize cbor\", e); } return failure(channelid, ctap2responsecode.invalid_cbor); }","classification":"NONSATD","isFinished":true,"code_context_2":"unsignedinteger subcommand = (unsignedinteger) pinparams.get(new unsignedinteger(0x02)); switch(subcommand.getvalue().intvalue()) { case 0x01: \/\/ get retries list<dataitem> retries = pinrequesthandler.getretries(); return immutablerawmessage.builder()","code_context_10":".channelid(channelid) .command(hidcommand.cbor) .payload(credential) .build(); case client_pin: map pinparams = (map) cbordecoder.decode(params).get(0); unsignedinteger pinprotocol = (unsignedinteger) pinparams.get(new unsignedinteger(0x01)); \/\/ todo: handle pinprotocol != 1 somehow unsignedinteger subcommand = (unsignedinteger) pinparams.get(new unsignedinteger(0x02)); switch(subcommand.getvalue().intvalue()) { case 0x01: \/\/ get retries list<dataitem> retries = pinrequesthandler.getretries(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, retries)) .build(); case 0x02: \/\/ get key list<dataitem> key = pinrequesthandler.getkeyagreementkey(); return immutablerawmessage.builder() .channelid(channelid)","code_context_20":".payload(info) .build(); case make_credential: makecredentialrequest request = makecredentialrequest.frombytes(params); result<makecredentialresponse, ctap2responsecode> result = authenticator.makecredential(request.clientdatahash(), request.relayingpartyid(), request.userid(), request.supportedalgorithmids(), request.pinauth()); byte[] credential = result .handleerror(err -> aspayload(err, collections.emptylist())) .elseget(value -> aspayload(ctap2responsecode.ok, value.ascbormap())); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(credential) .build(); case client_pin: map pinparams = (map) cbordecoder.decode(params).get(0); unsignedinteger pinprotocol = (unsignedinteger) pinparams.get(new unsignedinteger(0x01)); \/\/ todo: handle pinprotocol != 1 somehow unsignedinteger subcommand = (unsignedinteger) pinparams.get(new unsignedinteger(0x02)); switch(subcommand.getvalue().intvalue()) { case 0x01: \/\/ get retries list<dataitem> retries = pinrequesthandler.getretries(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, retries)) .build(); case 0x02: \/\/ get key list<dataitem> key = pinrequesthandler.getkeyagreementkey(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, key)) .build(); case 0x03: \/\/ set pin map hostcosekey = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc = (bytestring) pinparams.get(new unsignedinteger(0x05)); ctap2responsecode code = pinrequesthandler.setpin(hostcosekey, newpinenc.getbytes(), pinauth.getbytes()); return immutablerawmessage.builder() .channelid(channelid)","repo":"mphi-rc\/pi-zero-security-key"}
{"id":14534,"comment_id":2,"comment":"\/\/ get key","code":"public rawmessage handlecborrequest(channelid channelid, byte[] payload) { if (payload.length == 0) { return rawmessage.error(channelid, hiderror.invalid_len); } ctap2method method = ctap2method.from(payload[0]); byte[] params = new byte[payload.length - 1]; system.arraycopy(payload, 1, params, 0, payload.length - 1); try { log.debug(\"received cbor request with method {} and body {}\", method, cbordecoder.decode(params)); } catch (cborexception e) { log.error(\"unable to deserialize cbor parameters\", e); return failure(channelid, ctap2responsecode.invalid_cbor); } try { switch (method) { case get_assertion: getassertionrequest gar = getassertionrequest.frombytes(params); byte[] assertion = authenticator.getassertion(gar) .handleerror(err -> aspayload(err, collections.emptylist())) .elseget(value -> aspayload(ctap2responsecode.ok, value.ascbormap())); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(assertion) .build(); case get_info: getinforesponse response = authenticator.getinfo(); log.trace(\"authenticator supports options {}\", response); byte[] info = aspayload(ctap2responsecode.ok, response.ascbormap()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(info) .build(); case make_credential: makecredentialrequest request = makecredentialrequest.frombytes(params); result<makecredentialresponse, ctap2responsecode> result = authenticator.makecredential(request.clientdatahash(), request.relayingpartyid(), request.userid(), request.supportedalgorithmids(), request.pinauth()); byte[] credential = result .handleerror(err -> aspayload(err, collections.emptylist())) .elseget(value -> aspayload(ctap2responsecode.ok, value.ascbormap())); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(credential) .build(); case client_pin: map pinparams = (map) cbordecoder.decode(params).get(0); unsignedinteger pinprotocol = (unsignedinteger) pinparams.get(new unsignedinteger(0x01)); \/\/ todo: handle pinprotocol != 1 somehow unsignedinteger subcommand = (unsignedinteger) pinparams.get(new unsignedinteger(0x02)); switch(subcommand.getvalue().intvalue()) { case 0x01: \/\/ get retries list<dataitem> retries = pinrequesthandler.getretries(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, retries)) .build(); case 0x02: \/\/ get key list<dataitem> key = pinrequesthandler.getkeyagreementkey(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, key)) .build(); case 0x03: \/\/ set pin map hostcosekey = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc = (bytestring) pinparams.get(new unsignedinteger(0x05)); ctap2responsecode code = pinrequesthandler.setpin(hostcosekey, newpinenc.getbytes(), pinauth.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code, collections.emptylist())) .build(); case 0x04: \/\/ change pin map hostcosekey2 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth2 = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc2 = (bytestring) pinparams.get(new unsignedinteger(0x05)); bytestring pinhashenc = (bytestring) pinparams.get(new unsignedinteger(0x06)); ctap2responsecode code2 = pinrequesthandler.changepin(hostcosekey2, pinhashenc.getbytes(), newpinenc2.getbytes(), pinauth2.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code2, collections.emptylist())) .build(); case 0x05: \/\/ get pin token map hostcosekey3 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinhashenc2 = (bytestring) pinparams.get(new unsignedinteger(0x06)); result<list<dataitem>, ctap2responsecode> pintoken = pinrequesthandler.getpintoken(hostcosekey3, pinhashenc2.getbytes()); byte[] pintokenpayload = pintoken.handleerror(err -> aspayload(err, collections.emptylist())) .elseget(val -> aspayload(ctap2responsecode.ok, val)); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(pintokenpayload) .build(); } break; case reset: case get_next_assertion: default: return rawmessage.error(channelid, hiderror.invalid_cmd); } } catch (cborexception e) { log.error(\"unable to deserialize cbor\", e); } return failure(channelid, ctap2responsecode.invalid_cbor); }","classification":"NONSATD","isFinished":true,"code_context_2":".payload(aspayload(ctap2responsecode.ok, retries)) .build(); case 0x02: \/\/ get key list<dataitem> key = pinrequesthandler.getkeyagreementkey(); return immutablerawmessage.builder()","code_context_10":"\/\/ todo: handle pinprotocol != 1 somehow unsignedinteger subcommand = (unsignedinteger) pinparams.get(new unsignedinteger(0x02)); switch(subcommand.getvalue().intvalue()) { case 0x01: \/\/ get retries list<dataitem> retries = pinrequesthandler.getretries(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, retries)) .build(); case 0x02: \/\/ get key list<dataitem> key = pinrequesthandler.getkeyagreementkey(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, key)) .build(); case 0x03: \/\/ set pin map hostcosekey = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc = (bytestring) pinparams.get(new unsignedinteger(0x05));","code_context_20":".handleerror(err -> aspayload(err, collections.emptylist())) .elseget(value -> aspayload(ctap2responsecode.ok, value.ascbormap())); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(credential) .build(); case client_pin: map pinparams = (map) cbordecoder.decode(params).get(0); unsignedinteger pinprotocol = (unsignedinteger) pinparams.get(new unsignedinteger(0x01)); \/\/ todo: handle pinprotocol != 1 somehow unsignedinteger subcommand = (unsignedinteger) pinparams.get(new unsignedinteger(0x02)); switch(subcommand.getvalue().intvalue()) { case 0x01: \/\/ get retries list<dataitem> retries = pinrequesthandler.getretries(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, retries)) .build(); case 0x02: \/\/ get key list<dataitem> key = pinrequesthandler.getkeyagreementkey(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, key)) .build(); case 0x03: \/\/ set pin map hostcosekey = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc = (bytestring) pinparams.get(new unsignedinteger(0x05)); ctap2responsecode code = pinrequesthandler.setpin(hostcosekey, newpinenc.getbytes(), pinauth.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code, collections.emptylist())) .build(); case 0x04: \/\/ change pin map hostcosekey2 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth2 = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc2 = (bytestring) pinparams.get(new unsignedinteger(0x05));","repo":"mphi-rc\/pi-zero-security-key"}
{"id":14534,"comment_id":3,"comment":"\/\/ set pin","code":"public rawmessage handlecborrequest(channelid channelid, byte[] payload) { if (payload.length == 0) { return rawmessage.error(channelid, hiderror.invalid_len); } ctap2method method = ctap2method.from(payload[0]); byte[] params = new byte[payload.length - 1]; system.arraycopy(payload, 1, params, 0, payload.length - 1); try { log.debug(\"received cbor request with method {} and body {}\", method, cbordecoder.decode(params)); } catch (cborexception e) { log.error(\"unable to deserialize cbor parameters\", e); return failure(channelid, ctap2responsecode.invalid_cbor); } try { switch (method) { case get_assertion: getassertionrequest gar = getassertionrequest.frombytes(params); byte[] assertion = authenticator.getassertion(gar) .handleerror(err -> aspayload(err, collections.emptylist())) .elseget(value -> aspayload(ctap2responsecode.ok, value.ascbormap())); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(assertion) .build(); case get_info: getinforesponse response = authenticator.getinfo(); log.trace(\"authenticator supports options {}\", response); byte[] info = aspayload(ctap2responsecode.ok, response.ascbormap()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(info) .build(); case make_credential: makecredentialrequest request = makecredentialrequest.frombytes(params); result<makecredentialresponse, ctap2responsecode> result = authenticator.makecredential(request.clientdatahash(), request.relayingpartyid(), request.userid(), request.supportedalgorithmids(), request.pinauth()); byte[] credential = result .handleerror(err -> aspayload(err, collections.emptylist())) .elseget(value -> aspayload(ctap2responsecode.ok, value.ascbormap())); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(credential) .build(); case client_pin: map pinparams = (map) cbordecoder.decode(params).get(0); unsignedinteger pinprotocol = (unsignedinteger) pinparams.get(new unsignedinteger(0x01)); \/\/ todo: handle pinprotocol != 1 somehow unsignedinteger subcommand = (unsignedinteger) pinparams.get(new unsignedinteger(0x02)); switch(subcommand.getvalue().intvalue()) { case 0x01: \/\/ get retries list<dataitem> retries = pinrequesthandler.getretries(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, retries)) .build(); case 0x02: \/\/ get key list<dataitem> key = pinrequesthandler.getkeyagreementkey(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, key)) .build(); case 0x03: \/\/ set pin map hostcosekey = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc = (bytestring) pinparams.get(new unsignedinteger(0x05)); ctap2responsecode code = pinrequesthandler.setpin(hostcosekey, newpinenc.getbytes(), pinauth.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code, collections.emptylist())) .build(); case 0x04: \/\/ change pin map hostcosekey2 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth2 = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc2 = (bytestring) pinparams.get(new unsignedinteger(0x05)); bytestring pinhashenc = (bytestring) pinparams.get(new unsignedinteger(0x06)); ctap2responsecode code2 = pinrequesthandler.changepin(hostcosekey2, pinhashenc.getbytes(), newpinenc2.getbytes(), pinauth2.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code2, collections.emptylist())) .build(); case 0x05: \/\/ get pin token map hostcosekey3 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinhashenc2 = (bytestring) pinparams.get(new unsignedinteger(0x06)); result<list<dataitem>, ctap2responsecode> pintoken = pinrequesthandler.getpintoken(hostcosekey3, pinhashenc2.getbytes()); byte[] pintokenpayload = pintoken.handleerror(err -> aspayload(err, collections.emptylist())) .elseget(val -> aspayload(ctap2responsecode.ok, val)); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(pintokenpayload) .build(); } break; case reset: case get_next_assertion: default: return rawmessage.error(channelid, hiderror.invalid_cmd); } } catch (cborexception e) { log.error(\"unable to deserialize cbor\", e); } return failure(channelid, ctap2responsecode.invalid_cbor); }","classification":"NONSATD","isFinished":true,"code_context_2":".payload(aspayload(ctap2responsecode.ok, key)) .build(); case 0x03: \/\/ set pin map hostcosekey = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth = (bytestring) pinparams.get(new unsignedinteger(0x04));","code_context_10":".command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, retries)) .build(); case 0x02: \/\/ get key list<dataitem> key = pinrequesthandler.getkeyagreementkey(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, key)) .build(); case 0x03: \/\/ set pin map hostcosekey = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc = (bytestring) pinparams.get(new unsignedinteger(0x05)); ctap2responsecode code = pinrequesthandler.setpin(hostcosekey, newpinenc.getbytes(), pinauth.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code, collections.emptylist())) .build(); case 0x04: \/\/ change pin","code_context_20":"case client_pin: map pinparams = (map) cbordecoder.decode(params).get(0); unsignedinteger pinprotocol = (unsignedinteger) pinparams.get(new unsignedinteger(0x01)); \/\/ todo: handle pinprotocol != 1 somehow unsignedinteger subcommand = (unsignedinteger) pinparams.get(new unsignedinteger(0x02)); switch(subcommand.getvalue().intvalue()) { case 0x01: \/\/ get retries list<dataitem> retries = pinrequesthandler.getretries(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, retries)) .build(); case 0x02: \/\/ get key list<dataitem> key = pinrequesthandler.getkeyagreementkey(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, key)) .build(); case 0x03: \/\/ set pin map hostcosekey = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc = (bytestring) pinparams.get(new unsignedinteger(0x05)); ctap2responsecode code = pinrequesthandler.setpin(hostcosekey, newpinenc.getbytes(), pinauth.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code, collections.emptylist())) .build(); case 0x04: \/\/ change pin map hostcosekey2 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth2 = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc2 = (bytestring) pinparams.get(new unsignedinteger(0x05)); bytestring pinhashenc = (bytestring) pinparams.get(new unsignedinteger(0x06)); ctap2responsecode code2 = pinrequesthandler.changepin(hostcosekey2, pinhashenc.getbytes(), newpinenc2.getbytes(), pinauth2.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code2, collections.emptylist())) .build();","repo":"mphi-rc\/pi-zero-security-key"}
{"id":14534,"comment_id":4,"comment":"\/\/ change pin","code":"public rawmessage handlecborrequest(channelid channelid, byte[] payload) { if (payload.length == 0) { return rawmessage.error(channelid, hiderror.invalid_len); } ctap2method method = ctap2method.from(payload[0]); byte[] params = new byte[payload.length - 1]; system.arraycopy(payload, 1, params, 0, payload.length - 1); try { log.debug(\"received cbor request with method {} and body {}\", method, cbordecoder.decode(params)); } catch (cborexception e) { log.error(\"unable to deserialize cbor parameters\", e); return failure(channelid, ctap2responsecode.invalid_cbor); } try { switch (method) { case get_assertion: getassertionrequest gar = getassertionrequest.frombytes(params); byte[] assertion = authenticator.getassertion(gar) .handleerror(err -> aspayload(err, collections.emptylist())) .elseget(value -> aspayload(ctap2responsecode.ok, value.ascbormap())); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(assertion) .build(); case get_info: getinforesponse response = authenticator.getinfo(); log.trace(\"authenticator supports options {}\", response); byte[] info = aspayload(ctap2responsecode.ok, response.ascbormap()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(info) .build(); case make_credential: makecredentialrequest request = makecredentialrequest.frombytes(params); result<makecredentialresponse, ctap2responsecode> result = authenticator.makecredential(request.clientdatahash(), request.relayingpartyid(), request.userid(), request.supportedalgorithmids(), request.pinauth()); byte[] credential = result .handleerror(err -> aspayload(err, collections.emptylist())) .elseget(value -> aspayload(ctap2responsecode.ok, value.ascbormap())); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(credential) .build(); case client_pin: map pinparams = (map) cbordecoder.decode(params).get(0); unsignedinteger pinprotocol = (unsignedinteger) pinparams.get(new unsignedinteger(0x01)); \/\/ todo: handle pinprotocol != 1 somehow unsignedinteger subcommand = (unsignedinteger) pinparams.get(new unsignedinteger(0x02)); switch(subcommand.getvalue().intvalue()) { case 0x01: \/\/ get retries list<dataitem> retries = pinrequesthandler.getretries(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, retries)) .build(); case 0x02: \/\/ get key list<dataitem> key = pinrequesthandler.getkeyagreementkey(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, key)) .build(); case 0x03: \/\/ set pin map hostcosekey = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc = (bytestring) pinparams.get(new unsignedinteger(0x05)); ctap2responsecode code = pinrequesthandler.setpin(hostcosekey, newpinenc.getbytes(), pinauth.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code, collections.emptylist())) .build(); case 0x04: \/\/ change pin map hostcosekey2 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth2 = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc2 = (bytestring) pinparams.get(new unsignedinteger(0x05)); bytestring pinhashenc = (bytestring) pinparams.get(new unsignedinteger(0x06)); ctap2responsecode code2 = pinrequesthandler.changepin(hostcosekey2, pinhashenc.getbytes(), newpinenc2.getbytes(), pinauth2.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code2, collections.emptylist())) .build(); case 0x05: \/\/ get pin token map hostcosekey3 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinhashenc2 = (bytestring) pinparams.get(new unsignedinteger(0x06)); result<list<dataitem>, ctap2responsecode> pintoken = pinrequesthandler.getpintoken(hostcosekey3, pinhashenc2.getbytes()); byte[] pintokenpayload = pintoken.handleerror(err -> aspayload(err, collections.emptylist())) .elseget(val -> aspayload(ctap2responsecode.ok, val)); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(pintokenpayload) .build(); } break; case reset: case get_next_assertion: default: return rawmessage.error(channelid, hiderror.invalid_cmd); } } catch (cborexception e) { log.error(\"unable to deserialize cbor\", e); } return failure(channelid, ctap2responsecode.invalid_cbor); }","classification":"NONSATD","isFinished":true,"code_context_2":".payload(aspayload(code, collections.emptylist())) .build(); case 0x04: \/\/ change pin map hostcosekey2 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth2 = (bytestring) pinparams.get(new unsignedinteger(0x04));","code_context_10":"case 0x03: \/\/ set pin map hostcosekey = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc = (bytestring) pinparams.get(new unsignedinteger(0x05)); ctap2responsecode code = pinrequesthandler.setpin(hostcosekey, newpinenc.getbytes(), pinauth.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code, collections.emptylist())) .build(); case 0x04: \/\/ change pin map hostcosekey2 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth2 = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc2 = (bytestring) pinparams.get(new unsignedinteger(0x05)); bytestring pinhashenc = (bytestring) pinparams.get(new unsignedinteger(0x06)); ctap2responsecode code2 = pinrequesthandler.changepin(hostcosekey2, pinhashenc.getbytes(), newpinenc2.getbytes(), pinauth2.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code2, collections.emptylist())) .build();","code_context_20":".command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, retries)) .build(); case 0x02: \/\/ get key list<dataitem> key = pinrequesthandler.getkeyagreementkey(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, key)) .build(); case 0x03: \/\/ set pin map hostcosekey = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc = (bytestring) pinparams.get(new unsignedinteger(0x05)); ctap2responsecode code = pinrequesthandler.setpin(hostcosekey, newpinenc.getbytes(), pinauth.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code, collections.emptylist())) .build(); case 0x04: \/\/ change pin map hostcosekey2 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth2 = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc2 = (bytestring) pinparams.get(new unsignedinteger(0x05)); bytestring pinhashenc = (bytestring) pinparams.get(new unsignedinteger(0x06)); ctap2responsecode code2 = pinrequesthandler.changepin(hostcosekey2, pinhashenc.getbytes(), newpinenc2.getbytes(), pinauth2.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code2, collections.emptylist())) .build(); case 0x05: \/\/ get pin token map hostcosekey3 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinhashenc2 = (bytestring) pinparams.get(new unsignedinteger(0x06)); result<list<dataitem>, ctap2responsecode> pintoken = pinrequesthandler.getpintoken(hostcosekey3, pinhashenc2.getbytes()); byte[] pintokenpayload = pintoken.handleerror(err -> aspayload(err, collections.emptylist())) .elseget(val -> aspayload(ctap2responsecode.ok, val)); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(pintokenpayload)","repo":"mphi-rc\/pi-zero-security-key"}
{"id":14534,"comment_id":5,"comment":"\/\/ get pin token","code":"public rawmessage handlecborrequest(channelid channelid, byte[] payload) { if (payload.length == 0) { return rawmessage.error(channelid, hiderror.invalid_len); } ctap2method method = ctap2method.from(payload[0]); byte[] params = new byte[payload.length - 1]; system.arraycopy(payload, 1, params, 0, payload.length - 1); try { log.debug(\"received cbor request with method {} and body {}\", method, cbordecoder.decode(params)); } catch (cborexception e) { log.error(\"unable to deserialize cbor parameters\", e); return failure(channelid, ctap2responsecode.invalid_cbor); } try { switch (method) { case get_assertion: getassertionrequest gar = getassertionrequest.frombytes(params); byte[] assertion = authenticator.getassertion(gar) .handleerror(err -> aspayload(err, collections.emptylist())) .elseget(value -> aspayload(ctap2responsecode.ok, value.ascbormap())); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(assertion) .build(); case get_info: getinforesponse response = authenticator.getinfo(); log.trace(\"authenticator supports options {}\", response); byte[] info = aspayload(ctap2responsecode.ok, response.ascbormap()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(info) .build(); case make_credential: makecredentialrequest request = makecredentialrequest.frombytes(params); result<makecredentialresponse, ctap2responsecode> result = authenticator.makecredential(request.clientdatahash(), request.relayingpartyid(), request.userid(), request.supportedalgorithmids(), request.pinauth()); byte[] credential = result .handleerror(err -> aspayload(err, collections.emptylist())) .elseget(value -> aspayload(ctap2responsecode.ok, value.ascbormap())); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(credential) .build(); case client_pin: map pinparams = (map) cbordecoder.decode(params).get(0); unsignedinteger pinprotocol = (unsignedinteger) pinparams.get(new unsignedinteger(0x01)); \/\/ todo: handle pinprotocol != 1 somehow unsignedinteger subcommand = (unsignedinteger) pinparams.get(new unsignedinteger(0x02)); switch(subcommand.getvalue().intvalue()) { case 0x01: \/\/ get retries list<dataitem> retries = pinrequesthandler.getretries(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, retries)) .build(); case 0x02: \/\/ get key list<dataitem> key = pinrequesthandler.getkeyagreementkey(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, key)) .build(); case 0x03: \/\/ set pin map hostcosekey = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc = (bytestring) pinparams.get(new unsignedinteger(0x05)); ctap2responsecode code = pinrequesthandler.setpin(hostcosekey, newpinenc.getbytes(), pinauth.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code, collections.emptylist())) .build(); case 0x04: \/\/ change pin map hostcosekey2 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth2 = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc2 = (bytestring) pinparams.get(new unsignedinteger(0x05)); bytestring pinhashenc = (bytestring) pinparams.get(new unsignedinteger(0x06)); ctap2responsecode code2 = pinrequesthandler.changepin(hostcosekey2, pinhashenc.getbytes(), newpinenc2.getbytes(), pinauth2.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code2, collections.emptylist())) .build(); case 0x05: \/\/ get pin token map hostcosekey3 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinhashenc2 = (bytestring) pinparams.get(new unsignedinteger(0x06)); result<list<dataitem>, ctap2responsecode> pintoken = pinrequesthandler.getpintoken(hostcosekey3, pinhashenc2.getbytes()); byte[] pintokenpayload = pintoken.handleerror(err -> aspayload(err, collections.emptylist())) .elseget(val -> aspayload(ctap2responsecode.ok, val)); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(pintokenpayload) .build(); } break; case reset: case get_next_assertion: default: return rawmessage.error(channelid, hiderror.invalid_cmd); } } catch (cborexception e) { log.error(\"unable to deserialize cbor\", e); } return failure(channelid, ctap2responsecode.invalid_cbor); }","classification":"NONSATD","isFinished":true,"code_context_2":".payload(aspayload(code2, collections.emptylist())) .build(); case 0x05: \/\/ get pin token map hostcosekey3 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinhashenc2 = (bytestring) pinparams.get(new unsignedinteger(0x06));","code_context_10":"map hostcosekey2 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth2 = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc2 = (bytestring) pinparams.get(new unsignedinteger(0x05)); bytestring pinhashenc = (bytestring) pinparams.get(new unsignedinteger(0x06)); ctap2responsecode code2 = pinrequesthandler.changepin(hostcosekey2, pinhashenc.getbytes(), newpinenc2.getbytes(), pinauth2.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code2, collections.emptylist())) .build(); case 0x05: \/\/ get pin token map hostcosekey3 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinhashenc2 = (bytestring) pinparams.get(new unsignedinteger(0x06)); result<list<dataitem>, ctap2responsecode> pintoken = pinrequesthandler.getpintoken(hostcosekey3, pinhashenc2.getbytes()); byte[] pintokenpayload = pintoken.handleerror(err -> aspayload(err, collections.emptylist())) .elseget(val -> aspayload(ctap2responsecode.ok, val)); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(pintokenpayload) .build();","code_context_20":"map hostcosekey = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc = (bytestring) pinparams.get(new unsignedinteger(0x05)); ctap2responsecode code = pinrequesthandler.setpin(hostcosekey, newpinenc.getbytes(), pinauth.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code, collections.emptylist())) .build(); case 0x04: \/\/ change pin map hostcosekey2 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth2 = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc2 = (bytestring) pinparams.get(new unsignedinteger(0x05)); bytestring pinhashenc = (bytestring) pinparams.get(new unsignedinteger(0x06)); ctap2responsecode code2 = pinrequesthandler.changepin(hostcosekey2, pinhashenc.getbytes(), newpinenc2.getbytes(), pinauth2.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code2, collections.emptylist())) .build(); case 0x05: \/\/ get pin token map hostcosekey3 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinhashenc2 = (bytestring) pinparams.get(new unsignedinteger(0x06)); result<list<dataitem>, ctap2responsecode> pintoken = pinrequesthandler.getpintoken(hostcosekey3, pinhashenc2.getbytes()); byte[] pintokenpayload = pintoken.handleerror(err -> aspayload(err, collections.emptylist())) .elseget(val -> aspayload(ctap2responsecode.ok, val)); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(pintokenpayload) .build(); } break; case reset: case get_next_assertion: default: return rawmessage.error(channelid, hiderror.invalid_cmd); } } catch (cborexception e) { log.error(\"unable to deserialize cbor\", e); }","repo":"mphi-rc\/pi-zero-security-key"}
{"id":22750,"comment_id":0,"comment":"\/\/fixme - this is likely wrong","code":"@test public void acceptedrequestisfullyapplied() throws engineexception { registrationcontext defcontext = new registrationcontext(false, triggeringmode.manualatlogin); initandcreateform(false, null); registrationrequest request = getrequest(); string id3 = registrationsman.submitregistrationrequest(request, defcontext); registrationsman.processregistrationrequest(id3, null, registrationrequestaction.accept, \"a2\", \"p2\"); registrationrequeststate fromdb = registrationsman.getregistrationrequests().get(0); assertequals(request, fromdb.getrequest()); assertequals(2, fromdb.getadmincomments().size()); assertequals(\"p2\", fromdb.getadmincomments().get(1).getcontents()); assertequals(\"a2\", fromdb.getadmincomments().get(0).getcontents()); assertequals(registrationrequeststatus.accepted, fromdb.getstatus()); assertequals(id3, fromdb.getrequestid()); assertnotnull(fromdb.gettimestamp()); entity added = idsman.getentity(new entityparam(new identitytav(x500identity.id, \"cn=registration test\"))); assertequals(entitystate.valid, added.getstate()); assertequals(engineinitialization.default_credential_requirement, added.getcredentialinfo().getcredentialrequirementid()); assertthat(fromdb.getcreatedentityid(), is(added.getid())); credentialpublicinformation cpi = added.getcredentialinfo().getcredentialsstate().get( engineinitialization.default_credential); assertequals(localcredentialstate.correct, cpi.getstate()); entityparam addedp = new entityparam(added.getid()); collection<string> groups = idsman.getgroups(addedp).keyset(); asserttrue(groups.contains(\"\/\")); asserttrue(groups.contains(\"\/a\")); asserttrue(groups.contains(\"\/b\")); collection<attributesclass> acs = acman.getentityattributeclasses(addedp, \"\/\"); assertequals(1, acs.size()); assertequals(initializercommon.naming_ac, acs.iterator().next().getname()); collection<attributeext> attrs = attrsman.getattributes(addedp, \"\/\", \"cn\"); assertequals(1, attrs.size()); assertequals(\"val\", attrs.iterator().next().getvalues().get(0)); attrs = attrsman.getattributes(addedp, \"\/\", \"email\"); assertequals(1, attrs.size()); string value = attrs.iterator().next().getvalues().get(0); verifiableemail ve = new verifiableemail(jsonutil.parse(value)); \/\/fixme - this is likely wrong assertequals(\"foo@example.com\", ve.getvalue()); assertequals(false, ve.getconfirmationinfo().isconfirmed()); }","classification":"DEFECT","isFinished":true,"code_context_2":"assertequals(1, attrs.size()); string value = attrs.iterator().next().getvalues().get(0); verifiableemail ve = new verifiableemail(jsonutil.parse(value)); \/\/fixme - this is likely wrong assertequals(\"foo@example.com\", ve.getvalue()); assertequals(false, ve.getconfirmationinfo().isconfirmed());","code_context_10":"asserttrue(groups.contains(\"\/b\")); collection<attributesclass> acs = acman.getentityattributeclasses(addedp, \"\/\"); assertequals(1, acs.size()); assertequals(initializercommon.naming_ac, acs.iterator().next().getname()); collection<attributeext> attrs = attrsman.getattributes(addedp, \"\/\", \"cn\"); assertequals(1, attrs.size()); assertequals(\"val\", attrs.iterator().next().getvalues().get(0)); attrs = attrsman.getattributes(addedp, \"\/\", \"email\"); assertequals(1, attrs.size()); string value = attrs.iterator().next().getvalues().get(0); verifiableemail ve = new verifiableemail(jsonutil.parse(value)); \/\/fixme - this is likely wrong assertequals(\"foo@example.com\", ve.getvalue()); assertequals(false, ve.getconfirmationinfo().isconfirmed()); }","code_context_20":"assertequals(engineinitialization.default_credential_requirement, added.getcredentialinfo().getcredentialrequirementid()); assertthat(fromdb.getcreatedentityid(), is(added.getid())); credentialpublicinformation cpi = added.getcredentialinfo().getcredentialsstate().get( engineinitialization.default_credential); assertequals(localcredentialstate.correct, cpi.getstate()); entityparam addedp = new entityparam(added.getid()); collection<string> groups = idsman.getgroups(addedp).keyset(); asserttrue(groups.contains(\"\/\")); asserttrue(groups.contains(\"\/a\")); asserttrue(groups.contains(\"\/b\")); collection<attributesclass> acs = acman.getentityattributeclasses(addedp, \"\/\"); assertequals(1, acs.size()); assertequals(initializercommon.naming_ac, acs.iterator().next().getname()); collection<attributeext> attrs = attrsman.getattributes(addedp, \"\/\", \"cn\"); assertequals(1, attrs.size()); assertequals(\"val\", attrs.iterator().next().getvalues().get(0)); attrs = attrsman.getattributes(addedp, \"\/\", \"email\"); assertequals(1, attrs.size()); string value = attrs.iterator().next().getvalues().get(0); verifiableemail ve = new verifiableemail(jsonutil.parse(value)); \/\/fixme - this is likely wrong assertequals(\"foo@example.com\", ve.getvalue()); assertequals(false, ve.getconfirmationinfo().isconfirmed()); }","repo":"olivier-maury\/unity"}
{"id":23007,"comment_id":0,"comment":"\/\/ test if the filename contains an indication of the subtitles (vostfr, ...)","code":"public static boolean isalreadysubtitled( downloadable videodownloadable, language subtitleslanguage ) throws ioexception, interruptedexception { list<downloadablefile> allfiles = downloadablemanager.getinstance().getallfiles( videodownloadable.getid() ); path mainvideofilepath; string filename; optional<path> optpath = selectmainvideofile( allfiles ); if (optpath.ispresent()) { mainvideofilepath = optpath.get(); filename = mainvideofilepath.getfilename().tostring(); } else { errormanager.getinstance().reporterror(string.format(\"no video file found for %s\", videodownloadable.tostring())); return false; } if (subtitleslanguage == null) { return true; } if (subtitleslanguage.getsubtokens() != null) { \/\/ test if the filename contains an indication of the subtitles (vostfr, ...) for (string subtoken : subtitleslanguage.getsubtokens()) { if ( stringutils.containsignorecase( filename, subtoken) ) { return true; } } } videometadata metadata = getinstance().getmetadata(videodownloadable, mainvideofilepath); if (metadata.getsubtitlelanguages() != null) { for (locale locale : metadata.getsubtitlelanguages()) { if (locale.getlanguage().equals( subtitleslanguage.getlocale().getlanguage() )) { return true; } } } list<downloadablefile> subtitlefiles = allfiles.stream() .filter( file -> subtitlesfilefilter.getinstance().accept( file.getfilepath() ) ) .collect( collectors.tolist() ); string filenamewithoutextension = filename; if ( filenamewithoutextension.lastindexof('.') > 0 ) { filenamewithoutextension = filenamewithoutextension.substring( 0, filenamewithoutextension.lastindexof('.')); } string targetfilenameregexp = filenamewithoutextension + \".\" + subtitleslanguage.getshortname() + \"\\\\.srt\"; for (downloadablefile subtitlefile : subtitlefiles) { string subtitlefilename = subtitlefile.getfilepath().getfilename().tostring(); if (regexp.matches(subtitlefilename, targetfilenameregexp )) { return true; } } \/\/ fixme : this last test will accept any subtitle file without checking the language if (!subtitlefiles.isempty()) { return true; } return false; }","classification":"NONSATD","isFinished":true,"code_context_2":"} if (subtitleslanguage.getsubtokens() != null) { \/\/ test if the filename contains an indication of the subtitles (vostfr, ...) for (string subtoken : subtitleslanguage.getsubtokens()) { if ( stringutils.containsignorecase( filename, subtoken) ) {","code_context_10":"mainvideofilepath = optpath.get(); filename = mainvideofilepath.getfilename().tostring(); } else { errormanager.getinstance().reporterror(string.format(\"no video file found for %s\", videodownloadable.tostring())); return false; } if (subtitleslanguage == null) { return true; } if (subtitleslanguage.getsubtokens() != null) { \/\/ test if the filename contains an indication of the subtitles (vostfr, ...) for (string subtoken : subtitleslanguage.getsubtokens()) { if ( stringutils.containsignorecase( filename, subtoken) ) { return true; } } } videometadata metadata = getinstance().getmetadata(videodownloadable, mainvideofilepath); if (metadata.getsubtitlelanguages() != null) { for (locale locale : metadata.getsubtitlelanguages()) { if (locale.getlanguage().equals( subtitleslanguage.getlocale().getlanguage() )) {","code_context_20":"public static boolean isalreadysubtitled( downloadable videodownloadable, language subtitleslanguage ) throws ioexception, interruptedexception { list<downloadablefile> allfiles = downloadablemanager.getinstance().getallfiles( videodownloadable.getid() ); path mainvideofilepath; string filename; optional<path> optpath = selectmainvideofile( allfiles ); if (optpath.ispresent()) { mainvideofilepath = optpath.get(); filename = mainvideofilepath.getfilename().tostring(); } else { errormanager.getinstance().reporterror(string.format(\"no video file found for %s\", videodownloadable.tostring())); return false; } if (subtitleslanguage == null) { return true; } if (subtitleslanguage.getsubtokens() != null) { \/\/ test if the filename contains an indication of the subtitles (vostfr, ...) for (string subtoken : subtitleslanguage.getsubtokens()) { if ( stringutils.containsignorecase( filename, subtoken) ) { return true; } } } videometadata metadata = getinstance().getmetadata(videodownloadable, mainvideofilepath); if (metadata.getsubtitlelanguages() != null) { for (locale locale : metadata.getsubtitlelanguages()) { if (locale.getlanguage().equals( subtitleslanguage.getlocale().getlanguage() )) { return true; } } } list<downloadablefile> subtitlefiles = allfiles.stream() .filter( file -> subtitlesfilefilter.getinstance().accept( file.getfilepath() ) ) .collect( collectors.tolist() ); string filenamewithoutextension = filename; if ( filenamewithoutextension.lastindexof('.') > 0 ) {","repo":"mozvip\/dynamo"}
{"id":23007,"comment_id":1,"comment":"\/\/ fixme : this last test will accept any subtitle file without checking the language","code":"public static boolean isalreadysubtitled( downloadable videodownloadable, language subtitleslanguage ) throws ioexception, interruptedexception { list<downloadablefile> allfiles = downloadablemanager.getinstance().getallfiles( videodownloadable.getid() ); path mainvideofilepath; string filename; optional<path> optpath = selectmainvideofile( allfiles ); if (optpath.ispresent()) { mainvideofilepath = optpath.get(); filename = mainvideofilepath.getfilename().tostring(); } else { errormanager.getinstance().reporterror(string.format(\"no video file found for %s\", videodownloadable.tostring())); return false; } if (subtitleslanguage == null) { return true; } if (subtitleslanguage.getsubtokens() != null) { \/\/ test if the filename contains an indication of the subtitles (vostfr, ...) for (string subtoken : subtitleslanguage.getsubtokens()) { if ( stringutils.containsignorecase( filename, subtoken) ) { return true; } } } videometadata metadata = getinstance().getmetadata(videodownloadable, mainvideofilepath); if (metadata.getsubtitlelanguages() != null) { for (locale locale : metadata.getsubtitlelanguages()) { if (locale.getlanguage().equals( subtitleslanguage.getlocale().getlanguage() )) { return true; } } } list<downloadablefile> subtitlefiles = allfiles.stream() .filter( file -> subtitlesfilefilter.getinstance().accept( file.getfilepath() ) ) .collect( collectors.tolist() ); string filenamewithoutextension = filename; if ( filenamewithoutextension.lastindexof('.') > 0 ) { filenamewithoutextension = filenamewithoutextension.substring( 0, filenamewithoutextension.lastindexof('.')); } string targetfilenameregexp = filenamewithoutextension + \".\" + subtitleslanguage.getshortname() + \"\\\\.srt\"; for (downloadablefile subtitlefile : subtitlefiles) { string subtitlefilename = subtitlefile.getfilepath().getfilename().tostring(); if (regexp.matches(subtitlefilename, targetfilenameregexp )) { return true; } } \/\/ fixme : this last test will accept any subtitle file without checking the language if (!subtitlefiles.isempty()) { return true; } return false; }","classification":"DEFECT","isFinished":true,"code_context_2":"} } \/\/ fixme : this last test will accept any subtitle file without checking the language if (!subtitlefiles.isempty()) { return true;","code_context_10":"if ( filenamewithoutextension.lastindexof('.') > 0 ) { filenamewithoutextension = filenamewithoutextension.substring( 0, filenamewithoutextension.lastindexof('.')); } string targetfilenameregexp = filenamewithoutextension + \".\" + subtitleslanguage.getshortname() + \"\\\\.srt\"; for (downloadablefile subtitlefile : subtitlefiles) { string subtitlefilename = subtitlefile.getfilepath().getfilename().tostring(); if (regexp.matches(subtitlefilename, targetfilenameregexp )) { return true; } } \/\/ fixme : this last test will accept any subtitle file without checking the language if (!subtitlefiles.isempty()) { return true; } return false; }","code_context_20":"if (locale.getlanguage().equals( subtitleslanguage.getlocale().getlanguage() )) { return true; } } } list<downloadablefile> subtitlefiles = allfiles.stream() .filter( file -> subtitlesfilefilter.getinstance().accept( file.getfilepath() ) ) .collect( collectors.tolist() ); string filenamewithoutextension = filename; if ( filenamewithoutextension.lastindexof('.') > 0 ) { filenamewithoutextension = filenamewithoutextension.substring( 0, filenamewithoutextension.lastindexof('.')); } string targetfilenameregexp = filenamewithoutextension + \".\" + subtitleslanguage.getshortname() + \"\\\\.srt\"; for (downloadablefile subtitlefile : subtitlefiles) { string subtitlefilename = subtitlefile.getfilepath().getfilename().tostring(); if (regexp.matches(subtitlefilename, targetfilenameregexp )) { return true; } } \/\/ fixme : this last test will accept any subtitle file without checking the language if (!subtitlefiles.isempty()) { return true; } return false; }","repo":"mozvip\/dynamo"}
{"id":14893,"comment_id":0,"comment":"\/** * create new block. * * @param nodes nodes from which block should be created; if the set of nodes contains inner * function calls, the called function body should not be included. * @param blockhead entry point for the block. *\/","code":"\/** * create new block. * * @param nodes nodes from which block should be created; if the set of nodes contains inner * function calls, the called function body should not be included. * @param blockhead entry point for the block. *\/ public void addblock(set<cfanode> nodes, cfanode blockhead) { set<referencedvariable> referencedvariables = collectreferencedvariables(nodes); set<cfanode> callnodes = collectcallnodes(nodes); set<cfanode> returnnodes = collectreturnnodes(nodes); set<functionentrynode> innerfunctioncalls = collectinnerfunctioncalls(nodes); if (callnodes.isempty()) { \/* what shall we do with function, which is not called from anywhere? * there are problems with them at partitioning building stage *\/ return; } cfanode registernode = null; for (cfanode node : callnodes) { registernode = node; if (node instanceof functionentrynode) { break; } } if (registernode == null) { \/\/it means, that there is no entry in this block. don't add it return; } referencedvariablesmap.put(registernode, referencedvariables); callnodesmap.put(registernode, callnodes); returnnodesmap.put(registernode, returnnodes); innerfunctioncallsmap.put(registernode, innerfunctioncalls); blocknodesmap.put(registernode, nodes); }","classification":"NONSATD","isFinished":true,"code_context_2":"public void addblock(set<cfanode> nodes, cfanode blockhead) { set<referencedvariable> referencedvariables = collectreferencedvariables(nodes); set<cfanode> callnodes = collectcallnodes(nodes); set<cfanode> returnnodes = collectreturnnodes(nodes); set<functionentrynode> innerfunctioncalls = collectinnerfunctioncalls(nodes); if (callnodes.isempty()) { \/* what shall we do with function, which is not called from anywhere? * there are problems with them at partitioning building stage *\/ return; } cfanode registernode = null; for (cfanode node : callnodes) { registernode = node; if (node instanceof functionentrynode) { break; } } if (registernode == null) { \/\/it means, that there is no entry in this block. don't add it return; } referencedvariablesmap.put(registernode, referencedvariables); callnodesmap.put(registernode, callnodes); returnnodesmap.put(registernode, returnnodes); innerfunctioncallsmap.put(registernode, innerfunctioncalls); blocknodesmap.put(registernode, nodes); }","code_context_10":"public void addblock(set<cfanode> nodes, cfanode blockhead) { set<referencedvariable> referencedvariables = collectreferencedvariables(nodes); set<cfanode> callnodes = collectcallnodes(nodes); set<cfanode> returnnodes = collectreturnnodes(nodes); set<functionentrynode> innerfunctioncalls = collectinnerfunctioncalls(nodes); if (callnodes.isempty()) { \/* what shall we do with function, which is not called from anywhere? * there are problems with them at partitioning building stage *\/ return; } cfanode registernode = null; for (cfanode node : callnodes) { registernode = node; if (node instanceof functionentrynode) { break; } } if (registernode == null) { \/\/it means, that there is no entry in this block. don't add it return; } referencedvariablesmap.put(registernode, referencedvariables); callnodesmap.put(registernode, callnodes); returnnodesmap.put(registernode, returnnodes); innerfunctioncallsmap.put(registernode, innerfunctioncalls); blocknodesmap.put(registernode, nodes); }","code_context_20":"public void addblock(set<cfanode> nodes, cfanode blockhead) { set<referencedvariable> referencedvariables = collectreferencedvariables(nodes); set<cfanode> callnodes = collectcallnodes(nodes); set<cfanode> returnnodes = collectreturnnodes(nodes); set<functionentrynode> innerfunctioncalls = collectinnerfunctioncalls(nodes); if (callnodes.isempty()) { \/* what shall we do with function, which is not called from anywhere? * there are problems with them at partitioning building stage *\/ return; } cfanode registernode = null; for (cfanode node : callnodes) { registernode = node; if (node instanceof functionentrynode) { break; } } if (registernode == null) { \/\/it means, that there is no entry in this block. don't add it return; } referencedvariablesmap.put(registernode, referencedvariables); callnodesmap.put(registernode, callnodes); returnnodesmap.put(registernode, returnnodes); innerfunctioncallsmap.put(registernode, innerfunctioncalls); blocknodesmap.put(registernode, nodes); }","repo":"prokopk1n\/cpachecker-1"}
{"id":14893,"comment_id":1,"comment":"\/* what shall we do with function, which is not called from anywhere? * there are problems with them at partitioning building stage *\/","code":"public void addblock(set<cfanode> nodes, cfanode blockhead) { set<referencedvariable> referencedvariables = collectreferencedvariables(nodes); set<cfanode> callnodes = collectcallnodes(nodes); set<cfanode> returnnodes = collectreturnnodes(nodes); set<functionentrynode> innerfunctioncalls = collectinnerfunctioncalls(nodes); if (callnodes.isempty()) { \/* what shall we do with function, which is not called from anywhere? * there are problems with them at partitioning building stage *\/ return; } cfanode registernode = null; for (cfanode node : callnodes) { registernode = node; if (node instanceof functionentrynode) { break; } } if (registernode == null) { \/\/it means, that there is no entry in this block. don't add it return; } referencedvariablesmap.put(registernode, referencedvariables); callnodesmap.put(registernode, callnodes); returnnodesmap.put(registernode, returnnodes); innerfunctioncallsmap.put(registernode, innerfunctioncalls); blocknodesmap.put(registernode, nodes); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"set<functionentrynode> innerfunctioncalls = collectinnerfunctioncalls(nodes); if (callnodes.isempty()) { \/* what shall we do with function, which is not called from anywhere? * there are problems with them at partitioning building stage *\/ return; }","code_context_10":"public void addblock(set<cfanode> nodes, cfanode blockhead) { set<referencedvariable> referencedvariables = collectreferencedvariables(nodes); set<cfanode> callnodes = collectcallnodes(nodes); set<cfanode> returnnodes = collectreturnnodes(nodes); set<functionentrynode> innerfunctioncalls = collectinnerfunctioncalls(nodes); if (callnodes.isempty()) { \/* what shall we do with function, which is not called from anywhere? * there are problems with them at partitioning building stage *\/ return; } cfanode registernode = null; for (cfanode node : callnodes) { registernode = node; if (node instanceof functionentrynode) { break; } } if (registernode == null) {","code_context_20":"public void addblock(set<cfanode> nodes, cfanode blockhead) { set<referencedvariable> referencedvariables = collectreferencedvariables(nodes); set<cfanode> callnodes = collectcallnodes(nodes); set<cfanode> returnnodes = collectreturnnodes(nodes); set<functionentrynode> innerfunctioncalls = collectinnerfunctioncalls(nodes); if (callnodes.isempty()) { \/* what shall we do with function, which is not called from anywhere? * there are problems with them at partitioning building stage *\/ return; } cfanode registernode = null; for (cfanode node : callnodes) { registernode = node; if (node instanceof functionentrynode) { break; } } if (registernode == null) { \/\/it means, that there is no entry in this block. don't add it return; } referencedvariablesmap.put(registernode, referencedvariables); callnodesmap.put(registernode, callnodes); returnnodesmap.put(registernode, returnnodes); innerfunctioncallsmap.put(registernode, innerfunctioncalls); blocknodesmap.put(registernode, nodes); }","repo":"prokopk1n\/cpachecker-1"}
{"id":14893,"comment_id":2,"comment":"\/\/it means, that there is no entry in this block. don't add it","code":"public void addblock(set<cfanode> nodes, cfanode blockhead) { set<referencedvariable> referencedvariables = collectreferencedvariables(nodes); set<cfanode> callnodes = collectcallnodes(nodes); set<cfanode> returnnodes = collectreturnnodes(nodes); set<functionentrynode> innerfunctioncalls = collectinnerfunctioncalls(nodes); if (callnodes.isempty()) { \/* what shall we do with function, which is not called from anywhere? * there are problems with them at partitioning building stage *\/ return; } cfanode registernode = null; for (cfanode node : callnodes) { registernode = node; if (node instanceof functionentrynode) { break; } } if (registernode == null) { \/\/it means, that there is no entry in this block. don't add it return; } referencedvariablesmap.put(registernode, referencedvariables); callnodesmap.put(registernode, callnodes); returnnodesmap.put(registernode, returnnodes); innerfunctioncallsmap.put(registernode, innerfunctioncalls); blocknodesmap.put(registernode, nodes); }","classification":"NONSATD","isFinished":true,"code_context_2":"} if (registernode == null) { \/\/it means, that there is no entry in this block. don't add it return; }","code_context_10":"return; } cfanode registernode = null; for (cfanode node : callnodes) { registernode = node; if (node instanceof functionentrynode) { break; } } if (registernode == null) { \/\/it means, that there is no entry in this block. don't add it return; } referencedvariablesmap.put(registernode, referencedvariables); callnodesmap.put(registernode, callnodes); returnnodesmap.put(registernode, returnnodes); innerfunctioncallsmap.put(registernode, innerfunctioncalls); blocknodesmap.put(registernode, nodes); }","code_context_20":"public void addblock(set<cfanode> nodes, cfanode blockhead) { set<referencedvariable> referencedvariables = collectreferencedvariables(nodes); set<cfanode> callnodes = collectcallnodes(nodes); set<cfanode> returnnodes = collectreturnnodes(nodes); set<functionentrynode> innerfunctioncalls = collectinnerfunctioncalls(nodes); if (callnodes.isempty()) { \/* what shall we do with function, which is not called from anywhere? * there are problems with them at partitioning building stage *\/ return; } cfanode registernode = null; for (cfanode node : callnodes) { registernode = node; if (node instanceof functionentrynode) { break; } } if (registernode == null) { \/\/it means, that there is no entry in this block. don't add it return; } referencedvariablesmap.put(registernode, referencedvariables); callnodesmap.put(registernode, callnodes); returnnodesmap.put(registernode, returnnodes); innerfunctioncallsmap.put(registernode, innerfunctioncalls); blocknodesmap.put(registernode, nodes); }","repo":"prokopk1n\/cpachecker-1"}
{"id":23121,"comment_id":0,"comment":"\/\/ not work, maybe only in android junit test.","code":"\/\/ not work, maybe only in android junit test. @test public void isjson_shouldreturntrue_whenstringisjsonarray() throws jsonexception { asserttrue(validatetor.isjson(\"[]\")); asserttrue(validatetor.isjson(\"[{\\\"id\\\":1}]\")); }","classification":"DEFECT","isFinished":true,"code_context_2":"@test public void isjson_shouldreturntrue_whenstringisjsonarray() throws jsonexception { asserttrue(validatetor.isjson(\"[]\")); asserttrue(validatetor.isjson(\"[{\\\"id\\\":1}]\")); }","code_context_10":"@test public void isjson_shouldreturntrue_whenstringisjsonarray() throws jsonexception { asserttrue(validatetor.isjson(\"[]\")); asserttrue(validatetor.isjson(\"[{\\\"id\\\":1}]\")); }","code_context_20":"@test public void isjson_shouldreturntrue_whenstringisjsonarray() throws jsonexception { asserttrue(validatetor.isjson(\"[]\")); asserttrue(validatetor.isjson(\"[{\\\"id\\\":1}]\")); }","repo":"nisrulz\/validatetor"}
{"id":23144,"comment_id":0,"comment":"\/** * make point obs from a single timestep of a grid * * @param timestep the grid * @param dt the timestep for the grid * * @return a field of pointobs * * @throws remoteexception java rmi problem * @throws visadexception visad problem *\/","code":"\/** * make point obs from a single timestep of a grid * * @param timestep the grid * @param dt the timestep for the grid * * @return a field of pointobs * * @throws remoteexception java rmi problem * @throws visadexception visad problem *\/ private static fieldimpl makepointobs(flatfield timestep, datetime dt) throws visadexception, remoteexception { if (timestep == null) { return null; } sampledset domain = getspatialdomain(timestep); int numpoints = domain.getlength(); integer1dset points = new integer1dset(realtype.getrealtype(\"index\"), numpoints); tupletype tt = getparamtype(timestep); tupletype rangetype = new tupletype(new mathtype[] { realtupletype.latitudelongitudealtitude, realtype.time, tt }); fieldimpl ff = new fieldimpl( new functiontype( ((settype) points.gettype()).getdomain(), rangetype), points); float[][] samples = timestep.getfloats(false); float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } earthlocation el = new earthlocationlite(lat, lon, alt); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el, dt, timestep.getsample(i), rangetype); ff.setsample(i, pot, false, false); } } return ff; }","classification":"NONSATD","isFinished":true,"code_context_2":"private static fieldimpl makepointobs(flatfield timestep, datetime dt) throws visadexception, remoteexception { if (timestep == null) { return null; } sampledset domain = getspatialdomain(timestep); int numpoints = domain.getlength(); integer1dset points = new integer1dset(realtype.getrealtype(\"index\"), numpoints); tupletype tt = getparamtype(timestep); tupletype rangetype = new tupletype(new mathtype[] { realtupletype.latitudelongitudealtitude, realtype.time, tt }); fieldimpl ff = new fieldimpl( new functiontype( ((settype) points.gettype()).getdomain(), rangetype), points); float[][] samples = timestep.getfloats(false); float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } earthlocation el = new earthlocationlite(lat, lon, alt); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el, dt, timestep.getsample(i), rangetype); ff.setsample(i, pot, false, false); } } return ff; }","code_context_10":"private static fieldimpl makepointobs(flatfield timestep, datetime dt) throws visadexception, remoteexception { if (timestep == null) { return null; } sampledset domain = getspatialdomain(timestep); int numpoints = domain.getlength(); integer1dset points = new integer1dset(realtype.getrealtype(\"index\"), numpoints); tupletype tt = getparamtype(timestep); tupletype rangetype = new tupletype(new mathtype[] { realtupletype.latitudelongitudealtitude, realtype.time, tt }); fieldimpl ff = new fieldimpl( new functiontype( ((settype) points.gettype()).getdomain(), rangetype), points); float[][] samples = timestep.getfloats(false); float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } earthlocation el = new earthlocationlite(lat, lon, alt); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el, dt, timestep.getsample(i), rangetype); ff.setsample(i, pot, false, false); } } return ff; }","code_context_20":"private static fieldimpl makepointobs(flatfield timestep, datetime dt) throws visadexception, remoteexception { if (timestep == null) { return null; } sampledset domain = getspatialdomain(timestep); int numpoints = domain.getlength(); integer1dset points = new integer1dset(realtype.getrealtype(\"index\"), numpoints); tupletype tt = getparamtype(timestep); tupletype rangetype = new tupletype(new mathtype[] { realtupletype.latitudelongitudealtitude, realtype.time, tt }); fieldimpl ff = new fieldimpl( new functiontype( ((settype) points.gettype()).getdomain(), rangetype), points); float[][] samples = timestep.getfloats(false); float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } earthlocation el = new earthlocationlite(lat, lon, alt); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el, dt, timestep.getsample(i), rangetype); ff.setsample(i, pot, false, false); } } return ff; }","repo":"oxelson\/IDV"}
{"id":23144,"comment_id":1,"comment":"\/\/ todo: make this more efficient","code":"private static fieldimpl makepointobs(flatfield timestep, datetime dt) throws visadexception, remoteexception { if (timestep == null) { return null; } sampledset domain = getspatialdomain(timestep); int numpoints = domain.getlength(); integer1dset points = new integer1dset(realtype.getrealtype(\"index\"), numpoints); tupletype tt = getparamtype(timestep); tupletype rangetype = new tupletype(new mathtype[] { realtupletype.latitudelongitudealtitude, realtype.time, tt }); fieldimpl ff = new fieldimpl( new functiontype( ((settype) points.gettype()).getdomain(), rangetype), points); float[][] samples = timestep.getfloats(false); float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } earthlocation el = new earthlocationlite(lat, lon, alt); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el, dt, timestep.getsample(i), rangetype); ff.setsample(i, pot, false, false); } } return ff; }","classification":"DESIGN","isFinished":true,"code_context_2":"} earthlocation el = new earthlocationlite(lat, lon, alt); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el, dt, timestep.getsample(i), rangetype);","code_context_10":"float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } earthlocation el = new earthlocationlite(lat, lon, alt); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el, dt, timestep.getsample(i), rangetype); ff.setsample(i, pot, false, false); } } return ff; }","code_context_20":"float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } earthlocation el = new earthlocationlite(lat, lon, alt); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el, dt, timestep.getsample(i), rangetype); ff.setsample(i, pot, false, false); } } return ff; }","repo":"oxelson\/IDV"}
{"id":23145,"comment_id":0,"comment":"\/** * make point obs from a single timestep of a grid * * @param timestep the grid * @param dt the timestep for the grid * * @return a field of pointobs * * @throws remoteexception java rmi problem * @throws visadexception visad problem *\/","code":"\/** * make point obs from a single timestep of a grid * * @param timestep the grid * @param dt the timestep for the grid * * @return a field of pointobs * * @throws remoteexception java rmi problem * @throws visadexception visad problem *\/ private static fieldimpl makepointobs(flatfield timestep, datetime dt, string function) throws visadexception, remoteexception { final boolean domax = function.equals(func_max); final boolean domin = function.equals(func_min); if (timestep == null) { return null; } sampledset domain = getspatialdomain(timestep); int numpoints = domain.getlength(); integer1dset points = new integer1dset(realtype.getrealtype(\"index\"), numpoints); tupletype tt = getparamtype(timestep); tupletype rangetype = new tupletype(new mathtype[] { realtupletype.latitudelongitudealtitude, realtype.time, tt }); fieldimpl ff = new fieldimpl( new functiontype( ((settype) points.gettype()).getdomain(), rangetype), points); float[][] samples = timestep.getfloats(false); float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; float pmin = float.positive_infinity; float pmax = float.negative_infinity; int index = 0; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } if(domax && (float)timestep.getvalues(i)[0] >= pmax){ pmax = (float)timestep.getvalues(i)[0]; index = i; } else if(domin && (float)timestep.getvalues(i)[0] < pmin){ pmin = (float)timestep.getvalues(i)[0]; index = i; } } } float alt0 = havealt ? geovals[2][index] : 0; earthlocation el0 = new earthlocationlite(geovals[latindex][index], geovals[lonindex][index], alt0); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el0, dt, timestep.getsample(index), rangetype); ff.setsample(0, pot, false, false); return ff; }","classification":"NONSATD","isFinished":true,"code_context_2":"private static fieldimpl makepointobs(flatfield timestep, datetime dt, string function) throws visadexception, remoteexception { final boolean domax = function.equals(func_max); final boolean domin = function.equals(func_min); if (timestep == null) { return null; } sampledset domain = getspatialdomain(timestep); int numpoints = domain.getlength(); integer1dset points = new integer1dset(realtype.getrealtype(\"index\"), numpoints); tupletype tt = getparamtype(timestep); tupletype rangetype = new tupletype(new mathtype[] { realtupletype.latitudelongitudealtitude, realtype.time, tt }); fieldimpl ff = new fieldimpl( new functiontype( ((settype) points.gettype()).getdomain(), rangetype), points); float[][] samples = timestep.getfloats(false); float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; float pmin = float.positive_infinity; float pmax = float.negative_infinity; int index = 0; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } if(domax && (float)timestep.getvalues(i)[0] >= pmax){ pmax = (float)timestep.getvalues(i)[0]; index = i; } else if(domin && (float)timestep.getvalues(i)[0] < pmin){ pmin = (float)timestep.getvalues(i)[0]; index = i; } } } float alt0 = havealt ? geovals[2][index] : 0; earthlocation el0 = new earthlocationlite(geovals[latindex][index], geovals[lonindex][index], alt0); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el0, dt, timestep.getsample(index), rangetype); ff.setsample(0, pot, false, false); return ff; }","code_context_10":"private static fieldimpl makepointobs(flatfield timestep, datetime dt, string function) throws visadexception, remoteexception { final boolean domax = function.equals(func_max); final boolean domin = function.equals(func_min); if (timestep == null) { return null; } sampledset domain = getspatialdomain(timestep); int numpoints = domain.getlength(); integer1dset points = new integer1dset(realtype.getrealtype(\"index\"), numpoints); tupletype tt = getparamtype(timestep); tupletype rangetype = new tupletype(new mathtype[] { realtupletype.latitudelongitudealtitude, realtype.time, tt }); fieldimpl ff = new fieldimpl( new functiontype( ((settype) points.gettype()).getdomain(), rangetype), points); float[][] samples = timestep.getfloats(false); float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; float pmin = float.positive_infinity; float pmax = float.negative_infinity; int index = 0; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } if(domax && (float)timestep.getvalues(i)[0] >= pmax){ pmax = (float)timestep.getvalues(i)[0]; index = i; } else if(domin && (float)timestep.getvalues(i)[0] < pmin){ pmin = (float)timestep.getvalues(i)[0]; index = i; } } } float alt0 = havealt ? geovals[2][index] : 0; earthlocation el0 = new earthlocationlite(geovals[latindex][index], geovals[lonindex][index], alt0); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el0, dt, timestep.getsample(index), rangetype); ff.setsample(0, pot, false, false); return ff; }","code_context_20":"private static fieldimpl makepointobs(flatfield timestep, datetime dt, string function) throws visadexception, remoteexception { final boolean domax = function.equals(func_max); final boolean domin = function.equals(func_min); if (timestep == null) { return null; } sampledset domain = getspatialdomain(timestep); int numpoints = domain.getlength(); integer1dset points = new integer1dset(realtype.getrealtype(\"index\"), numpoints); tupletype tt = getparamtype(timestep); tupletype rangetype = new tupletype(new mathtype[] { realtupletype.latitudelongitudealtitude, realtype.time, tt }); fieldimpl ff = new fieldimpl( new functiontype( ((settype) points.gettype()).getdomain(), rangetype), points); float[][] samples = timestep.getfloats(false); float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; float pmin = float.positive_infinity; float pmax = float.negative_infinity; int index = 0; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } if(domax && (float)timestep.getvalues(i)[0] >= pmax){ pmax = (float)timestep.getvalues(i)[0]; index = i; } else if(domin && (float)timestep.getvalues(i)[0] < pmin){ pmin = (float)timestep.getvalues(i)[0]; index = i; } } } float alt0 = havealt ? geovals[2][index] : 0; earthlocation el0 = new earthlocationlite(geovals[latindex][index], geovals[lonindex][index], alt0); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el0, dt, timestep.getsample(index), rangetype); ff.setsample(0, pot, false, false); return ff; }","repo":"oxelson\/IDV"}
{"id":23145,"comment_id":1,"comment":"\/\/ todo: make this more efficient","code":"private static fieldimpl makepointobs(flatfield timestep, datetime dt, string function) throws visadexception, remoteexception { final boolean domax = function.equals(func_max); final boolean domin = function.equals(func_min); if (timestep == null) { return null; } sampledset domain = getspatialdomain(timestep); int numpoints = domain.getlength(); integer1dset points = new integer1dset(realtype.getrealtype(\"index\"), numpoints); tupletype tt = getparamtype(timestep); tupletype rangetype = new tupletype(new mathtype[] { realtupletype.latitudelongitudealtitude, realtype.time, tt }); fieldimpl ff = new fieldimpl( new functiontype( ((settype) points.gettype()).getdomain(), rangetype), points); float[][] samples = timestep.getfloats(false); float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; float pmin = float.positive_infinity; float pmax = float.negative_infinity; int index = 0; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } if(domax && (float)timestep.getvalues(i)[0] >= pmax){ pmax = (float)timestep.getvalues(i)[0]; index = i; } else if(domin && (float)timestep.getvalues(i)[0] < pmin){ pmin = (float)timestep.getvalues(i)[0]; index = i; } } } float alt0 = havealt ? geovals[2][index] : 0; earthlocation el0 = new earthlocationlite(geovals[latindex][index], geovals[lonindex][index], alt0); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el0, dt, timestep.getsample(index), rangetype); ff.setsample(0, pot, false, false); return ff; }","classification":"DESIGN","isFinished":true,"code_context_2":": 0; earthlocation el0 = new earthlocationlite(geovals[latindex][index], geovals[lonindex][index], alt0); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el0, dt, timestep.getsample(index), rangetype);","code_context_10":"} else if(domin && (float)timestep.getvalues(i)[0] < pmin){ pmin = (float)timestep.getvalues(i)[0]; index = i; } } } float alt0 = havealt ? geovals[2][index] : 0; earthlocation el0 = new earthlocationlite(geovals[latindex][index], geovals[lonindex][index], alt0); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el0, dt, timestep.getsample(index), rangetype); ff.setsample(0, pot, false, false); return ff; }","code_context_20":"float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } if(domax && (float)timestep.getvalues(i)[0] >= pmax){ pmax = (float)timestep.getvalues(i)[0]; index = i; } else if(domin && (float)timestep.getvalues(i)[0] < pmin){ pmin = (float)timestep.getvalues(i)[0]; index = i; } } } float alt0 = havealt ? geovals[2][index] : 0; earthlocation el0 = new earthlocationlite(geovals[latindex][index], geovals[lonindex][index], alt0); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el0, dt, timestep.getsample(index), rangetype); ff.setsample(0, pot, false, false); return ff; }","repo":"oxelson\/IDV"}
{"id":23146,"comment_id":0,"comment":"\/** * make point obs from a single timestep of a grid * * @param timestep the grid * @param dt the timestep for the grid * * @return a field of pointobs * * @throws remoteexception java rmi problem * @throws visadexception visad problem *\/","code":"\/** * make point obs from a single timestep of a grid * * @param timestep the grid * @param dt the timestep for the grid * * @return a field of pointobs * * @throws remoteexception java rmi problem * @throws visadexception visad problem *\/ private static fieldimpl makepointobs(flatfield timestep, datetime dt, double min, double max) throws visadexception, remoteexception { if (timestep == null) { return null; } sampledset domain = getspatialdomain(timestep); int numpoints = domain.getlength(); integer1dset points = new integer1dset(realtype.getrealtype(\"index\"), numpoints); tupletype tt = getparamtype(timestep); tupletype rangetype = new tupletype(new mathtype[] { realtupletype.latitudelongitudealtitude, realtype.time, tt }); fieldimpl ff = new fieldimpl( new functiontype( ((settype) points.gettype()).getdomain(), rangetype), points); float[][] samples = timestep.getfloats(false); float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } if(timestep.getvalues(i)[0] >= min && timestep.getvalues(i)[0] < max) { earthlocation el = new earthlocationlite(lat, lon, alt); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el, dt, timestep.getsample(i), rangetype); ff.setsample(i, pot, false, false); } } } return ff; }","classification":"NONSATD","isFinished":true,"code_context_2":"private static fieldimpl makepointobs(flatfield timestep, datetime dt, double min, double max) throws visadexception, remoteexception { if (timestep == null) { return null; } sampledset domain = getspatialdomain(timestep); int numpoints = domain.getlength(); integer1dset points = new integer1dset(realtype.getrealtype(\"index\"), numpoints); tupletype tt = getparamtype(timestep); tupletype rangetype = new tupletype(new mathtype[] { realtupletype.latitudelongitudealtitude, realtype.time, tt }); fieldimpl ff = new fieldimpl( new functiontype( ((settype) points.gettype()).getdomain(), rangetype), points); float[][] samples = timestep.getfloats(false); float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } if(timestep.getvalues(i)[0] >= min && timestep.getvalues(i)[0] < max) { earthlocation el = new earthlocationlite(lat, lon, alt); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el, dt, timestep.getsample(i), rangetype); ff.setsample(i, pot, false, false); } } } return ff; }","code_context_10":"private static fieldimpl makepointobs(flatfield timestep, datetime dt, double min, double max) throws visadexception, remoteexception { if (timestep == null) { return null; } sampledset domain = getspatialdomain(timestep); int numpoints = domain.getlength(); integer1dset points = new integer1dset(realtype.getrealtype(\"index\"), numpoints); tupletype tt = getparamtype(timestep); tupletype rangetype = new tupletype(new mathtype[] { realtupletype.latitudelongitudealtitude, realtype.time, tt }); fieldimpl ff = new fieldimpl( new functiontype( ((settype) points.gettype()).getdomain(), rangetype), points); float[][] samples = timestep.getfloats(false); float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } if(timestep.getvalues(i)[0] >= min && timestep.getvalues(i)[0] < max) { earthlocation el = new earthlocationlite(lat, lon, alt); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el, dt, timestep.getsample(i), rangetype); ff.setsample(i, pot, false, false); } } } return ff; }","code_context_20":"private static fieldimpl makepointobs(flatfield timestep, datetime dt, double min, double max) throws visadexception, remoteexception { if (timestep == null) { return null; } sampledset domain = getspatialdomain(timestep); int numpoints = domain.getlength(); integer1dset points = new integer1dset(realtype.getrealtype(\"index\"), numpoints); tupletype tt = getparamtype(timestep); tupletype rangetype = new tupletype(new mathtype[] { realtupletype.latitudelongitudealtitude, realtype.time, tt }); fieldimpl ff = new fieldimpl( new functiontype( ((settype) points.gettype()).getdomain(), rangetype), points); float[][] samples = timestep.getfloats(false); float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } if(timestep.getvalues(i)[0] >= min && timestep.getvalues(i)[0] < max) { earthlocation el = new earthlocationlite(lat, lon, alt); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el, dt, timestep.getsample(i), rangetype); ff.setsample(i, pot, false, false); } } } return ff; }","repo":"oxelson\/IDV"}
{"id":23146,"comment_id":1,"comment":"\/\/ todo: make this more efficient","code":"private static fieldimpl makepointobs(flatfield timestep, datetime dt, double min, double max) throws visadexception, remoteexception { if (timestep == null) { return null; } sampledset domain = getspatialdomain(timestep); int numpoints = domain.getlength(); integer1dset points = new integer1dset(realtype.getrealtype(\"index\"), numpoints); tupletype tt = getparamtype(timestep); tupletype rangetype = new tupletype(new mathtype[] { realtupletype.latitudelongitudealtitude, realtype.time, tt }); fieldimpl ff = new fieldimpl( new functiontype( ((settype) points.gettype()).getdomain(), rangetype), points); float[][] samples = timestep.getfloats(false); float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } if(timestep.getvalues(i)[0] >= min && timestep.getvalues(i)[0] < max) { earthlocation el = new earthlocationlite(lat, lon, alt); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el, dt, timestep.getsample(i), rangetype); ff.setsample(i, pot, false, false); } } } return ff; }","classification":"DESIGN","isFinished":true,"code_context_2":"if(timestep.getvalues(i)[0] >= min && timestep.getvalues(i)[0] < max) { earthlocation el = new earthlocationlite(lat, lon, alt); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el, dt, timestep.getsample(i), rangetype);","code_context_10":"float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } if(timestep.getvalues(i)[0] >= min && timestep.getvalues(i)[0] < max) { earthlocation el = new earthlocationlite(lat, lon, alt); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el, dt, timestep.getsample(i), rangetype); ff.setsample(i, pot, false, false); } } } return ff; }","code_context_20":"boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } if(timestep.getvalues(i)[0] >= min && timestep.getvalues(i)[0] < max) { earthlocation el = new earthlocationlite(lat, lon, alt); \/\/ todo: make this more efficient pointobtuple pot = new pointobtuple(el, dt, timestep.getsample(i), rangetype); ff.setsample(i, pot, false, false); } } } return ff; }","repo":"oxelson\/IDV"}
{"id":14974,"comment_id":0,"comment":"\/** * returns the largest character or `null` if there are no characters. * * @deprecated please use maxornull instead *\/","code":"\/** * returns the largest character or `null` if there are no characters. * * @deprecated please use maxornull instead *\/ @nullable @deprecated public static character max(@nullable charsequence charsequence) { return maxornull(charsequence); }","classification":"NONSATD","isFinished":true,"code_context_2":"@nullable @deprecated public static character max(@nullable charsequence charsequence) { return maxornull(charsequence); }","code_context_10":"@nullable @deprecated public static character max(@nullable charsequence charsequence) { return maxornull(charsequence); }","code_context_20":"@nullable @deprecated public static character max(@nullable charsequence charsequence) { return maxornull(charsequence); }","repo":"panpf\/tools4j"}
{"id":14975,"comment_id":0,"comment":"\/** * returns the first character yielding the largest value of the given function or `null` if there are no characters. * * @deprecated please use maxbyornull instead *\/","code":"\/** * returns the first character yielding the largest value of the given function or `null` if there are no characters. * * @deprecated please use maxbyornull instead *\/ @nullable @deprecated public static <r extends comparable<r>> character maxby(@nullable charsequence charsequence, @notnull transformer<character, r> selector) { return maxbyornull(charsequence, selector); }","classification":"NONSATD","isFinished":true,"code_context_2":"@nullable @deprecated public static <r extends comparable<r>> character maxby(@nullable charsequence charsequence, @notnull transformer<character, r> selector) { return maxbyornull(charsequence, selector); }","code_context_10":"@nullable @deprecated public static <r extends comparable<r>> character maxby(@nullable charsequence charsequence, @notnull transformer<character, r> selector) { return maxbyornull(charsequence, selector); }","code_context_20":"@nullable @deprecated public static <r extends comparable<r>> character maxby(@nullable charsequence charsequence, @notnull transformer<character, r> selector) { return maxbyornull(charsequence, selector); }","repo":"panpf\/tools4j"}
{"id":14976,"comment_id":0,"comment":"\/** * returns the smallest character or `null` if there are no characters. * * @deprecated please use minornull instead *\/","code":"\/** * returns the smallest character or `null` if there are no characters. * * @deprecated please use minornull instead *\/ @nullable @deprecated public static character min(@nullable charsequence charsequence) { return minornull(charsequence); }","classification":"NONSATD","isFinished":true,"code_context_2":"@nullable @deprecated public static character min(@nullable charsequence charsequence) { return minornull(charsequence); }","code_context_10":"@nullable @deprecated public static character min(@nullable charsequence charsequence) { return minornull(charsequence); }","code_context_20":"@nullable @deprecated public static character min(@nullable charsequence charsequence) { return minornull(charsequence); }","repo":"panpf\/tools4j"}
{"id":14977,"comment_id":0,"comment":"\/** * returns the first character yielding the smallest value of the given function or `null` if there are no characters. * * @deprecated please use minbyornull instead *\/","code":"\/** * returns the first character yielding the smallest value of the given function or `null` if there are no characters. * * @deprecated please use minbyornull instead *\/ @nullable @deprecated public static <r extends comparable<r>> character minby(@nullable charsequence charsequence, @notnull transformer<character, r> selector) { return minbyornull(charsequence, selector); }","classification":"NONSATD","isFinished":true,"code_context_2":"@nullable @deprecated public static <r extends comparable<r>> character minby(@nullable charsequence charsequence, @notnull transformer<character, r> selector) { return minbyornull(charsequence, selector); }","code_context_10":"@nullable @deprecated public static <r extends comparable<r>> character minby(@nullable charsequence charsequence, @notnull transformer<character, r> selector) { return minbyornull(charsequence, selector); }","code_context_20":"@nullable @deprecated public static <r extends comparable<r>> character minby(@nullable charsequence charsequence, @notnull transformer<character, r> selector) { return minbyornull(charsequence, selector); }","repo":"panpf\/tools4j"}
{"id":23182,"comment_id":0,"comment":"\/** * @param args the command line arguments *\/","code":"\/** * @param args the command line arguments *\/ public static void main(string[] args) { \/\/ todo code application logic her \/\/ hola onasis int num = 0; \/\/ holaaaaa \/\/ qque ondass switch(num){ case 1: case 2: default: } \/\/ }","classification":"NONSATD","isFinished":true,"code_context_2":"public static void main(string[] args) { \/\/ todo code application logic her \/\/ hola onasis int num = 0; \/\/ holaaaaa \/\/ qque ondass switch(num){ case 1: case 2: default: } \/\/ }","code_context_10":"public static void main(string[] args) { \/\/ todo code application logic her \/\/ hola onasis int num = 0; \/\/ holaaaaa \/\/ qque ondass switch(num){ case 1: case 2: default: } \/\/ }","code_context_20":"public static void main(string[] args) { \/\/ todo code application logic her \/\/ hola onasis int num = 0; \/\/ holaaaaa \/\/ qque ondass switch(num){ case 1: case 2: default: } \/\/ }","repo":"monicastle\/Prueba"}
{"id":23182,"comment_id":1,"comment":"\/\/ todo code application logic her \/\/ hola onasis","code":"public static void main(string[] args) { \/\/ todo code application logic her \/\/ hola onasis int num = 0; \/\/ holaaaaa \/\/ qque ondass switch(num){ case 1: case 2: default: } \/\/ }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"public static void main(string[] args) { \/\/ todo code application logic her \/\/ hola onasis int num = 0; \/\/ holaaaaa","code_context_10":"public static void main(string[] args) { \/\/ todo code application logic her \/\/ hola onasis int num = 0; \/\/ holaaaaa \/\/ qque ondass switch(num){ case 1: case 2: default: } \/\/ }","code_context_20":"public static void main(string[] args) { \/\/ todo code application logic her \/\/ hola onasis int num = 0; \/\/ holaaaaa \/\/ qque ondass switch(num){ case 1: case 2: default: } \/\/ }","repo":"monicastle\/Prueba"}
{"id":23182,"comment_id":2,"comment":"\/\/ holaaaaa \/\/ qque ondass","code":"public static void main(string[] args) { \/\/ todo code application logic her \/\/ hola onasis int num = 0; \/\/ holaaaaa \/\/ qque ondass switch(num){ case 1: case 2: default: } \/\/ }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/ hola onasis int num = 0; \/\/ holaaaaa \/\/ qque ondass switch(num){ case 1:","code_context_10":"public static void main(string[] args) { \/\/ todo code application logic her \/\/ hola onasis int num = 0; \/\/ holaaaaa \/\/ qque ondass switch(num){ case 1: case 2: default: } \/\/ }","code_context_20":"public static void main(string[] args) { \/\/ todo code application logic her \/\/ hola onasis int num = 0; \/\/ holaaaaa \/\/ qque ondass switch(num){ case 1: case 2: default: } \/\/ }","repo":"monicastle\/Prueba"}
{"id":23182,"comment_id":3,"comment":"\/\/","code":"public static void main(string[] args) { \/\/ todo code application logic her \/\/ hola onasis int num = 0; \/\/ holaaaaa \/\/ qque ondass switch(num){ case 1: case 2: default: } \/\/ }","classification":"NONSATD","isFinished":true,"code_context_2":"public static void main(string[] args) { \/\/ todo code application logic her \/\/ hola onasis int num = 0;","code_context_10":"public static void main(string[] args) { \/\/ todo code application logic her \/\/ hola onasis int num = 0; \/\/ holaaaaa \/\/ qque ondass switch(num){ case 1: case 2: default: } \/\/","code_context_20":"public static void main(string[] args) { \/\/ todo code application logic her \/\/ hola onasis int num = 0; \/\/ holaaaaa \/\/ qque ondass switch(num){ case 1: case 2: default: } \/\/ }","repo":"monicastle\/Prueba"}
{"id":31571,"comment_id":0,"comment":"\/\/ for integral number type things, need to convert \"null\" into 0.","code":"private object convertnullvalue(rdstablecolumndetails thecolumndetail) { if (thecolumndetail.isnullable()) { return null; } \/\/ for integral number type things, need to convert \"null\" into 0. if (thecolumndetail.isintegraltype()) { return new integer(0); } \/\/ for decimal number type things, need to convert \"null\" into 0.0. if (thecolumndetail.isdecimaltype()) { return new double(0.0); } return null; \/\/ what can we do in this case :( }","classification":"NONSATD","isFinished":true,"code_context_2":"return null; } \/\/ for integral number type things, need to convert \"null\" into 0. if (thecolumndetail.isintegraltype()) { return new integer(0);","code_context_10":"private object convertnullvalue(rdstablecolumndetails thecolumndetail) { if (thecolumndetail.isnullable()) { return null; } \/\/ for integral number type things, need to convert \"null\" into 0. if (thecolumndetail.isintegraltype()) { return new integer(0); } \/\/ for decimal number type things, need to convert \"null\" into 0.0. if (thecolumndetail.isdecimaltype()) { return new double(0.0); } return null; \/\/ what can we do in this case :( }","code_context_20":"private object convertnullvalue(rdstablecolumndetails thecolumndetail) { if (thecolumndetail.isnullable()) { return null; } \/\/ for integral number type things, need to convert \"null\" into 0. if (thecolumndetail.isintegraltype()) { return new integer(0); } \/\/ for decimal number type things, need to convert \"null\" into 0.0. if (thecolumndetail.isdecimaltype()) { return new double(0.0); } return null; \/\/ what can we do in this case :( }","repo":"ogreflow\/ogre"}
{"id":31571,"comment_id":1,"comment":"\/\/ for decimal number type things, need to convert \"null\" into 0.0.","code":"private object convertnullvalue(rdstablecolumndetails thecolumndetail) { if (thecolumndetail.isnullable()) { return null; } \/\/ for integral number type things, need to convert \"null\" into 0. if (thecolumndetail.isintegraltype()) { return new integer(0); } \/\/ for decimal number type things, need to convert \"null\" into 0.0. if (thecolumndetail.isdecimaltype()) { return new double(0.0); } return null; \/\/ what can we do in this case :( }","classification":"NONSATD","isFinished":true,"code_context_2":"return new integer(0); } \/\/ for decimal number type things, need to convert \"null\" into 0.0. if (thecolumndetail.isdecimaltype()) { return new double(0.0);","code_context_10":"private object convertnullvalue(rdstablecolumndetails thecolumndetail) { if (thecolumndetail.isnullable()) { return null; } \/\/ for integral number type things, need to convert \"null\" into 0. if (thecolumndetail.isintegraltype()) { return new integer(0); } \/\/ for decimal number type things, need to convert \"null\" into 0.0. if (thecolumndetail.isdecimaltype()) { return new double(0.0); } return null; \/\/ what can we do in this case :( }","code_context_20":"private object convertnullvalue(rdstablecolumndetails thecolumndetail) { if (thecolumndetail.isnullable()) { return null; } \/\/ for integral number type things, need to convert \"null\" into 0. if (thecolumndetail.isintegraltype()) { return new integer(0); } \/\/ for decimal number type things, need to convert \"null\" into 0.0. if (thecolumndetail.isdecimaltype()) { return new double(0.0); } return null; \/\/ what can we do in this case :( }","repo":"ogreflow\/ogre"}
{"id":31571,"comment_id":2,"comment":"\/\/ what can we do in this case :(","code":"private object convertnullvalue(rdstablecolumndetails thecolumndetail) { if (thecolumndetail.isnullable()) { return null; } \/\/ for integral number type things, need to convert \"null\" into 0. if (thecolumndetail.isintegraltype()) { return new integer(0); } \/\/ for decimal number type things, need to convert \"null\" into 0.0. if (thecolumndetail.isdecimaltype()) { return new double(0.0); } return null; \/\/ what can we do in this case :( }","classification":"DESIGN","isFinished":true,"code_context_2":"return new double(0.0); } return null; \/\/ what can we do in this case :( }","code_context_10":"return null; } \/\/ for integral number type things, need to convert \"null\" into 0. if (thecolumndetail.isintegraltype()) { return new integer(0); } \/\/ for decimal number type things, need to convert \"null\" into 0.0. if (thecolumndetail.isdecimaltype()) { return new double(0.0); } return null; \/\/ what can we do in this case :( }","code_context_20":"private object convertnullvalue(rdstablecolumndetails thecolumndetail) { if (thecolumndetail.isnullable()) { return null; } \/\/ for integral number type things, need to convert \"null\" into 0. if (thecolumndetail.isintegraltype()) { return new integer(0); } \/\/ for decimal number type things, need to convert \"null\" into 0.0. if (thecolumndetail.isdecimaltype()) { return new double(0.0); } return null; \/\/ what can we do in this case :( }","repo":"ogreflow\/ogre"}
{"id":23738,"comment_id":0,"comment":"\/\/ todo implement a method","code":"@override public void validatestatusonupdate(post post) { \/\/ todo implement a method }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"@override public void validatestatusonupdate(post post) { \/\/ todo implement a method }","code_context_10":"@override public void validatestatusonupdate(post post) { \/\/ todo implement a method }","code_context_20":"@override public void validatestatusonupdate(post post) { \/\/ todo implement a method }","repo":"reckue\/note-api"}
{"id":32092,"comment_id":0,"comment":"\/* consider doing this in the tosca yaml parser *\/","code":"\/* consider doing this in the tosca yaml parser *\/ private boolean validparameters(list<string> parameters) { \/\/ todo: throw a parsing error exception on the yaml parser when params size is less than 2. return collectionutils.isnotempty(parameters) && parameters.size() >= 2; }","classification":"NONSATD","isFinished":true,"code_context_2":"private boolean validparameters(list<string> parameters) { \/\/ todo: throw a parsing error exception on the yaml parser when params size is less than 2. return collectionutils.isnotempty(parameters) && parameters.size() >= 2; }","code_context_10":"private boolean validparameters(list<string> parameters) { \/\/ todo: throw a parsing error exception on the yaml parser when params size is less than 2. return collectionutils.isnotempty(parameters) && parameters.size() >= 2; }","code_context_20":"private boolean validparameters(list<string> parameters) { \/\/ todo: throw a parsing error exception on the yaml parser when params size is less than 2. return collectionutils.isnotempty(parameters) && parameters.size() >= 2; }","repo":"ngouagna\/alien4cloud-cloudify2-provider"}
{"id":32092,"comment_id":1,"comment":"\/\/ todo: throw a parsing error exception on the yaml parser when params size is less than 2.","code":"private boolean validparameters(list<string> parameters) { \/\/ todo: throw a parsing error exception on the yaml parser when params size is less than 2. return collectionutils.isnotempty(parameters) && parameters.size() >= 2; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"private boolean validparameters(list<string> parameters) { \/\/ todo: throw a parsing error exception on the yaml parser when params size is less than 2. return collectionutils.isnotempty(parameters) && parameters.size() >= 2; }","code_context_10":"private boolean validparameters(list<string> parameters) { \/\/ todo: throw a parsing error exception on the yaml parser when params size is less than 2. return collectionutils.isnotempty(parameters) && parameters.size() >= 2; }","code_context_20":"private boolean validparameters(list<string> parameters) { \/\/ todo: throw a parsing error exception on the yaml parser when params size is less than 2. return collectionutils.isnotempty(parameters) && parameters.size() >= 2; }","repo":"ngouagna\/alien4cloud-cloudify2-provider"}
{"id":15833,"comment_id":0,"comment":"\/* skip this+servicechanged *\/","code":"private string get_location () { final stacktraceelement[] stacktrace = new throwable ().getstacktrace (); for (int i = 2 \/* skip this+servicechanged *\/; i < stacktrace.length; i++) { stacktraceelement ste = stacktrace [i]; string class_name = ste.getclassname (); if (!class_name.startswith (\"org.apache.felix.framework.\") \/\/ skip framework (todo: add more fws) && !class_name.equals (this.getclass ().getname ())) \/\/ skip ourselves { return (ste.tostring ()); } } return (\"stacktraceelement:unknown\"); }","classification":"NONSATD","isFinished":true,"code_context_2":"{ final stacktraceelement[] stacktrace = new throwable ().getstacktrace (); for (int i = 2 \/* skip this+servicechanged *\/; i < stacktrace.length; i++) { stacktraceelement ste = stacktrace [i];","code_context_10":"private string get_location () { final stacktraceelement[] stacktrace = new throwable ().getstacktrace (); for (int i = 2 \/* skip this+servicechanged *\/; i < stacktrace.length; i++) { stacktraceelement ste = stacktrace [i]; string class_name = ste.getclassname (); if (!class_name.startswith (\"org.apache.felix.framework.\") \/\/ skip framework (todo: add more fws) && !class_name.equals (this.getclass ().getname ())) \/\/ skip ourselves { return (ste.tostring ()); } } return (\"stacktraceelement:unknown\");","code_context_20":"private string get_location () { final stacktraceelement[] stacktrace = new throwable ().getstacktrace (); for (int i = 2 \/* skip this+servicechanged *\/; i < stacktrace.length; i++) { stacktraceelement ste = stacktrace [i]; string class_name = ste.getclassname (); if (!class_name.startswith (\"org.apache.felix.framework.\") \/\/ skip framework (todo: add more fws) && !class_name.equals (this.getclass ().getname ())) \/\/ skip ourselves { return (ste.tostring ()); } } return (\"stacktraceelement:unknown\"); }","repo":"neoautus\/lucidj-core"}
{"id":15833,"comment_id":1,"comment":"\/\/ skip framework (todo: add more fws)","code":"private string get_location () { final stacktraceelement[] stacktrace = new throwable ().getstacktrace (); for (int i = 2 \/* skip this+servicechanged *\/; i < stacktrace.length; i++) { stacktraceelement ste = stacktrace [i]; string class_name = ste.getclassname (); if (!class_name.startswith (\"org.apache.felix.framework.\") \/\/ skip framework (todo: add more fws) && !class_name.equals (this.getclass ().getname ())) \/\/ skip ourselves { return (ste.tostring ()); } } return (\"stacktraceelement:unknown\"); }","classification":"DESIGN","isFinished":true,"code_context_2":"stacktraceelement ste = stacktrace [i]; string class_name = ste.getclassname (); if (!class_name.startswith (\"org.apache.felix.framework.\") \/\/ skip framework (todo: add more fws) && !class_name.equals (this.getclass ().getname ())) \/\/ skip ourselves {","code_context_10":"private string get_location () { final stacktraceelement[] stacktrace = new throwable ().getstacktrace (); for (int i = 2 \/* skip this+servicechanged *\/; i < stacktrace.length; i++) { stacktraceelement ste = stacktrace [i]; string class_name = ste.getclassname (); if (!class_name.startswith (\"org.apache.felix.framework.\") \/\/ skip framework (todo: add more fws) && !class_name.equals (this.getclass ().getname ())) \/\/ skip ourselves { return (ste.tostring ()); } } return (\"stacktraceelement:unknown\"); }","code_context_20":"private string get_location () { final stacktraceelement[] stacktrace = new throwable ().getstacktrace (); for (int i = 2 \/* skip this+servicechanged *\/; i < stacktrace.length; i++) { stacktraceelement ste = stacktrace [i]; string class_name = ste.getclassname (); if (!class_name.startswith (\"org.apache.felix.framework.\") \/\/ skip framework (todo: add more fws) && !class_name.equals (this.getclass ().getname ())) \/\/ skip ourselves { return (ste.tostring ()); } } return (\"stacktraceelement:unknown\"); }","repo":"neoautus\/lucidj-core"}
{"id":15833,"comment_id":2,"comment":"\/\/ skip ourselves","code":"private string get_location () { final stacktraceelement[] stacktrace = new throwable ().getstacktrace (); for (int i = 2 \/* skip this+servicechanged *\/; i < stacktrace.length; i++) { stacktraceelement ste = stacktrace [i]; string class_name = ste.getclassname (); if (!class_name.startswith (\"org.apache.felix.framework.\") \/\/ skip framework (todo: add more fws) && !class_name.equals (this.getclass ().getname ())) \/\/ skip ourselves { return (ste.tostring ()); } } return (\"stacktraceelement:unknown\"); }","classification":"NONSATD","isFinished":true,"code_context_2":"string class_name = ste.getclassname (); if (!class_name.startswith (\"org.apache.felix.framework.\") \/\/ skip framework (todo: add more fws) && !class_name.equals (this.getclass ().getname ())) \/\/ skip ourselves { return (ste.tostring ());","code_context_10":"private string get_location () { final stacktraceelement[] stacktrace = new throwable ().getstacktrace (); for (int i = 2 \/* skip this+servicechanged *\/; i < stacktrace.length; i++) { stacktraceelement ste = stacktrace [i]; string class_name = ste.getclassname (); if (!class_name.startswith (\"org.apache.felix.framework.\") \/\/ skip framework (todo: add more fws) && !class_name.equals (this.getclass ().getname ())) \/\/ skip ourselves { return (ste.tostring ()); } } return (\"stacktraceelement:unknown\"); }","code_context_20":"private string get_location () { final stacktraceelement[] stacktrace = new throwable ().getstacktrace (); for (int i = 2 \/* skip this+servicechanged *\/; i < stacktrace.length; i++) { stacktraceelement ste = stacktrace [i]; string class_name = ste.getclassname (); if (!class_name.startswith (\"org.apache.felix.framework.\") \/\/ skip framework (todo: add more fws) && !class_name.equals (this.getclass ().getname ())) \/\/ skip ourselves { return (ste.tostring ()); } } return (\"stacktraceelement:unknown\"); }","repo":"neoautus\/lucidj-core"}
{"id":7735,"comment_id":0,"comment":"\/\/ todo(pdex): why are we making our own threadpool?","code":"public static void main(string[] args) { \/\/ todo(pdex): why are we making our own threadpool? final list<listeningexecutorservice> l = spez.servicepoolgenerator(thread_pool, \"spanner tailer event worker\"); final spannertailer tailer = new spannertailer(thread_pool, 200000000); \/\/ final eventpublisher publisher = new eventpublisher(project_name, topic_name); final threadlocal<eventpublisher> publisher = threadlocal.withinitial( () -> { return new eventpublisher(project_name, topic_name); }); final executorservice workstealingpool = executors.newworkstealingpool(); final listeningexecutorservice forkjoinpool = moreexecutors.listeningdecorator(workstealingpool); final map<string, string> metadata = new hashmap<>(); final countdownlatch donesignal = new countdownlatch(1); final scheduledexecutorservice scheduler = executors.newscheduledthreadpool(1); \/\/ populate cdc metadata metadata.put(\"srcdatabase\", db_name); metadata.put(\"srctablename\", table_name); metadata.put(\"dsttopic\", topic_name); final listenablefuture<schemaset> schemasetfuture = tailer.getschema(project_name, instance_name, db_name, table_name); futures.addcallback( schemasetfuture, new futurecallback<schemaset>() { @override public void onsuccess(schemaset schemaset) { log.info(\"successfully processed the table schema. starting the poller now ...\"); if (disruptor) { disruptorhandler handler = new disruptorhandler(schemaset, publisher, metadata, l.get(0)); handler.start(); tailer.setringbuffer(handler.getringbuffer()); scheduledfuture<?> result = tailer.start( 2, 500, project_name, instance_name, db_name, table_name, \"lpts_table\", schemaset.tscolname(), \"2000\"); donesignal.countdown(); } else { workstealinghandler handler = new workstealinghandler(scheduler, schemaset, publisher, metadata); tailer.start( handler, schemaset.tscolname(), l.size(), thread_pool, 500, project_name, instance_name, db_name, table_name, \"lpts_table\", \"2000\", 500, 500); scheduler.scheduleatfixedrate( () -> { handler.logstats(); tailer.logstats(); }, 30, 30, timeunit.seconds); donesignal.countdown(); } } @override public void onfailure(throwable t) { log.error(\"unable to process schema\", t); system.exit(-1); } }, l.get(l.size() % thread_pool)); try { log.debug(\"dumping all known loggers\"); loggercontext lc = (loggercontext) loggerfactory.getiloggerfactory(); java.util.iterator<ch.qos.logback.classic.logger> it = lc.getloggerlist().iterator(); while (it.hasnext()) { ch.qos.logback.classic.logger thislog = it.next(); log.debug(\"name: {} status: {}\", thislog.getname(), thislog.getlevel()); } log.info(\"waiting for donesignal\"); donesignal.await(); } catch (interruptedexception e) { e.printstacktrace(); } }","classification":"DESIGN","isFinished":true,"code_context_2":"public static void main(string[] args) { \/\/ todo(pdex): why are we making our own threadpool? final list<listeningexecutorservice> l = spez.servicepoolgenerator(thread_pool, \"spanner tailer event worker\");","code_context_10":"public static void main(string[] args) { \/\/ todo(pdex): why are we making our own threadpool? final list<listeningexecutorservice> l = spez.servicepoolgenerator(thread_pool, \"spanner tailer event worker\"); final spannertailer tailer = new spannertailer(thread_pool, 200000000); \/\/ final eventpublisher publisher = new eventpublisher(project_name, topic_name); final threadlocal<eventpublisher> publisher = threadlocal.withinitial( () -> { return new eventpublisher(project_name, topic_name); }); final executorservice workstealingpool = executors.newworkstealingpool();","code_context_20":"public static void main(string[] args) { \/\/ todo(pdex): why are we making our own threadpool? final list<listeningexecutorservice> l = spez.servicepoolgenerator(thread_pool, \"spanner tailer event worker\"); final spannertailer tailer = new spannertailer(thread_pool, 200000000); \/\/ final eventpublisher publisher = new eventpublisher(project_name, topic_name); final threadlocal<eventpublisher> publisher = threadlocal.withinitial( () -> { return new eventpublisher(project_name, topic_name); }); final executorservice workstealingpool = executors.newworkstealingpool(); final listeningexecutorservice forkjoinpool = moreexecutors.listeningdecorator(workstealingpool); final map<string, string> metadata = new hashmap<>(); final countdownlatch donesignal = new countdownlatch(1); final scheduledexecutorservice scheduler = executors.newscheduledthreadpool(1); \/\/ populate cdc metadata metadata.put(\"srcdatabase\", db_name); metadata.put(\"srctablename\", table_name); metadata.put(\"dsttopic\", topic_name); final listenablefuture<schemaset> schemasetfuture =","repo":"olavloite\/spez2"}
{"id":7735,"comment_id":1,"comment":"\/\/ final eventpublisher publisher = new eventpublisher(project_name, topic_name);","code":"public static void main(string[] args) { \/\/ todo(pdex): why are we making our own threadpool? final list<listeningexecutorservice> l = spez.servicepoolgenerator(thread_pool, \"spanner tailer event worker\"); final spannertailer tailer = new spannertailer(thread_pool, 200000000); \/\/ final eventpublisher publisher = new eventpublisher(project_name, topic_name); final threadlocal<eventpublisher> publisher = threadlocal.withinitial( () -> { return new eventpublisher(project_name, topic_name); }); final executorservice workstealingpool = executors.newworkstealingpool(); final listeningexecutorservice forkjoinpool = moreexecutors.listeningdecorator(workstealingpool); final map<string, string> metadata = new hashmap<>(); final countdownlatch donesignal = new countdownlatch(1); final scheduledexecutorservice scheduler = executors.newscheduledthreadpool(1); \/\/ populate cdc metadata metadata.put(\"srcdatabase\", db_name); metadata.put(\"srctablename\", table_name); metadata.put(\"dsttopic\", topic_name); final listenablefuture<schemaset> schemasetfuture = tailer.getschema(project_name, instance_name, db_name, table_name); futures.addcallback( schemasetfuture, new futurecallback<schemaset>() { @override public void onsuccess(schemaset schemaset) { log.info(\"successfully processed the table schema. starting the poller now ...\"); if (disruptor) { disruptorhandler handler = new disruptorhandler(schemaset, publisher, metadata, l.get(0)); handler.start(); tailer.setringbuffer(handler.getringbuffer()); scheduledfuture<?> result = tailer.start( 2, 500, project_name, instance_name, db_name, table_name, \"lpts_table\", schemaset.tscolname(), \"2000\"); donesignal.countdown(); } else { workstealinghandler handler = new workstealinghandler(scheduler, schemaset, publisher, metadata); tailer.start( handler, schemaset.tscolname(), l.size(), thread_pool, 500, project_name, instance_name, db_name, table_name, \"lpts_table\", \"2000\", 500, 500); scheduler.scheduleatfixedrate( () -> { handler.logstats(); tailer.logstats(); }, 30, 30, timeunit.seconds); donesignal.countdown(); } } @override public void onfailure(throwable t) { log.error(\"unable to process schema\", t); system.exit(-1); } }, l.get(l.size() % thread_pool)); try { log.debug(\"dumping all known loggers\"); loggercontext lc = (loggercontext) loggerfactory.getiloggerfactory(); java.util.iterator<ch.qos.logback.classic.logger> it = lc.getloggerlist().iterator(); while (it.hasnext()) { ch.qos.logback.classic.logger thislog = it.next(); log.debug(\"name: {} status: {}\", thislog.getname(), thislog.getlevel()); } log.info(\"waiting for donesignal\"); donesignal.await(); } catch (interruptedexception e) { e.printstacktrace(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"spez.servicepoolgenerator(thread_pool, \"spanner tailer event worker\"); final spannertailer tailer = new spannertailer(thread_pool, 200000000); \/\/ final eventpublisher publisher = new eventpublisher(project_name, topic_name); final threadlocal<eventpublisher> publisher = threadlocal.withinitial(","code_context_10":"public static void main(string[] args) { \/\/ todo(pdex): why are we making our own threadpool? final list<listeningexecutorservice> l = spez.servicepoolgenerator(thread_pool, \"spanner tailer event worker\"); final spannertailer tailer = new spannertailer(thread_pool, 200000000); \/\/ final eventpublisher publisher = new eventpublisher(project_name, topic_name); final threadlocal<eventpublisher> publisher = threadlocal.withinitial( () -> { return new eventpublisher(project_name, topic_name); }); final executorservice workstealingpool = executors.newworkstealingpool(); final listeningexecutorservice forkjoinpool = moreexecutors.listeningdecorator(workstealingpool); final map<string, string> metadata = new hashmap<>(); final countdownlatch donesignal = new countdownlatch(1);","code_context_20":"public static void main(string[] args) { \/\/ todo(pdex): why are we making our own threadpool? final list<listeningexecutorservice> l = spez.servicepoolgenerator(thread_pool, \"spanner tailer event worker\"); final spannertailer tailer = new spannertailer(thread_pool, 200000000); \/\/ final eventpublisher publisher = new eventpublisher(project_name, topic_name); final threadlocal<eventpublisher> publisher = threadlocal.withinitial( () -> { return new eventpublisher(project_name, topic_name); }); final executorservice workstealingpool = executors.newworkstealingpool(); final listeningexecutorservice forkjoinpool = moreexecutors.listeningdecorator(workstealingpool); final map<string, string> metadata = new hashmap<>(); final countdownlatch donesignal = new countdownlatch(1); final scheduledexecutorservice scheduler = executors.newscheduledthreadpool(1); \/\/ populate cdc metadata metadata.put(\"srcdatabase\", db_name); metadata.put(\"srctablename\", table_name); metadata.put(\"dsttopic\", topic_name); final listenablefuture<schemaset> schemasetfuture = tailer.getschema(project_name, instance_name, db_name, table_name); futures.addcallback( schemasetfuture, new futurecallback<schemaset>() {","repo":"olavloite\/spez2"}
{"id":7735,"comment_id":2,"comment":"\/\/ populate cdc metadata","code":"public static void main(string[] args) { \/\/ todo(pdex): why are we making our own threadpool? final list<listeningexecutorservice> l = spez.servicepoolgenerator(thread_pool, \"spanner tailer event worker\"); final spannertailer tailer = new spannertailer(thread_pool, 200000000); \/\/ final eventpublisher publisher = new eventpublisher(project_name, topic_name); final threadlocal<eventpublisher> publisher = threadlocal.withinitial( () -> { return new eventpublisher(project_name, topic_name); }); final executorservice workstealingpool = executors.newworkstealingpool(); final listeningexecutorservice forkjoinpool = moreexecutors.listeningdecorator(workstealingpool); final map<string, string> metadata = new hashmap<>(); final countdownlatch donesignal = new countdownlatch(1); final scheduledexecutorservice scheduler = executors.newscheduledthreadpool(1); \/\/ populate cdc metadata metadata.put(\"srcdatabase\", db_name); metadata.put(\"srctablename\", table_name); metadata.put(\"dsttopic\", topic_name); final listenablefuture<schemaset> schemasetfuture = tailer.getschema(project_name, instance_name, db_name, table_name); futures.addcallback( schemasetfuture, new futurecallback<schemaset>() { @override public void onsuccess(schemaset schemaset) { log.info(\"successfully processed the table schema. starting the poller now ...\"); if (disruptor) { disruptorhandler handler = new disruptorhandler(schemaset, publisher, metadata, l.get(0)); handler.start(); tailer.setringbuffer(handler.getringbuffer()); scheduledfuture<?> result = tailer.start( 2, 500, project_name, instance_name, db_name, table_name, \"lpts_table\", schemaset.tscolname(), \"2000\"); donesignal.countdown(); } else { workstealinghandler handler = new workstealinghandler(scheduler, schemaset, publisher, metadata); tailer.start( handler, schemaset.tscolname(), l.size(), thread_pool, 500, project_name, instance_name, db_name, table_name, \"lpts_table\", \"2000\", 500, 500); scheduler.scheduleatfixedrate( () -> { handler.logstats(); tailer.logstats(); }, 30, 30, timeunit.seconds); donesignal.countdown(); } } @override public void onfailure(throwable t) { log.error(\"unable to process schema\", t); system.exit(-1); } }, l.get(l.size() % thread_pool)); try { log.debug(\"dumping all known loggers\"); loggercontext lc = (loggercontext) loggerfactory.getiloggerfactory(); java.util.iterator<ch.qos.logback.classic.logger> it = lc.getloggerlist().iterator(); while (it.hasnext()) { ch.qos.logback.classic.logger thislog = it.next(); log.debug(\"name: {} status: {}\", thislog.getname(), thislog.getlevel()); } log.info(\"waiting for donesignal\"); donesignal.await(); } catch (interruptedexception e) { e.printstacktrace(); } }","classification":"NONSATD","isFinished":true,"code_context_2":"final countdownlatch donesignal = new countdownlatch(1); final scheduledexecutorservice scheduler = executors.newscheduledthreadpool(1); \/\/ populate cdc metadata metadata.put(\"srcdatabase\", db_name); metadata.put(\"srctablename\", table_name);","code_context_10":"threadlocal.withinitial( () -> { return new eventpublisher(project_name, topic_name); }); final executorservice workstealingpool = executors.newworkstealingpool(); final listeningexecutorservice forkjoinpool = moreexecutors.listeningdecorator(workstealingpool); final map<string, string> metadata = new hashmap<>(); final countdownlatch donesignal = new countdownlatch(1); final scheduledexecutorservice scheduler = executors.newscheduledthreadpool(1); \/\/ populate cdc metadata metadata.put(\"srcdatabase\", db_name); metadata.put(\"srctablename\", table_name); metadata.put(\"dsttopic\", topic_name); final listenablefuture<schemaset> schemasetfuture = tailer.getschema(project_name, instance_name, db_name, table_name); futures.addcallback( schemasetfuture, new futurecallback<schemaset>() { @override public void onsuccess(schemaset schemaset) {","code_context_20":"public static void main(string[] args) { \/\/ todo(pdex): why are we making our own threadpool? final list<listeningexecutorservice> l = spez.servicepoolgenerator(thread_pool, \"spanner tailer event worker\"); final spannertailer tailer = new spannertailer(thread_pool, 200000000); \/\/ final eventpublisher publisher = new eventpublisher(project_name, topic_name); final threadlocal<eventpublisher> publisher = threadlocal.withinitial( () -> { return new eventpublisher(project_name, topic_name); }); final executorservice workstealingpool = executors.newworkstealingpool(); final listeningexecutorservice forkjoinpool = moreexecutors.listeningdecorator(workstealingpool); final map<string, string> metadata = new hashmap<>(); final countdownlatch donesignal = new countdownlatch(1); final scheduledexecutorservice scheduler = executors.newscheduledthreadpool(1); \/\/ populate cdc metadata metadata.put(\"srcdatabase\", db_name); metadata.put(\"srctablename\", table_name); metadata.put(\"dsttopic\", topic_name); final listenablefuture<schemaset> schemasetfuture = tailer.getschema(project_name, instance_name, db_name, table_name); futures.addcallback( schemasetfuture, new futurecallback<schemaset>() { @override public void onsuccess(schemaset schemaset) { log.info(\"successfully processed the table schema. starting the poller now ...\"); if (disruptor) { disruptorhandler handler = new disruptorhandler(schemaset, publisher, metadata, l.get(0)); handler.start(); tailer.setringbuffer(handler.getringbuffer()); scheduledfuture<?> result = tailer.start( 2, 500,","repo":"olavloite\/spez2"}
{"id":24154,"comment_id":0,"comment":"\/** * create mono that completes exceptionally with exception `illegalstateexception`. *\/","code":"\/** * create mono that completes exceptionally with exception `illegalstateexception`. *\/ @test public void trouble_maker() { mono<string> trouble = null; \/\/todo: change this line stepverifier.create(trouble) .expecterror(illegalstateexception.class) .verify(); }","classification":"NONSATD","isFinished":true,"code_context_2":"@test public void trouble_maker() { mono<string> trouble = null; \/\/todo: change this line stepverifier.create(trouble) .expecterror(illegalstateexception.class) .verify(); }","code_context_10":"@test public void trouble_maker() { mono<string> trouble = null; \/\/todo: change this line stepverifier.create(trouble) .expecterror(illegalstateexception.class) .verify(); }","code_context_20":"@test public void trouble_maker() { mono<string> trouble = null; \/\/todo: change this line stepverifier.create(trouble) .expecterror(illegalstateexception.class) .verify(); }","repo":"nicolasbelfis\/practical-reactor"}
{"id":24154,"comment_id":1,"comment":"\/\/todo: change this line","code":"@test public void trouble_maker() { mono<string> trouble = null; \/\/todo: change this line stepverifier.create(trouble) .expecterror(illegalstateexception.class) .verify(); }","classification":"DESIGN","isFinished":true,"code_context_2":"@test public void trouble_maker() { mono<string> trouble = null; \/\/todo: change this line stepverifier.create(trouble) .expecterror(illegalstateexception.class)","code_context_10":"@test public void trouble_maker() { mono<string> trouble = null; \/\/todo: change this line stepverifier.create(trouble) .expecterror(illegalstateexception.class) .verify(); }","code_context_20":"@test public void trouble_maker() { mono<string> trouble = null; \/\/todo: change this line stepverifier.create(trouble) .expecterror(illegalstateexception.class) .verify(); }","repo":"nicolasbelfis\/practical-reactor"}
{"id":24160,"comment_id":0,"comment":"\/** * create callable that increments the counter and returns the counter value, and then use `repeat()` operator to create flux that emits * values from 0 to 10. *\/","code":"\/** * create callable that increments the counter and returns the counter value, and then use `repeat()` operator to create flux that emits * values from 0 to 10. *\/ @test public void repeat() { atomicinteger counter = new atomicinteger(0); flux<integer> repeated = null; \/\/todo: change this line system.out.println(\"repeat: \"); stepverifier.create(repeated.doonnext(system.out::println)) .expectnext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) .verifycomplete(); }","classification":"NONSATD","isFinished":true,"code_context_2":"@test public void repeat() { atomicinteger counter = new atomicinteger(0); flux<integer> repeated = null; \/\/todo: change this line system.out.println(\"repeat: \"); stepverifier.create(repeated.doonnext(system.out::println)) .expectnext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) .verifycomplete(); }","code_context_10":"@test public void repeat() { atomicinteger counter = new atomicinteger(0); flux<integer> repeated = null; \/\/todo: change this line system.out.println(\"repeat: \"); stepverifier.create(repeated.doonnext(system.out::println)) .expectnext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) .verifycomplete(); }","code_context_20":"@test public void repeat() { atomicinteger counter = new atomicinteger(0); flux<integer> repeated = null; \/\/todo: change this line system.out.println(\"repeat: \"); stepverifier.create(repeated.doonnext(system.out::println)) .expectnext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) .verifycomplete(); }","repo":"nicolasbelfis\/practical-reactor"}
{"id":24160,"comment_id":1,"comment":"\/\/todo: change this line","code":"@test public void repeat() { atomicinteger counter = new atomicinteger(0); flux<integer> repeated = null; \/\/todo: change this line system.out.println(\"repeat: \"); stepverifier.create(repeated.doonnext(system.out::println)) .expectnext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) .verifycomplete(); }","classification":"DESIGN","isFinished":true,"code_context_2":"public void repeat() { atomicinteger counter = new atomicinteger(0); flux<integer> repeated = null; \/\/todo: change this line system.out.println(\"repeat: \"); stepverifier.create(repeated.doonnext(system.out::println))","code_context_10":"@test public void repeat() { atomicinteger counter = new atomicinteger(0); flux<integer> repeated = null; \/\/todo: change this line system.out.println(\"repeat: \"); stepverifier.create(repeated.doonnext(system.out::println)) .expectnext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) .verifycomplete(); }","code_context_20":"@test public void repeat() { atomicinteger counter = new atomicinteger(0); flux<integer> repeated = null; \/\/todo: change this line system.out.println(\"repeat: \"); stepverifier.create(repeated.doonnext(system.out::println)) .expectnext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) .verifycomplete(); }","repo":"nicolasbelfis\/practical-reactor"}
{"id":7823,"comment_id":0,"comment":"\/\/ evaluate a segmented funtion for a single value. return -1 if no valid segment found . \/\/ if fn type is 0, perform an interpolation on the table","code":"\/\/ evaluate a segmented funtion for a single value. return -1 if no valid segment found . \/\/ if fn type is 0, perform an interpolation on the table private static double evalsegmentedfn(final cmstonecurve g, double r) { int i; for (i = g.nsegments-1; i >= 0 ; --i) { \/\/ check for domain if ((r > g.segments[i].x0) && (r <= g.segments[i].x1)) { \/\/ type == 0 means segment is sampled if (g.segments[i].type == 0) { float r1 = (float)(r - g.segments[i].x0); float[] out = new float[1]; \/\/ setup the table (todo: clean that) g.seginterp[i].table = g.segments[i].sampledpoints; g.seginterp[i].interpolation.getfloat().run(new float[]{r1}, out, g.seginterp[i]); return out[0]; } else { return g.evals[i].run(g.segments[i].type, g.segments[i].params, r); } } } return minus_inf; }","classification":"NONSATD","isFinished":true,"code_context_2":"private static double evalsegmentedfn(final cmstonecurve g, double r) { int i; for (i = g.nsegments-1; i >= 0 ; --i) { \/\/ check for domain if ((r > g.segments[i].x0) && (r <= g.segments[i].x1)) { \/\/ type == 0 means segment is sampled if (g.segments[i].type == 0) { float r1 = (float)(r - g.segments[i].x0); float[] out = new float[1]; \/\/ setup the table (todo: clean that) g.seginterp[i].table = g.segments[i].sampledpoints; g.seginterp[i].interpolation.getfloat().run(new float[]{r1}, out, g.seginterp[i]); return out[0]; } else { return g.evals[i].run(g.segments[i].type, g.segments[i].params, r); } } } return minus_inf; }","code_context_10":"private static double evalsegmentedfn(final cmstonecurve g, double r) { int i; for (i = g.nsegments-1; i >= 0 ; --i) { \/\/ check for domain if ((r > g.segments[i].x0) && (r <= g.segments[i].x1)) { \/\/ type == 0 means segment is sampled if (g.segments[i].type == 0) { float r1 = (float)(r - g.segments[i].x0); float[] out = new float[1]; \/\/ setup the table (todo: clean that) g.seginterp[i].table = g.segments[i].sampledpoints; g.seginterp[i].interpolation.getfloat().run(new float[]{r1}, out, g.seginterp[i]); return out[0]; } else { return g.evals[i].run(g.segments[i].type, g.segments[i].params, r); } } } return minus_inf; }","code_context_20":"private static double evalsegmentedfn(final cmstonecurve g, double r) { int i; for (i = g.nsegments-1; i >= 0 ; --i) { \/\/ check for domain if ((r > g.segments[i].x0) && (r <= g.segments[i].x1)) { \/\/ type == 0 means segment is sampled if (g.segments[i].type == 0) { float r1 = (float)(r - g.segments[i].x0); float[] out = new float[1]; \/\/ setup the table (todo: clean that) g.seginterp[i].table = g.segments[i].sampledpoints; g.seginterp[i].interpolation.getfloat().run(new float[]{r1}, out, g.seginterp[i]); return out[0]; } else { return g.evals[i].run(g.segments[i].type, g.segments[i].params, r); } } } return minus_inf; }","repo":"rcmaniac25\/little-cms-for-blackberry"}
{"id":7823,"comment_id":1,"comment":"\/\/ check for domain","code":"private static double evalsegmentedfn(final cmstonecurve g, double r) { int i; for (i = g.nsegments-1; i >= 0 ; --i) { \/\/ check for domain if ((r > g.segments[i].x0) && (r <= g.segments[i].x1)) { \/\/ type == 0 means segment is sampled if (g.segments[i].type == 0) { float r1 = (float)(r - g.segments[i].x0); float[] out = new float[1]; \/\/ setup the table (todo: clean that) g.seginterp[i].table = g.segments[i].sampledpoints; g.seginterp[i].interpolation.getfloat().run(new float[]{r1}, out, g.seginterp[i]); return out[0]; } else { return g.evals[i].run(g.segments[i].type, g.segments[i].params, r); } } } return minus_inf; }","classification":"NONSATD","isFinished":true,"code_context_2":"for (i = g.nsegments-1; i >= 0 ; --i) { \/\/ check for domain if ((r > g.segments[i].x0) && (r <= g.segments[i].x1)) {","code_context_10":"private static double evalsegmentedfn(final cmstonecurve g, double r) { int i; for (i = g.nsegments-1; i >= 0 ; --i) { \/\/ check for domain if ((r > g.segments[i].x0) && (r <= g.segments[i].x1)) { \/\/ type == 0 means segment is sampled if (g.segments[i].type == 0) { float r1 = (float)(r - g.segments[i].x0); float[] out = new float[1]; \/\/ setup the table (todo: clean that) g.seginterp[i].table = g.segments[i].sampledpoints; g.seginterp[i].interpolation.getfloat().run(new float[]{r1}, out, g.seginterp[i]);","code_context_20":"private static double evalsegmentedfn(final cmstonecurve g, double r) { int i; for (i = g.nsegments-1; i >= 0 ; --i) { \/\/ check for domain if ((r > g.segments[i].x0) && (r <= g.segments[i].x1)) { \/\/ type == 0 means segment is sampled if (g.segments[i].type == 0) { float r1 = (float)(r - g.segments[i].x0); float[] out = new float[1]; \/\/ setup the table (todo: clean that) g.seginterp[i].table = g.segments[i].sampledpoints; g.seginterp[i].interpolation.getfloat().run(new float[]{r1}, out, g.seginterp[i]); return out[0]; } else { return g.evals[i].run(g.segments[i].type, g.segments[i].params, r); } } } return minus_inf; }","repo":"rcmaniac25\/little-cms-for-blackberry"}
{"id":7823,"comment_id":2,"comment":"\/\/ type == 0 means segment is sampled","code":"private static double evalsegmentedfn(final cmstonecurve g, double r) { int i; for (i = g.nsegments-1; i >= 0 ; --i) { \/\/ check for domain if ((r > g.segments[i].x0) && (r <= g.segments[i].x1)) { \/\/ type == 0 means segment is sampled if (g.segments[i].type == 0) { float r1 = (float)(r - g.segments[i].x0); float[] out = new float[1]; \/\/ setup the table (todo: clean that) g.seginterp[i].table = g.segments[i].sampledpoints; g.seginterp[i].interpolation.getfloat().run(new float[]{r1}, out, g.seginterp[i]); return out[0]; } else { return g.evals[i].run(g.segments[i].type, g.segments[i].params, r); } } } return minus_inf; }","classification":"NONSATD","isFinished":true,"code_context_2":"if ((r > g.segments[i].x0) && (r <= g.segments[i].x1)) { \/\/ type == 0 means segment is sampled if (g.segments[i].type == 0) {","code_context_10":"private static double evalsegmentedfn(final cmstonecurve g, double r) { int i; for (i = g.nsegments-1; i >= 0 ; --i) { \/\/ check for domain if ((r > g.segments[i].x0) && (r <= g.segments[i].x1)) { \/\/ type == 0 means segment is sampled if (g.segments[i].type == 0) { float r1 = (float)(r - g.segments[i].x0); float[] out = new float[1]; \/\/ setup the table (todo: clean that) g.seginterp[i].table = g.segments[i].sampledpoints; g.seginterp[i].interpolation.getfloat().run(new float[]{r1}, out, g.seginterp[i]); return out[0]; } else","code_context_20":"private static double evalsegmentedfn(final cmstonecurve g, double r) { int i; for (i = g.nsegments-1; i >= 0 ; --i) { \/\/ check for domain if ((r > g.segments[i].x0) && (r <= g.segments[i].x1)) { \/\/ type == 0 means segment is sampled if (g.segments[i].type == 0) { float r1 = (float)(r - g.segments[i].x0); float[] out = new float[1]; \/\/ setup the table (todo: clean that) g.seginterp[i].table = g.segments[i].sampledpoints; g.seginterp[i].interpolation.getfloat().run(new float[]{r1}, out, g.seginterp[i]); return out[0]; } else { return g.evals[i].run(g.segments[i].type, g.segments[i].params, r); } } } return minus_inf; }","repo":"rcmaniac25\/little-cms-for-blackberry"}
{"id":7823,"comment_id":3,"comment":"\/\/ setup the table (todo: clean that)","code":"private static double evalsegmentedfn(final cmstonecurve g, double r) { int i; for (i = g.nsegments-1; i >= 0 ; --i) { \/\/ check for domain if ((r > g.segments[i].x0) && (r <= g.segments[i].x1)) { \/\/ type == 0 means segment is sampled if (g.segments[i].type == 0) { float r1 = (float)(r - g.segments[i].x0); float[] out = new float[1]; \/\/ setup the table (todo: clean that) g.seginterp[i].table = g.segments[i].sampledpoints; g.seginterp[i].interpolation.getfloat().run(new float[]{r1}, out, g.seginterp[i]); return out[0]; } else { return g.evals[i].run(g.segments[i].type, g.segments[i].params, r); } } } return minus_inf; }","classification":"DESIGN","isFinished":true,"code_context_2":"float r1 = (float)(r - g.segments[i].x0); float[] out = new float[1]; \/\/ setup the table (todo: clean that) g.seginterp[i].table = g.segments[i].sampledpoints; g.seginterp[i].interpolation.getfloat().run(new float[]{r1}, out, g.seginterp[i]);","code_context_10":"for (i = g.nsegments-1; i >= 0 ; --i) { \/\/ check for domain if ((r > g.segments[i].x0) && (r <= g.segments[i].x1)) { \/\/ type == 0 means segment is sampled if (g.segments[i].type == 0) { float r1 = (float)(r - g.segments[i].x0); float[] out = new float[1]; \/\/ setup the table (todo: clean that) g.seginterp[i].table = g.segments[i].sampledpoints; g.seginterp[i].interpolation.getfloat().run(new float[]{r1}, out, g.seginterp[i]); return out[0]; } else { return g.evals[i].run(g.segments[i].type, g.segments[i].params, r); } } }","code_context_20":"private static double evalsegmentedfn(final cmstonecurve g, double r) { int i; for (i = g.nsegments-1; i >= 0 ; --i) { \/\/ check for domain if ((r > g.segments[i].x0) && (r <= g.segments[i].x1)) { \/\/ type == 0 means segment is sampled if (g.segments[i].type == 0) { float r1 = (float)(r - g.segments[i].x0); float[] out = new float[1]; \/\/ setup the table (todo: clean that) g.seginterp[i].table = g.segments[i].sampledpoints; g.seginterp[i].interpolation.getfloat().run(new float[]{r1}, out, g.seginterp[i]); return out[0]; } else { return g.evals[i].run(g.segments[i].type, g.segments[i].params, r); } } } return minus_inf; }","repo":"rcmaniac25\/little-cms-for-blackberry"}
{"id":16061,"comment_id":0,"comment":"\/** * {@inheritdoc} *\/","code":"\/** * {@inheritdoc} *\/ @override protected buffereddatatable[] execute(final buffereddatatable[] indata, final executioncontext exec) throws exception { datacolumnspec[] allcolspecs = new datacolumnspec[1]; allcolspecs[0] = new datacolumnspeccreator(\"url\", stringcell.type).createspec(); datatablespec outputspec = new datatablespec(allcolspecs); \/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary. buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); }else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","classification":"NONSATD","isFinished":true,"code_context_2":"@override protected buffereddatatable[] execute(final buffereddatatable[] indata, final executioncontext exec) throws exception { datacolumnspec[] allcolspecs = new datacolumnspec[1]; allcolspecs[0] = new datacolumnspeccreator(\"url\", stringcell.type).createspec(); datatablespec outputspec = new datatablespec(allcolspecs); \/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary. buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); }else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","code_context_10":"@override protected buffereddatatable[] execute(final buffereddatatable[] indata, final executioncontext exec) throws exception { datacolumnspec[] allcolspecs = new datacolumnspec[1]; allcolspecs[0] = new datacolumnspeccreator(\"url\", stringcell.type).createspec(); datatablespec outputspec = new datatablespec(allcolspecs); \/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary. buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); }else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","code_context_20":"@override protected buffereddatatable[] execute(final buffereddatatable[] indata, final executioncontext exec) throws exception { datacolumnspec[] allcolspecs = new datacolumnspec[1]; allcolspecs[0] = new datacolumnspeccreator(\"url\", stringcell.type).createspec(); datatablespec outputspec = new datatablespec(allcolspecs); \/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary. buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); }else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","repo":"openphacts\/OPS-Knime"}
{"id":16061,"comment_id":1,"comment":"\/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary.","code":"@override protected buffereddatatable[] execute(final buffereddatatable[] indata, final executioncontext exec) throws exception { datacolumnspec[] allcolspecs = new datacolumnspec[1]; allcolspecs[0] = new datacolumnspeccreator(\"url\", stringcell.type).createspec(); datatablespec outputspec = new datatablespec(allcolspecs); \/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary. buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); }else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","classification":"NONSATD","isFinished":true,"code_context_2":"new datacolumnspeccreator(\"url\", stringcell.type).createspec(); datatablespec outputspec = new datatablespec(allcolspecs); \/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary. buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1];","code_context_10":"@override protected buffereddatatable[] execute(final buffereddatatable[] indata, final executioncontext exec) throws exception { datacolumnspec[] allcolspecs = new datacolumnspec[1]; allcolspecs[0] = new datacolumnspeccreator(\"url\", stringcell.type).createspec(); datatablespec outputspec = new datatablespec(allcolspecs); \/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary. buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator();","code_context_20":"@override protected buffereddatatable[] execute(final buffereddatatable[] indata, final executioncontext exec) throws exception { datacolumnspec[] allcolspecs = new datacolumnspec[1]; allcolspecs[0] = new datacolumnspeccreator(\"url\", stringcell.type).createspec(); datatablespec outputspec = new datatablespec(allcolspecs); \/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary. buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate);","repo":"openphacts\/OPS-Knime"}
{"id":16061,"comment_id":2,"comment":"\/\/while(varit.hasnext()){","code":"@override protected buffereddatatable[] execute(final buffereddatatable[] indata, final executioncontext exec) throws exception { datacolumnspec[] allcolspecs = new datacolumnspec[1]; allcolspecs[0] = new datacolumnspeccreator(\"url\", stringcell.type).createspec(); datatablespec outputspec = new datatablespec(allcolspecs); \/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary. buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); }else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","classification":"NONSATD","isFinished":true,"code_context_2":"string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator();","code_context_10":"\/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary. buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate);","code_context_20":"@override protected buffereddatatable[] execute(final buffereddatatable[] indata, final executioncontext exec) throws exception { datacolumnspec[] allcolspecs = new datacolumnspec[1]; allcolspecs[0] = new datacolumnspeccreator(\"url\", stringcell.type).createspec(); datatablespec outputspec = new datatablespec(allcolspecs); \/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary. buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); }else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }","repo":"openphacts\/OPS-Knime"}
{"id":16061,"comment_id":3,"comment":"\/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate);","code":"@override protected buffereddatatable[] execute(final buffereddatatable[] indata, final executioncontext exec) throws exception { datacolumnspec[] allcolspecs = new datacolumnspec[1]; allcolspecs[0] = new datacolumnspeccreator(\"url\", stringcell.type).createspec(); datatablespec outputspec = new datatablespec(allcolspecs); \/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary. buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); }else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","classification":"NONSATD","isFinished":true,"code_context_2":"string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate);","code_context_10":"string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); }else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){","code_context_20":"\/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary. buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); }else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate);","repo":"openphacts\/OPS-Knime"}
{"id":16061,"comment_id":4,"comment":"\/\/get rid of the &","code":"@override protected buffereddatatable[] execute(final buffereddatatable[] indata, final executioncontext exec) throws exception { datacolumnspec[] allcolspecs = new datacolumnspec[1]; allcolspecs[0] = new datacolumnspeccreator(\"url\", stringcell.type).createspec(); datatablespec outputspec = new datatablespec(allcolspecs); \/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary. buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); }else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","classification":"NONSATD","isFinished":true,"code_context_2":"system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){","code_context_10":"}else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"));","code_context_20":"int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); }else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\");","repo":"openphacts\/OPS-Knime"}
{"id":16061,"comment_id":5,"comment":"\/\/system.out.println(\"now we are here\");","code":"@override protected buffereddatatable[] execute(final buffereddatatable[] indata, final executioncontext exec) throws exception { datacolumnspec[] allcolspecs = new datacolumnspec[1]; allcolspecs[0] = new datacolumnspeccreator(\"url\", stringcell.type).createspec(); datatablespec outputspec = new datatablespec(allcolspecs); \/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary. buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); }else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","classification":"NONSATD","isFinished":true,"code_context_2":"urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){","code_context_10":"if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate);","code_context_20":"string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\");","repo":"openphacts\/OPS-Knime"}
{"id":16061,"comment_id":6,"comment":"\/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1);","code":"@override protected buffereddatatable[] execute(final buffereddatatable[] indata, final executioncontext exec) throws exception { datacolumnspec[] allcolspecs = new datacolumnspec[1]; allcolspecs[0] = new datacolumnspeccreator(\"url\", stringcell.type).createspec(); datatablespec outputspec = new datatablespec(allcolspecs); \/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary. buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); }else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","classification":"NONSATD","isFinished":true,"code_context_2":"system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{","code_context_10":"system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++;","code_context_20":"}else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\");","repo":"openphacts\/OPS-Knime"}
{"id":16061,"comment_id":7,"comment":"\/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate);","code":"@override protected buffereddatatable[] execute(final buffereddatatable[] indata, final executioncontext exec) throws exception { datacolumnspec[] allcolspecs = new datacolumnspec[1]; allcolspecs[0] = new datacolumnspeccreator(\"url\", stringcell.type).createspec(); datatablespec outputspec = new datatablespec(allcolspecs); \/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary. buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); }else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","classification":"NONSATD","isFinished":true,"code_context_2":"urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } }","code_context_10":"urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\");","code_context_20":"configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate);","repo":"openphacts\/OPS-Knime"}
{"id":16061,"comment_id":8,"comment":"\/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\");","code":"@override protected buffereddatatable[] execute(final buffereddatatable[] indata, final executioncontext exec) throws exception { datacolumnspec[] allcolspecs = new datacolumnspec[1]; allcolspecs[0] = new datacolumnspeccreator(\"url\", stringcell.type).createspec(); datatablespec outputspec = new datatablespec(allcolspecs); \/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary. buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); }else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","classification":"NONSATD","isFinished":true,"code_context_2":"} system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\");","code_context_10":"} \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); }","code_context_20":"urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","repo":"openphacts\/OPS-Knime"}
{"id":16061,"comment_id":9,"comment":"\/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\");","code":"@override protected buffereddatatable[] execute(final buffereddatatable[] indata, final executioncontext exec) throws exception { datacolumnspec[] allcolspecs = new datacolumnspec[1]; allcolspecs[0] = new datacolumnspeccreator(\"url\", stringcell.type).createspec(); datatablespec outputspec = new datatablespec(allcolspecs); \/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary. buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); }else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","classification":"DEFECT","isFinished":true,"code_context_2":"urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){","code_context_10":"} colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close();","code_context_20":"if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","repo":"openphacts\/OPS-Knime"}
{"id":16061,"comment_id":10,"comment":"\/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate);","code":"@override protected buffereddatatable[] execute(final buffereddatatable[] indata, final executioncontext exec) throws exception { datacolumnspec[] allcolspecs = new datacolumnspec[1]; allcolspecs[0] = new datacolumnspeccreator(\"url\", stringcell.type).createspec(); datatablespec outputspec = new datatablespec(allcolspecs); \/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary. buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); }else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","classification":"NONSATD","isFinished":true,"code_context_2":"urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells);","code_context_10":"urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","code_context_20":"\/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","repo":"openphacts\/OPS-Knime"}
{"id":16061,"comment_id":11,"comment":"\/\/ todo: return a buffereddatatable for each output port","code":"@override protected buffereddatatable[] execute(final buffereddatatable[] indata, final executioncontext exec) throws exception { datacolumnspec[] allcolspecs = new datacolumnspec[1]; allcolspecs[0] = new datacolumnspeccreator(\"url\", stringcell.type).createspec(); datatablespec outputspec = new datatablespec(allcolspecs); \/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary. buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ \/\/while(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); \/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); }else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); \/\/get rid of the & } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ \/\/system.out.println(\"now we are here\"); system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ \/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1); urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate); } } colcount++; } } system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","code_context_10":"if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","code_context_20":"} system.out.println(\"yy:\"+urltemplate); \/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); \/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } \/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate); cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); \/\/ todo: return a buffereddatatable for each output port return new buffereddatatable[]{out}; }","repo":"openphacts\/OPS-Knime"}
{"id":16088,"comment_id":0,"comment":"\/\/ todo: account for assembly attributes","code":"private void parsenamespaceortypes() throws featurenotsupportedexception { while (!curtok.equals(eof)) { \/\/ todo: account for assembly attributes parsepossibleattributes(true); if (curattributes.size() > 0) { for (attributenode an : curattributes) { cu.attributes.add(an); } curattributes.clear(); } \/\/ can be usingdirectives, globalattribs, or namespacemembersdecls \/\/ namespacemembersdecls include namespaces, class, struct, interface, enum, delegate switch (curtok.id) { case tokenid.using: \/\/ using directive parseusingdirectives(); break; case tokenid.new: case tokenid.public: case tokenid.protected: case tokenid.partial: case tokenid.static: case tokenid.internal: case tokenid.private: case tokenid.abstract: case tokenid.sealed: \/\/parsetypemodifier(); curmods |= modmap.get(curtok.id); advance(); break; case tokenid.namespace: parsenamespace(); break; case tokenid.class: parseclass(); break; case tokenid.struct: parsestruct(); break; case tokenid.interface: parseinterface(); break; case tokenid.enum: parseenum(); break; case tokenid.delegate: parsedelegate(); break; case tokenid.semi: advance(); break; default: return; } } }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"private void parsenamespaceortypes() throws featurenotsupportedexception { while (!curtok.equals(eof)) { \/\/ todo: account for assembly attributes parsepossibleattributes(true); if (curattributes.size() > 0) {","code_context_10":"private void parsenamespaceortypes() throws featurenotsupportedexception { while (!curtok.equals(eof)) { \/\/ todo: account for assembly attributes parsepossibleattributes(true); if (curattributes.size() > 0) { for (attributenode an : curattributes) { cu.attributes.add(an); } curattributes.clear(); } \/\/ can be usingdirectives, globalattribs, or namespacemembersdecls \/\/ namespacemembersdecls include namespaces, class, struct, interface, enum, delegate switch (curtok.id) {","code_context_20":"private void parsenamespaceortypes() throws featurenotsupportedexception { while (!curtok.equals(eof)) { \/\/ todo: account for assembly attributes parsepossibleattributes(true); if (curattributes.size() > 0) { for (attributenode an : curattributes) { cu.attributes.add(an); } curattributes.clear(); } \/\/ can be usingdirectives, globalattribs, or namespacemembersdecls \/\/ namespacemembersdecls include namespaces, class, struct, interface, enum, delegate switch (curtok.id) { case tokenid.using: \/\/ using directive parseusingdirectives(); break; case tokenid.new: case tokenid.public: case tokenid.protected: case tokenid.partial: case tokenid.static: case tokenid.internal:","repo":"osoco\/comprendiendo-software-creando-herramientas"}
{"id":16088,"comment_id":1,"comment":"\/\/ can be usingdirectives, globalattribs, or namespacemembersdecls \/\/ namespacemembersdecls include namespaces, class, struct, interface, enum, delegate","code":"private void parsenamespaceortypes() throws featurenotsupportedexception { while (!curtok.equals(eof)) { \/\/ todo: account for assembly attributes parsepossibleattributes(true); if (curattributes.size() > 0) { for (attributenode an : curattributes) { cu.attributes.add(an); } curattributes.clear(); } \/\/ can be usingdirectives, globalattribs, or namespacemembersdecls \/\/ namespacemembersdecls include namespaces, class, struct, interface, enum, delegate switch (curtok.id) { case tokenid.using: \/\/ using directive parseusingdirectives(); break; case tokenid.new: case tokenid.public: case tokenid.protected: case tokenid.partial: case tokenid.static: case tokenid.internal: case tokenid.private: case tokenid.abstract: case tokenid.sealed: \/\/parsetypemodifier(); curmods |= modmap.get(curtok.id); advance(); break; case tokenid.namespace: parsenamespace(); break; case tokenid.class: parseclass(); break; case tokenid.struct: parsestruct(); break; case tokenid.interface: parseinterface(); break; case tokenid.enum: parseenum(); break; case tokenid.delegate: parsedelegate(); break; case tokenid.semi: advance(); break; default: return; } } }","classification":"NONSATD","isFinished":true,"code_context_2":"curattributes.clear(); } \/\/ can be usingdirectives, globalattribs, or namespacemembersdecls \/\/ namespacemembersdecls include namespaces, class, struct, interface, enum, delegate switch (curtok.id) { case tokenid.using:","code_context_10":"private void parsenamespaceortypes() throws featurenotsupportedexception { while (!curtok.equals(eof)) { \/\/ todo: account for assembly attributes parsepossibleattributes(true); if (curattributes.size() > 0) { for (attributenode an : curattributes) { cu.attributes.add(an); } curattributes.clear(); } \/\/ can be usingdirectives, globalattribs, or namespacemembersdecls \/\/ namespacemembersdecls include namespaces, class, struct, interface, enum, delegate switch (curtok.id) { case tokenid.using: \/\/ using directive parseusingdirectives(); break; case tokenid.new: case tokenid.public: case tokenid.protected: case tokenid.partial: case tokenid.static:","code_context_20":"private void parsenamespaceortypes() throws featurenotsupportedexception { while (!curtok.equals(eof)) { \/\/ todo: account for assembly attributes parsepossibleattributes(true); if (curattributes.size() > 0) { for (attributenode an : curattributes) { cu.attributes.add(an); } curattributes.clear(); } \/\/ can be usingdirectives, globalattribs, or namespacemembersdecls \/\/ namespacemembersdecls include namespaces, class, struct, interface, enum, delegate switch (curtok.id) { case tokenid.using: \/\/ using directive parseusingdirectives(); break; case tokenid.new: case tokenid.public: case tokenid.protected: case tokenid.partial: case tokenid.static: case tokenid.internal: case tokenid.private: case tokenid.abstract: case tokenid.sealed: \/\/parsetypemodifier(); curmods |= modmap.get(curtok.id); advance(); break; case tokenid.namespace: parsenamespace();","repo":"osoco\/comprendiendo-software-creando-herramientas"}
{"id":16088,"comment_id":2,"comment":"\/\/ using directive","code":"private void parsenamespaceortypes() throws featurenotsupportedexception { while (!curtok.equals(eof)) { \/\/ todo: account for assembly attributes parsepossibleattributes(true); if (curattributes.size() > 0) { for (attributenode an : curattributes) { cu.attributes.add(an); } curattributes.clear(); } \/\/ can be usingdirectives, globalattribs, or namespacemembersdecls \/\/ namespacemembersdecls include namespaces, class, struct, interface, enum, delegate switch (curtok.id) { case tokenid.using: \/\/ using directive parseusingdirectives(); break; case tokenid.new: case tokenid.public: case tokenid.protected: case tokenid.partial: case tokenid.static: case tokenid.internal: case tokenid.private: case tokenid.abstract: case tokenid.sealed: \/\/parsetypemodifier(); curmods |= modmap.get(curtok.id); advance(); break; case tokenid.namespace: parsenamespace(); break; case tokenid.class: parseclass(); break; case tokenid.struct: parsestruct(); break; case tokenid.interface: parseinterface(); break; case tokenid.enum: parseenum(); break; case tokenid.delegate: parsedelegate(); break; case tokenid.semi: advance(); break; default: return; } } }","classification":"NONSATD","isFinished":true,"code_context_2":"switch (curtok.id) { case tokenid.using: \/\/ using directive parseusingdirectives(); break;","code_context_10":"if (curattributes.size() > 0) { for (attributenode an : curattributes) { cu.attributes.add(an); } curattributes.clear(); } \/\/ can be usingdirectives, globalattribs, or namespacemembersdecls \/\/ namespacemembersdecls include namespaces, class, struct, interface, enum, delegate switch (curtok.id) { case tokenid.using: \/\/ using directive parseusingdirectives(); break; case tokenid.new: case tokenid.public: case tokenid.protected: case tokenid.partial: case tokenid.static: case tokenid.internal: case tokenid.private: case tokenid.abstract:","code_context_20":"private void parsenamespaceortypes() throws featurenotsupportedexception { while (!curtok.equals(eof)) { \/\/ todo: account for assembly attributes parsepossibleattributes(true); if (curattributes.size() > 0) { for (attributenode an : curattributes) { cu.attributes.add(an); } curattributes.clear(); } \/\/ can be usingdirectives, globalattribs, or namespacemembersdecls \/\/ namespacemembersdecls include namespaces, class, struct, interface, enum, delegate switch (curtok.id) { case tokenid.using: \/\/ using directive parseusingdirectives(); break; case tokenid.new: case tokenid.public: case tokenid.protected: case tokenid.partial: case tokenid.static: case tokenid.internal: case tokenid.private: case tokenid.abstract: case tokenid.sealed: \/\/parsetypemodifier(); curmods |= modmap.get(curtok.id); advance(); break; case tokenid.namespace: parsenamespace(); break; case tokenid.class: parseclass();","repo":"osoco\/comprendiendo-software-creando-herramientas"}
{"id":16088,"comment_id":3,"comment":"\/\/parsetypemodifier();","code":"private void parsenamespaceortypes() throws featurenotsupportedexception { while (!curtok.equals(eof)) { \/\/ todo: account for assembly attributes parsepossibleattributes(true); if (curattributes.size() > 0) { for (attributenode an : curattributes) { cu.attributes.add(an); } curattributes.clear(); } \/\/ can be usingdirectives, globalattribs, or namespacemembersdecls \/\/ namespacemembersdecls include namespaces, class, struct, interface, enum, delegate switch (curtok.id) { case tokenid.using: \/\/ using directive parseusingdirectives(); break; case tokenid.new: case tokenid.public: case tokenid.protected: case tokenid.partial: case tokenid.static: case tokenid.internal: case tokenid.private: case tokenid.abstract: case tokenid.sealed: \/\/parsetypemodifier(); curmods |= modmap.get(curtok.id); advance(); break; case tokenid.namespace: parsenamespace(); break; case tokenid.class: parseclass(); break; case tokenid.struct: parsestruct(); break; case tokenid.interface: parseinterface(); break; case tokenid.enum: parseenum(); break; case tokenid.delegate: parsedelegate(); break; case tokenid.semi: advance(); break; default: return; } } }","classification":"NONSATD","isFinished":true,"code_context_2":"case tokenid.abstract: case tokenid.sealed: \/\/parsetypemodifier(); curmods |= modmap.get(curtok.id); advance();","code_context_10":"break; case tokenid.new: case tokenid.public: case tokenid.protected: case tokenid.partial: case tokenid.static: case tokenid.internal: case tokenid.private: case tokenid.abstract: case tokenid.sealed: \/\/parsetypemodifier(); curmods |= modmap.get(curtok.id); advance(); break; case tokenid.namespace: parsenamespace(); break; case tokenid.class: parseclass(); break; case tokenid.struct:","code_context_20":"cu.attributes.add(an); } curattributes.clear(); } \/\/ can be usingdirectives, globalattribs, or namespacemembersdecls \/\/ namespacemembersdecls include namespaces, class, struct, interface, enum, delegate switch (curtok.id) { case tokenid.using: \/\/ using directive parseusingdirectives(); break; case tokenid.new: case tokenid.public: case tokenid.protected: case tokenid.partial: case tokenid.static: case tokenid.internal: case tokenid.private: case tokenid.abstract: case tokenid.sealed: \/\/parsetypemodifier(); curmods |= modmap.get(curtok.id); advance(); break; case tokenid.namespace: parsenamespace(); break; case tokenid.class: parseclass(); break; case tokenid.struct: parsestruct(); break; case tokenid.interface: parseinterface(); break; case tokenid.enum: parseenum(); break; case tokenid.delegate: parsedelegate();","repo":"osoco\/comprendiendo-software-creando-herramientas"}
{"id":16089,"comment_id":0,"comment":"\/\/ over hash","code":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break; } inppdirective = false; return result; }","classification":"NONSATD","isFinished":true,"code_context_2":"int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0];","code_context_10":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define:","code_context_20":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword();","repo":"osoco\/comprendiendo-software-creando-herramientas"}
{"id":16089,"comment_id":1,"comment":"\/\/ conditional-symbol pp-newline","code":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break; } inppdirective = false; return result; }","classification":"NONSATD","isFinished":true,"code_context_2":"switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) {","code_context_10":"identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) {","code_context_20":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount;","repo":"osoco\/comprendiendo-software-creando-herramientas"}
{"id":16089,"comment_id":2,"comment":"\/\/ conditional-symbol pp-newline","code":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break; } inppdirective = false; return result; }","classification":"NONSATD","isFinished":true,"code_context_2":"switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) {","code_context_10":"identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) {","code_context_20":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount;","repo":"osoco\/comprendiendo-software-creando-herramientas"}
{"id":16089,"comment_id":3,"comment":"\/\/ pp-expression pp-newline conditional-section(opt)","code":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break; } inppdirective = false; return result; }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance();","code_context_10":"break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; }","code_context_20":"reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif:","repo":"osoco\/comprendiendo-software-creando-herramientas"}
{"id":16089,"comment_id":4,"comment":"\/\/ todo: account for true, false, ||, &&, ==, !=, !","code":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break; } inppdirective = false; return result; }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) {","code_context_10":"} result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block","code_context_20":"if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) {","repo":"osoco\/comprendiendo-software-creando-herramientas"}
{"id":16089,"comment_id":5,"comment":"\/\/result = new ppifnode(parseexpressiontonewline());","code":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break; } inppdirective = false; return result; }","classification":"NONSATD","isFinished":true,"code_context_2":"ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance();","code_context_10":"if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt)","code_context_20":"case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif:","repo":"osoco\/comprendiendo-software-creando-herramientas"}
{"id":16089,"comment_id":6,"comment":"\/\/ skip this block","code":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break; } inppdirective = false; return result; }","classification":"NONSATD","isFinished":true,"code_context_2":"} if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); }","code_context_10":"\/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) {","code_context_20":"} result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line:","repo":"osoco\/comprendiendo-software-creando-herramientas"}
{"id":16089,"comment_id":7,"comment":"\/\/ pp-expression pp-newline conditional-section(opt)","code":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break; } inppdirective = false; return result; }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance();","code_context_10":"break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; }","code_context_20":"reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif:","repo":"osoco\/comprendiendo-software-creando-herramientas"}
{"id":16089,"comment_id":8,"comment":"\/\/ pp-newline conditional-section(opt)","code":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break; } inppdirective = false; return result; }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block","code_context_10":"if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break;","code_context_20":"ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message","repo":"osoco\/comprendiendo-software-creando-herramientas"}
{"id":16089,"comment_id":9,"comment":"\/\/ skip this block","code":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break; } inppdirective = false; return result; }","classification":"NONSATD","isFinished":true,"code_context_2":"} if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); }","code_context_10":"\/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) {","code_context_20":"} result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line:","repo":"osoco\/comprendiendo-software-creando-herramientas"}
{"id":16089,"comment_id":10,"comment":"\/\/ pp-newline","code":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break; } inppdirective = false; return result; }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block","code_context_10":"if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break;","code_context_20":"ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message","repo":"osoco\/comprendiendo-software-creando-herramientas"}
{"id":16089,"comment_id":11,"comment":"\/\/ line-indicator pp-newline","code":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break; } inppdirective = false; return result; }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break;","code_context_10":"\/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break;","code_context_20":"skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message","repo":"osoco\/comprendiendo-software-creando-herramientas"}
{"id":16089,"comment_id":12,"comment":"\/\/ pp-message","code":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break; } inppdirective = false; return result; }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break;","code_context_10":"case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break;","code_context_20":"\/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break;","repo":"osoco\/comprendiendo-software-creando-herramientas"}
{"id":16089,"comment_id":13,"comment":"\/\/ pp-message","code":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break; } inppdirective = false; return result; }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break;","code_context_10":"case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break;","code_context_20":"\/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break;","repo":"osoco\/comprendiendo-software-creando-herramientas"}
{"id":16089,"comment_id":14,"comment":"\/\/ pp-message","code":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break; } inppdirective = false; return result; }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break;","code_context_10":"case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break;","code_context_20":"\/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break;","repo":"osoco\/comprendiendo-software-creando-herramientas"}
{"id":16089,"comment_id":15,"comment":"\/\/ pp-message","code":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break; } inppdirective = false; return result; }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break;","code_context_10":"case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break;","code_context_20":"\/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break;","repo":"osoco\/comprendiendo-software-creando-herramientas"}
{"id":16089,"comment_id":16,"comment":"\/\/ pp-message","code":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); \/\/ over hash identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: \/\/ conditional-symbol pp-newline identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: \/\/ conditional-symbol pp-newline identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: \/\/ pp-expression pp-newline conditional-section(opt) if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; \/\/ todo: account for true, false, ||, &&, ==, !=, ! identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } \/\/result = new ppifnode(parseexpressiontonewline()); if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.elif: \/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break; } inppdirective = false; return result; }","classification":"NONSATD","isFinished":true,"code_context_2":"break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break;","code_context_10":"case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break;","code_context_20":"\/\/ pp-expression pp-newline conditional-section(opt) skiptoeol(startline); break; case preprocessorid.else: \/\/ pp-newline conditional-section(opt) if (ppcondition == true) { \/\/ skip this block skiptoelseorendif(); } break; case preprocessorid.endif: \/\/ pp-newline result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: \/\/ line-indicator pp-newline skiptoeol(startline); break; case preprocessorid.error: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.warning: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.region: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.endregion: \/\/ pp-message skiptoeol(startline); break; case preprocessorid.pragma: \/\/ pp-message skiptoeol(startline); break; default: break;","repo":"osoco\/comprendiendo-software-creando-herramientas"}
{"id":16146,"comment_id":0,"comment":"\/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"NONSATD","isFinished":true,"code_context_2":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet","code_context_10":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet);","code_context_20":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":1,"comment":"\/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"DESIGN","isFinished":true,"code_context_2":"\/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) {","code_context_10":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length();","code_context_20":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) {","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":2,"comment":"\/\/now we use the excelgenerator to generate the workbooks","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"NONSATD","isFinished":true,"code_context_2":"int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) {","code_context_10":"for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf);","code_context_20":"\/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":3,"comment":"\/\/create a config for this workbook","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"NONSATD","isFinished":true,"code_context_2":"for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable","code_context_10":"sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) {","code_context_20":"\/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); });","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":4,"comment":"\/\/todo configurable","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"\/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) {","code_context_10":"workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig();","code_context_20":"\/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts)","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":5,"comment":"\/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"DESIGN","isFinished":true,"code_context_2":"sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k);","code_context_10":"for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options);","code_context_20":"for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":6,"comment":"\/\/todo maybe make a getsingleordefault method","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"DESIGN","isFinished":true,"code_context_2":"exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset);","code_context_10":"workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class);","code_context_20":"} int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } }","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":7,"comment":"\/\/draw the excelcell matrix from exceltable","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"NONSATD","isFinished":true,"code_context_2":"point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset","code_context_10":"sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else {","code_context_20":"\/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf);","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":8,"comment":"\/\/it uses the tableconf offset","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); });","code_context_10":"\/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); }","code_context_20":"for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf);","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":9,"comment":"\/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts)","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"}); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) {","code_context_10":"excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); }","code_context_20":"\/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder);","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":10,"comment":"\/\/in one sheet multiple tables could be existing","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"NONSATD","isFinished":true,"code_context_2":"throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \");","code_context_10":"d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i);","code_context_20":"\/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping());","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":11,"comment":"\/\/sheet name comes from table content","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"NONSATD","isFinished":true,"code_context_2":"} } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf);","code_context_10":"if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null;","code_context_20":"point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping());","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":12,"comment":"\/\/per sheet","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"NONSATD","isFinished":true,"code_context_2":"sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i);","code_context_10":"throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) {","code_context_20":"tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns);","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":13,"comment":"\/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"NONSATD","isFinished":true,"code_context_2":"}\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder);","code_context_10":"\/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard);","code_context_20":"d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) {","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":14,"comment":"\/\/write provenance =================================================","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"NONSATD","isFinished":true,"code_context_2":"file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null;","code_context_10":"} \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel();","code_context_20":"classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter(","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":15,"comment":"\/\/used in rdfprovenance for fast lookup reified statements","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"NONSATD","isFinished":true,"code_context_2":"} } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance","code_context_10":"new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge","code_context_20":"provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); }","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":16,"comment":"\/\/need here sheetname for provenance","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"NONSATD","isFinished":true,"code_context_2":"\/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet);","code_context_10":"new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue;","code_context_20":"provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel);","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":17,"comment":"\/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"NONSATD","isFinished":true,"code_context_2":"provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; }","code_context_10":"\/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) {","code_context_20":"new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) {","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":18,"comment":"\/\/no provenance information for this cell","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"NONSATD","isFinished":true,"code_context_2":"} if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; }","code_context_10":"for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel);","code_context_20":"csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) {","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":19,"comment":"\/\/write to files","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"NONSATD","isFinished":true,"code_context_2":"} } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\");","code_context_10":"} if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\");","code_context_20":"\/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) {","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":20,"comment":"\/\/key is sheet name","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"NONSATD","isFinished":true,"code_context_2":"} if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage);","code_context_10":"} } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) {","code_context_20":"} catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1);","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":21,"comment":"\/\/count how often","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"NONSATD","isFinished":true,"code_context_2":"for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) {","code_context_10":"} catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) {","code_context_20":"file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage);","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":22,"comment":"\/\/skip the ones with no prov and no address (temp cells)","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"NONSATD","isFinished":true,"code_context_2":"for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue;","code_context_10":"if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>());","code_context_20":"throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray();","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":23,"comment":"\/\/because json array hash is always different","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"NONSATD","isFinished":true,"code_context_2":"object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); }","code_context_10":"map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset());","code_context_20":"throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); }","repo":"mschroeder-github\/datasprout"}
{"id":16146,"comment_id":24,"comment":"\/\/per workbook","code":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); \/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); \/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); \/\/now we use the excelgenerator to generate the workbooks excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); \/\/create a config for this workbook excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); \/\/todo configurable workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); \/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); \/\/todo maybe make a getsingleordefault method point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); \/\/draw the excelcell matrix from exceltable tableconf.setstaticcelldrawer(d -> { \/\/it uses the tableconf offset d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); \/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts) classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } \/\/in one sheet multiple tables could be existing if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } \/\/sheet name comes from table content sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); }\/\/per sheet excelgeneratorresult result = excelgenerator.generate(null, workbookconf); \/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); \/\/write provenance ================================================= model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } \/\/used in rdfprovenance for fast lookup reified statements map<statement, resource> stmt2res = new hashmap<>(); \/\/need here sheetname for provenance for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { \/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method continue; } if (prov.getstatements().isempty()) { \/\/no provenance information for this cell continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } \/\/write to files if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { \/\/key is sheet name jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); \/\/count how often map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { \/\/skip the ones with no prov and no address (temp cells) if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { \/\/because json array hash is always different val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","classification":"NONSATD","isFinished":true,"code_context_2":"} } }\/\/per workbook }","code_context_10":"persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","code_context_20":"jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }\/\/per workbook }","repo":"mschroeder-github\/datasprout"}
{"id":16159,"comment_id":0,"comment":"\/\/ probably incorrect - comparing object[] arrays with arrays.equals","code":"@override public boolean equals(object o) { if (this == o) return true; if (o == null || getclass() != o.getclass()) return false; parameterizedtypeimpl that = (parameterizedtypeimpl) o; \/\/ probably incorrect - comparing object[] arrays with arrays.equals if (!arrays.equals(actualtypearguments, that.actualtypearguments)) return false; if (ownertype != null ? !ownertype.equals(that.ownertype) : that.ownertype != null) return false; return rawtype != null ? rawtype.equals(that.rawtype) : that.rawtype == null; }","classification":"DEFECT","isFinished":true,"code_context_2":"if (o == null || getclass() != o.getclass()) return false; parameterizedtypeimpl that = (parameterizedtypeimpl) o; \/\/ probably incorrect - comparing object[] arrays with arrays.equals if (!arrays.equals(actualtypearguments, that.actualtypearguments)) return false; if (ownertype != null ? !ownertype.equals(that.ownertype) : that.ownertype != null) return false;","code_context_10":"@override public boolean equals(object o) { if (this == o) return true; if (o == null || getclass() != o.getclass()) return false; parameterizedtypeimpl that = (parameterizedtypeimpl) o; \/\/ probably incorrect - comparing object[] arrays with arrays.equals if (!arrays.equals(actualtypearguments, that.actualtypearguments)) return false; if (ownertype != null ? !ownertype.equals(that.ownertype) : that.ownertype != null) return false; return rawtype != null ? rawtype.equals(that.rawtype) : that.rawtype == null; }","code_context_20":"@override public boolean equals(object o) { if (this == o) return true; if (o == null || getclass() != o.getclass()) return false; parameterizedtypeimpl that = (parameterizedtypeimpl) o; \/\/ probably incorrect - comparing object[] arrays with arrays.equals if (!arrays.equals(actualtypearguments, that.actualtypearguments)) return false; if (ownertype != null ? !ownertype.equals(that.ownertype) : that.ownertype != null) return false; return rawtype != null ? rawtype.equals(that.rawtype) : that.rawtype == null; }","repo":"osglworks\/java-di"}
{"id":8062,"comment_id":0,"comment":"\/\/ objecteventlistener","code":"@override \/\/ objecteventlistener public object addingobject (object obj, int index) { objectrenderer renderer = rendererfactory.newrenderer (obj); \/\/ todo: vaadin session handling layout.addcomponent (renderer, index); active_renderers.put (get_object_hash (obj), renderer); log.info (\"<<renderer>> addingobject() layout height = {} {}\", layout.getheight (), layout.getheightunits ().tostring ()); log.info (\"add new renderer {}: obj={} or={} \/\/\/ active_renderers={}\", this, get_object_hash (obj), renderer, active_renderers); return (obj); }","classification":"NONSATD","isFinished":true,"code_context_2":"@override \/\/ objecteventlistener public object addingobject (object obj, int index) {","code_context_10":"@override \/\/ objecteventlistener public object addingobject (object obj, int index) { objectrenderer renderer = rendererfactory.newrenderer (obj); \/\/ todo: vaadin session handling layout.addcomponent (renderer, index); active_renderers.put (get_object_hash (obj), renderer); log.info (\"<<renderer>> addingobject() layout height = {} {}\", layout.getheight (), layout.getheightunits ().tostring ()); log.info (\"add new renderer {}: obj={} or={} \/\/\/ active_renderers={}\", this, get_object_hash (obj), renderer, active_renderers); return (obj); }","code_context_20":"@override \/\/ objecteventlistener public object addingobject (object obj, int index) { objectrenderer renderer = rendererfactory.newrenderer (obj); \/\/ todo: vaadin session handling layout.addcomponent (renderer, index); active_renderers.put (get_object_hash (obj), renderer); log.info (\"<<renderer>> addingobject() layout height = {} {}\", layout.getheight (), layout.getheightunits ().tostring ()); log.info (\"add new renderer {}: obj={} or={} \/\/\/ active_renderers={}\", this, get_object_hash (obj), renderer, active_renderers); return (obj); }","repo":"neoautus\/lucidj"}
{"id":8062,"comment_id":1,"comment":"\/\/ todo: vaadin session handling","code":"@override \/\/ objecteventlistener public object addingobject (object obj, int index) { objectrenderer renderer = rendererfactory.newrenderer (obj); \/\/ todo: vaadin session handling layout.addcomponent (renderer, index); active_renderers.put (get_object_hash (obj), renderer); log.info (\"<<renderer>> addingobject() layout height = {} {}\", layout.getheight (), layout.getheightunits ().tostring ()); log.info (\"add new renderer {}: obj={} or={} \/\/\/ active_renderers={}\", this, get_object_hash (obj), renderer, active_renderers); return (obj); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"{ objectrenderer renderer = rendererfactory.newrenderer (obj); \/\/ todo: vaadin session handling layout.addcomponent (renderer, index); active_renderers.put (get_object_hash (obj), renderer);","code_context_10":"@override \/\/ objecteventlistener public object addingobject (object obj, int index) { objectrenderer renderer = rendererfactory.newrenderer (obj); \/\/ todo: vaadin session handling layout.addcomponent (renderer, index); active_renderers.put (get_object_hash (obj), renderer); log.info (\"<<renderer>> addingobject() layout height = {} {}\", layout.getheight (), layout.getheightunits ().tostring ()); log.info (\"add new renderer {}: obj={} or={} \/\/\/ active_renderers={}\", this, get_object_hash (obj), renderer, active_renderers); return (obj); }","code_context_20":"@override \/\/ objecteventlistener public object addingobject (object obj, int index) { objectrenderer renderer = rendererfactory.newrenderer (obj); \/\/ todo: vaadin session handling layout.addcomponent (renderer, index); active_renderers.put (get_object_hash (obj), renderer); log.info (\"<<renderer>> addingobject() layout height = {} {}\", layout.getheight (), layout.getheightunits ().tostring ()); log.info (\"add new renderer {}: obj={} or={} \/\/\/ active_renderers={}\", this, get_object_hash (obj), renderer, active_renderers); return (obj); }","repo":"neoautus\/lucidj"}
{"id":8063,"comment_id":0,"comment":"\/\/ objecteventlistener","code":"@override \/\/ objecteventlistener public void removingobject (object obj, int index) { string hash = get_object_hash (obj); objectrenderer renderer = active_renderers.get (hash); log.info (\"removingobject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers); \/\/ only deal with valid renderers if (renderer != null) { \/\/ todo: vaadin session handling layout.removecomponent (renderer); log.info (\"<<renderer>> removingobject() layout height = {} {}\", layout.getheight (), layout.getheightunits ().tostring ()); } active_renderers.remove (hash); }","classification":"NONSATD","isFinished":true,"code_context_2":"@override \/\/ objecteventlistener public void removingobject (object obj, int index) {","code_context_10":"@override \/\/ objecteventlistener public void removingobject (object obj, int index) { string hash = get_object_hash (obj); objectrenderer renderer = active_renderers.get (hash); log.info (\"removingobject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers); \/\/ only deal with valid renderers if (renderer != null) { \/\/ todo: vaadin session handling layout.removecomponent (renderer);","code_context_20":"@override \/\/ objecteventlistener public void removingobject (object obj, int index) { string hash = get_object_hash (obj); objectrenderer renderer = active_renderers.get (hash); log.info (\"removingobject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers); \/\/ only deal with valid renderers if (renderer != null) { \/\/ todo: vaadin session handling layout.removecomponent (renderer); log.info (\"<<renderer>> removingobject() layout height = {} {}\", layout.getheight (), layout.getheightunits ().tostring ()); } active_renderers.remove (hash); }","repo":"neoautus\/lucidj"}
{"id":8063,"comment_id":1,"comment":"\/\/ only deal with valid renderers","code":"@override \/\/ objecteventlistener public void removingobject (object obj, int index) { string hash = get_object_hash (obj); objectrenderer renderer = active_renderers.get (hash); log.info (\"removingobject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers); \/\/ only deal with valid renderers if (renderer != null) { \/\/ todo: vaadin session handling layout.removecomponent (renderer); log.info (\"<<renderer>> removingobject() layout height = {} {}\", layout.getheight (), layout.getheightunits ().tostring ()); } active_renderers.remove (hash); }","classification":"NONSATD","isFinished":true,"code_context_2":"objectrenderer renderer = active_renderers.get (hash); log.info (\"removingobject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers); \/\/ only deal with valid renderers if (renderer != null) {","code_context_10":"@override \/\/ objecteventlistener public void removingobject (object obj, int index) { string hash = get_object_hash (obj); objectrenderer renderer = active_renderers.get (hash); log.info (\"removingobject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers); \/\/ only deal with valid renderers if (renderer != null) { \/\/ todo: vaadin session handling layout.removecomponent (renderer); log.info (\"<<renderer>> removingobject() layout height = {} {}\", layout.getheight (), layout.getheightunits ().tostring ()); } active_renderers.remove (hash); }","code_context_20":"@override \/\/ objecteventlistener public void removingobject (object obj, int index) { string hash = get_object_hash (obj); objectrenderer renderer = active_renderers.get (hash); log.info (\"removingobject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers); \/\/ only deal with valid renderers if (renderer != null) { \/\/ todo: vaadin session handling layout.removecomponent (renderer); log.info (\"<<renderer>> removingobject() layout height = {} {}\", layout.getheight (), layout.getheightunits ().tostring ()); } active_renderers.remove (hash); }","repo":"neoautus\/lucidj"}
{"id":8063,"comment_id":2,"comment":"\/\/ todo: vaadin session handling","code":"@override \/\/ objecteventlistener public void removingobject (object obj, int index) { string hash = get_object_hash (obj); objectrenderer renderer = active_renderers.get (hash); log.info (\"removingobject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers); \/\/ only deal with valid renderers if (renderer != null) { \/\/ todo: vaadin session handling layout.removecomponent (renderer); log.info (\"<<renderer>> removingobject() layout height = {} {}\", layout.getheight (), layout.getheightunits ().tostring ()); } active_renderers.remove (hash); }","classification":"IMPLEMENTATION","isFinished":true,"code_context_2":"if (renderer != null) { \/\/ todo: vaadin session handling layout.removecomponent (renderer); log.info (\"<<renderer>> removingobject() layout height = {} {}\", layout.getheight (), layout.getheightunits ().tostring ());","code_context_10":"@override \/\/ objecteventlistener public void removingobject (object obj, int index) { string hash = get_object_hash (obj); objectrenderer renderer = active_renderers.get (hash); log.info (\"removingobject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers); \/\/ only deal with valid renderers if (renderer != null) { \/\/ todo: vaadin session handling layout.removecomponent (renderer); log.info (\"<<renderer>> removingobject() layout height = {} {}\", layout.getheight (), layout.getheightunits ().tostring ()); } active_renderers.remove (hash); }","code_context_20":"@override \/\/ objecteventlistener public void removingobject (object obj, int index) { string hash = get_object_hash (obj); objectrenderer renderer = active_renderers.get (hash); log.info (\"removingobject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers); \/\/ only deal with valid renderers if (renderer != null) { \/\/ todo: vaadin session handling layout.removecomponent (renderer); log.info (\"<<renderer>> removingobject() layout height = {} {}\", layout.getheight (), layout.getheightunits ().tostring ()); } active_renderers.remove (hash); }","repo":"neoautus\/lucidj"}

{"id":24703,"original_code":"@Override\n        public boolean onStartNode(ProjectPath path) {\n            JpaEntityMap entityMap = (JpaEntityMap) path.getObject();\n            \/\/ TODO: andrus, 4\/28\/2006 - actually we need to analyze preloaded classes and\n            \/\/ see how they were annotated to choose the right access type...\n            entityMap.setAccess(AccessType.FIELD);\n            return true;\n        }","code":"@Override\n        public boolean onStartNode(ProjectPath path) {\n            JpaEntityMap entityMap = (JpaEntityMap) path.getObject();\n           \n           \n            entityMap.setAccess(AccessType.FIELD);\n            return true;\n        }","cleancode":"@override public boolean onstartnode(projectpath path) { jpaentitymap entitymap = (jpaentitymap) path.getobject(); entitymap.setaccess(accesstype.field); return true; }","comment":"\/\/ todo: andrus, 4\/28\/2006 - actually we need to analyze preloaded classes and \/\/ see how they were annotated to choose the right access type...","repo":"JavaQualitasCorpus\/cayenne-3.0.1","code_context_2":"public boolean onStartNode(ProjectPath path) {\nJpaEntityMap entityMap = (JpaEntityMap) path.getObject();\n\/\/ TODO: andrus, 4\/28\/2006 - actually we need to analyze preloaded classes and\n\/\/ see how they were annotated to choose the right access type...\nentityMap.setAccess(AccessType.FIELD);\nreturn true;","code_context_10":"@Override\npublic boolean onStartNode(ProjectPath path) {\nJpaEntityMap entityMap = (JpaEntityMap) path.getObject();\n\/\/ TODO: andrus, 4\/28\/2006 - actually we need to analyze preloaded classes and\n\/\/ see how they were annotated to choose the right access type...\nentityMap.setAccess(AccessType.FIELD);\nreturn true;\n}","code_context_20":"@Override\npublic boolean onStartNode(ProjectPath path) {\nJpaEntityMap entityMap = (JpaEntityMap) path.getObject();\n\/\/ TODO: andrus, 4\/28\/2006 - actually we need to analyze preloaded classes and\n\/\/ see how they were annotated to choose the right access type...\nentityMap.setAccess(AccessType.FIELD);\nreturn true;\n}","label":[1,0,0,0]}
{"id":24704,"original_code":"@Override\n        public boolean onStartNode(ProjectPath path) {\n            JpaRelationship relationship = (JpaRelationship) path.getObjectParent();\n            JpaJoinColumn column = (JpaJoinColumn) path.getObject();\n            if (column.getTable() == null) {\n                JpaEntity entity = path.firstInstanceOf(JpaEntity.class);\n                column.setTable(entity.getTable().getName());\n            }\n            \/\/ JPA Spec, 2.1.8.2 (same for all relationship owners):\n            \/\/ The following mapping defaults apply: [...]\n            \/\/ Table A contains a foreign key to table B. The foreign key column\n            \/\/ name is formed as the concatenation of the following: the name of\n            \/\/ the relationship property or field of entityA; \"_\" ; the name of\n            \/\/ the primary key column in table B. The foreign key column has the\n            \/\/ same type as the primary key of table B.\n            JpaEntityMap map = path.firstInstanceOf(JpaEntityMap.class);\n            JpaEntity target = map.entityForClass(relationship.getTargetEntityName());\n            if (target == null) {\n                context.recordConflict(new SimpleValidationFailure(\n                        relationship,\n                        \"Invalid relationship target \"\n                                + relationship.getTargetEntityName()));\n            }\n            else if (target.getAttributes() == null\n                    || target.getAttributes().getIds().isEmpty()) {\n                context.recordConflict(new SimpleValidationFailure(\n                        target,\n                        \"Relationship target has no PK defined: \"\n                                + relationship.getTargetEntityName()));\n            }\n            else if (target.getAttributes().getIds().size() > 1) {\n                \/\/ TODO: andrus, 4\/30\/2006 implement this; note that instead of\n                \/\/ checking for \"attribute.getJoinColumns().isEmpty()\" above,\n                \/\/ we'll have to match individual columns\n                context.recordConflict(new SimpleValidationFailure(\n                        relationship,\n                        \"Defaults for compound FK are not implemented.\"));\n            }\n            else {\n                JpaId id = target.getAttributes().getIds().iterator().next();\n                String pkName = id.getColumn() != null ? id.getColumn().getName() : id\n                        .getName();\n                column.setName(relationship.getName() + '_' + pkName);\n                column.setReferencedColumnName(id.getColumn() != null ? id\n                        .getColumn()\n                        .getName() : id.getName());\n            }\n            return true;\n        }","code":"@Override\n        public boolean onStartNode(ProjectPath path) {\n            JpaRelationship relationship = (JpaRelationship) path.getObjectParent();\n            JpaJoinColumn column = (JpaJoinColumn) path.getObject();\n            if (column.getTable() == null) {\n                JpaEntity entity = path.firstInstanceOf(JpaEntity.class);\n                column.setTable(entity.getTable().getName());\n            }\n           \n           \n           \n           \n           \n           \n           \n            JpaEntityMap map = path.firstInstanceOf(JpaEntityMap.class);\n            JpaEntity target = map.entityForClass(relationship.getTargetEntityName());\n            if (target == null) {\n                context.recordConflict(new SimpleValidationFailure(\n                        relationship,\n                        \"Invalid relationship target \"\n                                + relationship.getTargetEntityName()));\n            }\n            else if (target.getAttributes() == null\n                    || target.getAttributes().getIds().isEmpty()) {\n                context.recordConflict(new SimpleValidationFailure(\n                        target,\n                        \"Relationship target has no PK defined: \"\n                                + relationship.getTargetEntityName()));\n            }\n            else if (target.getAttributes().getIds().size() > 1) {\n               \n               \n               \n                context.recordConflict(new SimpleValidationFailure(\n                        relationship,\n                        \"Defaults for compound FK are not implemented.\"));\n            }\n            else {\n                JpaId id = target.getAttributes().getIds().iterator().next();\n                String pkName = id.getColumn() != null ? id.getColumn().getName() : id\n                        .getName();\n                column.setName(relationship.getName() + '_' + pkName);\n                column.setReferencedColumnName(id.getColumn() != null ? id\n                        .getColumn()\n                        .getName() : id.getName());\n            }\n            return true;\n        }","cleancode":"@override public boolean onstartnode(projectpath path) { jparelationship relationship = (jparelationship) path.getobjectparent(); jpajoincolumn column = (jpajoincolumn) path.getobject(); if (column.gettable() == null) { jpaentity entity = path.firstinstanceof(jpaentity.class); column.settable(entity.gettable().getname()); } jpaentitymap map = path.firstinstanceof(jpaentitymap.class); jpaentity target = map.entityforclass(relationship.gettargetentityname()); if (target == null) { context.recordconflict(new simplevalidationfailure( relationship, \"invalid relationship target \" + relationship.gettargetentityname())); } else if (target.getattributes() == null || target.getattributes().getids().isempty()) { context.recordconflict(new simplevalidationfailure( target, \"relationship target has no pk defined: \" + relationship.gettargetentityname())); } else if (target.getattributes().getids().size() > 1) { context.recordconflict(new simplevalidationfailure( relationship, \"defaults for compound fk are not implemented.\")); } else { jpaid id = target.getattributes().getids().iterator().next(); string pkname = id.getcolumn() != null ? id.getcolumn().getname() : id .getname(); column.setname(relationship.getname() + '_' + pkname); column.setreferencedcolumnname(id.getcolumn() != null ? id .getcolumn() .getname() : id.getname()); } return true; }","comment":"\/\/ jpa spec, 2.1.8.2 (same for all relationship owners): \/\/ the following mapping defaults apply: [...] \/\/ table a contains a foreign key to table b. the foreign key column \/\/ name is formed as the concatenation of the following: the name of \/\/ the relationship property or field of entitya; \"_\" ; the name of \/\/ the primary key column in table b. the foreign key column has the \/\/ same type as the primary key of table b.\n\/\/ todo: andrus, 4\/30\/2006 implement this; note that instead of \/\/ checking for \"attribute.getjoincolumns().isempty()\" above, \/\/ we'll have to match individual columns","repo":"JavaQualitasCorpus\/cayenne-3.0.1","code_context_2":"column.setTable(entity.getTable().getName());\n}\n\/\/ JPA Spec, 2.1.8.2 (same for all relationship owners):\n\/\/ The following mapping defaults apply: [...]\n\/\/ Table A contains a foreign key to table B. The foreign key column\n\/\/ name is formed as the concatenation of the following: the name of\n\/\/ the relationship property or field of entityA; \"_\" ; the name of\n\/\/ the primary key column in table B. The foreign key column has the\n\/\/ same type as the primary key of table B.\nJpaEntityMap map = path.firstInstanceOf(JpaEntityMap.class);\nJpaEntity target = map.entityForClass(relationship.getTargetEntityName());\n\n}\nelse if (target.getAttributes().getIds().size() > 1) {\n\/\/ TODO: andrus, 4\/30\/2006 implement this; note that instead of\n\/\/ checking for \"attribute.getJoinColumns().isEmpty()\" above,\n\/\/ we'll have to match individual columns\ncontext.recordConflict(new SimpleValidationFailure(\nrelationship,","code_context_10":"@Override\npublic boolean onStartNode(ProjectPath path) {\nJpaRelationship relationship = (JpaRelationship) path.getObjectParent();\nJpaJoinColumn column = (JpaJoinColumn) path.getObject();\nif (column.getTable() == null) {\nJpaEntity entity = path.firstInstanceOf(JpaEntity.class);\ncolumn.setTable(entity.getTable().getName());\n}\n\/\/ JPA Spec, 2.1.8.2 (same for all relationship owners):\n\/\/ The following mapping defaults apply: [...]\n\/\/ Table A contains a foreign key to table B. The foreign key column\n\/\/ name is formed as the concatenation of the following: the name of\n\/\/ the relationship property or field of entityA; \"_\" ; the name of\n\/\/ the primary key column in table B. The foreign key column has the\n\/\/ same type as the primary key of table B.\nJpaEntityMap map = path.firstInstanceOf(JpaEntityMap.class);\nJpaEntity target = map.entityForClass(relationship.getTargetEntityName());\nif (target == null) {\ncontext.recordConflict(new SimpleValidationFailure(\nrelationship,\n\"Invalid relationship target \"\n+ relationship.getTargetEntityName()));\n}\nelse if (target.getAttributes() == null\n|| target.getAttributes().getIds().isEmpty()) {\n\n+ relationship.getTargetEntityName()));\n}\nelse if (target.getAttributes() == null\n|| target.getAttributes().getIds().isEmpty()) {\ncontext.recordConflict(new SimpleValidationFailure(\ntarget,\n\"Relationship target has no PK defined: \"\n+ relationship.getTargetEntityName()));\n}\nelse if (target.getAttributes().getIds().size() > 1) {\n\/\/ TODO: andrus, 4\/30\/2006 implement this; note that instead of\n\/\/ checking for \"attribute.getJoinColumns().isEmpty()\" above,\n\/\/ we'll have to match individual columns\ncontext.recordConflict(new SimpleValidationFailure(\nrelationship,\n\"Defaults for compound FK are not implemented.\"));\n}\nelse {\nJpaId id = target.getAttributes().getIds().iterator().next();\nString pkName = id.getColumn() != null ? id.getColumn().getName() : id\n.getName();\ncolumn.setName(relationship.getName() + '_' + pkName);\ncolumn.setReferencedColumnName(id.getColumn() != null ? id","code_context_20":"@Override\npublic boolean onStartNode(ProjectPath path) {\nJpaRelationship relationship = (JpaRelationship) path.getObjectParent();\nJpaJoinColumn column = (JpaJoinColumn) path.getObject();\nif (column.getTable() == null) {\nJpaEntity entity = path.firstInstanceOf(JpaEntity.class);\ncolumn.setTable(entity.getTable().getName());\n}\n\/\/ JPA Spec, 2.1.8.2 (same for all relationship owners):\n\/\/ The following mapping defaults apply: [...]\n\/\/ Table A contains a foreign key to table B. The foreign key column\n\/\/ name is formed as the concatenation of the following: the name of\n\/\/ the relationship property or field of entityA; \"_\" ; the name of\n\/\/ the primary key column in table B. The foreign key column has the\n\/\/ same type as the primary key of table B.\nJpaEntityMap map = path.firstInstanceOf(JpaEntityMap.class);\nJpaEntity target = map.entityForClass(relationship.getTargetEntityName());\nif (target == null) {\ncontext.recordConflict(new SimpleValidationFailure(\nrelationship,\n\"Invalid relationship target \"\n+ relationship.getTargetEntityName()));\n}\nelse if (target.getAttributes() == null\n|| target.getAttributes().getIds().isEmpty()) {\ncontext.recordConflict(new SimpleValidationFailure(\ntarget,\n\"Relationship target has no PK defined: \"\n+ relationship.getTargetEntityName()));\n}\nelse if (target.getAttributes().getIds().size() > 1) {\n\/\/ TODO: andrus, 4\/30\/2006 implement this; note that instead of\n\/\/ checking for \"attribute.getJoinColumns().isEmpty()\" above,\n\/\/ we'll have to match individual columns\ncontext.recordConflict(new SimpleValidationFailure(\n\n\/\/ name is formed as the concatenation of the following: the name of\n\/\/ the relationship property or field of entityA; \"_\" ; the name of\n\/\/ the primary key column in table B. The foreign key column has the\n\/\/ same type as the primary key of table B.\nJpaEntityMap map = path.firstInstanceOf(JpaEntityMap.class);\nJpaEntity target = map.entityForClass(relationship.getTargetEntityName());\nif (target == null) {\ncontext.recordConflict(new SimpleValidationFailure(\nrelationship,\n\"Invalid relationship target \"\n+ relationship.getTargetEntityName()));\n}\nelse if (target.getAttributes() == null\n|| target.getAttributes().getIds().isEmpty()) {\ncontext.recordConflict(new SimpleValidationFailure(\ntarget,\n\"Relationship target has no PK defined: \"\n+ relationship.getTargetEntityName()));\n}\nelse if (target.getAttributes().getIds().size() > 1) {\n\/\/ TODO: andrus, 4\/30\/2006 implement this; note that instead of\n\/\/ checking for \"attribute.getJoinColumns().isEmpty()\" above,\n\/\/ we'll have to match individual columns\ncontext.recordConflict(new SimpleValidationFailure(\nrelationship,\n\"Defaults for compound FK are not implemented.\"));\n}\nelse {\nJpaId id = target.getAttributes().getIds().iterator().next();\nString pkName = id.getColumn() != null ? id.getColumn().getName() : id\n.getName();\ncolumn.setName(relationship.getName() + '_' + pkName);\ncolumn.setReferencedColumnName(id.getColumn() != null ? id\n.getColumn()\n.getName() : id.getName());\n}\nreturn true;\n}","label":[0,1,0,0]}
{"id":16569,"original_code":"private Result executeTest(Path.ID id, QCInterpreter interpreter, Decl.FunctionOrMethod dec, TestType testType, int numTest, BigInteger lowerLimit, BigInteger upperLimit) {\n\t\t\/\/ Get the method for generating test values\n\t\tGenerateTest testGen;\n\t\ttry {\n\t\t\tif(testType == TestType.EXHAUSTIVE) {\n\t\t\t\ttestGen = new ExhaustiveGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n\t\t\t}\n\t\t\telse {\n\t            testGen = new RandomGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n\t\t\t}\n\t\t} catch (IntegerRangeException e) {\n\t\t\tSystem.out.println(\"Integer range was invalid for the limits given.\");\n\t\t\treturn Result.ERRORS;\n\t\t}\n\t\t\/\/ Get the function's relevant header information\n\t\tNameID name = new NameID(id, dec.getName().get());\n\t\tType.Callable type = dec.getType();\n\t\tTuple<Expr> preconditions = dec.getRequires();\n\t\tTuple<Expr> postconditions = dec.getEnsures();\n\t\tTuple<Decl.Variable> inputParameters = dec.getParameters();\n\t\tTuple<Decl.Variable> outputParameters = dec.getReturns();\n\t\tSystem.out.println(\"Name of the function\/method: \" + name.name());\n\/\/\t\tSystem.out.println(\"FUNCTION PARAM TYPES \"+ inputParameters);\n\/\/\t\tSystem.out.println(\"PRECONDITION \"+ preconditions);\n\/\/\t\tSystem.out.println(\"POSTCONDITION \"+ postconditions);\n\/\/\t\t\/\/ Have to remove the pre and post conditions out of the \n\/\/\t\t\/\/ function so the function is executed without validation\n\/\/\t\t\/\/ Validation will be conducted manually inside the function.\n\/\/\t\tTuple<Expr> empty = new Tuple<Expr>();\t\t\n\/\/\t\tdec.setOperand(4, empty); \/\/ Remove precondition\n\/\/\t\tdec.setOperand(5, empty); \/\/ Remove postcondition\n\t\tboolean completedAll = false;\n\t\tint numSkipped = 0;\n\t\tint numPassed = 0;\n\t\tint numFailed = 0;\n\t\tfor(int i=0; i < numTest; i++) {\n\t\t\trecursiveType.clear();\n\t\t\t\/\/ Stop execution if all possible combinations have been generated \n\t\t\t\/\/ Can do this for methods as well as a new call stack is created each time\n\t\t\tif(testGen.exceedSize() && i != 0) {\n\t\t\t\tcompletedAll = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRValue[] paramValues = null;\n\t\t\tCallStack frame = interpreter.new CallStack();\n\t\t\t\/\/ Check the precondition\n\t\t\ttry {\n\t\t\t\tparamValues = testGen.generateParameters();\n\t\t\t\tfor(int j=0; j < inputParameters.size(); j++) {\n\t\t\t\t\tDecl.Variable parameter = inputParameters.get(j);\n\t\t\t\t\tframe.putLocal(parameter.getName(), paramValues[j]);\n\t\t\t\t}\n\t\t\t\tinterpreter.checkInvariants(frame, preconditions);\n\t\t\t}\n\t\t\tcatch(CannotGenerateException e) {\n\t\t\t\tSystem.out.println(e);\n\t\t\t\treturn Result.ERRORS;\n\t\t\t}\n\t\t\tcatch(AssertionError e){\n\t\t\t\tSystem.out.println(\"Pre-condition failed on input: \" + Arrays.toString(paramValues));\n\t\t\t\tnumSkipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcatch(RuntimeException e) {\n\t\t\t\tSystem.out.println(\"Error occurred when generating input \" + e + \": \" + e.getMessage());\n\t\t\t\treturn Result.ERRORS;\n\t\t\t}\n\t\t\tSystem.out.println(\"INPUT: \" + Arrays.toString(paramValues));\n\t\t\t\/\/ Checks the postcondition when it is executed\n\t\t\tRValue[] returns = null;\n\t\t\ttry {\n\t\t\t\treturns = interpreter.execute(name, type, frame, false, false, paramValues);\n\t\t\t\trecursiveType.clear();\n\t\t\t}\n\t\t\tcatch(AssertionError e) {\n\t\t\t\tSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\n\t\t\t\tnumFailed++;\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\tcatch(RuntimeException e) {\n\t\t\t\tSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\n\t\t\t\treturn Result.ERRORS;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\t\/\/ Add the return values into the frame for validation\n\t\t\t\tfor(int j=0; j < outputParameters.size(); j++) {\n\t\t\t\t\tDecl.Variable parameter = outputParameters.get(j);\n\t\t\t\t\tType paramType = parameter.getType();\n\t\t\t\t\tboolean valid = checkInvariant(interpreter, paramType, returns[j]);\n\t\t\t\t\tif(!valid) {\n\t\t\t\t\t\tthrow new AssertionError(\"Type constraints for \" + parameter  + \" failed\");\n\t\t\t\t\t}\n\t\t\t\t\tframe.putLocal(parameter.getName(), returns[j]);\n\t\t\t\t}\t\n\t\t\t\ttry {\n\t\t\t\t\tinterpreter.checkInvariants(frame, postconditions);\n\t\t\t\t\tnumPassed++;\n\/\/\t\t\t\t\t\/\/ Print out any return values produced\n\t\t\t\t\tif (returns != null) {\n\t\t\t\t\t\tSystem.out.println(\"OUTPUT: \" + Arrays.toString(returns));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch(AssertionError e) {\n\t\t\t\t\tSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\n\t\t\t\t\tSystem.out.println(\"Postcondition failed \" + e);\n\t\t\t\t\tnumFailed++;\n\t\t\t\t} \n\t\t\t\tcatch(RuntimeException e) {\n\t\t\t\t\tSystem.out.println(\"Error when checking invariants of return values \" + e + \": \" + e.getMessage());\n\t\t\t\t\treturn Result.ERRORS;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(AssertionError e) {\n\t\t\t\tSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\n\t\t\t\tSystem.out.println(\"Due to error \" + e);\n\t\t\t\tnumFailed++;\n\t\t\t} \n\t\t\tcatch(RuntimeException e) {\n\t\t\t\tSystem.out.println(\"Error when checking type invariants of return values \" + e + \": \" + e.getMessage());\n\t\t\t\treturn Result.ERRORS;\n\t\t\t}\n\t\t\tcatch (ResolutionError e) {\n\t\t\t\t\/\/ FIXME resolution error\n\t\t\t\te.printStackTrace();\n\t\t\t\tassert false;\n\t\t\t} \n\t\t}\n\t\t\/\/ Overall test statistics\n\t\tif(completedAll) {\n\t\t\tSystem.out.println(\"Tested all possible combinations\");\n\t\t\tint numActualTest = numPassed + numFailed + numSkipped;\n\t\t\tif(numFailed == 0) {\n\t\t\t\tif(numPassed > 0) {\n\t\t\t\t\tSystem.out.printf(\"Ok: %d passed  (%.2f %%), %d skipped (%.2f %%), ran %d tests %n\",\n\t\t\t\t\t\t\tnumPassed, (double) 100 * numPassed\/numActualTest, numSkipped, (double) 100 * numSkipped\/numActualTest, numActualTest);\n\t\t\t\t\treturn Result.PASSED;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.println(\"All tests skipped!\");\n\t\t\t\t\treturn Result.SKIPPED;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"Failed: %d passed (%.2f %%), %d failed (%.2f %%), %d skipped (%.2f %%), ran %d tests%n\",\n\t\t\t\t\tnumPassed, (double) 100 * numPassed\/numActualTest, numFailed, (double) 100 * numFailed\/numActualTest, numSkipped, (double) 100 * numSkipped\/numActualTest, numActualTest);\n\t\t\treturn Result.FAILED;\n\t\t}\n\t\telse if(numPassed + numSkipped == numTest) {\n\t\t\tassert numFailed == 0;\n\t\t\tSystem.out.printf(\"Ok: %d passed  (%.2f %%), %d skipped (%.2f %%), ran %d tests %n\",\n\t\t\t\t\tnumPassed, (double) 100 * numPassed\/numTest, numSkipped, (double) 100 * numSkipped\/numTest, numTest);\n\t\t\treturn Result.PASSED;\n\t\t}\n\t\telse if(numSkipped == numTest) {\n\t\t\tSystem.out.println(\"All tests skipped!\");\n\t\t\treturn Result.SKIPPED;\n\t\t}\n\t\telse {\n\t\t\tSystem.out.printf(\"Failed: %d passed (%.2f %%), %d failed (%.2f %%), %d skipped (%.2f %%), ran %d tests%n\",\n\t\t\t\t\tnumPassed, (double) 100 * numPassed\/numTest, numFailed, (double) 100 * numFailed\/numTest, numSkipped, (double) 100 * numSkipped\/numTest, numTest);\n\t\t\treturn Result.FAILED;\n\t\t}\n\t}","code":"private Result executeTest(Path.ID id, QCInterpreter interpreter, Decl.FunctionOrMethod dec, TestType testType, int numTest, BigInteger lowerLimit, BigInteger upperLimit) {\n\t\n\t\tGenerateTest testGen;\n\t\ttry {\n\t\t\tif(testType == TestType.EXHAUSTIVE) {\n\t\t\t\ttestGen = new ExhaustiveGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n\t\t\t}\n\t\t\telse {\n\t            testGen = new RandomGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n\t\t\t}\n\t\t} catch (IntegerRangeException e) {\n\t\t\tSystem.out.println(\"Integer range was invalid for the limits given.\");\n\t\t\treturn Result.ERRORS;\n\t\t}\n\t\n\t\tNameID name = new NameID(id, dec.getName().get());\n\t\tType.Callable type = dec.getType();\n\t\tTuple<Expr> preconditions = dec.getRequires();\n\t\tTuple<Expr> postconditions = dec.getEnsures();\n\t\tTuple<Decl.Variable> inputParameters = dec.getParameters();\n\t\tTuple<Decl.Variable> outputParameters = dec.getReturns();\n\t\tSystem.out.println(\"Name of the function\/method: \" + name.name());\n\t\tboolean completedAll = false;\n\t\tint numSkipped = 0;\n\t\tint numPassed = 0;\n\t\tint numFailed = 0;\n\t\tfor(int i=0; i < numTest; i++) {\n\t\t\trecursiveType.clear();\n\t\t\n\t\t\n\t\t\tif(testGen.exceedSize() && i != 0) {\n\t\t\t\tcompletedAll = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRValue[] paramValues = null;\n\t\t\tCallStack frame = interpreter.new CallStack();\n\t\t\n\t\t\ttry {\n\t\t\t\tparamValues = testGen.generateParameters();\n\t\t\t\tfor(int j=0; j < inputParameters.size(); j++) {\n\t\t\t\t\tDecl.Variable parameter = inputParameters.get(j);\n\t\t\t\t\tframe.putLocal(parameter.getName(), paramValues[j]);\n\t\t\t\t}\n\t\t\t\tinterpreter.checkInvariants(frame, preconditions);\n\t\t\t}\n\t\t\tcatch(CannotGenerateException e) {\n\t\t\t\tSystem.out.println(e);\n\t\t\t\treturn Result.ERRORS;\n\t\t\t}\n\t\t\tcatch(AssertionError e){\n\t\t\t\tSystem.out.println(\"Pre-condition failed on input: \" + Arrays.toString(paramValues));\n\t\t\t\tnumSkipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcatch(RuntimeException e) {\n\t\t\t\tSystem.out.println(\"Error occurred when generating input \" + e + \": \" + e.getMessage());\n\t\t\t\treturn Result.ERRORS;\n\t\t\t}\n\t\t\tSystem.out.println(\"INPUT: \" + Arrays.toString(paramValues));\n\t\t\n\t\t\tRValue[] returns = null;\n\t\t\ttry {\n\t\t\t\treturns = interpreter.execute(name, type, frame, false, false, paramValues);\n\t\t\t\trecursiveType.clear();\n\t\t\t}\n\t\t\tcatch(AssertionError e) {\n\t\t\t\tSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\n\t\t\t\tnumFailed++;\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\tcatch(RuntimeException e) {\n\t\t\t\tSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\n\t\t\t\treturn Result.ERRORS;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\n\t\t\t\tfor(int j=0; j < outputParameters.size(); j++) {\n\t\t\t\t\tDecl.Variable parameter = outputParameters.get(j);\n\t\t\t\t\tType paramType = parameter.getType();\n\t\t\t\t\tboolean valid = checkInvariant(interpreter, paramType, returns[j]);\n\t\t\t\t\tif(!valid) {\n\t\t\t\t\t\tthrow new AssertionError(\"Type constraints for \" + parameter  + \" failed\");\n\t\t\t\t\t}\n\t\t\t\t\tframe.putLocal(parameter.getName(), returns[j]);\n\t\t\t\t}\t\n\t\t\t\ttry {\n\t\t\t\t\tinterpreter.checkInvariants(frame, postconditions);\n\t\t\t\t\tnumPassed++;\n\t\t\t\t\tif (returns != null) {\n\t\t\t\t\t\tSystem.out.println(\"OUTPUT: \" + Arrays.toString(returns));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch(AssertionError e) {\n\t\t\t\t\tSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\n\t\t\t\t\tSystem.out.println(\"Postcondition failed \" + e);\n\t\t\t\t\tnumFailed++;\n\t\t\t\t} \n\t\t\t\tcatch(RuntimeException e) {\n\t\t\t\t\tSystem.out.println(\"Error when checking invariants of return values \" + e + \": \" + e.getMessage());\n\t\t\t\t\treturn Result.ERRORS;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(AssertionError e) {\n\t\t\t\tSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\n\t\t\t\tSystem.out.println(\"Due to error \" + e);\n\t\t\t\tnumFailed++;\n\t\t\t} \n\t\t\tcatch(RuntimeException e) {\n\t\t\t\tSystem.out.println(\"Error when checking type invariants of return values \" + e + \": \" + e.getMessage());\n\t\t\t\treturn Result.ERRORS;\n\t\t\t}\n\t\t\tcatch (ResolutionError e) {\n\t\t\t\n\t\t\t\te.printStackTrace();\n\t\t\t\tassert false;\n\t\t\t} \n\t\t}\n\t\n\t\tif(completedAll) {\n\t\t\tSystem.out.println(\"Tested all possible combinations\");\n\t\t\tint numActualTest = numPassed + numFailed + numSkipped;\n\t\t\tif(numFailed == 0) {\n\t\t\t\tif(numPassed > 0) {\n\t\t\t\t\tSystem.out.printf(\"Ok: %d passed  (%.2f %%), %d skipped (%.2f %%), ran %d tests %n\",\n\t\t\t\t\t\t\tnumPassed, (double) 100 * numPassed\/numActualTest, numSkipped, (double) 100 * numSkipped\/numActualTest, numActualTest);\n\t\t\t\t\treturn Result.PASSED;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.println(\"All tests skipped!\");\n\t\t\t\t\treturn Result.SKIPPED;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"Failed: %d passed (%.2f %%), %d failed (%.2f %%), %d skipped (%.2f %%), ran %d tests%n\",\n\t\t\t\t\tnumPassed, (double) 100 * numPassed\/numActualTest, numFailed, (double) 100 * numFailed\/numActualTest, numSkipped, (double) 100 * numSkipped\/numActualTest, numActualTest);\n\t\t\treturn Result.FAILED;\n\t\t}\n\t\telse if(numPassed + numSkipped == numTest) {\n\t\t\tassert numFailed == 0;\n\t\t\tSystem.out.printf(\"Ok: %d passed  (%.2f %%), %d skipped (%.2f %%), ran %d tests %n\",\n\t\t\t\t\tnumPassed, (double) 100 * numPassed\/numTest, numSkipped, (double) 100 * numSkipped\/numTest, numTest);\n\t\t\treturn Result.PASSED;\n\t\t}\n\t\telse if(numSkipped == numTest) {\n\t\t\tSystem.out.println(\"All tests skipped!\");\n\t\t\treturn Result.SKIPPED;\n\t\t}\n\t\telse {\n\t\t\tSystem.out.printf(\"Failed: %d passed (%.2f %%), %d failed (%.2f %%), %d skipped (%.2f %%), ran %d tests%n\",\n\t\t\t\t\tnumPassed, (double) 100 * numPassed\/numTest, numFailed, (double) 100 * numFailed\/numTest, numSkipped, (double) 100 * numSkipped\/numTest, numTest);\n\t\t\treturn Result.FAILED;\n\t\t}\n\t}","cleancode":"private result executetest(path.id id, qcinterpreter interpreter, decl.functionormethod dec, testtype testtype, int numtest, biginteger lowerlimit, biginteger upperlimit) { generatetest testgen; try { if(testtype == testtype.exhaustive) { testgen = new exhaustivegeneratetest(dec.getparameters(), interpreter, numtest, lowerlimit, upperlimit); } else { testgen = new randomgeneratetest(dec.getparameters(), interpreter, numtest, lowerlimit, upperlimit); } } catch (integerrangeexception e) { system.out.println(\"integer range was invalid for the limits given.\"); return result.errors; } nameid name = new nameid(id, dec.getname().get()); type.callable type = dec.gettype(); tuple<expr> preconditions = dec.getrequires(); tuple<expr> postconditions = dec.getensures(); tuple<decl.variable> inputparameters = dec.getparameters(); tuple<decl.variable> outputparameters = dec.getreturns(); system.out.println(\"name of the function\/method: \" + name.name()); boolean completedall = false; int numskipped = 0; int numpassed = 0; int numfailed = 0; for(int i=0; i < numtest; i++) { recursivetype.clear(); if(testgen.exceedsize() && i != 0) { completedall = true; break; } rvalue[] paramvalues = null; callstack frame = interpreter.new callstack(); try { paramvalues = testgen.generateparameters(); for(int j=0; j < inputparameters.size(); j++) { decl.variable parameter = inputparameters.get(j); frame.putlocal(parameter.getname(), paramvalues[j]); } interpreter.checkinvariants(frame, preconditions); } catch(cannotgenerateexception e) { system.out.println(e); return result.errors; } catch(assertionerror e){ system.out.println(\"pre-condition failed on input: \" + arrays.tostring(paramvalues)); numskipped++; continue; } catch(runtimeexception e) { system.out.println(\"error occurred when generating input \" + e + \": \" + e.getmessage()); return result.errors; } system.out.println(\"input: \" + arrays.tostring(paramvalues)); rvalue[] returns = null; try { returns = interpreter.execute(name, type, frame, false, false, paramvalues); recursivetype.clear(); } catch(assertionerror e) { system.out.println(\"error occurred during execution \" + e + \": \" + e.getmessage()); numfailed++; continue; } catch(runtimeexception e) { system.out.println(\"error occurred during execution \" + e + \": \" + e.getmessage()); return result.errors; } try { for(int j=0; j < outputparameters.size(); j++) { decl.variable parameter = outputparameters.get(j); type paramtype = parameter.gettype(); boolean valid = checkinvariant(interpreter, paramtype, returns[j]); if(!valid) { throw new assertionerror(\"type constraints for \" + parameter + \" failed\"); } frame.putlocal(parameter.getname(), returns[j]); } try { interpreter.checkinvariants(frame, postconditions); numpassed++; if (returns != null) { system.out.println(\"output: \" + arrays.tostring(returns)); } } catch(assertionerror e) { system.out.printf(\"failed input: %s%nfailed output: %s%n\", arrays.tostring(paramvalues), arrays.tostring(returns)); system.out.println(\"postcondition failed \" + e); numfailed++; } catch(runtimeexception e) { system.out.println(\"error when checking invariants of return values \" + e + \": \" + e.getmessage()); return result.errors; } } catch(assertionerror e) { system.out.printf(\"failed input: %s%nfailed output: %s%n\", arrays.tostring(paramvalues), arrays.tostring(returns)); system.out.println(\"due to error \" + e); numfailed++; } catch(runtimeexception e) { system.out.println(\"error when checking type invariants of return values \" + e + \": \" + e.getmessage()); return result.errors; } catch (resolutionerror e) { e.printstacktrace(); assert false; } } if(completedall) { system.out.println(\"tested all possible combinations\"); int numactualtest = numpassed + numfailed + numskipped; if(numfailed == 0) { if(numpassed > 0) { system.out.printf(\"ok: %d passed (%.2f %%), %d skipped (%.2f %%), ran %d tests %n\", numpassed, (double) 100 * numpassed\/numactualtest, numskipped, (double) 100 * numskipped\/numactualtest, numactualtest); return result.passed; } else { system.out.println(\"all tests skipped!\"); return result.skipped; } } system.out.printf(\"failed: %d passed (%.2f %%), %d failed (%.2f %%), %d skipped (%.2f %%), ran %d tests%n\", numpassed, (double) 100 * numpassed\/numactualtest, numfailed, (double) 100 * numfailed\/numactualtest, numskipped, (double) 100 * numskipped\/numactualtest, numactualtest); return result.failed; } else if(numpassed + numskipped == numtest) { assert numfailed == 0; system.out.printf(\"ok: %d passed (%.2f %%), %d skipped (%.2f %%), ran %d tests %n\", numpassed, (double) 100 * numpassed\/numtest, numskipped, (double) 100 * numskipped\/numtest, numtest); return result.passed; } else if(numskipped == numtest) { system.out.println(\"all tests skipped!\"); return result.skipped; } else { system.out.printf(\"failed: %d passed (%.2f %%), %d failed (%.2f %%), %d skipped (%.2f %%), ran %d tests%n\", numpassed, (double) 100 * numpassed\/numtest, numfailed, (double) 100 * numfailed\/numtest, numskipped, (double) 100 * numskipped\/numtest, numtest); return result.failed; } }","comment":"\/** * test a function from a wyil file * by executing the test with randomised parameters * @param id the module used * @param interpreter whiley interpreter used to execute the function\/method * @param dec the function or method * @param testtype the type of tests to generate * @param numtest the number of tests to execute * @param lowerlimit the lower constraint used when generating integers * @param upperlimit the upper constraint used when generating integers *\/\n\/\/ get the method for generating test values\n\/\/ get the function's relevant header information\n\/\/ system.out.println(\"function param types \"+ inputparameters); \/\/ system.out.println(\"precondition \"+ preconditions); \/\/ system.out.println(\"postcondition \"+ postconditions); \/\/ \/\/ have to remove the pre and post conditions out of the \/\/ \/\/ function so the function is executed without validation \/\/ \/\/ validation will be conducted manually inside the function. \/\/ tuple<expr> empty = new tuple<expr>(); \/\/ dec.setoperand(4, empty); \/\/ remove precondition \/\/ dec.setoperand(5, empty); \/\/ remove postcondition\n\/\/ stop execution if all possible combinations have been generated \/\/ can do this for methods as well as a new call stack is created each time\n\/\/ check the precondition\n\/\/ checks the postcondition when it is executed\n\/\/ add the return values into the frame for validation\n\/\/ \/\/ print out any return values produced\n\/\/ fixme resolution error\n\/\/ overall test statistics","repo":"JC626\/quickcheck-for-whiley","code_context_2":"private Result executeTest(Path.ID id, QCInterpreter interpreter, Decl.FunctionOrMethod dec, TestType testType, int numTest, BigInteger lowerLimit, BigInteger upperLimit) {\n\/\/ Get the method for generating test values\nGenerateTest testGen;\ntry {\nif(testType == TestType.EXHAUSTIVE) {\ntestGen = new ExhaustiveGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n}\nelse {\ntestGen = new RandomGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n}\n} catch (IntegerRangeException e) {\nSystem.out.println(\"Integer range was invalid for the limits given.\");\nreturn Result.ERRORS;\n}\n\/\/ Get the function's relevant header information\nNameID name = new NameID(id, dec.getName().get());\nType.Callable type = dec.getType();\nTuple<Expr> preconditions = dec.getRequires();\nTuple<Expr> postconditions = dec.getEnsures();\nTuple<Decl.Variable> inputParameters = dec.getParameters();\nTuple<Decl.Variable> outputParameters = dec.getReturns();\nSystem.out.println(\"Name of the function\/method: \" + name.name());\n\/\/ System.out.println(\"FUNCTION PARAM TYPES \"+ inputParameters);\n\/\/ System.out.println(\"PRECONDITION \"+ preconditions);\n\/\/ System.out.println(\"POSTCONDITION \"+ postconditions);\n\/\/ \/\/ Have to remove the pre and post conditions out of the\n\/\/ \/\/ function so the function is executed without validation\n\/\/ \/\/ Validation will be conducted manually inside the function.\n\/\/ Tuple<Expr> empty = new Tuple<Expr>();\n\/\/ dec.setOperand(4, empty); \/\/ Remove precondition\n\/\/ dec.setOperand(5, empty); \/\/ Remove postcondition\nboolean completedAll = false;\nint numSkipped = 0;\nint numPassed = 0;\nint numFailed = 0;\nfor(int i=0; i < numTest; i++) {\nrecursiveType.clear();\n\/\/ Stop execution if all possible combinations have been generated\n\/\/ Can do this for methods as well as a new call stack is created each time\nif(testGen.exceedSize() && i != 0) {\ncompletedAll = true;\nbreak;\n}\nRValue[] paramValues = null;\nCallStack frame = interpreter.new CallStack();\n\/\/ Check the precondition\ntry {\nparamValues = testGen.generateParameters();\nfor(int j=0; j < inputParameters.size(); j++) {\nDecl.Variable parameter = inputParameters.get(j);\nframe.putLocal(parameter.getName(), paramValues[j]);\n}\ninterpreter.checkInvariants(frame, preconditions);\n}\ncatch(CannotGenerateException e) {\nSystem.out.println(e);\nreturn Result.ERRORS;\n}\ncatch(AssertionError e){\nSystem.out.println(\"Pre-condition failed on input: \" + Arrays.toString(paramValues));\nnumSkipped++;\ncontinue;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error occurred when generating input \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\nSystem.out.println(\"INPUT: \" + Arrays.toString(paramValues));\n\/\/ Checks the postcondition when it is executed\nRValue[] returns = null;\ntry {\nreturns = interpreter.execute(name, type, frame, false, false, paramValues);\nrecursiveType.clear();\n}\ncatch(AssertionError e) {\nSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\nnumFailed++;\ncontinue;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\ntry {\n\/\/ Add the return values into the frame for validation\nfor(int j=0; j < outputParameters.size(); j++) {\nDecl.Variable parameter = outputParameters.get(j);\nType paramType = parameter.getType();\nboolean valid = checkInvariant(interpreter, paramType, returns[j]);\nif(!valid) {\nthrow new AssertionError(\"Type constraints for \" + parameter + \" failed\");\n}\nframe.putLocal(parameter.getName(), returns[j]);\n}\ntry {\ninterpreter.checkInvariants(frame, postconditions);\nnumPassed++;\n\/\/ \/\/ Print out any return values produced\nif (returns != null) {\nSystem.out.println(\"OUTPUT: \" + Arrays.toString(returns));\n}\n}\ncatch(AssertionError e) {\nSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\nSystem.out.println(\"Postcondition failed \" + e);\nnumFailed++;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error when checking invariants of return values \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\n}\ncatch(AssertionError e) {\nSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\nSystem.out.println(\"Due to error \" + e);\nnumFailed++;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error when checking type invariants of return values \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\ncatch (ResolutionError e) {\n\/\/ FIXME resolution error\ne.printStackTrace();\nassert false;\n}\n}\n\/\/ Overall test statistics\nif(completedAll) {\nSystem.out.println(\"Tested all possible combinations\");\nint numActualTest = numPassed + numFailed + numSkipped;\nif(numFailed == 0) {\nif(numPassed > 0) {\nSystem.out.printf(\"Ok: %d passed (%.2f %%), %d skipped (%.2f %%), ran %d tests %n\",\nnumPassed, (double) 100 * numPassed\/numActualTest, numSkipped, (double) 100 * numSkipped\/numActualTest, numActualTest);\nreturn Result.PASSED;\n}\nelse {\nSystem.out.println(\"All tests skipped!\");\nreturn Result.SKIPPED;\n}\n}\nSystem.out.printf(\"Failed: %d passed (%.2f %%), %d failed (%.2f %%), %d skipped (%.2f %%), ran %d tests%n\",\nnumPassed, (double) 100 * numPassed\/numActualTest, numFailed, (double) 100 * numFailed\/numActualTest, numSkipped, (double) 100 * numSkipped\/numActualTest, numActualTest);\nreturn Result.FAILED;\n}\nelse if(numPassed + numSkipped == numTest) {\nassert numFailed == 0;\nSystem.out.printf(\"Ok: %d passed (%.2f %%), %d skipped (%.2f %%), ran %d tests %n\",\nnumPassed, (double) 100 * numPassed\/numTest, numSkipped, (double) 100 * numSkipped\/numTest, numTest);\nreturn Result.PASSED;\n}\nelse if(numSkipped == numTest) {\nSystem.out.println(\"All tests skipped!\");\nreturn Result.SKIPPED;\n}\nelse {\nSystem.out.printf(\"Failed: %d passed (%.2f %%), %d failed (%.2f %%), %d skipped (%.2f %%), ran %d tests%n\",\nnumPassed, (double) 100 * numPassed\/numTest, numFailed, (double) 100 * numFailed\/numTest, numSkipped, (double) 100 * numSkipped\/numTest, numTest);\nreturn Result.FAILED;\n}\n}\n\nprivate Result executeTest(Path.ID id, QCInterpreter interpreter, Decl.FunctionOrMethod dec, TestType testType, int numTest, BigInteger lowerLimit, BigInteger upperLimit) {\n\/\/ Get the method for generating test values\nGenerateTest testGen;\ntry {\n\nreturn Result.ERRORS;\n}\n\/\/ Get the function's relevant header information\nNameID name = new NameID(id, dec.getName().get());\nType.Callable type = dec.getType();\n\nTuple<Decl.Variable> outputParameters = dec.getReturns();\nSystem.out.println(\"Name of the function\/method: \" + name.name());\n\/\/ System.out.println(\"FUNCTION PARAM TYPES \"+ inputParameters);\n\/\/ System.out.println(\"PRECONDITION \"+ preconditions);\n\/\/ System.out.println(\"POSTCONDITION \"+ postconditions);\n\/\/ \/\/ Have to remove the pre and post conditions out of the\n\/\/ \/\/ function so the function is executed without validation\n\/\/ \/\/ Validation will be conducted manually inside the function.\n\/\/ Tuple<Expr> empty = new Tuple<Expr>();\n\/\/ dec.setOperand(4, empty); \/\/ Remove precondition\n\/\/ dec.setOperand(5, empty); \/\/ Remove postcondition\nboolean completedAll = false;\nint numSkipped = 0;\n\nfor(int i=0; i < numTest; i++) {\nrecursiveType.clear();\n\/\/ Stop execution if all possible combinations have been generated\n\/\/ Can do this for methods as well as a new call stack is created each time\nif(testGen.exceedSize() && i != 0) {\ncompletedAll = true;\n\nRValue[] paramValues = null;\nCallStack frame = interpreter.new CallStack();\n\/\/ Check the precondition\ntry {\nparamValues = testGen.generateParameters();\n\n}\nSystem.out.println(\"INPUT: \" + Arrays.toString(paramValues));\n\/\/ Checks the postcondition when it is executed\nRValue[] returns = null;\ntry {\n\n}\ntry {\n\/\/ Add the return values into the frame for validation\nfor(int j=0; j < outputParameters.size(); j++) {\nDecl.Variable parameter = outputParameters.get(j);\n\ninterpreter.checkInvariants(frame, postconditions);\nnumPassed++;\n\/\/ \/\/ Print out any return values produced\nif (returns != null) {\nSystem.out.println(\"OUTPUT: \" + Arrays.toString(returns));\n\n}\ncatch (ResolutionError e) {\n\/\/ FIXME resolution error\ne.printStackTrace();\nassert false;\n\n}\n}\n\/\/ Overall test statistics\nif(completedAll) {\nSystem.out.println(\"Tested all possible combinations\");","code_context_10":"private Result executeTest(Path.ID id, QCInterpreter interpreter, Decl.FunctionOrMethod dec, TestType testType, int numTest, BigInteger lowerLimit, BigInteger upperLimit) {\n\/\/ Get the method for generating test values\nGenerateTest testGen;\ntry {\nif(testType == TestType.EXHAUSTIVE) {\ntestGen = new ExhaustiveGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n}\nelse {\ntestGen = new RandomGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n}\n} catch (IntegerRangeException e) {\nSystem.out.println(\"Integer range was invalid for the limits given.\");\nreturn Result.ERRORS;\n}\n\/\/ Get the function's relevant header information\nNameID name = new NameID(id, dec.getName().get());\nType.Callable type = dec.getType();\nTuple<Expr> preconditions = dec.getRequires();\nTuple<Expr> postconditions = dec.getEnsures();\nTuple<Decl.Variable> inputParameters = dec.getParameters();\nTuple<Decl.Variable> outputParameters = dec.getReturns();\nSystem.out.println(\"Name of the function\/method: \" + name.name());\n\/\/ System.out.println(\"FUNCTION PARAM TYPES \"+ inputParameters);\n\/\/ System.out.println(\"PRECONDITION \"+ preconditions);\n\/\/ System.out.println(\"POSTCONDITION \"+ postconditions);\n\/\/ \/\/ Have to remove the pre and post conditions out of the\n\/\/ \/\/ function so the function is executed without validation\n\/\/ \/\/ Validation will be conducted manually inside the function.\n\/\/ Tuple<Expr> empty = new Tuple<Expr>();\n\/\/ dec.setOperand(4, empty); \/\/ Remove precondition\n\/\/ dec.setOperand(5, empty); \/\/ Remove postcondition\nboolean completedAll = false;\nint numSkipped = 0;\nint numPassed = 0;\nint numFailed = 0;\nfor(int i=0; i < numTest; i++) {\nrecursiveType.clear();\n\/\/ Stop execution if all possible combinations have been generated\n\/\/ Can do this for methods as well as a new call stack is created each time\nif(testGen.exceedSize() && i != 0) {\ncompletedAll = true;\nbreak;\n}\nRValue[] paramValues = null;\nCallStack frame = interpreter.new CallStack();\n\/\/ Check the precondition\ntry {\nparamValues = testGen.generateParameters();\nfor(int j=0; j < inputParameters.size(); j++) {\nDecl.Variable parameter = inputParameters.get(j);\nframe.putLocal(parameter.getName(), paramValues[j]);\n}\ninterpreter.checkInvariants(frame, preconditions);\n}\ncatch(CannotGenerateException e) {\nSystem.out.println(e);\nreturn Result.ERRORS;\n}\ncatch(AssertionError e){\nSystem.out.println(\"Pre-condition failed on input: \" + Arrays.toString(paramValues));\nnumSkipped++;\ncontinue;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error occurred when generating input \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\nSystem.out.println(\"INPUT: \" + Arrays.toString(paramValues));\n\/\/ Checks the postcondition when it is executed\nRValue[] returns = null;\ntry {\nreturns = interpreter.execute(name, type, frame, false, false, paramValues);\nrecursiveType.clear();\n}\ncatch(AssertionError e) {\nSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\nnumFailed++;\ncontinue;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\ntry {\n\/\/ Add the return values into the frame for validation\nfor(int j=0; j < outputParameters.size(); j++) {\nDecl.Variable parameter = outputParameters.get(j);\nType paramType = parameter.getType();\nboolean valid = checkInvariant(interpreter, paramType, returns[j]);\nif(!valid) {\nthrow new AssertionError(\"Type constraints for \" + parameter + \" failed\");\n}\nframe.putLocal(parameter.getName(), returns[j]);\n}\ntry {\ninterpreter.checkInvariants(frame, postconditions);\nnumPassed++;\n\/\/ \/\/ Print out any return values produced\nif (returns != null) {\nSystem.out.println(\"OUTPUT: \" + Arrays.toString(returns));\n}\n}\ncatch(AssertionError e) {\nSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\nSystem.out.println(\"Postcondition failed \" + e);\nnumFailed++;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error when checking invariants of return values \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\n}\ncatch(AssertionError e) {\nSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\nSystem.out.println(\"Due to error \" + e);\nnumFailed++;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error when checking type invariants of return values \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\ncatch (ResolutionError e) {\n\/\/ FIXME resolution error\ne.printStackTrace();\nassert false;\n}\n}\n\/\/ Overall test statistics\nif(completedAll) {\nSystem.out.println(\"Tested all possible combinations\");\nint numActualTest = numPassed + numFailed + numSkipped;\nif(numFailed == 0) {\nif(numPassed > 0) {\nSystem.out.printf(\"Ok: %d passed (%.2f %%), %d skipped (%.2f %%), ran %d tests %n\",\nnumPassed, (double) 100 * numPassed\/numActualTest, numSkipped, (double) 100 * numSkipped\/numActualTest, numActualTest);\nreturn Result.PASSED;\n}\nelse {\nSystem.out.println(\"All tests skipped!\");\nreturn Result.SKIPPED;\n}\n}\nSystem.out.printf(\"Failed: %d passed (%.2f %%), %d failed (%.2f %%), %d skipped (%.2f %%), ran %d tests%n\",\nnumPassed, (double) 100 * numPassed\/numActualTest, numFailed, (double) 100 * numFailed\/numActualTest, numSkipped, (double) 100 * numSkipped\/numActualTest, numActualTest);\nreturn Result.FAILED;\n}\nelse if(numPassed + numSkipped == numTest) {\nassert numFailed == 0;\nSystem.out.printf(\"Ok: %d passed (%.2f %%), %d skipped (%.2f %%), ran %d tests %n\",\nnumPassed, (double) 100 * numPassed\/numTest, numSkipped, (double) 100 * numSkipped\/numTest, numTest);\nreturn Result.PASSED;\n}\nelse if(numSkipped == numTest) {\nSystem.out.println(\"All tests skipped!\");\nreturn Result.SKIPPED;\n}\nelse {\nSystem.out.printf(\"Failed: %d passed (%.2f %%), %d failed (%.2f %%), %d skipped (%.2f %%), ran %d tests%n\",\nnumPassed, (double) 100 * numPassed\/numTest, numFailed, (double) 100 * numFailed\/numTest, numSkipped, (double) 100 * numSkipped\/numTest, numTest);\nreturn Result.FAILED;\n}\n}\n\nprivate Result executeTest(Path.ID id, QCInterpreter interpreter, Decl.FunctionOrMethod dec, TestType testType, int numTest, BigInteger lowerLimit, BigInteger upperLimit) {\n\/\/ Get the method for generating test values\nGenerateTest testGen;\ntry {\nif(testType == TestType.EXHAUSTIVE) {\ntestGen = new ExhaustiveGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n}\nelse {\ntestGen = new RandomGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n}\n} catch (IntegerRangeException e) {\nSystem.out.println(\"Integer range was invalid for the limits given.\");\n\nif(testType == TestType.EXHAUSTIVE) {\ntestGen = new ExhaustiveGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n}\nelse {\ntestGen = new RandomGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n}\n} catch (IntegerRangeException e) {\nSystem.out.println(\"Integer range was invalid for the limits given.\");\nreturn Result.ERRORS;\n}\n\/\/ Get the function's relevant header information\nNameID name = new NameID(id, dec.getName().get());\nType.Callable type = dec.getType();\nTuple<Expr> preconditions = dec.getRequires();\nTuple<Expr> postconditions = dec.getEnsures();\nTuple<Decl.Variable> inputParameters = dec.getParameters();\nTuple<Decl.Variable> outputParameters = dec.getReturns();\nSystem.out.println(\"Name of the function\/method: \" + name.name());\n\/\/ System.out.println(\"FUNCTION PARAM TYPES \"+ inputParameters);\n\/\/ System.out.println(\"PRECONDITION \"+ preconditions);\n\/\/ System.out.println(\"POSTCONDITION \"+ postconditions);\n\nreturn Result.ERRORS;\n}\n\/\/ Get the function's relevant header information\nNameID name = new NameID(id, dec.getName().get());\nType.Callable type = dec.getType();\nTuple<Expr> preconditions = dec.getRequires();\nTuple<Expr> postconditions = dec.getEnsures();\nTuple<Decl.Variable> inputParameters = dec.getParameters();\nTuple<Decl.Variable> outputParameters = dec.getReturns();\nSystem.out.println(\"Name of the function\/method: \" + name.name());\n\/\/ System.out.println(\"FUNCTION PARAM TYPES \"+ inputParameters);\n\/\/ System.out.println(\"PRECONDITION \"+ preconditions);\n\/\/ System.out.println(\"POSTCONDITION \"+ postconditions);\n\/\/ \/\/ Have to remove the pre and post conditions out of the\n\/\/ \/\/ function so the function is executed without validation\n\/\/ \/\/ Validation will be conducted manually inside the function.\n\/\/ Tuple<Expr> empty = new Tuple<Expr>();\n\/\/ dec.setOperand(4, empty); \/\/ Remove precondition\n\/\/ dec.setOperand(5, empty); \/\/ Remove postcondition\nboolean completedAll = false;\nint numSkipped = 0;\nint numPassed = 0;\nint numFailed = 0;\nfor(int i=0; i < numTest; i++) {\nrecursiveType.clear();\n\/\/ Stop execution if all possible combinations have been generated\n\/\/ Can do this for methods as well as a new call stack is created each time\nif(testGen.exceedSize() && i != 0) {\ncompletedAll = true;\n\n\/\/ \/\/ Validation will be conducted manually inside the function.\n\/\/ Tuple<Expr> empty = new Tuple<Expr>();\n\/\/ dec.setOperand(4, empty); \/\/ Remove precondition\n\/\/ dec.setOperand(5, empty); \/\/ Remove postcondition\nboolean completedAll = false;\nint numSkipped = 0;\nint numPassed = 0;\nint numFailed = 0;\nfor(int i=0; i < numTest; i++) {\nrecursiveType.clear();\n\/\/ Stop execution if all possible combinations have been generated\n\/\/ Can do this for methods as well as a new call stack is created each time\nif(testGen.exceedSize() && i != 0) {\ncompletedAll = true;\nbreak;\n}\nRValue[] paramValues = null;\nCallStack frame = interpreter.new CallStack();\n\/\/ Check the precondition\ntry {\nparamValues = testGen.generateParameters();\nfor(int j=0; j < inputParameters.size(); j++) {\n\nfor(int i=0; i < numTest; i++) {\nrecursiveType.clear();\n\/\/ Stop execution if all possible combinations have been generated\n\/\/ Can do this for methods as well as a new call stack is created each time\nif(testGen.exceedSize() && i != 0) {\ncompletedAll = true;\nbreak;\n}\nRValue[] paramValues = null;\nCallStack frame = interpreter.new CallStack();\n\/\/ Check the precondition\ntry {\nparamValues = testGen.generateParameters();\nfor(int j=0; j < inputParameters.size(); j++) {\nDecl.Variable parameter = inputParameters.get(j);\nframe.putLocal(parameter.getName(), paramValues[j]);\n}\ninterpreter.checkInvariants(frame, preconditions);\n}\ncatch(CannotGenerateException e) {\nSystem.out.println(e);\n\ncatch(AssertionError e){\nSystem.out.println(\"Pre-condition failed on input: \" + Arrays.toString(paramValues));\nnumSkipped++;\ncontinue;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error occurred when generating input \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\nSystem.out.println(\"INPUT: \" + Arrays.toString(paramValues));\n\/\/ Checks the postcondition when it is executed\nRValue[] returns = null;\ntry {\nreturns = interpreter.execute(name, type, frame, false, false, paramValues);\nrecursiveType.clear();\n}\ncatch(AssertionError e) {\nSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\nnumFailed++;\ncontinue;\n}\n\ncatch(AssertionError e) {\nSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\nnumFailed++;\ncontinue;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\ntry {\n\/\/ Add the return values into the frame for validation\nfor(int j=0; j < outputParameters.size(); j++) {\nDecl.Variable parameter = outputParameters.get(j);\nType paramType = parameter.getType();\nboolean valid = checkInvariant(interpreter, paramType, returns[j]);\nif(!valid) {\nthrow new AssertionError(\"Type constraints for \" + parameter + \" failed\");\n}\nframe.putLocal(parameter.getName(), returns[j]);\n}\ntry {\n\nType paramType = parameter.getType();\nboolean valid = checkInvariant(interpreter, paramType, returns[j]);\nif(!valid) {\nthrow new AssertionError(\"Type constraints for \" + parameter + \" failed\");\n}\nframe.putLocal(parameter.getName(), returns[j]);\n}\ntry {\ninterpreter.checkInvariants(frame, postconditions);\nnumPassed++;\n\/\/ \/\/ Print out any return values produced\nif (returns != null) {\nSystem.out.println(\"OUTPUT: \" + Arrays.toString(returns));\n}\n}\ncatch(AssertionError e) {\nSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\nSystem.out.println(\"Postcondition failed \" + e);\nnumFailed++;\n}\ncatch(RuntimeException e) {\n\ncatch(AssertionError e) {\nSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\nSystem.out.println(\"Due to error \" + e);\nnumFailed++;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error when checking type invariants of return values \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\ncatch (ResolutionError e) {\n\/\/ FIXME resolution error\ne.printStackTrace();\nassert false;\n}\n}\n\/\/ Overall test statistics\nif(completedAll) {\nSystem.out.println(\"Tested all possible combinations\");\nint numActualTest = numPassed + numFailed + numSkipped;\nif(numFailed == 0) {\nif(numPassed > 0) {\n\ncatch(RuntimeException e) {\nSystem.out.println(\"Error when checking type invariants of return values \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\ncatch (ResolutionError e) {\n\/\/ FIXME resolution error\ne.printStackTrace();\nassert false;\n}\n}\n\/\/ Overall test statistics\nif(completedAll) {\nSystem.out.println(\"Tested all possible combinations\");\nint numActualTest = numPassed + numFailed + numSkipped;\nif(numFailed == 0) {\nif(numPassed > 0) {\nSystem.out.printf(\"Ok: %d passed (%.2f %%), %d skipped (%.2f %%), ran %d tests %n\",\nnumPassed, (double) 100 * numPassed\/numActualTest, numSkipped, (double) 100 * numSkipped\/numActualTest, numActualTest);\nreturn Result.PASSED;\n}\nelse {","code_context_20":"private Result executeTest(Path.ID id, QCInterpreter interpreter, Decl.FunctionOrMethod dec, TestType testType, int numTest, BigInteger lowerLimit, BigInteger upperLimit) {\n\/\/ Get the method for generating test values\nGenerateTest testGen;\ntry {\nif(testType == TestType.EXHAUSTIVE) {\ntestGen = new ExhaustiveGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n}\nelse {\ntestGen = new RandomGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n}\n} catch (IntegerRangeException e) {\nSystem.out.println(\"Integer range was invalid for the limits given.\");\nreturn Result.ERRORS;\n}\n\/\/ Get the function's relevant header information\nNameID name = new NameID(id, dec.getName().get());\nType.Callable type = dec.getType();\nTuple<Expr> preconditions = dec.getRequires();\nTuple<Expr> postconditions = dec.getEnsures();\nTuple<Decl.Variable> inputParameters = dec.getParameters();\nTuple<Decl.Variable> outputParameters = dec.getReturns();\nSystem.out.println(\"Name of the function\/method: \" + name.name());\n\/\/ System.out.println(\"FUNCTION PARAM TYPES \"+ inputParameters);\n\/\/ System.out.println(\"PRECONDITION \"+ preconditions);\n\/\/ System.out.println(\"POSTCONDITION \"+ postconditions);\n\/\/ \/\/ Have to remove the pre and post conditions out of the\n\/\/ \/\/ function so the function is executed without validation\n\/\/ \/\/ Validation will be conducted manually inside the function.\n\/\/ Tuple<Expr> empty = new Tuple<Expr>();\n\/\/ dec.setOperand(4, empty); \/\/ Remove precondition\n\/\/ dec.setOperand(5, empty); \/\/ Remove postcondition\nboolean completedAll = false;\nint numSkipped = 0;\nint numPassed = 0;\nint numFailed = 0;\nfor(int i=0; i < numTest; i++) {\nrecursiveType.clear();\n\/\/ Stop execution if all possible combinations have been generated\n\/\/ Can do this for methods as well as a new call stack is created each time\nif(testGen.exceedSize() && i != 0) {\ncompletedAll = true;\nbreak;\n}\nRValue[] paramValues = null;\nCallStack frame = interpreter.new CallStack();\n\/\/ Check the precondition\ntry {\nparamValues = testGen.generateParameters();\nfor(int j=0; j < inputParameters.size(); j++) {\nDecl.Variable parameter = inputParameters.get(j);\nframe.putLocal(parameter.getName(), paramValues[j]);\n}\ninterpreter.checkInvariants(frame, preconditions);\n}\ncatch(CannotGenerateException e) {\nSystem.out.println(e);\nreturn Result.ERRORS;\n}\ncatch(AssertionError e){\nSystem.out.println(\"Pre-condition failed on input: \" + Arrays.toString(paramValues));\nnumSkipped++;\ncontinue;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error occurred when generating input \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\nSystem.out.println(\"INPUT: \" + Arrays.toString(paramValues));\n\/\/ Checks the postcondition when it is executed\nRValue[] returns = null;\ntry {\nreturns = interpreter.execute(name, type, frame, false, false, paramValues);\nrecursiveType.clear();\n}\ncatch(AssertionError e) {\nSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\nnumFailed++;\ncontinue;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\ntry {\n\/\/ Add the return values into the frame for validation\nfor(int j=0; j < outputParameters.size(); j++) {\nDecl.Variable parameter = outputParameters.get(j);\nType paramType = parameter.getType();\nboolean valid = checkInvariant(interpreter, paramType, returns[j]);\nif(!valid) {\nthrow new AssertionError(\"Type constraints for \" + parameter + \" failed\");\n}\nframe.putLocal(parameter.getName(), returns[j]);\n}\ntry {\ninterpreter.checkInvariants(frame, postconditions);\nnumPassed++;\n\/\/ \/\/ Print out any return values produced\nif (returns != null) {\nSystem.out.println(\"OUTPUT: \" + Arrays.toString(returns));\n}\n}\ncatch(AssertionError e) {\nSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\nSystem.out.println(\"Postcondition failed \" + e);\nnumFailed++;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error when checking invariants of return values \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\n}\ncatch(AssertionError e) {\nSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\nSystem.out.println(\"Due to error \" + e);\nnumFailed++;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error when checking type invariants of return values \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\ncatch (ResolutionError e) {\n\/\/ FIXME resolution error\ne.printStackTrace();\nassert false;\n}\n}\n\/\/ Overall test statistics\nif(completedAll) {\nSystem.out.println(\"Tested all possible combinations\");\nint numActualTest = numPassed + numFailed + numSkipped;\nif(numFailed == 0) {\nif(numPassed > 0) {\nSystem.out.printf(\"Ok: %d passed (%.2f %%), %d skipped (%.2f %%), ran %d tests %n\",\nnumPassed, (double) 100 * numPassed\/numActualTest, numSkipped, (double) 100 * numSkipped\/numActualTest, numActualTest);\nreturn Result.PASSED;\n}\nelse {\nSystem.out.println(\"All tests skipped!\");\nreturn Result.SKIPPED;\n}\n}\nSystem.out.printf(\"Failed: %d passed (%.2f %%), %d failed (%.2f %%), %d skipped (%.2f %%), ran %d tests%n\",\nnumPassed, (double) 100 * numPassed\/numActualTest, numFailed, (double) 100 * numFailed\/numActualTest, numSkipped, (double) 100 * numSkipped\/numActualTest, numActualTest);\nreturn Result.FAILED;\n}\nelse if(numPassed + numSkipped == numTest) {\nassert numFailed == 0;\nSystem.out.printf(\"Ok: %d passed (%.2f %%), %d skipped (%.2f %%), ran %d tests %n\",\nnumPassed, (double) 100 * numPassed\/numTest, numSkipped, (double) 100 * numSkipped\/numTest, numTest);\nreturn Result.PASSED;\n}\nelse if(numSkipped == numTest) {\nSystem.out.println(\"All tests skipped!\");\nreturn Result.SKIPPED;\n}\nelse {\nSystem.out.printf(\"Failed: %d passed (%.2f %%), %d failed (%.2f %%), %d skipped (%.2f %%), ran %d tests%n\",\nnumPassed, (double) 100 * numPassed\/numTest, numFailed, (double) 100 * numFailed\/numTest, numSkipped, (double) 100 * numSkipped\/numTest, numTest);\nreturn Result.FAILED;\n}\n}\n\nprivate Result executeTest(Path.ID id, QCInterpreter interpreter, Decl.FunctionOrMethod dec, TestType testType, int numTest, BigInteger lowerLimit, BigInteger upperLimit) {\n\/\/ Get the method for generating test values\nGenerateTest testGen;\ntry {\nif(testType == TestType.EXHAUSTIVE) {\ntestGen = new ExhaustiveGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n}\nelse {\ntestGen = new RandomGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n}\n} catch (IntegerRangeException e) {\nSystem.out.println(\"Integer range was invalid for the limits given.\");\nreturn Result.ERRORS;\n}\n\/\/ Get the function's relevant header information\nNameID name = new NameID(id, dec.getName().get());\nType.Callable type = dec.getType();\nTuple<Expr> preconditions = dec.getRequires();\nTuple<Expr> postconditions = dec.getEnsures();\nTuple<Decl.Variable> inputParameters = dec.getParameters();\nTuple<Decl.Variable> outputParameters = dec.getReturns();\nSystem.out.println(\"Name of the function\/method: \" + name.name());\n\nprivate Result executeTest(Path.ID id, QCInterpreter interpreter, Decl.FunctionOrMethod dec, TestType testType, int numTest, BigInteger lowerLimit, BigInteger upperLimit) {\n\/\/ Get the method for generating test values\nGenerateTest testGen;\ntry {\nif(testType == TestType.EXHAUSTIVE) {\ntestGen = new ExhaustiveGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n}\nelse {\ntestGen = new RandomGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n}\n} catch (IntegerRangeException e) {\nSystem.out.println(\"Integer range was invalid for the limits given.\");\nreturn Result.ERRORS;\n}\n\/\/ Get the function's relevant header information\nNameID name = new NameID(id, dec.getName().get());\nType.Callable type = dec.getType();\nTuple<Expr> preconditions = dec.getRequires();\nTuple<Expr> postconditions = dec.getEnsures();\nTuple<Decl.Variable> inputParameters = dec.getParameters();\nTuple<Decl.Variable> outputParameters = dec.getReturns();\nSystem.out.println(\"Name of the function\/method: \" + name.name());\n\/\/ System.out.println(\"FUNCTION PARAM TYPES \"+ inputParameters);\n\/\/ System.out.println(\"PRECONDITION \"+ preconditions);\n\/\/ System.out.println(\"POSTCONDITION \"+ postconditions);\n\/\/ \/\/ Have to remove the pre and post conditions out of the\n\/\/ \/\/ function so the function is executed without validation\n\/\/ \/\/ Validation will be conducted manually inside the function.\n\/\/ Tuple<Expr> empty = new Tuple<Expr>();\n\/\/ dec.setOperand(4, empty); \/\/ Remove precondition\n\/\/ dec.setOperand(5, empty); \/\/ Remove postcondition\nboolean completedAll = false;\nint numSkipped = 0;\nint numPassed = 0;\nint numFailed = 0;\n\nGenerateTest testGen;\ntry {\nif(testType == TestType.EXHAUSTIVE) {\ntestGen = new ExhaustiveGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n}\nelse {\ntestGen = new RandomGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n}\n} catch (IntegerRangeException e) {\nSystem.out.println(\"Integer range was invalid for the limits given.\");\nreturn Result.ERRORS;\n}\n\/\/ Get the function's relevant header information\nNameID name = new NameID(id, dec.getName().get());\nType.Callable type = dec.getType();\nTuple<Expr> preconditions = dec.getRequires();\nTuple<Expr> postconditions = dec.getEnsures();\nTuple<Decl.Variable> inputParameters = dec.getParameters();\nTuple<Decl.Variable> outputParameters = dec.getReturns();\nSystem.out.println(\"Name of the function\/method: \" + name.name());\n\/\/ System.out.println(\"FUNCTION PARAM TYPES \"+ inputParameters);\n\/\/ System.out.println(\"PRECONDITION \"+ preconditions);\n\/\/ System.out.println(\"POSTCONDITION \"+ postconditions);\n\/\/ \/\/ Have to remove the pre and post conditions out of the\n\/\/ \/\/ function so the function is executed without validation\n\/\/ \/\/ Validation will be conducted manually inside the function.\n\/\/ Tuple<Expr> empty = new Tuple<Expr>();\n\/\/ dec.setOperand(4, empty); \/\/ Remove precondition\n\/\/ dec.setOperand(5, empty); \/\/ Remove postcondition\nboolean completedAll = false;\nint numSkipped = 0;\nint numPassed = 0;\nint numFailed = 0;\nfor(int i=0; i < numTest; i++) {\nrecursiveType.clear();\n\/\/ Stop execution if all possible combinations have been generated\n\/\/ Can do this for methods as well as a new call stack is created each time\nif(testGen.exceedSize() && i != 0) {\ncompletedAll = true;\nbreak;\n}\nRValue[] paramValues = null;\nCallStack frame = interpreter.new CallStack();\n\/\/ Check the precondition\ntry {\nparamValues = testGen.generateParameters();\nfor(int j=0; j < inputParameters.size(); j++) {\nDecl.Variable parameter = inputParameters.get(j);\nframe.putLocal(parameter.getName(), paramValues[j]);\n\nTuple<Expr> preconditions = dec.getRequires();\nTuple<Expr> postconditions = dec.getEnsures();\nTuple<Decl.Variable> inputParameters = dec.getParameters();\nTuple<Decl.Variable> outputParameters = dec.getReturns();\nSystem.out.println(\"Name of the function\/method: \" + name.name());\n\/\/ System.out.println(\"FUNCTION PARAM TYPES \"+ inputParameters);\n\/\/ System.out.println(\"PRECONDITION \"+ preconditions);\n\/\/ System.out.println(\"POSTCONDITION \"+ postconditions);\n\/\/ \/\/ Have to remove the pre and post conditions out of the\n\/\/ \/\/ function so the function is executed without validation\n\/\/ \/\/ Validation will be conducted manually inside the function.\n\/\/ Tuple<Expr> empty = new Tuple<Expr>();\n\/\/ dec.setOperand(4, empty); \/\/ Remove precondition\n\/\/ dec.setOperand(5, empty); \/\/ Remove postcondition\nboolean completedAll = false;\nint numSkipped = 0;\nint numPassed = 0;\nint numFailed = 0;\nfor(int i=0; i < numTest; i++) {\nrecursiveType.clear();\n\/\/ Stop execution if all possible combinations have been generated\n\/\/ Can do this for methods as well as a new call stack is created each time\nif(testGen.exceedSize() && i != 0) {\ncompletedAll = true;\nbreak;\n}\nRValue[] paramValues = null;\nCallStack frame = interpreter.new CallStack();\n\/\/ Check the precondition\ntry {\nparamValues = testGen.generateParameters();\nfor(int j=0; j < inputParameters.size(); j++) {\nDecl.Variable parameter = inputParameters.get(j);\nframe.putLocal(parameter.getName(), paramValues[j]);\n}\ninterpreter.checkInvariants(frame, preconditions);\n}\ncatch(CannotGenerateException e) {\nSystem.out.println(e);\nreturn Result.ERRORS;\n}\ncatch(AssertionError e){\n\n\/\/ \/\/ Have to remove the pre and post conditions out of the\n\/\/ \/\/ function so the function is executed without validation\n\/\/ \/\/ Validation will be conducted manually inside the function.\n\/\/ Tuple<Expr> empty = new Tuple<Expr>();\n\/\/ dec.setOperand(4, empty); \/\/ Remove precondition\n\/\/ dec.setOperand(5, empty); \/\/ Remove postcondition\nboolean completedAll = false;\nint numSkipped = 0;\nint numPassed = 0;\nint numFailed = 0;\nfor(int i=0; i < numTest; i++) {\nrecursiveType.clear();\n\/\/ Stop execution if all possible combinations have been generated\n\/\/ Can do this for methods as well as a new call stack is created each time\nif(testGen.exceedSize() && i != 0) {\ncompletedAll = true;\nbreak;\n}\nRValue[] paramValues = null;\nCallStack frame = interpreter.new CallStack();\n\/\/ Check the precondition\ntry {\nparamValues = testGen.generateParameters();\nfor(int j=0; j < inputParameters.size(); j++) {\nDecl.Variable parameter = inputParameters.get(j);\nframe.putLocal(parameter.getName(), paramValues[j]);\n}\ninterpreter.checkInvariants(frame, preconditions);\n}\ncatch(CannotGenerateException e) {\nSystem.out.println(e);\nreturn Result.ERRORS;\n}\ncatch(AssertionError e){\nSystem.out.println(\"Pre-condition failed on input: \" + Arrays.toString(paramValues));\nnumSkipped++;\ncontinue;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error occurred when generating input \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n\nfor(int j=0; j < inputParameters.size(); j++) {\nDecl.Variable parameter = inputParameters.get(j);\nframe.putLocal(parameter.getName(), paramValues[j]);\n}\ninterpreter.checkInvariants(frame, preconditions);\n}\ncatch(CannotGenerateException e) {\nSystem.out.println(e);\nreturn Result.ERRORS;\n}\ncatch(AssertionError e){\nSystem.out.println(\"Pre-condition failed on input: \" + Arrays.toString(paramValues));\nnumSkipped++;\ncontinue;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error occurred when generating input \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\nSystem.out.println(\"INPUT: \" + Arrays.toString(paramValues));\n\/\/ Checks the postcondition when it is executed\nRValue[] returns = null;\ntry {\nreturns = interpreter.execute(name, type, frame, false, false, paramValues);\nrecursiveType.clear();\n}\ncatch(AssertionError e) {\nSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\nnumFailed++;\ncontinue;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\ntry {\n\/\/ Add the return values into the frame for validation\nfor(int j=0; j < outputParameters.size(); j++) {\nDecl.Variable parameter = outputParameters.get(j);\nType paramType = parameter.getType();\nboolean valid = checkInvariant(interpreter, paramType, returns[j]);\n\nSystem.out.println(\"Error occurred when generating input \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\nSystem.out.println(\"INPUT: \" + Arrays.toString(paramValues));\n\/\/ Checks the postcondition when it is executed\nRValue[] returns = null;\ntry {\nreturns = interpreter.execute(name, type, frame, false, false, paramValues);\nrecursiveType.clear();\n}\ncatch(AssertionError e) {\nSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\nnumFailed++;\ncontinue;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\ntry {\n\/\/ Add the return values into the frame for validation\nfor(int j=0; j < outputParameters.size(); j++) {\nDecl.Variable parameter = outputParameters.get(j);\nType paramType = parameter.getType();\nboolean valid = checkInvariant(interpreter, paramType, returns[j]);\nif(!valid) {\nthrow new AssertionError(\"Type constraints for \" + parameter + \" failed\");\n}\nframe.putLocal(parameter.getName(), returns[j]);\n}\ntry {\ninterpreter.checkInvariants(frame, postconditions);\nnumPassed++;\n\/\/ \/\/ Print out any return values produced\nif (returns != null) {\nSystem.out.println(\"OUTPUT: \" + Arrays.toString(returns));\n}\n}\ncatch(AssertionError e) {\nSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\nSystem.out.println(\"Postcondition failed \" + e);\n\ncontinue;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\ntry {\n\/\/ Add the return values into the frame for validation\nfor(int j=0; j < outputParameters.size(); j++) {\nDecl.Variable parameter = outputParameters.get(j);\nType paramType = parameter.getType();\nboolean valid = checkInvariant(interpreter, paramType, returns[j]);\nif(!valid) {\nthrow new AssertionError(\"Type constraints for \" + parameter + \" failed\");\n}\nframe.putLocal(parameter.getName(), returns[j]);\n}\ntry {\ninterpreter.checkInvariants(frame, postconditions);\nnumPassed++;\n\/\/ \/\/ Print out any return values produced\nif (returns != null) {\nSystem.out.println(\"OUTPUT: \" + Arrays.toString(returns));\n}\n}\ncatch(AssertionError e) {\nSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\nSystem.out.println(\"Postcondition failed \" + e);\nnumFailed++;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error when checking invariants of return values \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\n}\ncatch(AssertionError e) {\nSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\nSystem.out.println(\"Due to error \" + e);\nnumFailed++;\n}\ncatch(RuntimeException e) {\n\ncatch(AssertionError e) {\nSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\nSystem.out.println(\"Postcondition failed \" + e);\nnumFailed++;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error when checking invariants of return values \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\n}\ncatch(AssertionError e) {\nSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\nSystem.out.println(\"Due to error \" + e);\nnumFailed++;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error when checking type invariants of return values \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\ncatch (ResolutionError e) {\n\/\/ FIXME resolution error\ne.printStackTrace();\nassert false;\n}\n}\n\/\/ Overall test statistics\nif(completedAll) {\nSystem.out.println(\"Tested all possible combinations\");\nint numActualTest = numPassed + numFailed + numSkipped;\nif(numFailed == 0) {\nif(numPassed > 0) {\nSystem.out.printf(\"Ok: %d passed (%.2f %%), %d skipped (%.2f %%), ran %d tests %n\",\nnumPassed, (double) 100 * numPassed\/numActualTest, numSkipped, (double) 100 * numSkipped\/numActualTest, numActualTest);\nreturn Result.PASSED;\n}\nelse {\nSystem.out.println(\"All tests skipped!\");\nreturn Result.SKIPPED;\n}\n}\nSystem.out.printf(\"Failed: %d passed (%.2f %%), %d failed (%.2f %%), %d skipped (%.2f %%), ran %d tests%n\",\n\ncatch(RuntimeException e) {\nSystem.out.println(\"Error when checking invariants of return values \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\n}\ncatch(AssertionError e) {\nSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\nSystem.out.println(\"Due to error \" + e);\nnumFailed++;\n}\ncatch(RuntimeException e) {\nSystem.out.println(\"Error when checking type invariants of return values \" + e + \": \" + e.getMessage());\nreturn Result.ERRORS;\n}\ncatch (ResolutionError e) {\n\/\/ FIXME resolution error\ne.printStackTrace();\nassert false;\n}\n}\n\/\/ Overall test statistics\nif(completedAll) {\nSystem.out.println(\"Tested all possible combinations\");\nint numActualTest = numPassed + numFailed + numSkipped;\nif(numFailed == 0) {\nif(numPassed > 0) {\nSystem.out.printf(\"Ok: %d passed (%.2f %%), %d skipped (%.2f %%), ran %d tests %n\",\nnumPassed, (double) 100 * numPassed\/numActualTest, numSkipped, (double) 100 * numSkipped\/numActualTest, numActualTest);\nreturn Result.PASSED;\n}\nelse {\nSystem.out.println(\"All tests skipped!\");\nreturn Result.SKIPPED;\n}\n}\nSystem.out.printf(\"Failed: %d passed (%.2f %%), %d failed (%.2f %%), %d skipped (%.2f %%), ran %d tests%n\",\nnumPassed, (double) 100 * numPassed\/numActualTest, numFailed, (double) 100 * numFailed\/numActualTest, numSkipped, (double) 100 * numSkipped\/numActualTest, numActualTest);\nreturn Result.FAILED;\n}\nelse if(numPassed + numSkipped == numTest) {\nassert numFailed == 0;","label":[0,0,1,0]}
{"id":8419,"original_code":"@GET\n  @Path(\"getDefaultNotebook\")\n  @Produces(MediaType.TEXT_PLAIN)\n  public String getDefaultNotebook() {\n    final String defaultNotebookUrl = this.bkConfig.getDefaultNotebookUrl();\n    \/\/ TODO, assume the url is a file path for now.\n    java.nio.file.Path defaultNotebookFile = Paths.get(defaultNotebookUrl);\n    String content = this.utils.readFile(defaultNotebookFile);\n    if (content == null) {\n      System.out.println(\"Warning, default notebook is empty\");\n      return \"\";\n    }\n    return clean(content);\n  }","code":"@GET\n  @Path(\"getDefaultNotebook\")\n  @Produces(MediaType.TEXT_PLAIN)\n  public String getDefaultNotebook() {\n    final String defaultNotebookUrl = this.bkConfig.getDefaultNotebookUrl();\n   \n    java.nio.file.Path defaultNotebookFile = Paths.get(defaultNotebookUrl);\n    String content = this.utils.readFile(defaultNotebookFile);\n    if (content == null) {\n      System.out.println(\"Warning, default notebook is empty\");\n      return \"\";\n    }\n    return clean(content);\n  }","cleancode":"@get @path(\"getdefaultnotebook\") @produces(mediatype.text_plain) public string getdefaultnotebook() { final string defaultnotebookurl = this.bkconfig.getdefaultnotebookurl(); java.nio.file.path defaultnotebookfile = paths.get(defaultnotebookurl); string content = this.utils.readfile(defaultnotebookfile); if (content == null) { system.out.println(\"warning, default notebook is empty\"); return \"\"; } return clean(content); }","comment":"\/\/ todo, assume the url is a file path for now.","repo":"NunoEdgarGFlowHub\/beaker-notebook","code_context_2":"public String getDefaultNotebook() {\nfinal String defaultNotebookUrl = this.bkConfig.getDefaultNotebookUrl();\n\/\/ TODO, assume the url is a file path for now.\njava.nio.file.Path defaultNotebookFile = Paths.get(defaultNotebookUrl);\nString content = this.utils.readFile(defaultNotebookFile);","code_context_10":"@GET\n@Path(\"getDefaultNotebook\")\n@Produces(MediaType.TEXT_PLAIN)\npublic String getDefaultNotebook() {\nfinal String defaultNotebookUrl = this.bkConfig.getDefaultNotebookUrl();\n\/\/ TODO, assume the url is a file path for now.\njava.nio.file.Path defaultNotebookFile = Paths.get(defaultNotebookUrl);\nString content = this.utils.readFile(defaultNotebookFile);\nif (content == null) {\nSystem.out.println(\"Warning, default notebook is empty\");\nreturn \"\";\n}\nreturn clean(content);\n}","code_context_20":"@GET\n@Path(\"getDefaultNotebook\")\n@Produces(MediaType.TEXT_PLAIN)\npublic String getDefaultNotebook() {\nfinal String defaultNotebookUrl = this.bkConfig.getDefaultNotebookUrl();\n\/\/ TODO, assume the url is a file path for now.\njava.nio.file.Path defaultNotebookFile = Paths.get(defaultNotebookUrl);\nString content = this.utils.readFile(defaultNotebookFile);\nif (content == null) {\nSystem.out.println(\"Warning, default notebook is empty\");\nreturn \"\";\n}\nreturn clean(content);\n}","label":[1,0,0,0]}
{"id":8421,"original_code":"@POST\n  @Path(\"setPreference\")\n  public synchronized void setPreference(\n    @FormParam(\"preferencename\") String preferenceName,\n    @FormParam(\"preferencevalue\") String preferenceValue) {\n    if ((preferenceName == null) || (preferenceValue == null))\n      return;\n    Object newValue = null;\n    \/\/ Validate boolean preferences\n    String[] booleanPrefs = {\"advanced-mode\", \"allow-anonymous-usage-tracking\", \"fs-reverse\"};\n    if (Arrays.asList(booleanPrefs).contains(preferenceName)){\n      switch (preferenceValue){\n        case \"true\":\n          newValue = Boolean.TRUE;\n          break;\n        case \"false\":\n          newValue = Boolean.FALSE;\n          break;\n        default:\n          return;\n      }\n      if (preferenceName.equals(\"advanced-mode\"))\n        this.isUseAdvancedMode = (Boolean) newValue;\n      else if (preferenceName == \"allow\")\n        this.isAllowAnonymousTracking = (Boolean) newValue;\n    }\n    \/\/ Validate edit mode\n    else if (preferenceName.equals(\"edit-mode\")){\n      String[] validModes = {\"vim\", \"emacs\", \"default\"};\n      if (Arrays.asList(validModes).contains(preferenceValue)){\n        newValue = preferenceValue;\n        this.editMode = preferenceValue;\n      }\n    }\n    \/\/ Validate edit mode\n    else if (preferenceName.equals(\"fs-order-by\")){\n      String[] validModes = {\"uri\", \"modified\"};\n      if (Arrays.asList(validModes).contains(preferenceValue)){\n        newValue = preferenceValue;\n      }\n    }\n    final String preferenceFileUrl = this.bkConfig.getPreferenceFileUrl();\n    \/\/ TODO, assume the url is a file path for now.\n    \/\/ System.out.println(preferenceFileUrl + \" url!!!!\\n\");\n    \/\/ Use a temporary for atomic writing\n    java.nio.file.Path preferenceFileTmp = Paths.get(preferenceFileUrl + \".tmp\");\n    java.nio.file.Path preferenceFile = Paths.get(preferenceFileUrl);\n    try {\n      ObjectMapper om = new ObjectMapper();\n      TypeReference readType = new TypeReference<HashMap<String, Object>>() {\n      };\n      Map<String, Object> prefs = om.readValue(preferenceFile.toFile(), readType);\n      Object oldValue = (Object) prefs.get(preferenceName);\n      \/\/ If value changed, write it to the file too\n      if (!Objects.equals(newValue, oldValue)) {\n        Files.deleteIfExists(preferenceFileTmp);\n        prefs.put(preferenceName, newValue);\n        om.writerWithDefaultPrettyPrinter().writeValue(preferenceFileTmp.toFile(), prefs);\n        \/\/ Move tmp to normal\n        Files.move(preferenceFileTmp, preferenceFile, REPLACE_EXISTING);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }","code":"@POST\n  @Path(\"setPreference\")\n  public synchronized void setPreference(\n    @FormParam(\"preferencename\") String preferenceName,\n    @FormParam(\"preferencevalue\") String preferenceValue) {\n    if ((preferenceName == null) || (preferenceValue == null))\n      return;\n    Object newValue = null;\n   \n    String[] booleanPrefs = {\"advanced-mode\", \"allow-anonymous-usage-tracking\", \"fs-reverse\"};\n    if (Arrays.asList(booleanPrefs).contains(preferenceName)){\n      switch (preferenceValue){\n        case \"true\":\n          newValue = Boolean.TRUE;\n          break;\n        case \"false\":\n          newValue = Boolean.FALSE;\n          break;\n        default:\n          return;\n      }\n      if (preferenceName.equals(\"advanced-mode\"))\n        this.isUseAdvancedMode = (Boolean) newValue;\n      else if (preferenceName == \"allow\")\n        this.isAllowAnonymousTracking = (Boolean) newValue;\n    }\n   \n    else if (preferenceName.equals(\"edit-mode\")){\n      String[] validModes = {\"vim\", \"emacs\", \"default\"};\n      if (Arrays.asList(validModes).contains(preferenceValue)){\n        newValue = preferenceValue;\n        this.editMode = preferenceValue;\n      }\n    }\n   \n    else if (preferenceName.equals(\"fs-order-by\")){\n      String[] validModes = {\"uri\", \"modified\"};\n      if (Arrays.asList(validModes).contains(preferenceValue)){\n        newValue = preferenceValue;\n      }\n    }\n    final String preferenceFileUrl = this.bkConfig.getPreferenceFileUrl();\n   \n   \n   \n    java.nio.file.Path preferenceFileTmp = Paths.get(preferenceFileUrl + \".tmp\");\n    java.nio.file.Path preferenceFile = Paths.get(preferenceFileUrl);\n    try {\n      ObjectMapper om = new ObjectMapper();\n      TypeReference readType = new TypeReference<HashMap<String, Object>>() {\n      };\n      Map<String, Object> prefs = om.readValue(preferenceFile.toFile(), readType);\n      Object oldValue = (Object) prefs.get(preferenceName);\n     \n      if (!Objects.equals(newValue, oldValue)) {\n        Files.deleteIfExists(preferenceFileTmp);\n        prefs.put(preferenceName, newValue);\n        om.writerWithDefaultPrettyPrinter().writeValue(preferenceFileTmp.toFile(), prefs);\n       \n        Files.move(preferenceFileTmp, preferenceFile, REPLACE_EXISTING);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }","cleancode":"@post @path(\"setpreference\") public synchronized void setpreference( @formparam(\"preferencename\") string preferencename, @formparam(\"preferencevalue\") string preferencevalue) { if ((preferencename == null) || (preferencevalue == null)) return; object newvalue = null; string[] booleanprefs = {\"advanced-mode\", \"allow-anonymous-usage-tracking\", \"fs-reverse\"}; if (arrays.aslist(booleanprefs).contains(preferencename)){ switch (preferencevalue){ case \"true\": newvalue = boolean.true; break; case \"false\": newvalue = boolean.false; break; default: return; } if (preferencename.equals(\"advanced-mode\")) this.isuseadvancedmode = (boolean) newvalue; else if (preferencename == \"allow\") this.isallowanonymoustracking = (boolean) newvalue; } else if (preferencename.equals(\"edit-mode\")){ string[] validmodes = {\"vim\", \"emacs\", \"default\"}; if (arrays.aslist(validmodes).contains(preferencevalue)){ newvalue = preferencevalue; this.editmode = preferencevalue; } } else if (preferencename.equals(\"fs-order-by\")){ string[] validmodes = {\"uri\", \"modified\"}; if (arrays.aslist(validmodes).contains(preferencevalue)){ newvalue = preferencevalue; } } final string preferencefileurl = this.bkconfig.getpreferencefileurl(); java.nio.file.path preferencefiletmp = paths.get(preferencefileurl + \".tmp\"); java.nio.file.path preferencefile = paths.get(preferencefileurl); try { objectmapper om = new objectmapper(); typereference readtype = new typereference<hashmap<string, object>>() { }; map<string, object> prefs = om.readvalue(preferencefile.tofile(), readtype); object oldvalue = (object) prefs.get(preferencename); if (!objects.equals(newvalue, oldvalue)) { files.deleteifexists(preferencefiletmp); prefs.put(preferencename, newvalue); om.writerwithdefaultprettyprinter().writevalue(preferencefiletmp.tofile(), prefs); files.move(preferencefiletmp, preferencefile, replace_existing); } } catch (ioexception e) { e.printstacktrace(); } }","comment":"\/\/ validate boolean preferences\n\/\/ validate edit mode\n\/\/ validate edit mode\n\/\/ todo, assume the url is a file path for now. \/\/ system.out.println(preferencefileurl + \" url!!!!\\n\"); \/\/ use a temporary for atomic writing\n\/\/ if value changed, write it to the file too\n\/\/ move tmp to normal","repo":"NunoEdgarGFlowHub\/beaker-notebook","code_context_2":"return;\nObject newValue = null;\n\/\/ Validate boolean preferences\nString[] booleanPrefs = {\"advanced-mode\", \"allow-anonymous-usage-tracking\", \"fs-reverse\"};\nif (Arrays.asList(booleanPrefs).contains(preferenceName)){\n\nthis.isAllowAnonymousTracking = (Boolean) newValue;\n}\n\/\/ Validate edit mode\nelse if (preferenceName.equals(\"edit-mode\")){\nString[] validModes = {\"vim\", \"emacs\", \"default\"};\n\nthis.isAllowAnonymousTracking = (Boolean) newValue;\n}\n\/\/ Validate edit mode\nelse if (preferenceName.equals(\"edit-mode\")){\nString[] validModes = {\"vim\", \"emacs\", \"default\"};\n\n}\nfinal String preferenceFileUrl = this.bkConfig.getPreferenceFileUrl();\n\/\/ TODO, assume the url is a file path for now.\n\/\/ System.out.println(preferenceFileUrl + \" url!!!!\\n\");\n\/\/ Use a temporary for atomic writing\njava.nio.file.Path preferenceFileTmp = Paths.get(preferenceFileUrl + \".tmp\");\njava.nio.file.Path preferenceFile = Paths.get(preferenceFileUrl);\n\nMap<String, Object> prefs = om.readValue(preferenceFile.toFile(), readType);\nObject oldValue = (Object) prefs.get(preferenceName);\n\/\/ If value changed, write it to the file too\nif (!Objects.equals(newValue, oldValue)) {\nFiles.deleteIfExists(preferenceFileTmp);\n\nprefs.put(preferenceName, newValue);\nom.writerWithDefaultPrettyPrinter().writeValue(preferenceFileTmp.toFile(), prefs);\n\/\/ Move tmp to normal\nFiles.move(preferenceFileTmp, preferenceFile, REPLACE_EXISTING);\n}","code_context_10":"@POST\n@Path(\"setPreference\")\npublic synchronized void setPreference(\n@FormParam(\"preferencename\") String preferenceName,\n@FormParam(\"preferencevalue\") String preferenceValue) {\nif ((preferenceName == null) || (preferenceValue == null))\nreturn;\nObject newValue = null;\n\/\/ Validate boolean preferences\nString[] booleanPrefs = {\"advanced-mode\", \"allow-anonymous-usage-tracking\", \"fs-reverse\"};\nif (Arrays.asList(booleanPrefs).contains(preferenceName)){\nswitch (preferenceValue){\ncase \"true\":\nnewValue = Boolean.TRUE;\nbreak;\ncase \"false\":\nnewValue = Boolean.FALSE;\nbreak;\ndefault:\n\nnewValue = Boolean.FALSE;\nbreak;\ndefault:\nreturn;\n}\nif (preferenceName.equals(\"advanced-mode\"))\nthis.isUseAdvancedMode = (Boolean) newValue;\nelse if (preferenceName == \"allow\")\nthis.isAllowAnonymousTracking = (Boolean) newValue;\n}\n\/\/ Validate edit mode\nelse if (preferenceName.equals(\"edit-mode\")){\nString[] validModes = {\"vim\", \"emacs\", \"default\"};\nif (Arrays.asList(validModes).contains(preferenceValue)){\nnewValue = preferenceValue;\nthis.editMode = preferenceValue;\n}\n}\n\/\/ Validate edit mode\nelse if (preferenceName.equals(\"fs-order-by\")){\nString[] validModes = {\"uri\", \"modified\"};\n\nnewValue = Boolean.FALSE;\nbreak;\ndefault:\nreturn;\n}\nif (preferenceName.equals(\"advanced-mode\"))\nthis.isUseAdvancedMode = (Boolean) newValue;\nelse if (preferenceName == \"allow\")\nthis.isAllowAnonymousTracking = (Boolean) newValue;\n}\n\/\/ Validate edit mode\nelse if (preferenceName.equals(\"edit-mode\")){\nString[] validModes = {\"vim\", \"emacs\", \"default\"};\nif (Arrays.asList(validModes).contains(preferenceValue)){\nnewValue = preferenceValue;\nthis.editMode = preferenceValue;\n}\n}\n\/\/ Validate edit mode\nelse if (preferenceName.equals(\"fs-order-by\")){\nString[] validModes = {\"uri\", \"modified\"};\n\n}\n}\n\/\/ Validate edit mode\nelse if (preferenceName.equals(\"fs-order-by\")){\nString[] validModes = {\"uri\", \"modified\"};\nif (Arrays.asList(validModes).contains(preferenceValue)){\nnewValue = preferenceValue;\n}\n}\nfinal String preferenceFileUrl = this.bkConfig.getPreferenceFileUrl();\n\/\/ TODO, assume the url is a file path for now.\n\/\/ System.out.println(preferenceFileUrl + \" url!!!!\\n\");\n\/\/ Use a temporary for atomic writing\njava.nio.file.Path preferenceFileTmp = Paths.get(preferenceFileUrl + \".tmp\");\njava.nio.file.Path preferenceFile = Paths.get(preferenceFileUrl);\ntry {\nObjectMapper om = new ObjectMapper();\nTypeReference readType = new TypeReference<HashMap<String, Object>>() {\n};\nMap<String, Object> prefs = om.readValue(preferenceFile.toFile(), readType);\nObject oldValue = (Object) prefs.get(preferenceName);\n\/\/ If value changed, write it to the file too\nif (!Objects.equals(newValue, oldValue)) {\n\n\/\/ System.out.println(preferenceFileUrl + \" url!!!!\\n\");\n\/\/ Use a temporary for atomic writing\njava.nio.file.Path preferenceFileTmp = Paths.get(preferenceFileUrl + \".tmp\");\njava.nio.file.Path preferenceFile = Paths.get(preferenceFileUrl);\ntry {\nObjectMapper om = new ObjectMapper();\nTypeReference readType = new TypeReference<HashMap<String, Object>>() {\n};\nMap<String, Object> prefs = om.readValue(preferenceFile.toFile(), readType);\nObject oldValue = (Object) prefs.get(preferenceName);\n\/\/ If value changed, write it to the file too\nif (!Objects.equals(newValue, oldValue)) {\nFiles.deleteIfExists(preferenceFileTmp);\nprefs.put(preferenceName, newValue);\nom.writerWithDefaultPrettyPrinter().writeValue(preferenceFileTmp.toFile(), prefs);\n\/\/ Move tmp to normal\nFiles.move(preferenceFileTmp, preferenceFile, REPLACE_EXISTING);\n}\n} catch (IOException e) {\ne.printStackTrace();\n}\n\nObjectMapper om = new ObjectMapper();\nTypeReference readType = new TypeReference<HashMap<String, Object>>() {\n};\nMap<String, Object> prefs = om.readValue(preferenceFile.toFile(), readType);\nObject oldValue = (Object) prefs.get(preferenceName);\n\/\/ If value changed, write it to the file too\nif (!Objects.equals(newValue, oldValue)) {\nFiles.deleteIfExists(preferenceFileTmp);\nprefs.put(preferenceName, newValue);\nom.writerWithDefaultPrettyPrinter().writeValue(preferenceFileTmp.toFile(), prefs);\n\/\/ Move tmp to normal\nFiles.move(preferenceFileTmp, preferenceFile, REPLACE_EXISTING);\n}\n} catch (IOException e) {\ne.printStackTrace();\n}\n}","code_context_20":"@POST\n@Path(\"setPreference\")\npublic synchronized void setPreference(\n@FormParam(\"preferencename\") String preferenceName,\n@FormParam(\"preferencevalue\") String preferenceValue) {\nif ((preferenceName == null) || (preferenceValue == null))\nreturn;\nObject newValue = null;\n\/\/ Validate boolean preferences\nString[] booleanPrefs = {\"advanced-mode\", \"allow-anonymous-usage-tracking\", \"fs-reverse\"};\nif (Arrays.asList(booleanPrefs).contains(preferenceName)){\nswitch (preferenceValue){\ncase \"true\":\nnewValue = Boolean.TRUE;\nbreak;\ncase \"false\":\nnewValue = Boolean.FALSE;\nbreak;\ndefault:\nreturn;\n}\nif (preferenceName.equals(\"advanced-mode\"))\nthis.isUseAdvancedMode = (Boolean) newValue;\nelse if (preferenceName == \"allow\")\nthis.isAllowAnonymousTracking = (Boolean) newValue;\n}\n\/\/ Validate edit mode\nelse if (preferenceName.equals(\"edit-mode\")){\nString[] validModes = {\"vim\", \"emacs\", \"default\"};\n\nreturn;\nObject newValue = null;\n\/\/ Validate boolean preferences\nString[] booleanPrefs = {\"advanced-mode\", \"allow-anonymous-usage-tracking\", \"fs-reverse\"};\nif (Arrays.asList(booleanPrefs).contains(preferenceName)){\nswitch (preferenceValue){\ncase \"true\":\nnewValue = Boolean.TRUE;\nbreak;\ncase \"false\":\nnewValue = Boolean.FALSE;\nbreak;\ndefault:\nreturn;\n}\nif (preferenceName.equals(\"advanced-mode\"))\nthis.isUseAdvancedMode = (Boolean) newValue;\nelse if (preferenceName == \"allow\")\nthis.isAllowAnonymousTracking = (Boolean) newValue;\n}\n\/\/ Validate edit mode\nelse if (preferenceName.equals(\"edit-mode\")){\nString[] validModes = {\"vim\", \"emacs\", \"default\"};\nif (Arrays.asList(validModes).contains(preferenceValue)){\nnewValue = preferenceValue;\nthis.editMode = preferenceValue;\n}\n}\n\/\/ Validate edit mode\nelse if (preferenceName.equals(\"fs-order-by\")){\nString[] validModes = {\"uri\", \"modified\"};\nif (Arrays.asList(validModes).contains(preferenceValue)){\nnewValue = preferenceValue;\n}\n}\nfinal String preferenceFileUrl = this.bkConfig.getPreferenceFileUrl();\n\/\/ TODO, assume the url is a file path for now.\n\/\/ System.out.println(preferenceFileUrl + \" url!!!!\\n\");\n\/\/ Use a temporary for atomic writing\njava.nio.file.Path preferenceFileTmp = Paths.get(preferenceFileUrl + \".tmp\");\njava.nio.file.Path preferenceFile = Paths.get(preferenceFileUrl);\n\nreturn;\nObject newValue = null;\n\/\/ Validate boolean preferences\nString[] booleanPrefs = {\"advanced-mode\", \"allow-anonymous-usage-tracking\", \"fs-reverse\"};\nif (Arrays.asList(booleanPrefs).contains(preferenceName)){\nswitch (preferenceValue){\ncase \"true\":\nnewValue = Boolean.TRUE;\nbreak;\ncase \"false\":\nnewValue = Boolean.FALSE;\nbreak;\ndefault:\nreturn;\n}\nif (preferenceName.equals(\"advanced-mode\"))\nthis.isUseAdvancedMode = (Boolean) newValue;\nelse if (preferenceName == \"allow\")\nthis.isAllowAnonymousTracking = (Boolean) newValue;\n}\n\/\/ Validate edit mode\nelse if (preferenceName.equals(\"edit-mode\")){\nString[] validModes = {\"vim\", \"emacs\", \"default\"};\nif (Arrays.asList(validModes).contains(preferenceValue)){\nnewValue = preferenceValue;\nthis.editMode = preferenceValue;\n}\n}\n\/\/ Validate edit mode\nelse if (preferenceName.equals(\"fs-order-by\")){\nString[] validModes = {\"uri\", \"modified\"};\nif (Arrays.asList(validModes).contains(preferenceValue)){\nnewValue = preferenceValue;\n}\n}\nfinal String preferenceFileUrl = this.bkConfig.getPreferenceFileUrl();\n\/\/ TODO, assume the url is a file path for now.\n\/\/ System.out.println(preferenceFileUrl + \" url!!!!\\n\");\n\/\/ Use a temporary for atomic writing\njava.nio.file.Path preferenceFileTmp = Paths.get(preferenceFileUrl + \".tmp\");\njava.nio.file.Path preferenceFile = Paths.get(preferenceFileUrl);\n\nthis.isUseAdvancedMode = (Boolean) newValue;\nelse if (preferenceName == \"allow\")\nthis.isAllowAnonymousTracking = (Boolean) newValue;\n}\n\/\/ Validate edit mode\nelse if (preferenceName.equals(\"edit-mode\")){\nString[] validModes = {\"vim\", \"emacs\", \"default\"};\nif (Arrays.asList(validModes).contains(preferenceValue)){\nnewValue = preferenceValue;\nthis.editMode = preferenceValue;\n}\n}\n\/\/ Validate edit mode\nelse if (preferenceName.equals(\"fs-order-by\")){\nString[] validModes = {\"uri\", \"modified\"};\nif (Arrays.asList(validModes).contains(preferenceValue)){\nnewValue = preferenceValue;\n}\n}\nfinal String preferenceFileUrl = this.bkConfig.getPreferenceFileUrl();\n\/\/ TODO, assume the url is a file path for now.\n\/\/ System.out.println(preferenceFileUrl + \" url!!!!\\n\");\n\/\/ Use a temporary for atomic writing\njava.nio.file.Path preferenceFileTmp = Paths.get(preferenceFileUrl + \".tmp\");\njava.nio.file.Path preferenceFile = Paths.get(preferenceFileUrl);\ntry {\nObjectMapper om = new ObjectMapper();\nTypeReference readType = new TypeReference<HashMap<String, Object>>() {\n};\nMap<String, Object> prefs = om.readValue(preferenceFile.toFile(), readType);\nObject oldValue = (Object) prefs.get(preferenceName);\n\/\/ If value changed, write it to the file too\nif (!Objects.equals(newValue, oldValue)) {\nFiles.deleteIfExists(preferenceFileTmp);\nprefs.put(preferenceName, newValue);\nom.writerWithDefaultPrettyPrinter().writeValue(preferenceFileTmp.toFile(), prefs);\n\/\/ Move tmp to normal\nFiles.move(preferenceFileTmp, preferenceFile, REPLACE_EXISTING);\n}\n} catch (IOException e) {\ne.printStackTrace();\n}\n}\n\n}\n\/\/ Validate edit mode\nelse if (preferenceName.equals(\"fs-order-by\")){\nString[] validModes = {\"uri\", \"modified\"};\nif (Arrays.asList(validModes).contains(preferenceValue)){\nnewValue = preferenceValue;\n}\n}\nfinal String preferenceFileUrl = this.bkConfig.getPreferenceFileUrl();\n\/\/ TODO, assume the url is a file path for now.\n\/\/ System.out.println(preferenceFileUrl + \" url!!!!\\n\");\n\/\/ Use a temporary for atomic writing\njava.nio.file.Path preferenceFileTmp = Paths.get(preferenceFileUrl + \".tmp\");\njava.nio.file.Path preferenceFile = Paths.get(preferenceFileUrl);\ntry {\nObjectMapper om = new ObjectMapper();\nTypeReference readType = new TypeReference<HashMap<String, Object>>() {\n};\nMap<String, Object> prefs = om.readValue(preferenceFile.toFile(), readType);\nObject oldValue = (Object) prefs.get(preferenceName);\n\/\/ If value changed, write it to the file too\nif (!Objects.equals(newValue, oldValue)) {\nFiles.deleteIfExists(preferenceFileTmp);\nprefs.put(preferenceName, newValue);\nom.writerWithDefaultPrettyPrinter().writeValue(preferenceFileTmp.toFile(), prefs);\n\/\/ Move tmp to normal\nFiles.move(preferenceFileTmp, preferenceFile, REPLACE_EXISTING);\n}\n} catch (IOException e) {\ne.printStackTrace();\n}\n}\n\nnewValue = preferenceValue;\n}\n}\nfinal String preferenceFileUrl = this.bkConfig.getPreferenceFileUrl();\n\/\/ TODO, assume the url is a file path for now.\n\/\/ System.out.println(preferenceFileUrl + \" url!!!!\\n\");\n\/\/ Use a temporary for atomic writing\njava.nio.file.Path preferenceFileTmp = Paths.get(preferenceFileUrl + \".tmp\");\njava.nio.file.Path preferenceFile = Paths.get(preferenceFileUrl);\ntry {\nObjectMapper om = new ObjectMapper();\nTypeReference readType = new TypeReference<HashMap<String, Object>>() {\n};\nMap<String, Object> prefs = om.readValue(preferenceFile.toFile(), readType);\nObject oldValue = (Object) prefs.get(preferenceName);\n\/\/ If value changed, write it to the file too\nif (!Objects.equals(newValue, oldValue)) {\nFiles.deleteIfExists(preferenceFileTmp);\nprefs.put(preferenceName, newValue);\nom.writerWithDefaultPrettyPrinter().writeValue(preferenceFileTmp.toFile(), prefs);\n\/\/ Move tmp to normal\nFiles.move(preferenceFileTmp, preferenceFile, REPLACE_EXISTING);\n}\n} catch (IOException e) {\ne.printStackTrace();\n}\n}","label":[1,0,0,0]}
{"id":8420,"original_code":"private void resetConfig() {\n    final String configFileUrl = this.bkConfig.getConfigFileUrl();\n    final String preferenceFileUrl = this.bkConfig.getPreferenceFileUrl();\n    \/\/ TODO, assume the url is a file path for now.\n    java.nio.file.Path configFile = Paths.get(configFileUrl);\n    java.nio.file.Path preferenceFile = Paths.get(preferenceFileUrl);\n    try {\n      JSONParser parser = new JSONParser();\n      JSONObject configJsonObject =\n          (JSONObject) parser.parse(this.utils.readFile(configFile));\n      JSONObject preferenceJsonObject =\n          (JSONObject) parser.parse(this.utils.readFile(preferenceFile));\n      String isAllowTracking = mergeBooleanSetting(\n          \"allow-anonymous-usage-tracking\",\n          configJsonObject,\n          preferenceJsonObject);\n      setPreference(\"allow-anonymous-usage-tracking\", isAllowTracking);\n      String isUseAdvancedMode = mergeBooleanSetting(\n          \"advanced-mode\",\n          configJsonObject,\n          preferenceJsonObject);\n      setPreference(\"advanced-mode\", isUseAdvancedMode);\n      String mergedEditMode = mergeStringSetting(\n          \"edit-mode\",\n          configJsonObject,\n          preferenceJsonObject);\n      setPreference(\"edit-mode\", mergedEditMode);\n      this.initPlugins.addAll(\n          mergeListSetting(\"init\", configJsonObject, preferenceJsonObject));\n      this.controlPanelMenuPlugins.addAll(\n          mergeListSetting(\"control-panel-menu-plugins\", configJsonObject, preferenceJsonObject));\n      this.menuPlugins.addAll(\n          mergeListSetting(\"notebook-app-menu-plugins\", configJsonObject, preferenceJsonObject));\n      this.cellMenuPlugins.addAll(\n          mergeListSetting(\"notebook-cell-menu-plugins\", configJsonObject, preferenceJsonObject));\n    } catch (ParseException e) {\n      throw new RuntimeException(\"failed getting beaker configurations from config file\", e);\n    }\n  }","code":"private void resetConfig() {\n    final String configFileUrl = this.bkConfig.getConfigFileUrl();\n    final String preferenceFileUrl = this.bkConfig.getPreferenceFileUrl();\n   \n    java.nio.file.Path configFile = Paths.get(configFileUrl);\n    java.nio.file.Path preferenceFile = Paths.get(preferenceFileUrl);\n    try {\n      JSONParser parser = new JSONParser();\n      JSONObject configJsonObject =\n          (JSONObject) parser.parse(this.utils.readFile(configFile));\n      JSONObject preferenceJsonObject =\n          (JSONObject) parser.parse(this.utils.readFile(preferenceFile));\n      String isAllowTracking = mergeBooleanSetting(\n          \"allow-anonymous-usage-tracking\",\n          configJsonObject,\n          preferenceJsonObject);\n      setPreference(\"allow-anonymous-usage-tracking\", isAllowTracking);\n      String isUseAdvancedMode = mergeBooleanSetting(\n          \"advanced-mode\",\n          configJsonObject,\n          preferenceJsonObject);\n      setPreference(\"advanced-mode\", isUseAdvancedMode);\n      String mergedEditMode = mergeStringSetting(\n          \"edit-mode\",\n          configJsonObject,\n          preferenceJsonObject);\n      setPreference(\"edit-mode\", mergedEditMode);\n      this.initPlugins.addAll(\n          mergeListSetting(\"init\", configJsonObject, preferenceJsonObject));\n      this.controlPanelMenuPlugins.addAll(\n          mergeListSetting(\"control-panel-menu-plugins\", configJsonObject, preferenceJsonObject));\n      this.menuPlugins.addAll(\n          mergeListSetting(\"notebook-app-menu-plugins\", configJsonObject, preferenceJsonObject));\n      this.cellMenuPlugins.addAll(\n          mergeListSetting(\"notebook-cell-menu-plugins\", configJsonObject, preferenceJsonObject));\n    } catch (ParseException e) {\n      throw new RuntimeException(\"failed getting beaker configurations from config file\", e);\n    }\n  }","cleancode":"private void resetconfig() { final string configfileurl = this.bkconfig.getconfigfileurl(); final string preferencefileurl = this.bkconfig.getpreferencefileurl(); java.nio.file.path configfile = paths.get(configfileurl); java.nio.file.path preferencefile = paths.get(preferencefileurl); try { jsonparser parser = new jsonparser(); jsonobject configjsonobject = (jsonobject) parser.parse(this.utils.readfile(configfile)); jsonobject preferencejsonobject = (jsonobject) parser.parse(this.utils.readfile(preferencefile)); string isallowtracking = mergebooleansetting( \"allow-anonymous-usage-tracking\", configjsonobject, preferencejsonobject); setpreference(\"allow-anonymous-usage-tracking\", isallowtracking); string isuseadvancedmode = mergebooleansetting( \"advanced-mode\", configjsonobject, preferencejsonobject); setpreference(\"advanced-mode\", isuseadvancedmode); string mergededitmode = mergestringsetting( \"edit-mode\", configjsonobject, preferencejsonobject); setpreference(\"edit-mode\", mergededitmode); this.initplugins.addall( mergelistsetting(\"init\", configjsonobject, preferencejsonobject)); this.controlpanelmenuplugins.addall( mergelistsetting(\"control-panel-menu-plugins\", configjsonobject, preferencejsonobject)); this.menuplugins.addall( mergelistsetting(\"notebook-app-menu-plugins\", configjsonobject, preferencejsonobject)); this.cellmenuplugins.addall( mergelistsetting(\"notebook-cell-menu-plugins\", configjsonobject, preferencejsonobject)); } catch (parseexception e) { throw new runtimeexception(\"failed getting beaker configurations from config file\", e); } }","comment":"\/\/ todo, assume the url is a file path for now.","repo":"NunoEdgarGFlowHub\/beaker-notebook","code_context_2":"final String configFileUrl = this.bkConfig.getConfigFileUrl();\nfinal String preferenceFileUrl = this.bkConfig.getPreferenceFileUrl();\n\/\/ TODO, assume the url is a file path for now.\njava.nio.file.Path configFile = Paths.get(configFileUrl);\njava.nio.file.Path preferenceFile = Paths.get(preferenceFileUrl);","code_context_10":"private void resetConfig() {\nfinal String configFileUrl = this.bkConfig.getConfigFileUrl();\nfinal String preferenceFileUrl = this.bkConfig.getPreferenceFileUrl();\n\/\/ TODO, assume the url is a file path for now.\njava.nio.file.Path configFile = Paths.get(configFileUrl);\njava.nio.file.Path preferenceFile = Paths.get(preferenceFileUrl);\ntry {\nJSONParser parser = new JSONParser();\nJSONObject configJsonObject =\n(JSONObject) parser.parse(this.utils.readFile(configFile));\nJSONObject preferenceJsonObject =\n(JSONObject) parser.parse(this.utils.readFile(preferenceFile));\nString isAllowTracking = mergeBooleanSetting(\n\"allow-anonymous-usage-tracking\",","code_context_20":"private void resetConfig() {\nfinal String configFileUrl = this.bkConfig.getConfigFileUrl();\nfinal String preferenceFileUrl = this.bkConfig.getPreferenceFileUrl();\n\/\/ TODO, assume the url is a file path for now.\njava.nio.file.Path configFile = Paths.get(configFileUrl);\njava.nio.file.Path preferenceFile = Paths.get(preferenceFileUrl);\ntry {\nJSONParser parser = new JSONParser();\nJSONObject configJsonObject =\n(JSONObject) parser.parse(this.utils.readFile(configFile));\nJSONObject preferenceJsonObject =\n(JSONObject) parser.parse(this.utils.readFile(preferenceFile));\nString isAllowTracking = mergeBooleanSetting(\n\"allow-anonymous-usage-tracking\",\nconfigJsonObject,\npreferenceJsonObject);\nsetPreference(\"allow-anonymous-usage-tracking\", isAllowTracking);\nString isUseAdvancedMode = mergeBooleanSetting(\n\"advanced-mode\",\nconfigJsonObject,\npreferenceJsonObject);\nsetPreference(\"advanced-mode\", isUseAdvancedMode);\nString mergedEditMode = mergeStringSetting(\n\"edit-mode\",","label":[1,0,0,0]}
{"id":8457,"original_code":"@Override\n    @StartHandler(phase = Phase.INBOUND_EVENT_CONNECTORS)\n    public void start() {\n        if (activeProcessorThreads() > 0 || workLauncherRunning.get()) {\n            if (state.get().isRunning()) {\n                \/\/ then it's ok. It's already running\n                return;\n            } else {\n                \/\/ this is problematic. There are still active threads pending a shutdown.\n                throw new IllegalStateException(\"Cannot start this processor. It is pending shutdown...\");\n            }\n        }\n        State previousState = state.getAndSet(State.STARTED);\n        if (!previousState.isRunning()) {\n            startSegmentWorkers();\n        }\n    }","code":"@Override\n    @StartHandler(phase = Phase.INBOUND_EVENT_CONNECTORS)\n    public void start() {\n        if (activeProcessorThreads() > 0 || workLauncherRunning.get()) {\n            if (state.get().isRunning()) {\n               \n                return;\n            } else {\n               \n                throw new IllegalStateException(\"Cannot start this processor. It is pending shutdown...\");\n            }\n        }\n        State previousState = state.getAndSet(State.STARTED);\n        if (!previousState.isRunning()) {\n            startSegmentWorkers();\n        }\n    }","cleancode":"@override @starthandler(phase = phase.inbound_event_connectors) public void start() { if (activeprocessorthreads() > 0 || worklauncherrunning.get()) { if (state.get().isrunning()) { return; } else { throw new illegalstateexception(\"cannot start this processor. it is pending shutdown...\"); } } state previousstate = state.getandset(state.started); if (!previousstate.isrunning()) { startsegmentworkers(); } }","comment":"\/** * start this processor. the processor will open an event stream on its message source in a new thread using {@link * streamablemessagesource#openstream(trackingtoken)}. the {@link trackingtoken} used to open the stream will be * fetched from the {@link tokenstore}. * <p> * upon start up of an application, this method will be invoked in the {@link phase#inbound_event_connectors} * phase. *\/\n\/\/ then it's ok. it's already running\n\/\/ this is problematic. there are still active threads pending a shutdown.","repo":"Mu-L\/AxonFramework","code_context_2":"@Override\n@StartHandler(phase = Phase.INBOUND_EVENT_CONNECTORS)\npublic void start() {\nif (activeProcessorThreads() > 0 || workLauncherRunning.get()) {\nif (state.get().isRunning()) {\n\/\/ then it's ok. It's already running\nreturn;\n} else {\n\/\/ this is problematic. There are still active threads pending a shutdown.\nthrow new IllegalStateException(\"Cannot start this processor. It is pending shutdown...\");\n}\n}\nState previousState = state.getAndSet(State.STARTED);\nif (!previousState.isRunning()) {\nstartSegmentWorkers();\n}\n}\n\nif (activeProcessorThreads() > 0 || workLauncherRunning.get()) {\nif (state.get().isRunning()) {\n\/\/ then it's ok. It's already running\nreturn;\n} else {\n\nreturn;\n} else {\n\/\/ this is problematic. There are still active threads pending a shutdown.\nthrow new IllegalStateException(\"Cannot start this processor. It is pending shutdown...\");\n}","code_context_10":"@Override\n@StartHandler(phase = Phase.INBOUND_EVENT_CONNECTORS)\npublic void start() {\nif (activeProcessorThreads() > 0 || workLauncherRunning.get()) {\nif (state.get().isRunning()) {\n\/\/ then it's ok. It's already running\nreturn;\n} else {\n\/\/ this is problematic. There are still active threads pending a shutdown.\nthrow new IllegalStateException(\"Cannot start this processor. It is pending shutdown...\");\n}\n}\nState previousState = state.getAndSet(State.STARTED);\nif (!previousState.isRunning()) {\nstartSegmentWorkers();\n}\n}\n\n@Override\n@StartHandler(phase = Phase.INBOUND_EVENT_CONNECTORS)\npublic void start() {\nif (activeProcessorThreads() > 0 || workLauncherRunning.get()) {\nif (state.get().isRunning()) {\n\/\/ then it's ok. It's already running\nreturn;\n} else {\n\/\/ this is problematic. There are still active threads pending a shutdown.\nthrow new IllegalStateException(\"Cannot start this processor. It is pending shutdown...\");\n}\n}\nState previousState = state.getAndSet(State.STARTED);\nif (!previousState.isRunning()) {\nstartSegmentWorkers();\n}\n\n@Override\n@StartHandler(phase = Phase.INBOUND_EVENT_CONNECTORS)\npublic void start() {\nif (activeProcessorThreads() > 0 || workLauncherRunning.get()) {\nif (state.get().isRunning()) {\n\/\/ then it's ok. It's already running\nreturn;\n} else {\n\/\/ this is problematic. There are still active threads pending a shutdown.\nthrow new IllegalStateException(\"Cannot start this processor. It is pending shutdown...\");\n}\n}\nState previousState = state.getAndSet(State.STARTED);\nif (!previousState.isRunning()) {\nstartSegmentWorkers();\n}\n}","code_context_20":"@Override\n@StartHandler(phase = Phase.INBOUND_EVENT_CONNECTORS)\npublic void start() {\nif (activeProcessorThreads() > 0 || workLauncherRunning.get()) {\nif (state.get().isRunning()) {\n\/\/ then it's ok. It's already running\nreturn;\n} else {\n\/\/ this is problematic. There are still active threads pending a shutdown.\nthrow new IllegalStateException(\"Cannot start this processor. It is pending shutdown...\");\n}\n}\nState previousState = state.getAndSet(State.STARTED);\nif (!previousState.isRunning()) {\nstartSegmentWorkers();\n}\n}\n\n@Override\n@StartHandler(phase = Phase.INBOUND_EVENT_CONNECTORS)\npublic void start() {\nif (activeProcessorThreads() > 0 || workLauncherRunning.get()) {\nif (state.get().isRunning()) {\n\/\/ then it's ok. It's already running\nreturn;\n} else {\n\/\/ this is problematic. There are still active threads pending a shutdown.\nthrow new IllegalStateException(\"Cannot start this processor. It is pending shutdown...\");\n}\n}\nState previousState = state.getAndSet(State.STARTED);\nif (!previousState.isRunning()) {\nstartSegmentWorkers();\n}\n}\n\n@Override\n@StartHandler(phase = Phase.INBOUND_EVENT_CONNECTORS)\npublic void start() {\nif (activeProcessorThreads() > 0 || workLauncherRunning.get()) {\nif (state.get().isRunning()) {\n\/\/ then it's ok. It's already running\nreturn;\n} else {\n\/\/ this is problematic. There are still active threads pending a shutdown.\nthrow new IllegalStateException(\"Cannot start this processor. It is pending shutdown...\");\n}\n}\nState previousState = state.getAndSet(State.STARTED);\nif (!previousState.isRunning()) {\nstartSegmentWorkers();\n}\n}","label":[0,0,1,0]}
{"id":275,"original_code":"public void update(Observable arg0, Object arg) {\n\t\t\/\/ arg is Event\n\t\tif (!(arg instanceof Event))\n\t\t\treturn;\n\t\tEvent event = (Event) arg;\n\t\t\/\/ check the event function against the functions we have notifications watching for\n\t\tString function = event.getEvent();\n\t\t\/\/we err on the side of caution here in checking all events that might invalidate the data in the cache -DH\n\t\tif (UserDirectoryService.SECURE_ADD_USER.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN_PASSWORD.equals(function)\n\t\t\t\t|| UserDirectoryService.SECURE_UPDATE_USER_ANY.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN.equals(function)) {\n\t\t\t\/\/we need the userId\n\t\t\tReference ref = entityManager.newReference(event.getResource());\n\t\t\t\/\/ look for group reference. Need to replace it with parent site reference\n\t\t\tString refId = ref.getId();\n\t\t\ttry {\n\t\t\t\tString eid = userDirectoryService.getUserEid(refId);\n\t\t\t\tlog.debug(\"removing \" + eid + \" from cache\");\n\t\t\t\tauthenticationCache.removeAuthentification(eid);\n\t\t\t\tuserCache.remove(UserDirectoryService.IDCACHE + eid);\n\t\t\t\tuserCache.remove(UserDirectoryService.EIDCACHE + refId);\n\t\t\t} catch (UserNotDefinedException e) {\n\t\t\t\t\/\/not sure how we'd end up here\n\t\t\t\tlog.warn(e.getMessage(), e);\n\t\t\t}\n\t\t} \n\t}","code":"public void update(Observable arg0, Object arg) {\n\t\n\t\tif (!(arg instanceof Event))\n\t\t\treturn;\n\t\tEvent event = (Event) arg;\n\t\n\t\tString function = event.getEvent();\n\t\n\t\tif (UserDirectoryService.SECURE_ADD_USER.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN_PASSWORD.equals(function)\n\t\t\t\t|| UserDirectoryService.SECURE_UPDATE_USER_ANY.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN.equals(function)) {\n\t\t\n\t\t\tReference ref = entityManager.newReference(event.getResource());\n\t\t\n\t\t\tString refId = ref.getId();\n\t\t\ttry {\n\t\t\t\tString eid = userDirectoryService.getUserEid(refId);\n\t\t\t\tlog.debug(\"removing \" + eid + \" from cache\");\n\t\t\t\tauthenticationCache.removeAuthentification(eid);\n\t\t\t\tuserCache.remove(UserDirectoryService.IDCACHE + eid);\n\t\t\t\tuserCache.remove(UserDirectoryService.EIDCACHE + refId);\n\t\t\t} catch (UserNotDefinedException e) {\n\t\t\t\n\t\t\t\tlog.warn(e.getMessage(), e);\n\t\t\t}\n\t\t} \n\t}","cleancode":"public void update(observable arg0, object arg) { if (!(arg instanceof event)) return; event event = (event) arg; string function = event.getevent(); if (userdirectoryservice.secure_add_user.equals(function) || userdirectoryservice.secure_update_user_own_password.equals(function) || userdirectoryservice.secure_update_user_any.equals(function) || userdirectoryservice.secure_update_user_own.equals(function)) { reference ref = entitymanager.newreference(event.getresource()); string refid = ref.getid(); try { string eid = userdirectoryservice.getusereid(refid); log.debug(\"removing \" + eid + \" from cache\"); authenticationcache.removeauthentification(eid); usercache.remove(userdirectoryservice.idcache + eid); usercache.remove(userdirectoryservice.eidcache + refid); } catch (usernotdefinedexception e) { log.warn(e.getmessage(), e); } } }","comment":"\/\/ arg is event\n\/\/ check the event function against the functions we have notifications watching for\n\/\/we err on the side of caution here in checking all events that might invalidate the data in the cache -dh\n\/\/we need the userid\n\/\/ look for group reference. need to replace it with parent site reference\n\/\/not sure how we'd end up here","repo":"RyanAFinney\/sakai","code_context_2":"public void update(Observable arg0, Object arg) {\n\/\/ arg is Event\nif (!(arg instanceof Event))\nreturn;\n\nreturn;\nEvent event = (Event) arg;\n\/\/ check the event function against the functions we have notifications watching for\nString function = event.getEvent();\n\/\/we err on the side of caution here in checking all events that might invalidate the data in the cache -DH\n\n\/\/ check the event function against the functions we have notifications watching for\nString function = event.getEvent();\n\/\/we err on the side of caution here in checking all events that might invalidate the data in the cache -DH\nif (UserDirectoryService.SECURE_ADD_USER.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN_PASSWORD.equals(function)\n|| UserDirectoryService.SECURE_UPDATE_USER_ANY.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN.equals(function)) {\n\nif (UserDirectoryService.SECURE_ADD_USER.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN_PASSWORD.equals(function)\n|| UserDirectoryService.SECURE_UPDATE_USER_ANY.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN.equals(function)) {\n\/\/we need the userId\nReference ref = entityManager.newReference(event.getResource());\n\/\/ look for group reference. Need to replace it with parent site reference\n\n\/\/we need the userId\nReference ref = entityManager.newReference(event.getResource());\n\/\/ look for group reference. Need to replace it with parent site reference\nString refId = ref.getId();\ntry {\n\nuserCache.remove(UserDirectoryService.EIDCACHE + refId);\n} catch (UserNotDefinedException e) {\n\/\/not sure how we'd end up here\nlog.warn(e.getMessage(), e);\n}","code_context_10":"public void update(Observable arg0, Object arg) {\n\/\/ arg is Event\nif (!(arg instanceof Event))\nreturn;\nEvent event = (Event) arg;\n\/\/ check the event function against the functions we have notifications watching for\nString function = event.getEvent();\n\/\/we err on the side of caution here in checking all events that might invalidate the data in the cache -DH\nif (UserDirectoryService.SECURE_ADD_USER.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN_PASSWORD.equals(function)\n|| UserDirectoryService.SECURE_UPDATE_USER_ANY.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN.equals(function)) {\n\/\/we need the userId\nReference ref = entityManager.newReference(event.getResource());\n\npublic void update(Observable arg0, Object arg) {\n\/\/ arg is Event\nif (!(arg instanceof Event))\nreturn;\nEvent event = (Event) arg;\n\/\/ check the event function against the functions we have notifications watching for\nString function = event.getEvent();\n\/\/we err on the side of caution here in checking all events that might invalidate the data in the cache -DH\nif (UserDirectoryService.SECURE_ADD_USER.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN_PASSWORD.equals(function)\n|| UserDirectoryService.SECURE_UPDATE_USER_ANY.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN.equals(function)) {\n\/\/we need the userId\nReference ref = entityManager.newReference(event.getResource());\n\/\/ look for group reference. Need to replace it with parent site reference\nString refId = ref.getId();\ntry {\nString eid = userDirectoryService.getUserEid(refId);\n\npublic void update(Observable arg0, Object arg) {\n\/\/ arg is Event\nif (!(arg instanceof Event))\nreturn;\nEvent event = (Event) arg;\n\/\/ check the event function against the functions we have notifications watching for\nString function = event.getEvent();\n\/\/we err on the side of caution here in checking all events that might invalidate the data in the cache -DH\nif (UserDirectoryService.SECURE_ADD_USER.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN_PASSWORD.equals(function)\n|| UserDirectoryService.SECURE_UPDATE_USER_ANY.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN.equals(function)) {\n\/\/we need the userId\nReference ref = entityManager.newReference(event.getResource());\n\/\/ look for group reference. Need to replace it with parent site reference\nString refId = ref.getId();\ntry {\nString eid = userDirectoryService.getUserEid(refId);\nlog.debug(\"removing \" + eid + \" from cache\");\nauthenticationCache.removeAuthentification(eid);\n\npublic void update(Observable arg0, Object arg) {\n\/\/ arg is Event\nif (!(arg instanceof Event))\nreturn;\nEvent event = (Event) arg;\n\/\/ check the event function against the functions we have notifications watching for\nString function = event.getEvent();\n\/\/we err on the side of caution here in checking all events that might invalidate the data in the cache -DH\nif (UserDirectoryService.SECURE_ADD_USER.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN_PASSWORD.equals(function)\n|| UserDirectoryService.SECURE_UPDATE_USER_ANY.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN.equals(function)) {\n\/\/we need the userId\nReference ref = entityManager.newReference(event.getResource());\n\/\/ look for group reference. Need to replace it with parent site reference\nString refId = ref.getId();\ntry {\nString eid = userDirectoryService.getUserEid(refId);\nlog.debug(\"removing \" + eid + \" from cache\");\nauthenticationCache.removeAuthentification(eid);\nuserCache.remove(UserDirectoryService.IDCACHE + eid);\nuserCache.remove(UserDirectoryService.EIDCACHE + refId);\n} catch (UserNotDefinedException e) {\n\nif (!(arg instanceof Event))\nreturn;\nEvent event = (Event) arg;\n\/\/ check the event function against the functions we have notifications watching for\nString function = event.getEvent();\n\/\/we err on the side of caution here in checking all events that might invalidate the data in the cache -DH\nif (UserDirectoryService.SECURE_ADD_USER.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN_PASSWORD.equals(function)\n|| UserDirectoryService.SECURE_UPDATE_USER_ANY.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN.equals(function)) {\n\/\/we need the userId\nReference ref = entityManager.newReference(event.getResource());\n\/\/ look for group reference. Need to replace it with parent site reference\nString refId = ref.getId();\ntry {\nString eid = userDirectoryService.getUserEid(refId);\nlog.debug(\"removing \" + eid + \" from cache\");\nauthenticationCache.removeAuthentification(eid);\nuserCache.remove(UserDirectoryService.IDCACHE + eid);\nuserCache.remove(UserDirectoryService.EIDCACHE + refId);\n} catch (UserNotDefinedException e) {\n\/\/not sure how we'd end up here\nlog.warn(e.getMessage(), e);\n\nReference ref = entityManager.newReference(event.getResource());\n\/\/ look for group reference. Need to replace it with parent site reference\nString refId = ref.getId();\ntry {\nString eid = userDirectoryService.getUserEid(refId);\nlog.debug(\"removing \" + eid + \" from cache\");\nauthenticationCache.removeAuthentification(eid);\nuserCache.remove(UserDirectoryService.IDCACHE + eid);\nuserCache.remove(UserDirectoryService.EIDCACHE + refId);\n} catch (UserNotDefinedException e) {\n\/\/not sure how we'd end up here\nlog.warn(e.getMessage(), e);\n}\n}\n}","code_context_20":"public void update(Observable arg0, Object arg) {\n\/\/ arg is Event\nif (!(arg instanceof Event))\nreturn;\nEvent event = (Event) arg;\n\/\/ check the event function against the functions we have notifications watching for\nString function = event.getEvent();\n\/\/we err on the side of caution here in checking all events that might invalidate the data in the cache -DH\nif (UserDirectoryService.SECURE_ADD_USER.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN_PASSWORD.equals(function)\n|| UserDirectoryService.SECURE_UPDATE_USER_ANY.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN.equals(function)) {\n\/\/we need the userId\nReference ref = entityManager.newReference(event.getResource());\n\/\/ look for group reference. Need to replace it with parent site reference\nString refId = ref.getId();\ntry {\nString eid = userDirectoryService.getUserEid(refId);\nlog.debug(\"removing \" + eid + \" from cache\");\nauthenticationCache.removeAuthentification(eid);\nuserCache.remove(UserDirectoryService.IDCACHE + eid);\nuserCache.remove(UserDirectoryService.EIDCACHE + refId);\n} catch (UserNotDefinedException e) {\n\/\/not sure how we'd end up here\n\npublic void update(Observable arg0, Object arg) {\n\/\/ arg is Event\nif (!(arg instanceof Event))\nreturn;\nEvent event = (Event) arg;\n\/\/ check the event function against the functions we have notifications watching for\nString function = event.getEvent();\n\/\/we err on the side of caution here in checking all events that might invalidate the data in the cache -DH\nif (UserDirectoryService.SECURE_ADD_USER.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN_PASSWORD.equals(function)\n|| UserDirectoryService.SECURE_UPDATE_USER_ANY.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN.equals(function)) {\n\/\/we need the userId\nReference ref = entityManager.newReference(event.getResource());\n\/\/ look for group reference. Need to replace it with parent site reference\nString refId = ref.getId();\ntry {\nString eid = userDirectoryService.getUserEid(refId);\nlog.debug(\"removing \" + eid + \" from cache\");\nauthenticationCache.removeAuthentification(eid);\nuserCache.remove(UserDirectoryService.IDCACHE + eid);\nuserCache.remove(UserDirectoryService.EIDCACHE + refId);\n} catch (UserNotDefinedException e) {\n\/\/not sure how we'd end up here\nlog.warn(e.getMessage(), e);\n}\n}\n}\n\npublic void update(Observable arg0, Object arg) {\n\/\/ arg is Event\nif (!(arg instanceof Event))\nreturn;\nEvent event = (Event) arg;\n\/\/ check the event function against the functions we have notifications watching for\nString function = event.getEvent();\n\/\/we err on the side of caution here in checking all events that might invalidate the data in the cache -DH\nif (UserDirectoryService.SECURE_ADD_USER.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN_PASSWORD.equals(function)\n|| UserDirectoryService.SECURE_UPDATE_USER_ANY.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN.equals(function)) {\n\/\/we need the userId\nReference ref = entityManager.newReference(event.getResource());\n\/\/ look for group reference. Need to replace it with parent site reference\nString refId = ref.getId();\ntry {\nString eid = userDirectoryService.getUserEid(refId);\nlog.debug(\"removing \" + eid + \" from cache\");\nauthenticationCache.removeAuthentification(eid);\nuserCache.remove(UserDirectoryService.IDCACHE + eid);\nuserCache.remove(UserDirectoryService.EIDCACHE + refId);\n} catch (UserNotDefinedException e) {\n\/\/not sure how we'd end up here\nlog.warn(e.getMessage(), e);\n}\n}\n}\n\npublic void update(Observable arg0, Object arg) {\n\/\/ arg is Event\nif (!(arg instanceof Event))\nreturn;\nEvent event = (Event) arg;\n\/\/ check the event function against the functions we have notifications watching for\nString function = event.getEvent();\n\/\/we err on the side of caution here in checking all events that might invalidate the data in the cache -DH\nif (UserDirectoryService.SECURE_ADD_USER.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN_PASSWORD.equals(function)\n|| UserDirectoryService.SECURE_UPDATE_USER_ANY.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN.equals(function)) {\n\/\/we need the userId\nReference ref = entityManager.newReference(event.getResource());\n\/\/ look for group reference. Need to replace it with parent site reference\nString refId = ref.getId();\ntry {\nString eid = userDirectoryService.getUserEid(refId);\nlog.debug(\"removing \" + eid + \" from cache\");\nauthenticationCache.removeAuthentification(eid);\nuserCache.remove(UserDirectoryService.IDCACHE + eid);\nuserCache.remove(UserDirectoryService.EIDCACHE + refId);\n} catch (UserNotDefinedException e) {\n\/\/not sure how we'd end up here\nlog.warn(e.getMessage(), e);\n}\n}\n}\n\npublic void update(Observable arg0, Object arg) {\n\/\/ arg is Event\nif (!(arg instanceof Event))\nreturn;\nEvent event = (Event) arg;\n\/\/ check the event function against the functions we have notifications watching for\nString function = event.getEvent();\n\/\/we err on the side of caution here in checking all events that might invalidate the data in the cache -DH\nif (UserDirectoryService.SECURE_ADD_USER.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN_PASSWORD.equals(function)\n|| UserDirectoryService.SECURE_UPDATE_USER_ANY.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN.equals(function)) {\n\/\/we need the userId\nReference ref = entityManager.newReference(event.getResource());\n\/\/ look for group reference. Need to replace it with parent site reference\nString refId = ref.getId();\ntry {\nString eid = userDirectoryService.getUserEid(refId);\nlog.debug(\"removing \" + eid + \" from cache\");\nauthenticationCache.removeAuthentification(eid);\nuserCache.remove(UserDirectoryService.IDCACHE + eid);\nuserCache.remove(UserDirectoryService.EIDCACHE + refId);\n} catch (UserNotDefinedException e) {\n\/\/not sure how we'd end up here\nlog.warn(e.getMessage(), e);\n}\n}\n}\n\n\/\/ arg is Event\nif (!(arg instanceof Event))\nreturn;\nEvent event = (Event) arg;\n\/\/ check the event function against the functions we have notifications watching for\nString function = event.getEvent();\n\/\/we err on the side of caution here in checking all events that might invalidate the data in the cache -DH\nif (UserDirectoryService.SECURE_ADD_USER.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN_PASSWORD.equals(function)\n|| UserDirectoryService.SECURE_UPDATE_USER_ANY.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN.equals(function)) {\n\/\/we need the userId\nReference ref = entityManager.newReference(event.getResource());\n\/\/ look for group reference. Need to replace it with parent site reference\nString refId = ref.getId();\ntry {\nString eid = userDirectoryService.getUserEid(refId);\nlog.debug(\"removing \" + eid + \" from cache\");\nauthenticationCache.removeAuthentification(eid);\nuserCache.remove(UserDirectoryService.IDCACHE + eid);\nuserCache.remove(UserDirectoryService.EIDCACHE + refId);\n} catch (UserNotDefinedException e) {\n\/\/not sure how we'd end up here\nlog.warn(e.getMessage(), e);\n}\n}\n}","label":[1,0,0,0]}
{"id":286,"original_code":"public static String getAppProcess32Bit() {\n        return getAppProcess32Bit(true);\n    }","code":"public static String getAppProcess32Bit() {\n        return getAppProcess32Bit(true);\n    }","cleancode":"public static string getappprocess32bit() { return getappprocess32bit(true); }","comment":"\/** * get the path to the 32-bit app_process binary.<br> * <br> * it is unlikely you will need to call this method. * * @see #getappprocess() * @see #getappprocess32bit(boolean) * * @return path to 32-bit app_process or app_process with unspecified bits or null *\/","repo":"Lobesitdoll\/librootjava","code_context_2":"public static String getAppProcess32Bit() {\nreturn getAppProcess32Bit(true);\n}","code_context_10":"public static String getAppProcess32Bit() {\nreturn getAppProcess32Bit(true);\n}","code_context_20":"public static String getAppProcess32Bit() {\nreturn getAppProcess32Bit(true);\n}","label":[0,0,0,0]}
{"id":8492,"original_code":"@Pure\n    @Override\n    public boolean equals(@Nullable Object o) {\n      if (o == null) return false; \/\/ never happens\n      if (this == o) return true;\n      \/\/ This test is illegal because WeakKey is a generic type,\n      \/\/ so use the getClass hack below instead.\n      \/\/ if (!(o instanceof WeakKey)) return false;\n      if (!(o.getClass().equals(WeakKey.class))) return false;\n      Object t = this.get();\n      @SuppressWarnings(\"unchecked\")\n      Object u = ((WeakKey) o).get();\n      if ((t == null) || (u == null)) return false;\n      if (t == u) return true;\n      return keyEquals(t, u);\n    }","code":"@Pure\n    @Override\n    public boolean equals(@Nullable Object o) {\n      if (o == null) return false;\n      if (this == o) return true;\n     \n     \n     \n      if (!(o.getClass().equals(WeakKey.class))) return false;\n      Object t = this.get();\n      @SuppressWarnings(\"unchecked\")\n      Object u = ((WeakKey) o).get();\n      if ((t == null) || (u == null)) return false;\n      if (t == u) return true;\n      return keyEquals(t, u);\n    }","cleancode":"@pure @override public boolean equals(@nullable object o) { if (o == null) return false; if (this == o) return true; if (!(o.getclass().equals(weakkey.class))) return false; object t = this.get(); @suppresswarnings(\"unchecked\") object u = ((weakkey) o).get(); if ((t == null) || (u == null)) return false; if (t == u) return true; return keyequals(t, u); }","comment":"\/* a weakkey is equal to another weakkey iff they both refer to objects that are, in turn, equal according to their own equals methods *\/\n\/\/ never happens\n\/\/ this test is illegal because weakkey is a generic type, \/\/ so use the getclass hack below instead. \/\/ if (!(o instanceof weakkey)) return false;","repo":"Nargeshdb\/plume-util","code_context_2":"@Pure\n@Override\npublic boolean equals(@Nullable Object o) {\nif (o == null) return false; \/\/ never happens\nif (this == o) return true;\n\/\/ This test is illegal because WeakKey is a generic type,\n\/\/ so use the getClass hack below instead.\n\/\/ if (!(o instanceof WeakKey)) return false;\nif (!(o.getClass().equals(WeakKey.class))) return false;\nObject t = this.get();\n@SuppressWarnings(\"unchecked\")\nObject u = ((WeakKey) o).get();\nif ((t == null) || (u == null)) return false;\nif (t == u) return true;\nreturn keyEquals(t, u);\n}\n\n@Override\npublic boolean equals(@Nullable Object o) {\nif (o == null) return false; \/\/ never happens\nif (this == o) return true;\n\/\/ This test is illegal because WeakKey is a generic type,\n\nif (o == null) return false; \/\/ never happens\nif (this == o) return true;\n\/\/ This test is illegal because WeakKey is a generic type,\n\/\/ so use the getClass hack below instead.\n\/\/ if (!(o instanceof WeakKey)) return false;\nif (!(o.getClass().equals(WeakKey.class))) return false;\nObject t = this.get();","code_context_10":"@Pure\n@Override\npublic boolean equals(@Nullable Object o) {\nif (o == null) return false; \/\/ never happens\nif (this == o) return true;\n\/\/ This test is illegal because WeakKey is a generic type,\n\/\/ so use the getClass hack below instead.\n\/\/ if (!(o instanceof WeakKey)) return false;\nif (!(o.getClass().equals(WeakKey.class))) return false;\nObject t = this.get();\n@SuppressWarnings(\"unchecked\")\nObject u = ((WeakKey) o).get();\nif ((t == null) || (u == null)) return false;\nif (t == u) return true;\nreturn keyEquals(t, u);\n}\n\n@Pure\n@Override\npublic boolean equals(@Nullable Object o) {\nif (o == null) return false; \/\/ never happens\nif (this == o) return true;\n\/\/ This test is illegal because WeakKey is a generic type,\n\/\/ so use the getClass hack below instead.\n\/\/ if (!(o instanceof WeakKey)) return false;\nif (!(o.getClass().equals(WeakKey.class))) return false;\nObject t = this.get();\n@SuppressWarnings(\"unchecked\")\nObject u = ((WeakKey) o).get();\nif ((t == null) || (u == null)) return false;\nif (t == u) return true;\n\n@Pure\n@Override\npublic boolean equals(@Nullable Object o) {\nif (o == null) return false; \/\/ never happens\nif (this == o) return true;\n\/\/ This test is illegal because WeakKey is a generic type,\n\/\/ so use the getClass hack below instead.\n\/\/ if (!(o instanceof WeakKey)) return false;\nif (!(o.getClass().equals(WeakKey.class))) return false;\nObject t = this.get();\n@SuppressWarnings(\"unchecked\")\nObject u = ((WeakKey) o).get();\nif ((t == null) || (u == null)) return false;\nif (t == u) return true;\nreturn keyEquals(t, u);\n}","code_context_20":"@Pure\n@Override\npublic boolean equals(@Nullable Object o) {\nif (o == null) return false; \/\/ never happens\nif (this == o) return true;\n\/\/ This test is illegal because WeakKey is a generic type,\n\/\/ so use the getClass hack below instead.\n\/\/ if (!(o instanceof WeakKey)) return false;\nif (!(o.getClass().equals(WeakKey.class))) return false;\nObject t = this.get();\n@SuppressWarnings(\"unchecked\")\nObject u = ((WeakKey) o).get();\nif ((t == null) || (u == null)) return false;\nif (t == u) return true;\nreturn keyEquals(t, u);\n}\n\n@Pure\n@Override\npublic boolean equals(@Nullable Object o) {\nif (o == null) return false; \/\/ never happens\nif (this == o) return true;\n\/\/ This test is illegal because WeakKey is a generic type,\n\/\/ so use the getClass hack below instead.\n\/\/ if (!(o instanceof WeakKey)) return false;\nif (!(o.getClass().equals(WeakKey.class))) return false;\nObject t = this.get();\n@SuppressWarnings(\"unchecked\")\nObject u = ((WeakKey) o).get();\nif ((t == null) || (u == null)) return false;\nif (t == u) return true;\nreturn keyEquals(t, u);\n}\n\n@Pure\n@Override\npublic boolean equals(@Nullable Object o) {\nif (o == null) return false; \/\/ never happens\nif (this == o) return true;\n\/\/ This test is illegal because WeakKey is a generic type,\n\/\/ so use the getClass hack below instead.\n\/\/ if (!(o instanceof WeakKey)) return false;\nif (!(o.getClass().equals(WeakKey.class))) return false;\nObject t = this.get();\n@SuppressWarnings(\"unchecked\")\nObject u = ((WeakKey) o).get();\nif ((t == null) || (u == null)) return false;\nif (t == u) return true;\nreturn keyEquals(t, u);\n}","label":[1,0,0,0]}
{"id":16687,"original_code":"public void applyGPSSetting() {\n        \/\/ verify if GPS enable on device\n        if(GPSService.isGPSProviderEnable(context) || GPSService.isNetworkProviderEnable(context)) {\n            GPSSettingController gpsSettingController = new GPSSettingController(mMapView.getContext());\n            Boolean showGPSLocation = gpsSettingController.getGPSLocationState();\n            Boolean showGPSLocationOnCenter = gpsSettingController.getGPSCenterState();\n            if (showGPSLocation != null)\n                if (showGPSLocation) {\n                    MainActivity mainActivity = (MainActivity) context;\n                    GPSOverlayController gpsOverlayController = mainActivity.getMainController().getGpsOverlayController();\n                    gpsOverlayController.addGPSTrackerLayer();\n                    gpsOverlayController.setKeepOnCenter( ((showGPSLocationOnCenter != null)?(showGPSLocationOnCenter):(false)) );\n                }\n        }else {\n            \/\/ TODO: notify user when the state of the GPS resource is disabled. use one icon on action bar?\n        }\n    }","code":"public void applyGPSSetting() {\n       \n        if(GPSService.isGPSProviderEnable(context) || GPSService.isNetworkProviderEnable(context)) {\n            GPSSettingController gpsSettingController = new GPSSettingController(mMapView.getContext());\n            Boolean showGPSLocation = gpsSettingController.getGPSLocationState();\n            Boolean showGPSLocationOnCenter = gpsSettingController.getGPSCenterState();\n            if (showGPSLocation != null)\n                if (showGPSLocation) {\n                    MainActivity mainActivity = (MainActivity) context;\n                    GPSOverlayController gpsOverlayController = mainActivity.getMainController().getGpsOverlayController();\n                    gpsOverlayController.addGPSTrackerLayer();\n                    gpsOverlayController.setKeepOnCenter( ((showGPSLocationOnCenter != null)?(showGPSLocationOnCenter):(false)) );\n                }\n        }else {\n           \n        }\n    }","cleancode":"public void applygpssetting() { if(gpsservice.isgpsproviderenable(context) || gpsservice.isnetworkproviderenable(context)) { gpssettingcontroller gpssettingcontroller = new gpssettingcontroller(mmapview.getcontext()); boolean showgpslocation = gpssettingcontroller.getgpslocationstate(); boolean showgpslocationoncenter = gpssettingcontroller.getgpscenterstate(); if (showgpslocation != null) if (showgpslocation) { mainactivity mainactivity = (mainactivity) context; gpsoverlaycontroller gpsoverlaycontroller = mainactivity.getmaincontroller().getgpsoverlaycontroller(); gpsoverlaycontroller.addgpstrackerlayer(); gpsoverlaycontroller.setkeeponcenter( ((showgpslocationoncenter != null)?(showgpslocationoncenter):(false)) ); } }else { } }","comment":"\/** * reads the gps configuration and inserts gps overlay on map, if it is enabled. *\/\n\/\/ verify if gps enable on device\n\/\/ todo: notify user when the state of the gps resource is disabled. use one icon on action bar?","repo":"MalteBerlin\/TerraMobile","code_context_2":"public void applyGPSSetting() {\n\/\/ verify if GPS enable on device\nif(GPSService.isGPSProviderEnable(context) || GPSService.isNetworkProviderEnable(context)) {\nGPSSettingController gpsSettingController = new GPSSettingController(mMapView.getContext());\nBoolean showGPSLocation = gpsSettingController.getGPSLocationState();\nBoolean showGPSLocationOnCenter = gpsSettingController.getGPSCenterState();\nif (showGPSLocation != null)\nif (showGPSLocation) {\nMainActivity mainActivity = (MainActivity) context;\nGPSOverlayController gpsOverlayController = mainActivity.getMainController().getGpsOverlayController();\ngpsOverlayController.addGPSTrackerLayer();\ngpsOverlayController.setKeepOnCenter( ((showGPSLocationOnCenter != null)?(showGPSLocationOnCenter):(false)) );\n}\n}else {\n\/\/ TODO: notify user when the state of the GPS resource is disabled. use one icon on action bar?\n}\n}\n\npublic void applyGPSSetting() {\n\/\/ verify if GPS enable on device\nif(GPSService.isGPSProviderEnable(context) || GPSService.isNetworkProviderEnable(context)) {\nGPSSettingController gpsSettingController = new GPSSettingController(mMapView.getContext());\n\n}\n}else {\n\/\/ TODO: notify user when the state of the GPS resource is disabled. use one icon on action bar?\n}\n}","code_context_10":"public void applyGPSSetting() {\n\/\/ verify if GPS enable on device\nif(GPSService.isGPSProviderEnable(context) || GPSService.isNetworkProviderEnable(context)) {\nGPSSettingController gpsSettingController = new GPSSettingController(mMapView.getContext());\nBoolean showGPSLocation = gpsSettingController.getGPSLocationState();\nBoolean showGPSLocationOnCenter = gpsSettingController.getGPSCenterState();\nif (showGPSLocation != null)\nif (showGPSLocation) {\nMainActivity mainActivity = (MainActivity) context;\nGPSOverlayController gpsOverlayController = mainActivity.getMainController().getGpsOverlayController();\ngpsOverlayController.addGPSTrackerLayer();\ngpsOverlayController.setKeepOnCenter( ((showGPSLocationOnCenter != null)?(showGPSLocationOnCenter):(false)) );\n}\n}else {\n\/\/ TODO: notify user when the state of the GPS resource is disabled. use one icon on action bar?\n}\n}\n\npublic void applyGPSSetting() {\n\/\/ verify if GPS enable on device\nif(GPSService.isGPSProviderEnable(context) || GPSService.isNetworkProviderEnable(context)) {\nGPSSettingController gpsSettingController = new GPSSettingController(mMapView.getContext());\nBoolean showGPSLocation = gpsSettingController.getGPSLocationState();\nBoolean showGPSLocationOnCenter = gpsSettingController.getGPSCenterState();\nif (showGPSLocation != null)\nif (showGPSLocation) {\nMainActivity mainActivity = (MainActivity) context;\nGPSOverlayController gpsOverlayController = mainActivity.getMainController().getGpsOverlayController();\ngpsOverlayController.addGPSTrackerLayer();\ngpsOverlayController.setKeepOnCenter( ((showGPSLocationOnCenter != null)?(showGPSLocationOnCenter):(false)) );\n\nBoolean showGPSLocation = gpsSettingController.getGPSLocationState();\nBoolean showGPSLocationOnCenter = gpsSettingController.getGPSCenterState();\nif (showGPSLocation != null)\nif (showGPSLocation) {\nMainActivity mainActivity = (MainActivity) context;\nGPSOverlayController gpsOverlayController = mainActivity.getMainController().getGpsOverlayController();\ngpsOverlayController.addGPSTrackerLayer();\ngpsOverlayController.setKeepOnCenter( ((showGPSLocationOnCenter != null)?(showGPSLocationOnCenter):(false)) );\n}\n}else {\n\/\/ TODO: notify user when the state of the GPS resource is disabled. use one icon on action bar?\n}\n}","code_context_20":"public void applyGPSSetting() {\n\/\/ verify if GPS enable on device\nif(GPSService.isGPSProviderEnable(context) || GPSService.isNetworkProviderEnable(context)) {\nGPSSettingController gpsSettingController = new GPSSettingController(mMapView.getContext());\nBoolean showGPSLocation = gpsSettingController.getGPSLocationState();\nBoolean showGPSLocationOnCenter = gpsSettingController.getGPSCenterState();\nif (showGPSLocation != null)\nif (showGPSLocation) {\nMainActivity mainActivity = (MainActivity) context;\nGPSOverlayController gpsOverlayController = mainActivity.getMainController().getGpsOverlayController();\ngpsOverlayController.addGPSTrackerLayer();\ngpsOverlayController.setKeepOnCenter( ((showGPSLocationOnCenter != null)?(showGPSLocationOnCenter):(false)) );\n}\n}else {\n\/\/ TODO: notify user when the state of the GPS resource is disabled. use one icon on action bar?\n}\n}\n\npublic void applyGPSSetting() {\n\/\/ verify if GPS enable on device\nif(GPSService.isGPSProviderEnable(context) || GPSService.isNetworkProviderEnable(context)) {\nGPSSettingController gpsSettingController = new GPSSettingController(mMapView.getContext());\nBoolean showGPSLocation = gpsSettingController.getGPSLocationState();\nBoolean showGPSLocationOnCenter = gpsSettingController.getGPSCenterState();\nif (showGPSLocation != null)\nif (showGPSLocation) {\nMainActivity mainActivity = (MainActivity) context;\nGPSOverlayController gpsOverlayController = mainActivity.getMainController().getGpsOverlayController();\ngpsOverlayController.addGPSTrackerLayer();\ngpsOverlayController.setKeepOnCenter( ((showGPSLocationOnCenter != null)?(showGPSLocationOnCenter):(false)) );\n}\n}else {\n\/\/ TODO: notify user when the state of the GPS resource is disabled. use one icon on action bar?\n}\n}\n\npublic void applyGPSSetting() {\n\/\/ verify if GPS enable on device\nif(GPSService.isGPSProviderEnable(context) || GPSService.isNetworkProviderEnable(context)) {\nGPSSettingController gpsSettingController = new GPSSettingController(mMapView.getContext());\nBoolean showGPSLocation = gpsSettingController.getGPSLocationState();\nBoolean showGPSLocationOnCenter = gpsSettingController.getGPSCenterState();\nif (showGPSLocation != null)\nif (showGPSLocation) {\nMainActivity mainActivity = (MainActivity) context;\nGPSOverlayController gpsOverlayController = mainActivity.getMainController().getGpsOverlayController();\ngpsOverlayController.addGPSTrackerLayer();\ngpsOverlayController.setKeepOnCenter( ((showGPSLocationOnCenter != null)?(showGPSLocationOnCenter):(false)) );\n}\n}else {\n\/\/ TODO: notify user when the state of the GPS resource is disabled. use one icon on action bar?\n}\n}","label":[0,1,0,0]}
{"id":325,"original_code":"void tracksDropped(Point startPoint, Point dropPoint, List<Track> tracks) {\n            \/\/ This cast is horrid but we can't fix everything at once.\n            TrackPanel panel = ((TrackPanel) getParent());\n            List<MouseableRegion> regions = getMouseRegions();\n            if (regions.isEmpty()) {\n                \/\/ empty panel,  just add the tracks\n                panel.addTracks(tracks);\n            } else {\n                \/\/ Find the regions containing the startPoint and point\n                boolean before = true;\n                MouseableRegion dropRegion = null;\n                MouseableRegion startRegion = null;\n                for (MouseableRegion region : regions) {\n                    if (region.containsPoint(dropPoint.x, dropPoint.y)) {\n                        dropRegion = region;\n                        Rectangle bnds = dropRegion.getBounds();\n                        int dy1 = (dropPoint.y - bnds.y);\n                        int dy2 = bnds.height - dy1;\n                        before = dy1 < dy2;\n                    }\n                    if (region.containsPoint(startPoint.x, startPoint.y)) {\n                        startRegion = region;\n                    }\n                    if (dropRegion != null && startRegion != null) {\n                        break;\n                    }\n                }\n                Track dropTrack = null;\n                if (dropRegion != null) {\n                    Iterator<Track> tmp = dropRegion.getTracks().iterator();\n                    if (tmp.hasNext()) {\n                        dropTrack = tmp.next();\n                    }\n                }\n                panel.moveSelectedTracksTo(tracks, dropTrack, before);\n            }\n        }","code":"void tracksDropped(Point startPoint, Point dropPoint, List<Track> tracks) {\n           \n            TrackPanel panel = ((TrackPanel) getParent());\n            List<MouseableRegion> regions = getMouseRegions();\n            if (regions.isEmpty()) {\n               \n                panel.addTracks(tracks);\n            } else {\n               \n                boolean before = true;\n                MouseableRegion dropRegion = null;\n                MouseableRegion startRegion = null;\n                for (MouseableRegion region : regions) {\n                    if (region.containsPoint(dropPoint.x, dropPoint.y)) {\n                        dropRegion = region;\n                        Rectangle bnds = dropRegion.getBounds();\n                        int dy1 = (dropPoint.y - bnds.y);\n                        int dy2 = bnds.height - dy1;\n                        before = dy1 < dy2;\n                    }\n                    if (region.containsPoint(startPoint.x, startPoint.y)) {\n                        startRegion = region;\n                    }\n                    if (dropRegion != null && startRegion != null) {\n                        break;\n                    }\n                }\n                Track dropTrack = null;\n                if (dropRegion != null) {\n                    Iterator<Track> tmp = dropRegion.getTracks().iterator();\n                    if (tmp.hasNext()) {\n                        dropTrack = tmp.next();\n                    }\n                }\n                panel.moveSelectedTracksTo(tracks, dropTrack, before);\n            }\n        }","cleancode":"void tracksdropped(point startpoint, point droppoint, list<track> tracks) { trackpanel panel = ((trackpanel) getparent()); list<mouseableregion> regions = getmouseregions(); if (regions.isempty()) { panel.addtracks(tracks); } else { boolean before = true; mouseableregion dropregion = null; mouseableregion startregion = null; for (mouseableregion region : regions) { if (region.containspoint(droppoint.x, droppoint.y)) { dropregion = region; rectangle bnds = dropregion.getbounds(); int dy1 = (droppoint.y - bnds.y); int dy2 = bnds.height - dy1; before = dy1 < dy2; } if (region.containspoint(startpoint.x, startpoint.y)) { startregion = region; } if (dropregion != null && startregion != null) { break; } } track droptrack = null; if (dropregion != null) { iterator<track> tmp = dropregion.gettracks().iterator(); if (tmp.hasnext()) { droptrack = tmp.next(); } } panel.moveselectedtracksto(tracks, droptrack, before); } }","comment":"\/\/ this cast is horrid but we can't fix everything at once.\n\/\/ empty panel, just add the tracks\n\/\/ find the regions containing the startpoint and point","repo":"Karimi-Lab\/ALEA","code_context_2":"void tracksDropped(Point startPoint, Point dropPoint, List<Track> tracks) {\n\/\/ This cast is horrid but we can't fix everything at once.\nTrackPanel panel = ((TrackPanel) getParent());\nList<MouseableRegion> regions = getMouseRegions();\n\nList<MouseableRegion> regions = getMouseRegions();\nif (regions.isEmpty()) {\n\/\/ empty panel, just add the tracks\npanel.addTracks(tracks);\n} else {\n\npanel.addTracks(tracks);\n} else {\n\/\/ Find the regions containing the startPoint and point\nboolean before = true;\nMouseableRegion dropRegion = null;","code_context_10":"void tracksDropped(Point startPoint, Point dropPoint, List<Track> tracks) {\n\/\/ This cast is horrid but we can't fix everything at once.\nTrackPanel panel = ((TrackPanel) getParent());\nList<MouseableRegion> regions = getMouseRegions();\nif (regions.isEmpty()) {\n\/\/ empty panel, just add the tracks\npanel.addTracks(tracks);\n} else {\n\/\/ Find the regions containing the startPoint and point\nboolean before = true;\nMouseableRegion dropRegion = null;\nMouseableRegion startRegion = null;\n\nvoid tracksDropped(Point startPoint, Point dropPoint, List<Track> tracks) {\n\/\/ This cast is horrid but we can't fix everything at once.\nTrackPanel panel = ((TrackPanel) getParent());\nList<MouseableRegion> regions = getMouseRegions();\nif (regions.isEmpty()) {\n\/\/ empty panel, just add the tracks\npanel.addTracks(tracks);\n} else {\n\/\/ Find the regions containing the startPoint and point\nboolean before = true;\nMouseableRegion dropRegion = null;\nMouseableRegion startRegion = null;\nfor (MouseableRegion region : regions) {\nif (region.containsPoint(dropPoint.x, dropPoint.y)) {\ndropRegion = region;\nRectangle bnds = dropRegion.getBounds();\n\nvoid tracksDropped(Point startPoint, Point dropPoint, List<Track> tracks) {\n\/\/ This cast is horrid but we can't fix everything at once.\nTrackPanel panel = ((TrackPanel) getParent());\nList<MouseableRegion> regions = getMouseRegions();\nif (regions.isEmpty()) {\n\/\/ empty panel, just add the tracks\npanel.addTracks(tracks);\n} else {\n\/\/ Find the regions containing the startPoint and point\nboolean before = true;\nMouseableRegion dropRegion = null;\nMouseableRegion startRegion = null;\nfor (MouseableRegion region : regions) {\nif (region.containsPoint(dropPoint.x, dropPoint.y)) {\ndropRegion = region;\nRectangle bnds = dropRegion.getBounds();\nint dy1 = (dropPoint.y - bnds.y);\nint dy2 = bnds.height - dy1;\nbefore = dy1 < dy2;","code_context_20":"void tracksDropped(Point startPoint, Point dropPoint, List<Track> tracks) {\n\/\/ This cast is horrid but we can't fix everything at once.\nTrackPanel panel = ((TrackPanel) getParent());\nList<MouseableRegion> regions = getMouseRegions();\nif (regions.isEmpty()) {\n\/\/ empty panel, just add the tracks\npanel.addTracks(tracks);\n} else {\n\/\/ Find the regions containing the startPoint and point\nboolean before = true;\nMouseableRegion dropRegion = null;\nMouseableRegion startRegion = null;\nfor (MouseableRegion region : regions) {\nif (region.containsPoint(dropPoint.x, dropPoint.y)) {\ndropRegion = region;\nRectangle bnds = dropRegion.getBounds();\nint dy1 = (dropPoint.y - bnds.y);\nint dy2 = bnds.height - dy1;\nbefore = dy1 < dy2;\n}\nif (region.containsPoint(startPoint.x, startPoint.y)) {\nstartRegion = region;\n\nvoid tracksDropped(Point startPoint, Point dropPoint, List<Track> tracks) {\n\/\/ This cast is horrid but we can't fix everything at once.\nTrackPanel panel = ((TrackPanel) getParent());\nList<MouseableRegion> regions = getMouseRegions();\nif (regions.isEmpty()) {\n\/\/ empty panel, just add the tracks\npanel.addTracks(tracks);\n} else {\n\/\/ Find the regions containing the startPoint and point\nboolean before = true;\nMouseableRegion dropRegion = null;\nMouseableRegion startRegion = null;\nfor (MouseableRegion region : regions) {\nif (region.containsPoint(dropPoint.x, dropPoint.y)) {\ndropRegion = region;\nRectangle bnds = dropRegion.getBounds();\nint dy1 = (dropPoint.y - bnds.y);\nint dy2 = bnds.height - dy1;\nbefore = dy1 < dy2;\n}\nif (region.containsPoint(startPoint.x, startPoint.y)) {\nstartRegion = region;\n}\nif (dropRegion != null && startRegion != null) {\nbreak;\n}\n\nvoid tracksDropped(Point startPoint, Point dropPoint, List<Track> tracks) {\n\/\/ This cast is horrid but we can't fix everything at once.\nTrackPanel panel = ((TrackPanel) getParent());\nList<MouseableRegion> regions = getMouseRegions();\nif (regions.isEmpty()) {\n\/\/ empty panel, just add the tracks\npanel.addTracks(tracks);\n} else {\n\/\/ Find the regions containing the startPoint and point\nboolean before = true;\nMouseableRegion dropRegion = null;\nMouseableRegion startRegion = null;\nfor (MouseableRegion region : regions) {\nif (region.containsPoint(dropPoint.x, dropPoint.y)) {\ndropRegion = region;\nRectangle bnds = dropRegion.getBounds();\nint dy1 = (dropPoint.y - bnds.y);\nint dy2 = bnds.height - dy1;\nbefore = dy1 < dy2;\n}\nif (region.containsPoint(startPoint.x, startPoint.y)) {\nstartRegion = region;\n}\nif (dropRegion != null && startRegion != null) {\nbreak;\n}\n}\nTrack dropTrack = null;\nif (dropRegion != null) {","label":[1,0,0,0]}
{"id":343,"original_code":"@AfterMethod\n    public void cleanupResources() throws SQLException {\n        TEST_NUMBER++;\n        \/\/todo issue #232 fix increment topic partition name for tests on multi jvm\n        ALL_RESOURCES.cleanUpClusters();\n        DB_RESOURCE.executeResource(JDBCUtil.DROP_TABLE_SQL_RESOURCE);\n    }","code":"@AfterMethod\n    public void cleanupResources() throws SQLException {\n        TEST_NUMBER++;\n       \n        ALL_RESOURCES.cleanUpClusters();\n        DB_RESOURCE.executeResource(JDBCUtil.DROP_TABLE_SQL_RESOURCE);\n    }","cleancode":"@aftermethod public void cleanupresources() throws sqlexception { test_number++; all_resources.cleanupclusters(); db_resource.executeresource(jdbcutil.drop_table_sql_resource); }","comment":"\/\/todo issue #232 fix increment topic partition name for tests on multi jvm","repo":"MayerRoman\/Lagerta","code_context_2":"public void cleanupResources() throws SQLException {\nTEST_NUMBER++;\n\/\/todo issue #232 fix increment topic partition name for tests on multi jvm\nALL_RESOURCES.cleanUpClusters();\nDB_RESOURCE.executeResource(JDBCUtil.DROP_TABLE_SQL_RESOURCE);","code_context_10":"@AfterMethod\npublic void cleanupResources() throws SQLException {\nTEST_NUMBER++;\n\/\/todo issue #232 fix increment topic partition name for tests on multi jvm\nALL_RESOURCES.cleanUpClusters();\nDB_RESOURCE.executeResource(JDBCUtil.DROP_TABLE_SQL_RESOURCE);\n}","code_context_20":"@AfterMethod\npublic void cleanupResources() throws SQLException {\nTEST_NUMBER++;\n\/\/todo issue #232 fix increment topic partition name for tests on multi jvm\nALL_RESOURCES.cleanUpClusters();\nDB_RESOURCE.executeResource(JDBCUtil.DROP_TABLE_SQL_RESOURCE);\n}","label":[0,0,1,0]}
{"id":24925,"original_code":"private void scheduleCleanup() {\n        if (cleanupRegistration != null) {\n            \/\/ Already scheduled\n            return;\n        }\n        cleanupRegistration = ui.beforeClientResponse(ui, ignore -> {\n            cleanupRegistration = null;\n            pendingCleanup = false;\n            \/\/ TODO Avoid copying by using Iterator.remove()\n            properties.keySet().stream().filter(property -> !lastUsed.contains(property)).collect(Collectors.toList())\n                    .forEach(unused -> properties.remove(unused).unregister());\n        });\n    }","code":"private void scheduleCleanup() {\n        if (cleanupRegistration != null) {\n           \n            return;\n        }\n        cleanupRegistration = ui.beforeClientResponse(ui, ignore -> {\n            cleanupRegistration = null;\n            pendingCleanup = false;\n           \n            properties.keySet().stream().filter(property -> !lastUsed.contains(property)).collect(Collectors.toList())\n                    .forEach(unused -> properties.remove(unused).unregister());\n        });\n    }","cleancode":"private void schedulecleanup() { if (cleanupregistration != null) { return; } cleanupregistration = ui.beforeclientresponse(ui, ignore -> { cleanupregistration = null; pendingcleanup = false; properties.keyset().stream().filter(property -> !lastused.contains(property)).collect(collectors.tolist()) .foreach(unused -> properties.remove(unused).unregister()); }); }","comment":"\/\/ already scheduled\n\/\/ todo avoid copying by using iterator.remove()","repo":"Legioth\/reactivevaadin","code_context_2":"private void scheduleCleanup() {\nif (cleanupRegistration != null) {\n\/\/ Already scheduled\nreturn;\n}\n\ncleanupRegistration = null;\npendingCleanup = false;\n\/\/ TODO Avoid copying by using Iterator.remove()\nproperties.keySet().stream().filter(property -> !lastUsed.contains(property)).collect(Collectors.toList())\n.forEach(unused -> properties.remove(unused).unregister());","code_context_10":"private void scheduleCleanup() {\nif (cleanupRegistration != null) {\n\/\/ Already scheduled\nreturn;\n}\ncleanupRegistration = ui.beforeClientResponse(ui, ignore -> {\ncleanupRegistration = null;\npendingCleanup = false;\n\/\/ TODO Avoid copying by using Iterator.remove()\nproperties.keySet().stream().filter(property -> !lastUsed.contains(property)).collect(Collectors.toList())\n.forEach(unused -> properties.remove(unused).unregister());\n});\n}\n\nprivate void scheduleCleanup() {\nif (cleanupRegistration != null) {\n\/\/ Already scheduled\nreturn;\n}\ncleanupRegistration = ui.beforeClientResponse(ui, ignore -> {\ncleanupRegistration = null;\npendingCleanup = false;\n\/\/ TODO Avoid copying by using Iterator.remove()\nproperties.keySet().stream().filter(property -> !lastUsed.contains(property)).collect(Collectors.toList())\n.forEach(unused -> properties.remove(unused).unregister());\n});\n}","code_context_20":"private void scheduleCleanup() {\nif (cleanupRegistration != null) {\n\/\/ Already scheduled\nreturn;\n}\ncleanupRegistration = ui.beforeClientResponse(ui, ignore -> {\ncleanupRegistration = null;\npendingCleanup = false;\n\/\/ TODO Avoid copying by using Iterator.remove()\nproperties.keySet().stream().filter(property -> !lastUsed.contains(property)).collect(Collectors.toList())\n.forEach(unused -> properties.remove(unused).unregister());\n});\n}\n\nprivate void scheduleCleanup() {\nif (cleanupRegistration != null) {\n\/\/ Already scheduled\nreturn;\n}\ncleanupRegistration = ui.beforeClientResponse(ui, ignore -> {\ncleanupRegistration = null;\npendingCleanup = false;\n\/\/ TODO Avoid copying by using Iterator.remove()\nproperties.keySet().stream().filter(property -> !lastUsed.contains(property)).collect(Collectors.toList())\n.forEach(unused -> properties.remove(unused).unregister());\n});\n}","label":[0,1,0,0]}
{"id":24936,"original_code":"@Override\n    protected Path getPath(Canvas canvas, Paint paint) {\n        Path path = new Path();\n        String text = formatText();\n        if (text == null) {\n            return path;\n        }\n        \/\/ TODO: get path while TextPath is set.\n        if (setupFillPaint(paint, 1.0f, getBox(paint, text))) {\n            applyTextPropertiesToPaint(paint);\n            paint.getTextPath(text, 0, text.length(), 0, -paint.ascent(), path);\n            path.transform(mMatrix);\n        }\n        return path;\n    }","code":"@Override\n    protected Path getPath(Canvas canvas, Paint paint) {\n        Path path = new Path();\n        String text = formatText();\n        if (text == null) {\n            return path;\n        }\n       \n        if (setupFillPaint(paint, 1.0f, getBox(paint, text))) {\n            applyTextPropertiesToPaint(paint);\n            paint.getTextPath(text, 0, text.length(), 0, -paint.ascent(), path);\n            path.transform(mMatrix);\n        }\n        return path;\n    }","cleancode":"@override protected path getpath(canvas canvas, paint paint) { path path = new path(); string text = formattext(); if (text == null) { return path; } if (setupfillpaint(paint, 1.0f, getbox(paint, text))) { applytextpropertiestopaint(paint); paint.gettextpath(text, 0, text.length(), 0, -paint.ascent(), path); path.transform(mmatrix); } return path; }","comment":"\/\/ todo: get path while textpath is set.","repo":"L8RMedia\/exponent","code_context_2":"return path;\n}\n\/\/ TODO: get path while TextPath is set.\nif (setupFillPaint(paint, 1.0f, getBox(paint, text))) {\napplyTextPropertiesToPaint(paint);","code_context_10":"@Override\nprotected Path getPath(Canvas canvas, Paint paint) {\nPath path = new Path();\nString text = formatText();\nif (text == null) {\nreturn path;\n}\n\/\/ TODO: get path while TextPath is set.\nif (setupFillPaint(paint, 1.0f, getBox(paint, text))) {\napplyTextPropertiesToPaint(paint);\npaint.getTextPath(text, 0, text.length(), 0, -paint.ascent(), path);\npath.transform(mMatrix);\n}\nreturn path;\n}","code_context_20":"@Override\nprotected Path getPath(Canvas canvas, Paint paint) {\nPath path = new Path();\nString text = formatText();\nif (text == null) {\nreturn path;\n}\n\/\/ TODO: get path while TextPath is set.\nif (setupFillPaint(paint, 1.0f, getBox(paint, text))) {\napplyTextPropertiesToPaint(paint);\npaint.getTextPath(text, 0, text.length(), 0, -paint.ascent(), path);\npath.transform(mMatrix);\n}\nreturn path;\n}","label":[0,1,0,0]}
{"id":8573,"original_code":"public void translate() {\n        \/\/TODO: translate code\n    }","code":"public void translate() {\n       \n    }","cleancode":"public void translate() { }","comment":"\/\/todo: translate code","repo":"JC-Bodoque\/geometric-transformer","code_context_2":"public void translate() {\n\/\/TODO: translate code\n}","code_context_10":"public void translate() {\n\/\/TODO: translate code\n}","code_context_20":"public void translate() {\n\/\/TODO: translate code\n}","label":[0,1,0,0]}
{"id":636,"original_code":"@Override\n    public <Q extends Facet> Q getFacet(final Class<Q> facetType) {\n        final Q facet = super.getFacet(facetType);\n        Q noopFacet = null;\n        if (isNotANoopFacet(facet)) {\n            return facet;\n        } else {\n            noopFacet = facet;\n        }\n        if (interfaces() != null) {\n            final List<ObjectSpecification> interfaces = interfaces();\n            for (int i = 0; i < interfaces.size(); i++) {\n                final ObjectSpecification interfaceSpec = interfaces.get(i);\n                if (interfaceSpec == null) {\n                    \/\/ HACK: shouldn't happen, but occurring on occasion when\n                    \/\/ running\n                    \/\/ XATs under JUnit4. Some sort of race condition?\n                    continue;\n                }\n                final Q interfaceFacet = interfaceSpec.getFacet(facetType);\n                if (isNotANoopFacet(interfaceFacet)) {\n                    return interfaceFacet;\n                } else {\n                    if (noopFacet == null) {\n                        noopFacet = interfaceFacet;\n                    }\n                }\n            }\n        }\n        \/\/ search up the inheritance hierarchy\n        final ObjectSpecification superSpec = superclass();\n        if (superSpec != null) {\n            final Q superClassFacet = superSpec.getFacet(facetType);\n            if (isNotANoopFacet(superClassFacet)) {\n                return superClassFacet;\n            }\n        }\n        return noopFacet;\n    }","code":"@Override\n    public <Q extends Facet> Q getFacet(final Class<Q> facetType) {\n        final Q facet = super.getFacet(facetType);\n        Q noopFacet = null;\n        if (isNotANoopFacet(facet)) {\n            return facet;\n        } else {\n            noopFacet = facet;\n        }\n        if (interfaces() != null) {\n            final List<ObjectSpecification> interfaces = interfaces();\n            for (int i = 0; i < interfaces.size(); i++) {\n                final ObjectSpecification interfaceSpec = interfaces.get(i);\n                if (interfaceSpec == null) {\n                   \n                   \n                   \n                    continue;\n                }\n                final Q interfaceFacet = interfaceSpec.getFacet(facetType);\n                if (isNotANoopFacet(interfaceFacet)) {\n                    return interfaceFacet;\n                } else {\n                    if (noopFacet == null) {\n                        noopFacet = interfaceFacet;\n                    }\n                }\n            }\n        }\n       \n        final ObjectSpecification superSpec = superclass();\n        if (superSpec != null) {\n            final Q superClassFacet = superSpec.getFacet(facetType);\n            if (isNotANoopFacet(superClassFacet)) {\n                return superClassFacet;\n            }\n        }\n        return noopFacet;\n    }","cleancode":"@override public <q extends facet> q getfacet(final class<q> facettype) { final q facet = super.getfacet(facettype); q noopfacet = null; if (isnotanoopfacet(facet)) { return facet; } else { noopfacet = facet; } if (interfaces() != null) { final list<objectspecification> interfaces = interfaces(); for (int i = 0; i < interfaces.size(); i++) { final objectspecification interfacespec = interfaces.get(i); if (interfacespec == null) { continue; } final q interfacefacet = interfacespec.getfacet(facettype); if (isnotanoopfacet(interfacefacet)) { return interfacefacet; } else { if (noopfacet == null) { noopfacet = interfacefacet; } } } } final objectspecification superspec = superclass(); if (superspec != null) { final q superclassfacet = superspec.getfacet(facettype); if (isnotanoopfacet(superclassfacet)) { return superclassfacet; } } return noopfacet; }","comment":"\/\/endregion \/\/region > facet handling\n\/\/ hack: shouldn't happen, but occurring on occasion when \/\/ running \/\/ xats under junit4. some sort of race condition?\n\/\/ search up the inheritance hierarchy","repo":"K-Rhen\/isis","code_context_2":"@Override\npublic <Q extends Facet> Q getFacet(final Class<Q> facetType) {\nfinal Q facet = super.getFacet(facetType);\nQ noopFacet = null;\nif (isNotANoopFacet(facet)) {\nreturn facet;\n} else {\nnoopFacet = facet;\n}\nif (interfaces() != null) {\nfinal List<ObjectSpecification> interfaces = interfaces();\nfor (int i = 0; i < interfaces.size(); i++) {\nfinal ObjectSpecification interfaceSpec = interfaces.get(i);\nif (interfaceSpec == null) {\n\/\/ HACK: shouldn't happen, but occurring on occasion when\n\/\/ running\n\/\/ XATs under JUnit4. Some sort of race condition?\ncontinue;\n}\nfinal Q interfaceFacet = interfaceSpec.getFacet(facetType);\nif (isNotANoopFacet(interfaceFacet)) {\nreturn interfaceFacet;\n} else {\nif (noopFacet == null) {\nnoopFacet = interfaceFacet;\n}\n}\n}\n}\n\/\/ search up the inheritance hierarchy\nfinal ObjectSpecification superSpec = superclass();\nif (superSpec != null) {\nfinal Q superClassFacet = superSpec.getFacet(facetType);\nif (isNotANoopFacet(superClassFacet)) {\nreturn superClassFacet;\n}\n}\nreturn noopFacet;\n}\n\nfinal ObjectSpecification interfaceSpec = interfaces.get(i);\nif (interfaceSpec == null) {\n\/\/ HACK: shouldn't happen, but occurring on occasion when\n\/\/ running\n\/\/ XATs under JUnit4. Some sort of race condition?\ncontinue;\n}\n\n}\n}\n\/\/ search up the inheritance hierarchy\nfinal ObjectSpecification superSpec = superclass();\nif (superSpec != null) {","code_context_10":"@Override\npublic <Q extends Facet> Q getFacet(final Class<Q> facetType) {\nfinal Q facet = super.getFacet(facetType);\nQ noopFacet = null;\nif (isNotANoopFacet(facet)) {\nreturn facet;\n} else {\nnoopFacet = facet;\n}\nif (interfaces() != null) {\nfinal List<ObjectSpecification> interfaces = interfaces();\nfor (int i = 0; i < interfaces.size(); i++) {\nfinal ObjectSpecification interfaceSpec = interfaces.get(i);\nif (interfaceSpec == null) {\n\/\/ HACK: shouldn't happen, but occurring on occasion when\n\/\/ running\n\/\/ XATs under JUnit4. Some sort of race condition?\ncontinue;\n}\nfinal Q interfaceFacet = interfaceSpec.getFacet(facetType);\nif (isNotANoopFacet(interfaceFacet)) {\nreturn interfaceFacet;\n} else {\nif (noopFacet == null) {\nnoopFacet = interfaceFacet;\n}\n}\n}\n}\n\/\/ search up the inheritance hierarchy\nfinal ObjectSpecification superSpec = superclass();\nif (superSpec != null) {\nfinal Q superClassFacet = superSpec.getFacet(facetType);\nif (isNotANoopFacet(superClassFacet)) {\nreturn superClassFacet;\n}\n}\nreturn noopFacet;\n}\n\nif (isNotANoopFacet(facet)) {\nreturn facet;\n} else {\nnoopFacet = facet;\n}\nif (interfaces() != null) {\nfinal List<ObjectSpecification> interfaces = interfaces();\nfor (int i = 0; i < interfaces.size(); i++) {\nfinal ObjectSpecification interfaceSpec = interfaces.get(i);\nif (interfaceSpec == null) {\n\/\/ HACK: shouldn't happen, but occurring on occasion when\n\/\/ running\n\/\/ XATs under JUnit4. Some sort of race condition?\ncontinue;\n}\nfinal Q interfaceFacet = interfaceSpec.getFacet(facetType);\nif (isNotANoopFacet(interfaceFacet)) {\nreturn interfaceFacet;\n} else {\nif (noopFacet == null) {\nnoopFacet = interfaceFacet;\n}\n}\n\nfinal Q interfaceFacet = interfaceSpec.getFacet(facetType);\nif (isNotANoopFacet(interfaceFacet)) {\nreturn interfaceFacet;\n} else {\nif (noopFacet == null) {\nnoopFacet = interfaceFacet;\n}\n}\n}\n}\n\/\/ search up the inheritance hierarchy\nfinal ObjectSpecification superSpec = superclass();\nif (superSpec != null) {\nfinal Q superClassFacet = superSpec.getFacet(facetType);\nif (isNotANoopFacet(superClassFacet)) {\nreturn superClassFacet;\n}\n}\nreturn noopFacet;\n}","code_context_20":"@Override\npublic <Q extends Facet> Q getFacet(final Class<Q> facetType) {\nfinal Q facet = super.getFacet(facetType);\nQ noopFacet = null;\nif (isNotANoopFacet(facet)) {\nreturn facet;\n} else {\nnoopFacet = facet;\n}\nif (interfaces() != null) {\nfinal List<ObjectSpecification> interfaces = interfaces();\nfor (int i = 0; i < interfaces.size(); i++) {\nfinal ObjectSpecification interfaceSpec = interfaces.get(i);\nif (interfaceSpec == null) {\n\/\/ HACK: shouldn't happen, but occurring on occasion when\n\/\/ running\n\/\/ XATs under JUnit4. Some sort of race condition?\ncontinue;\n}\nfinal Q interfaceFacet = interfaceSpec.getFacet(facetType);\nif (isNotANoopFacet(interfaceFacet)) {\nreturn interfaceFacet;\n} else {\nif (noopFacet == null) {\nnoopFacet = interfaceFacet;\n}\n}\n}\n}\n\/\/ search up the inheritance hierarchy\nfinal ObjectSpecification superSpec = superclass();\nif (superSpec != null) {\nfinal Q superClassFacet = superSpec.getFacet(facetType);\nif (isNotANoopFacet(superClassFacet)) {\nreturn superClassFacet;\n}\n}\nreturn noopFacet;\n}\n\n@Override\npublic <Q extends Facet> Q getFacet(final Class<Q> facetType) {\nfinal Q facet = super.getFacet(facetType);\nQ noopFacet = null;\nif (isNotANoopFacet(facet)) {\nreturn facet;\n} else {\nnoopFacet = facet;\n}\nif (interfaces() != null) {\nfinal List<ObjectSpecification> interfaces = interfaces();\nfor (int i = 0; i < interfaces.size(); i++) {\nfinal ObjectSpecification interfaceSpec = interfaces.get(i);\nif (interfaceSpec == null) {\n\/\/ HACK: shouldn't happen, but occurring on occasion when\n\/\/ running\n\/\/ XATs under JUnit4. Some sort of race condition?\ncontinue;\n}\nfinal Q interfaceFacet = interfaceSpec.getFacet(facetType);\nif (isNotANoopFacet(interfaceFacet)) {\nreturn interfaceFacet;\n} else {\nif (noopFacet == null) {\nnoopFacet = interfaceFacet;\n}\n}\n}\n}\n\/\/ search up the inheritance hierarchy\nfinal ObjectSpecification superSpec = superclass();\nif (superSpec != null) {\nfinal Q superClassFacet = superSpec.getFacet(facetType);\nif (isNotANoopFacet(superClassFacet)) {\nreturn superClassFacet;\n}\n}\n\nif (interfaces() != null) {\nfinal List<ObjectSpecification> interfaces = interfaces();\nfor (int i = 0; i < interfaces.size(); i++) {\nfinal ObjectSpecification interfaceSpec = interfaces.get(i);\nif (interfaceSpec == null) {\n\/\/ HACK: shouldn't happen, but occurring on occasion when\n\/\/ running\n\/\/ XATs under JUnit4. Some sort of race condition?\ncontinue;\n}\nfinal Q interfaceFacet = interfaceSpec.getFacet(facetType);\nif (isNotANoopFacet(interfaceFacet)) {\nreturn interfaceFacet;\n} else {\nif (noopFacet == null) {\nnoopFacet = interfaceFacet;\n}\n}\n}\n}\n\/\/ search up the inheritance hierarchy\nfinal ObjectSpecification superSpec = superclass();\nif (superSpec != null) {\nfinal Q superClassFacet = superSpec.getFacet(facetType);\nif (isNotANoopFacet(superClassFacet)) {\nreturn superClassFacet;\n}\n}\nreturn noopFacet;\n}","label":[1,0,0,0]}
{"id":643,"original_code":"protected void blast(T message) {\n\t\tlogger.debug(\"blast called for message: \" + message);\n\t\tMap<String,Object> filter = KStringUtil.toMap(message.getFilter());\n\t\tLong affinityAppId = null;\n\t\tMap<String, Object> data = createPayLoadData(message);\n\t\tList<D> deviceList = getDeviceList(filter, affinityAppId, message.isSandbox());\n\t\tint sendCount = 0;\n\t\tList<String> blastErrors = new ArrayList<String>();\n\t\tList<String> deviceIdList = new ArrayList<String>();\n\t\tfor (D device : deviceList) {\n\t\t\tlogger.debug(\"blast push device: \" + device);\n\t\t\tKPushService.Platform platform = getPushService().getPushPlatform(device.getPlatformName(), device.isSandbox());\n\t\t\tString endpoint = device.getPushEndpoint();\n\t\t\tif (platform == null || endpoint == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tgetPushService().publish(platform, endpoint, message.getMessage(), data);\n\t\t\t\tlogger.debug(\"\\n--------------------------\\n\"\n\t\t\t\t\t\t+ \"\\npush message:\"\n\t\t\t\t\t\t+ \"\\nplatform: \" + platform\n\t\t\t\t\t\t+ \"\\nendpoint: \" + endpoint\n\t\t\t\t\t\t+ \"\\nmessage: \" + message\n\t\t\t\t\t\t+ \"\\ndata: \" + data \n\t\t\t\t\t\t+ \"\\n--------------------------\\n\"\n\t\t\t\t);\n\t\t\t\tsendCount += 1;\n\t\t\t\tdeviceIdList.add(device.getId().toString());\n\t\t\t} catch (Exception e) {\n\t\t\t\tblastErrors.add(e.getMessage());\n\t\t\t}\n\t\t}\n\t\tlogger.debug(\"blast: updating sendCount: \" + sendCount); \n\t\tif (blastErrors.size() > 0) {\n\t\t\tlogger.warn(\"Broadcast blast errors\" + KStringUtil.join(blastErrors, \"\\n\\n\"));\n\t\t}\n\t\tmessage.setDeviceCount(sendCount);\n\t\t\/\/ FIXME: this won't save since it's a blob type and underlying framework needs to support it\n\t\tmessage.setDevices(KStringUtil.join(deviceIdList,\",\").getBytes());\n\t\tupdate(message);\n\t}","code":"protected void blast(T message) {\n\t\tlogger.debug(\"blast called for message: \" + message);\n\t\tMap<String,Object> filter = KStringUtil.toMap(message.getFilter());\n\t\tLong affinityAppId = null;\n\t\tMap<String, Object> data = createPayLoadData(message);\n\t\tList<D> deviceList = getDeviceList(filter, affinityAppId, message.isSandbox());\n\t\tint sendCount = 0;\n\t\tList<String> blastErrors = new ArrayList<String>();\n\t\tList<String> deviceIdList = new ArrayList<String>();\n\t\tfor (D device : deviceList) {\n\t\t\tlogger.debug(\"blast push device: \" + device);\n\t\t\tKPushService.Platform platform = getPushService().getPushPlatform(device.getPlatformName(), device.isSandbox());\n\t\t\tString endpoint = device.getPushEndpoint();\n\t\t\tif (platform == null || endpoint == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tgetPushService().publish(platform, endpoint, message.getMessage(), data);\n\t\t\t\tlogger.debug(\"\\n--------------------------\\n\"\n\t\t\t\t\t\t+ \"\\npush message:\"\n\t\t\t\t\t\t+ \"\\nplatform: \" + platform\n\t\t\t\t\t\t+ \"\\nendpoint: \" + endpoint\n\t\t\t\t\t\t+ \"\\nmessage: \" + message\n\t\t\t\t\t\t+ \"\\ndata: \" + data \n\t\t\t\t\t\t+ \"\\n--------------------------\\n\"\n\t\t\t\t);\n\t\t\t\tsendCount += 1;\n\t\t\t\tdeviceIdList.add(device.getId().toString());\n\t\t\t} catch (Exception e) {\n\t\t\t\tblastErrors.add(e.getMessage());\n\t\t\t}\n\t\t}\n\t\tlogger.debug(\"blast: updating sendCount: \" + sendCount); \n\t\tif (blastErrors.size() > 0) {\n\t\t\tlogger.warn(\"Broadcast blast errors\" + KStringUtil.join(blastErrors, \"\\n\\n\"));\n\t\t}\n\t\tmessage.setDeviceCount(sendCount);\n\t\n\t\tmessage.setDevices(KStringUtil.join(deviceIdList,\",\").getBytes());\n\t\tupdate(message);\n\t}","cleancode":"protected void blast(t message) { logger.debug(\"blast called for message: \" + message); map<string,object> filter = kstringutil.tomap(message.getfilter()); long affinityappid = null; map<string, object> data = createpayloaddata(message); list<d> devicelist = getdevicelist(filter, affinityappid, message.issandbox()); int sendcount = 0; list<string> blasterrors = new arraylist<string>(); list<string> deviceidlist = new arraylist<string>(); for (d device : devicelist) { logger.debug(\"blast push device: \" + device); kpushservice.platform platform = getpushservice().getpushplatform(device.getplatformname(), device.issandbox()); string endpoint = device.getpushendpoint(); if (platform == null || endpoint == null) { continue; } try { getpushservice().publish(platform, endpoint, message.getmessage(), data); logger.debug(\"\\n--------------------------\\n\" + \"\\npush message:\" + \"\\nplatform: \" + platform + \"\\nendpoint: \" + endpoint + \"\\nmessage: \" + message + \"\\ndata: \" + data + \"\\n--------------------------\\n\" ); sendcount += 1; deviceidlist.add(device.getid().tostring()); } catch (exception e) { blasterrors.add(e.getmessage()); } } logger.debug(\"blast: updating sendcount: \" + sendcount); if (blasterrors.size() > 0) { logger.warn(\"broadcast blast errors\" + kstringutil.join(blasterrors, \"\\n\\n\")); } message.setdevicecount(sendcount); message.setdevices(kstringutil.join(deviceidlist,\",\").getbytes()); update(message); }","comment":"\/\/ ----------------------------------------------------------------------------\n\/\/ fixme: this won't save since it's a blob type and underlying framework needs to support it","repo":"LinuxTek\/kona-app-model","code_context_2":"protected void blast(T message) {\nlogger.debug(\"blast called for message: \" + message);\nMap<String,Object> filter = KStringUtil.toMap(message.getFilter());\nLong affinityAppId = null;\nMap<String, Object> data = createPayLoadData(message);\nList<D> deviceList = getDeviceList(filter, affinityAppId, message.isSandbox());\nint sendCount = 0;\nList<String> blastErrors = new ArrayList<String>();\nList<String> deviceIdList = new ArrayList<String>();\nfor (D device : deviceList) {\nlogger.debug(\"blast push device: \" + device);\nKPushService.Platform platform = getPushService().getPushPlatform(device.getPlatformName(), device.isSandbox());\nString endpoint = device.getPushEndpoint();\nif (platform == null || endpoint == null) {\ncontinue;\n}\ntry {\ngetPushService().publish(platform, endpoint, message.getMessage(), data);\nlogger.debug(\"\\n--------------------------\\n\"\n+ \"\\npush message:\"\n+ \"\\nplatform: \" + platform\n+ \"\\nendpoint: \" + endpoint\n+ \"\\nmessage: \" + message\n+ \"\\ndata: \" + data\n+ \"\\n--------------------------\\n\"\n);\nsendCount += 1;\ndeviceIdList.add(device.getId().toString());\n} catch (Exception e) {\nblastErrors.add(e.getMessage());\n}\n}\nlogger.debug(\"blast: updating sendCount: \" + sendCount);\nif (blastErrors.size() > 0) {\nlogger.warn(\"Broadcast blast errors\" + KStringUtil.join(blastErrors, \"\\n\\n\"));\n}\nmessage.setDeviceCount(sendCount);\n\/\/ FIXME: this won't save since it's a blob type and underlying framework needs to support it\nmessage.setDevices(KStringUtil.join(deviceIdList,\",\").getBytes());\nupdate(message);\n}\n\n}\nmessage.setDeviceCount(sendCount);\n\/\/ FIXME: this won't save since it's a blob type and underlying framework needs to support it\nmessage.setDevices(KStringUtil.join(deviceIdList,\",\").getBytes());\nupdate(message);","code_context_10":"protected void blast(T message) {\nlogger.debug(\"blast called for message: \" + message);\nMap<String,Object> filter = KStringUtil.toMap(message.getFilter());\nLong affinityAppId = null;\nMap<String, Object> data = createPayLoadData(message);\nList<D> deviceList = getDeviceList(filter, affinityAppId, message.isSandbox());\nint sendCount = 0;\nList<String> blastErrors = new ArrayList<String>();\nList<String> deviceIdList = new ArrayList<String>();\nfor (D device : deviceList) {\nlogger.debug(\"blast push device: \" + device);\nKPushService.Platform platform = getPushService().getPushPlatform(device.getPlatformName(), device.isSandbox());\nString endpoint = device.getPushEndpoint();\nif (platform == null || endpoint == null) {\ncontinue;\n}\ntry {\ngetPushService().publish(platform, endpoint, message.getMessage(), data);\nlogger.debug(\"\\n--------------------------\\n\"\n+ \"\\npush message:\"\n+ \"\\nplatform: \" + platform\n+ \"\\nendpoint: \" + endpoint\n+ \"\\nmessage: \" + message\n+ \"\\ndata: \" + data\n+ \"\\n--------------------------\\n\"\n);\nsendCount += 1;\ndeviceIdList.add(device.getId().toString());\n} catch (Exception e) {\nblastErrors.add(e.getMessage());\n}\n}\nlogger.debug(\"blast: updating sendCount: \" + sendCount);\nif (blastErrors.size() > 0) {\nlogger.warn(\"Broadcast blast errors\" + KStringUtil.join(blastErrors, \"\\n\\n\"));\n}\nmessage.setDeviceCount(sendCount);\n\/\/ FIXME: this won't save since it's a blob type and underlying framework needs to support it\nmessage.setDevices(KStringUtil.join(deviceIdList,\",\").getBytes());\nupdate(message);\n}\n\ndeviceIdList.add(device.getId().toString());\n} catch (Exception e) {\nblastErrors.add(e.getMessage());\n}\n}\nlogger.debug(\"blast: updating sendCount: \" + sendCount);\nif (blastErrors.size() > 0) {\nlogger.warn(\"Broadcast blast errors\" + KStringUtil.join(blastErrors, \"\\n\\n\"));\n}\nmessage.setDeviceCount(sendCount);\n\/\/ FIXME: this won't save since it's a blob type and underlying framework needs to support it\nmessage.setDevices(KStringUtil.join(deviceIdList,\",\").getBytes());\nupdate(message);\n}","code_context_20":"protected void blast(T message) {\nlogger.debug(\"blast called for message: \" + message);\nMap<String,Object> filter = KStringUtil.toMap(message.getFilter());\nLong affinityAppId = null;\nMap<String, Object> data = createPayLoadData(message);\nList<D> deviceList = getDeviceList(filter, affinityAppId, message.isSandbox());\nint sendCount = 0;\nList<String> blastErrors = new ArrayList<String>();\nList<String> deviceIdList = new ArrayList<String>();\nfor (D device : deviceList) {\nlogger.debug(\"blast push device: \" + device);\nKPushService.Platform platform = getPushService().getPushPlatform(device.getPlatformName(), device.isSandbox());\nString endpoint = device.getPushEndpoint();\nif (platform == null || endpoint == null) {\ncontinue;\n}\ntry {\ngetPushService().publish(platform, endpoint, message.getMessage(), data);\nlogger.debug(\"\\n--------------------------\\n\"\n+ \"\\npush message:\"\n+ \"\\nplatform: \" + platform\n+ \"\\nendpoint: \" + endpoint\n+ \"\\nmessage: \" + message\n+ \"\\ndata: \" + data\n+ \"\\n--------------------------\\n\"\n);\nsendCount += 1;\ndeviceIdList.add(device.getId().toString());\n} catch (Exception e) {\nblastErrors.add(e.getMessage());\n}\n}\nlogger.debug(\"blast: updating sendCount: \" + sendCount);\nif (blastErrors.size() > 0) {\nlogger.warn(\"Broadcast blast errors\" + KStringUtil.join(blastErrors, \"\\n\\n\"));\n}\nmessage.setDeviceCount(sendCount);\n\/\/ FIXME: this won't save since it's a blob type and underlying framework needs to support it\nmessage.setDevices(KStringUtil.join(deviceIdList,\",\").getBytes());\nupdate(message);\n}\n\ngetPushService().publish(platform, endpoint, message.getMessage(), data);\nlogger.debug(\"\\n--------------------------\\n\"\n+ \"\\npush message:\"\n+ \"\\nplatform: \" + platform\n+ \"\\nendpoint: \" + endpoint\n+ \"\\nmessage: \" + message\n+ \"\\ndata: \" + data\n+ \"\\n--------------------------\\n\"\n);\nsendCount += 1;\ndeviceIdList.add(device.getId().toString());\n} catch (Exception e) {\nblastErrors.add(e.getMessage());\n}\n}\nlogger.debug(\"blast: updating sendCount: \" + sendCount);\nif (blastErrors.size() > 0) {\nlogger.warn(\"Broadcast blast errors\" + KStringUtil.join(blastErrors, \"\\n\\n\"));\n}\nmessage.setDeviceCount(sendCount);\n\/\/ FIXME: this won't save since it's a blob type and underlying framework needs to support it\nmessage.setDevices(KStringUtil.join(deviceIdList,\",\").getBytes());\nupdate(message);\n}","label":[0,0,1,0]}
{"id":17067,"original_code":"protected void closeLayout( )\n\t{\n\t\t\/\/TODO support specified height\/width\/alignment\n\t\tif ( root != null )\n\t\t{\n\t\t\troot.setContentHeight( childHeight );\n\t\t\tIStyle areaStyle = root.getStyle( );\n\t\t\tint width = getCurrentIP( )\n\t\t\t\t\t+ getOffsetX( )\n\t\t\t\t\t+ getDimensionValue( areaStyle\n\t\t\t\t\t\t\t.getProperty( StyleConstants.STYLE_PADDING_RIGHT ) )\n\t\t\t\t\t+ getDimensionValue( areaStyle\n\t\t\t\t\t\t\t.getProperty( StyleConstants.STYLE_BORDER_RIGHT_WIDTH ) );\n\t\t\troot.setWidth( width );\n\t\t\tint height = 0;\n\t\t\tIterator iter = root.getChildren( );\n\t\t\twhile(iter.hasNext())\n\t\t\t{\n\t\t\t\tAbstractArea child = (AbstractArea)iter.next( );\n\t\t\t\theight = Math.max( height, child.getAllocatedHeight( ));\n\t\t\t}\n\t\t\troot.setContentHeight( height );\n\t\t}\n\t\t\/\/FIXME verticalAlign may effect the root height.\n\t\tverticalAlign();\n\t}","code":"protected void closeLayout( )\n\t{\n\t\n\t\tif ( root != null )\n\t\t{\n\t\t\troot.setContentHeight( childHeight );\n\t\t\tIStyle areaStyle = root.getStyle( );\n\t\t\tint width = getCurrentIP( )\n\t\t\t\t\t+ getOffsetX( )\n\t\t\t\t\t+ getDimensionValue( areaStyle\n\t\t\t\t\t\t\t.getProperty( StyleConstants.STYLE_PADDING_RIGHT ) )\n\t\t\t\t\t+ getDimensionValue( areaStyle\n\t\t\t\t\t\t\t.getProperty( StyleConstants.STYLE_BORDER_RIGHT_WIDTH ) );\n\t\t\troot.setWidth( width );\n\t\t\tint height = 0;\n\t\t\tIterator iter = root.getChildren( );\n\t\t\twhile(iter.hasNext())\n\t\t\t{\n\t\t\t\tAbstractArea child = (AbstractArea)iter.next( );\n\t\t\t\theight = Math.max( height, child.getAllocatedHeight( ));\n\t\t\t}\n\t\t\troot.setContentHeight( height );\n\t\t}\n\t\n\t\tverticalAlign();\n\t}","cleancode":"protected void closelayout( ) { if ( root != null ) { root.setcontentheight( childheight ); istyle areastyle = root.getstyle( ); int width = getcurrentip( ) + getoffsetx( ) + getdimensionvalue( areastyle .getproperty( styleconstants.style_padding_right ) ) + getdimensionvalue( areastyle .getproperty( styleconstants.style_border_right_width ) ); root.setwidth( width ); int height = 0; iterator iter = root.getchildren( ); while(iter.hasnext()) { abstractarea child = (abstractarea)iter.next( ); height = math.max( height, child.getallocatedheight( )); } root.setcontentheight( height ); } verticalalign(); }","comment":"\/\/todo support specified height\/width\/alignment\n\/\/fixme verticalalign may effect the root height.","repo":"JamesCao2048\/BlizzardData","code_context_2":"protected void closeLayout( )\n{\n\/\/TODO support specified height\/width\/alignment\nif ( root != null )\n{\n\nroot.setContentHeight( height );\n}\n\/\/FIXME verticalAlign may effect the root height.\nverticalAlign();\n}","code_context_10":"protected void closeLayout( )\n{\n\/\/TODO support specified height\/width\/alignment\nif ( root != null )\n{\nroot.setContentHeight( childHeight );\nIStyle areaStyle = root.getStyle( );\nint width = getCurrentIP( )\n+ getOffsetX( )\n+ getDimensionValue( areaStyle\n.getProperty( StyleConstants.STYLE_PADDING_RIGHT ) )\n+ getDimensionValue( areaStyle\n.getProperty( StyleConstants.STYLE_BORDER_RIGHT_WIDTH ) );\n\nroot.setWidth( width );\nint height = 0;\nIterator iter = root.getChildren( );\nwhile(iter.hasNext())\n{\nAbstractArea child = (AbstractArea)iter.next( );\nheight = Math.max( height, child.getAllocatedHeight( ));\n}\nroot.setContentHeight( height );\n}\n\/\/FIXME verticalAlign may effect the root height.\nverticalAlign();\n}","code_context_20":"protected void closeLayout( )\n{\n\/\/TODO support specified height\/width\/alignment\nif ( root != null )\n{\nroot.setContentHeight( childHeight );\nIStyle areaStyle = root.getStyle( );\nint width = getCurrentIP( )\n+ getOffsetX( )\n+ getDimensionValue( areaStyle\n.getProperty( StyleConstants.STYLE_PADDING_RIGHT ) )\n+ getDimensionValue( areaStyle\n.getProperty( StyleConstants.STYLE_BORDER_RIGHT_WIDTH ) );\nroot.setWidth( width );\nint height = 0;\nIterator iter = root.getChildren( );\nwhile(iter.hasNext())\n{\nAbstractArea child = (AbstractArea)iter.next( );\nheight = Math.max( height, child.getAllocatedHeight( ));\n}\nroot.setContentHeight( height );\n}\n\nif ( root != null )\n{\nroot.setContentHeight( childHeight );\nIStyle areaStyle = root.getStyle( );\nint width = getCurrentIP( )\n+ getOffsetX( )\n+ getDimensionValue( areaStyle\n.getProperty( StyleConstants.STYLE_PADDING_RIGHT ) )\n+ getDimensionValue( areaStyle\n.getProperty( StyleConstants.STYLE_BORDER_RIGHT_WIDTH ) );\nroot.setWidth( width );\nint height = 0;\nIterator iter = root.getChildren( );\nwhile(iter.hasNext())\n{\nAbstractArea child = (AbstractArea)iter.next( );\nheight = Math.max( height, child.getAllocatedHeight( ));\n}\nroot.setContentHeight( height );\n}\n\/\/FIXME verticalAlign may effect the root height.\nverticalAlign();\n}","label":[0,1,1,0]}
{"id":8889,"original_code":"private void performEnableScreen() {\n        synchronized (mGlobalLock) {\n            if (DEBUG_BOOT) Slog.i(TAG_WM, \"performEnableScreen: mDisplayEnabled=\" + mDisplayEnabled\n                    + \" mForceDisplayEnabled=\" + mForceDisplayEnabled\n                    + \" mShowingBootMessages=\" + mShowingBootMessages\n                    + \" mSystemBooted=\" + mSystemBooted\n                    + \" mOnlyCore=\" + mOnlyCore,\n                    new RuntimeException(\"here\").fillInStackTrace());\n            if (mDisplayEnabled) {\n                return;\n            }\n            if (!mSystemBooted && !mShowingBootMessages) {\n                return;\n            }\n            if (!mShowingBootMessages && !mPolicy.canDismissBootAnimation()) {\n                return;\n            }\n            \/\/ Don't enable the screen until all existing windows have been drawn.\n            if (!mForceDisplayEnabled\n                    \/\/ TODO(multidisplay): Expand to all displays?\n                    && getDefaultDisplayContentLocked().checkWaitingForWindows()) {\n                return;\n            }\n            if (!mBootAnimationStopped) {\n                Trace.asyncTraceBegin(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0);\n                \/\/ stop boot animation\n                \/\/ formerly we would just kill the process, but we now ask it to exit so it\n                \/\/ can choose where to stop the animation.\n                SystemProperties.set(\"service.bootanim.exit\", \"1\");\n                mBootAnimationStopped = true;\n            }\n            if (!mForceDisplayEnabled && !checkBootAnimationCompleteLocked()) {\n                if (DEBUG_BOOT) Slog.i(TAG_WM, \"performEnableScreen: Waiting for anim complete\");\n                return;\n            }\n            try {\n                IBinder surfaceFlinger = ServiceManager.getService(\"SurfaceFlinger\");\n                if (surfaceFlinger != null) {\n                    Slog.i(TAG_WM, \"******* TELLING SURFACE FLINGER WE ARE BOOTED!\");\n                    Parcel data = Parcel.obtain();\n                    data.writeInterfaceToken(\"android.ui.ISurfaceComposer\");\n                    surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, \/\/ BOOT_FINISHED\n                            data, null, 0);\n                    data.recycle();\n                }\n            } catch (RemoteException ex) {\n                Slog.e(TAG_WM, \"Boot completed: SurfaceFlinger is dead!\");\n            }\n            EventLog.writeEvent(EventLogTags.WM_BOOT_ANIMATION_DONE, SystemClock.uptimeMillis());\n            Trace.asyncTraceEnd(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0);\n            mDisplayEnabled = true;\n            if (DEBUG_SCREEN_ON || DEBUG_BOOT) Slog.i(TAG_WM, \"******************** ENABLING SCREEN!\");\n            \/\/ Enable input dispatch.\n            mInputManagerCallback.setEventDispatchingLw(mEventDispatchingEnabled);\n        }\n        try {\n            mActivityManager.bootAnimationComplete();\n        } catch (RemoteException e) {\n        }\n        mPolicy.enableScreenAfterBoot();\n        \/\/ Make sure the last requested orientation has been applied.\n        updateRotationUnchecked(false, false);\n    }","code":"private void performEnableScreen() {\n        synchronized (mGlobalLock) {\n            if (DEBUG_BOOT) Slog.i(TAG_WM, \"performEnableScreen: mDisplayEnabled=\" + mDisplayEnabled\n                    + \" mForceDisplayEnabled=\" + mForceDisplayEnabled\n                    + \" mShowingBootMessages=\" + mShowingBootMessages\n                    + \" mSystemBooted=\" + mSystemBooted\n                    + \" mOnlyCore=\" + mOnlyCore,\n                    new RuntimeException(\"here\").fillInStackTrace());\n            if (mDisplayEnabled) {\n                return;\n            }\n            if (!mSystemBooted && !mShowingBootMessages) {\n                return;\n            }\n            if (!mShowingBootMessages && !mPolicy.canDismissBootAnimation()) {\n                return;\n            }\n           \n            if (!mForceDisplayEnabled\n                   \n                    && getDefaultDisplayContentLocked().checkWaitingForWindows()) {\n                return;\n            }\n            if (!mBootAnimationStopped) {\n                Trace.asyncTraceBegin(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0);\n               \n               \n               \n                SystemProperties.set(\"service.bootanim.exit\", \"1\");\n                mBootAnimationStopped = true;\n            }\n            if (!mForceDisplayEnabled && !checkBootAnimationCompleteLocked()) {\n                if (DEBUG_BOOT) Slog.i(TAG_WM, \"performEnableScreen: Waiting for anim complete\");\n                return;\n            }\n            try {\n                IBinder surfaceFlinger = ServiceManager.getService(\"SurfaceFlinger\");\n                if (surfaceFlinger != null) {\n                    Slog.i(TAG_WM, \"******* TELLING SURFACE FLINGER WE ARE BOOTED!\");\n                    Parcel data = Parcel.obtain();\n                    data.writeInterfaceToken(\"android.ui.ISurfaceComposer\");\n                    surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,\n                            data, null, 0);\n                    data.recycle();\n                }\n            } catch (RemoteException ex) {\n                Slog.e(TAG_WM, \"Boot completed: SurfaceFlinger is dead!\");\n            }\n            EventLog.writeEvent(EventLogTags.WM_BOOT_ANIMATION_DONE, SystemClock.uptimeMillis());\n            Trace.asyncTraceEnd(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0);\n            mDisplayEnabled = true;\n            if (DEBUG_SCREEN_ON || DEBUG_BOOT) Slog.i(TAG_WM, \"******************** ENABLING SCREEN!\");\n           \n            mInputManagerCallback.setEventDispatchingLw(mEventDispatchingEnabled);\n        }\n        try {\n            mActivityManager.bootAnimationComplete();\n        } catch (RemoteException e) {\n        }\n        mPolicy.enableScreenAfterBoot();\n       \n        updateRotationUnchecked(false, false);\n    }","cleancode":"private void performenablescreen() { synchronized (mgloballock) { if (debug_boot) slog.i(tag_wm, \"performenablescreen: mdisplayenabled=\" + mdisplayenabled + \" mforcedisplayenabled=\" + mforcedisplayenabled + \" mshowingbootmessages=\" + mshowingbootmessages + \" msystembooted=\" + msystembooted + \" monlycore=\" + monlycore, new runtimeexception(\"here\").fillinstacktrace()); if (mdisplayenabled) { return; } if (!msystembooted && !mshowingbootmessages) { return; } if (!mshowingbootmessages && !mpolicy.candismissbootanimation()) { return; } if (!mforcedisplayenabled && getdefaultdisplaycontentlocked().checkwaitingforwindows()) { return; } if (!mbootanimationstopped) { trace.asynctracebegin(trace_tag_window_manager, \"stop bootanim\", 0); systemproperties.set(\"service.bootanim.exit\", \"1\"); mbootanimationstopped = true; } if (!mforcedisplayenabled && !checkbootanimationcompletelocked()) { if (debug_boot) slog.i(tag_wm, \"performenablescreen: waiting for anim complete\"); return; } try { ibinder surfaceflinger = servicemanager.getservice(\"surfaceflinger\"); if (surfaceflinger != null) { slog.i(tag_wm, \"******* telling surface flinger we are booted!\"); parcel data = parcel.obtain(); data.writeinterfacetoken(\"android.ui.isurfacecomposer\"); surfaceflinger.transact(ibinder.first_call_transaction, data, null, 0); data.recycle(); } } catch (remoteexception ex) { slog.e(tag_wm, \"boot completed: surfaceflinger is dead!\"); } eventlog.writeevent(eventlogtags.wm_boot_animation_done, systemclock.uptimemillis()); trace.asynctraceend(trace_tag_window_manager, \"stop bootanim\", 0); mdisplayenabled = true; if (debug_screen_on || debug_boot) slog.i(tag_wm, \"******************** enabling screen!\"); minputmanagercallback.seteventdispatchinglw(meventdispatchingenabled); } try { mactivitymanager.bootanimationcomplete(); } catch (remoteexception e) { } mpolicy.enablescreenafterboot(); updaterotationunchecked(false, false); }","comment":"\/\/ don't enable the screen until all existing windows have been drawn.\n\/\/ todo(multidisplay): expand to all displays?\n\/\/ stop boot animation \/\/ formerly we would just kill the process, but we now ask it to exit so it \/\/ can choose where to stop the animation.\n\/\/ boot_finished\n\/\/ enable input dispatch.\n\/\/ make sure the last requested orientation has been applied.","repo":"LynzhX\/android_frameworks_base-1","code_context_2":"return;\n}\n\/\/ Don't enable the screen until all existing windows have been drawn.\nif (!mForceDisplayEnabled\n\/\/ TODO(multidisplay): Expand to all displays?\n\n\/\/ Don't enable the screen until all existing windows have been drawn.\nif (!mForceDisplayEnabled\n\/\/ TODO(multidisplay): Expand to all displays?\n&& getDefaultDisplayContentLocked().checkWaitingForWindows()) {\nreturn;\n\nif (!mBootAnimationStopped) {\nTrace.asyncTraceBegin(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0);\n\/\/ stop boot animation\n\/\/ formerly we would just kill the process, but we now ask it to exit so it\n\/\/ can choose where to stop the animation.\nSystemProperties.set(\"service.bootanim.exit\", \"1\");\nmBootAnimationStopped = true;\n\nParcel data = Parcel.obtain();\ndata.writeInterfaceToken(\"android.ui.ISurfaceComposer\");\nsurfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, \/\/ BOOT_FINISHED\ndata, null, 0);\ndata.recycle();\n\nmDisplayEnabled = true;\nif (DEBUG_SCREEN_ON || DEBUG_BOOT) Slog.i(TAG_WM, \"******************** ENABLING SCREEN!\");\n\/\/ Enable input dispatch.\nmInputManagerCallback.setEventDispatchingLw(mEventDispatchingEnabled);\n}\n\n}\nmPolicy.enableScreenAfterBoot();\n\/\/ Make sure the last requested orientation has been applied.\nupdateRotationUnchecked(false, false);\n}","code_context_10":"new RuntimeException(\"here\").fillInStackTrace());\nif (mDisplayEnabled) {\nreturn;\n}\nif (!mSystemBooted && !mShowingBootMessages) {\nreturn;\n}\nif (!mShowingBootMessages && !mPolicy.canDismissBootAnimation()) {\nreturn;\n}\n\/\/ Don't enable the screen until all existing windows have been drawn.\nif (!mForceDisplayEnabled\n\/\/ TODO(multidisplay): Expand to all displays?\n&& getDefaultDisplayContentLocked().checkWaitingForWindows()) {\nreturn;\n}\nif (!mBootAnimationStopped) {\nTrace.asyncTraceBegin(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0);\n\/\/ stop boot animation\n\/\/ formerly we would just kill the process, but we now ask it to exit so it\n\/\/ can choose where to stop the animation.\n\nreturn;\n}\nif (!mSystemBooted && !mShowingBootMessages) {\nreturn;\n}\nif (!mShowingBootMessages && !mPolicy.canDismissBootAnimation()) {\nreturn;\n}\n\/\/ Don't enable the screen until all existing windows have been drawn.\nif (!mForceDisplayEnabled\n\/\/ TODO(multidisplay): Expand to all displays?\n&& getDefaultDisplayContentLocked().checkWaitingForWindows()) {\nreturn;\n}\nif (!mBootAnimationStopped) {\nTrace.asyncTraceBegin(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0);\n\/\/ stop boot animation\n\/\/ formerly we would just kill the process, but we now ask it to exit so it\n\/\/ can choose where to stop the animation.\nSystemProperties.set(\"service.bootanim.exit\", \"1\");\nmBootAnimationStopped = true;\n\nreturn;\n}\n\/\/ Don't enable the screen until all existing windows have been drawn.\nif (!mForceDisplayEnabled\n\/\/ TODO(multidisplay): Expand to all displays?\n&& getDefaultDisplayContentLocked().checkWaitingForWindows()) {\nreturn;\n}\nif (!mBootAnimationStopped) {\nTrace.asyncTraceBegin(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0);\n\/\/ stop boot animation\n\/\/ formerly we would just kill the process, but we now ask it to exit so it\n\/\/ can choose where to stop the animation.\nSystemProperties.set(\"service.bootanim.exit\", \"1\");\nmBootAnimationStopped = true;\n}\nif (!mForceDisplayEnabled && !checkBootAnimationCompleteLocked()) {\nif (DEBUG_BOOT) Slog.i(TAG_WM, \"performEnableScreen: Waiting for anim complete\");\nreturn;\n}\ntry {\nIBinder surfaceFlinger = ServiceManager.getService(\"SurfaceFlinger\");\nif (surfaceFlinger != null) {\n\nif (!mForceDisplayEnabled && !checkBootAnimationCompleteLocked()) {\nif (DEBUG_BOOT) Slog.i(TAG_WM, \"performEnableScreen: Waiting for anim complete\");\nreturn;\n}\ntry {\nIBinder surfaceFlinger = ServiceManager.getService(\"SurfaceFlinger\");\nif (surfaceFlinger != null) {\nSlog.i(TAG_WM, \"******* TELLING SURFACE FLINGER WE ARE BOOTED!\");\nParcel data = Parcel.obtain();\ndata.writeInterfaceToken(\"android.ui.ISurfaceComposer\");\nsurfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, \/\/ BOOT_FINISHED\ndata, null, 0);\ndata.recycle();\n}\n} catch (RemoteException ex) {\nSlog.e(TAG_WM, \"Boot completed: SurfaceFlinger is dead!\");\n}\nEventLog.writeEvent(EventLogTags.WM_BOOT_ANIMATION_DONE, SystemClock.uptimeMillis());\nTrace.asyncTraceEnd(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0);\nmDisplayEnabled = true;\nif (DEBUG_SCREEN_ON || DEBUG_BOOT) Slog.i(TAG_WM, \"******************** ENABLING SCREEN!\");\n\ndata, null, 0);\ndata.recycle();\n}\n} catch (RemoteException ex) {\nSlog.e(TAG_WM, \"Boot completed: SurfaceFlinger is dead!\");\n}\nEventLog.writeEvent(EventLogTags.WM_BOOT_ANIMATION_DONE, SystemClock.uptimeMillis());\nTrace.asyncTraceEnd(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0);\nmDisplayEnabled = true;\nif (DEBUG_SCREEN_ON || DEBUG_BOOT) Slog.i(TAG_WM, \"******************** ENABLING SCREEN!\");\n\/\/ Enable input dispatch.\nmInputManagerCallback.setEventDispatchingLw(mEventDispatchingEnabled);\n}\ntry {\nmActivityManager.bootAnimationComplete();\n} catch (RemoteException e) {\n}\nmPolicy.enableScreenAfterBoot();\n\/\/ Make sure the last requested orientation has been applied.\nupdateRotationUnchecked(false, false);\n}\n\nmDisplayEnabled = true;\nif (DEBUG_SCREEN_ON || DEBUG_BOOT) Slog.i(TAG_WM, \"******************** ENABLING SCREEN!\");\n\/\/ Enable input dispatch.\nmInputManagerCallback.setEventDispatchingLw(mEventDispatchingEnabled);\n}\ntry {\nmActivityManager.bootAnimationComplete();\n} catch (RemoteException e) {\n}\nmPolicy.enableScreenAfterBoot();\n\/\/ Make sure the last requested orientation has been applied.\nupdateRotationUnchecked(false, false);\n}","code_context_20":"private void performEnableScreen() {\nsynchronized (mGlobalLock) {\nif (DEBUG_BOOT) Slog.i(TAG_WM, \"performEnableScreen: mDisplayEnabled=\" + mDisplayEnabled\n+ \" mForceDisplayEnabled=\" + mForceDisplayEnabled\n+ \" mShowingBootMessages=\" + mShowingBootMessages\n+ \" mSystemBooted=\" + mSystemBooted\n+ \" mOnlyCore=\" + mOnlyCore,\nnew RuntimeException(\"here\").fillInStackTrace());\nif (mDisplayEnabled) {\nreturn;\n}\nif (!mSystemBooted && !mShowingBootMessages) {\nreturn;\n}\nif (!mShowingBootMessages && !mPolicy.canDismissBootAnimation()) {\nreturn;\n}\n\/\/ Don't enable the screen until all existing windows have been drawn.\nif (!mForceDisplayEnabled\n\/\/ TODO(multidisplay): Expand to all displays?\n&& getDefaultDisplayContentLocked().checkWaitingForWindows()) {\nreturn;\n}\nif (!mBootAnimationStopped) {\nTrace.asyncTraceBegin(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0);\n\/\/ stop boot animation\n\/\/ formerly we would just kill the process, but we now ask it to exit so it\n\/\/ can choose where to stop the animation.\nSystemProperties.set(\"service.bootanim.exit\", \"1\");\nmBootAnimationStopped = true;\n}\nif (!mForceDisplayEnabled && !checkBootAnimationCompleteLocked()) {\nif (DEBUG_BOOT) Slog.i(TAG_WM, \"performEnableScreen: Waiting for anim complete\");\nreturn;\n}\ntry {\nIBinder surfaceFlinger = ServiceManager.getService(\"SurfaceFlinger\");\nif (surfaceFlinger != null) {\n\nprivate void performEnableScreen() {\nsynchronized (mGlobalLock) {\nif (DEBUG_BOOT) Slog.i(TAG_WM, \"performEnableScreen: mDisplayEnabled=\" + mDisplayEnabled\n+ \" mForceDisplayEnabled=\" + mForceDisplayEnabled\n+ \" mShowingBootMessages=\" + mShowingBootMessages\n+ \" mSystemBooted=\" + mSystemBooted\n+ \" mOnlyCore=\" + mOnlyCore,\nnew RuntimeException(\"here\").fillInStackTrace());\nif (mDisplayEnabled) {\nreturn;\n}\nif (!mSystemBooted && !mShowingBootMessages) {\nreturn;\n}\nif (!mShowingBootMessages && !mPolicy.canDismissBootAnimation()) {\nreturn;\n}\n\/\/ Don't enable the screen until all existing windows have been drawn.\nif (!mForceDisplayEnabled\n\/\/ TODO(multidisplay): Expand to all displays?\n&& getDefaultDisplayContentLocked().checkWaitingForWindows()) {\nreturn;\n}\nif (!mBootAnimationStopped) {\nTrace.asyncTraceBegin(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0);\n\/\/ stop boot animation\n\/\/ formerly we would just kill the process, but we now ask it to exit so it\n\/\/ can choose where to stop the animation.\nSystemProperties.set(\"service.bootanim.exit\", \"1\");\nmBootAnimationStopped = true;\n}\nif (!mForceDisplayEnabled && !checkBootAnimationCompleteLocked()) {\nif (DEBUG_BOOT) Slog.i(TAG_WM, \"performEnableScreen: Waiting for anim complete\");\nreturn;\n}\ntry {\nIBinder surfaceFlinger = ServiceManager.getService(\"SurfaceFlinger\");\nif (surfaceFlinger != null) {\nSlog.i(TAG_WM, \"******* TELLING SURFACE FLINGER WE ARE BOOTED!\");\nParcel data = Parcel.obtain();\n\n+ \" mSystemBooted=\" + mSystemBooted\n+ \" mOnlyCore=\" + mOnlyCore,\nnew RuntimeException(\"here\").fillInStackTrace());\nif (mDisplayEnabled) {\nreturn;\n}\nif (!mSystemBooted && !mShowingBootMessages) {\nreturn;\n}\nif (!mShowingBootMessages && !mPolicy.canDismissBootAnimation()) {\nreturn;\n}\n\/\/ Don't enable the screen until all existing windows have been drawn.\nif (!mForceDisplayEnabled\n\/\/ TODO(multidisplay): Expand to all displays?\n&& getDefaultDisplayContentLocked().checkWaitingForWindows()) {\nreturn;\n}\nif (!mBootAnimationStopped) {\nTrace.asyncTraceBegin(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0);\n\/\/ stop boot animation\n\/\/ formerly we would just kill the process, but we now ask it to exit so it\n\/\/ can choose where to stop the animation.\nSystemProperties.set(\"service.bootanim.exit\", \"1\");\nmBootAnimationStopped = true;\n}\nif (!mForceDisplayEnabled && !checkBootAnimationCompleteLocked()) {\nif (DEBUG_BOOT) Slog.i(TAG_WM, \"performEnableScreen: Waiting for anim complete\");\nreturn;\n}\ntry {\nIBinder surfaceFlinger = ServiceManager.getService(\"SurfaceFlinger\");\nif (surfaceFlinger != null) {\nSlog.i(TAG_WM, \"******* TELLING SURFACE FLINGER WE ARE BOOTED!\");\nParcel data = Parcel.obtain();\ndata.writeInterfaceToken(\"android.ui.ISurfaceComposer\");\nsurfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, \/\/ BOOT_FINISHED\ndata, null, 0);\ndata.recycle();\n}\n} catch (RemoteException ex) {\nSlog.e(TAG_WM, \"Boot completed: SurfaceFlinger is dead!\");\n}\n\nreturn;\n}\nif (!mBootAnimationStopped) {\nTrace.asyncTraceBegin(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0);\n\/\/ stop boot animation\n\/\/ formerly we would just kill the process, but we now ask it to exit so it\n\/\/ can choose where to stop the animation.\nSystemProperties.set(\"service.bootanim.exit\", \"1\");\nmBootAnimationStopped = true;\n}\nif (!mForceDisplayEnabled && !checkBootAnimationCompleteLocked()) {\nif (DEBUG_BOOT) Slog.i(TAG_WM, \"performEnableScreen: Waiting for anim complete\");\nreturn;\n}\ntry {\nIBinder surfaceFlinger = ServiceManager.getService(\"SurfaceFlinger\");\nif (surfaceFlinger != null) {\nSlog.i(TAG_WM, \"******* TELLING SURFACE FLINGER WE ARE BOOTED!\");\nParcel data = Parcel.obtain();\ndata.writeInterfaceToken(\"android.ui.ISurfaceComposer\");\nsurfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, \/\/ BOOT_FINISHED\ndata, null, 0);\ndata.recycle();\n}\n} catch (RemoteException ex) {\nSlog.e(TAG_WM, \"Boot completed: SurfaceFlinger is dead!\");\n}\nEventLog.writeEvent(EventLogTags.WM_BOOT_ANIMATION_DONE, SystemClock.uptimeMillis());\nTrace.asyncTraceEnd(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0);\nmDisplayEnabled = true;\nif (DEBUG_SCREEN_ON || DEBUG_BOOT) Slog.i(TAG_WM, \"******************** ENABLING SCREEN!\");\n\/\/ Enable input dispatch.\nmInputManagerCallback.setEventDispatchingLw(mEventDispatchingEnabled);\n}\ntry {\nmActivityManager.bootAnimationComplete();\n} catch (RemoteException e) {\n}\nmPolicy.enableScreenAfterBoot();\n\/\/ Make sure the last requested orientation has been applied.\nupdateRotationUnchecked(false, false);\n\nif (DEBUG_BOOT) Slog.i(TAG_WM, \"performEnableScreen: Waiting for anim complete\");\nreturn;\n}\ntry {\nIBinder surfaceFlinger = ServiceManager.getService(\"SurfaceFlinger\");\nif (surfaceFlinger != null) {\nSlog.i(TAG_WM, \"******* TELLING SURFACE FLINGER WE ARE BOOTED!\");\nParcel data = Parcel.obtain();\ndata.writeInterfaceToken(\"android.ui.ISurfaceComposer\");\nsurfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, \/\/ BOOT_FINISHED\ndata, null, 0);\ndata.recycle();\n}\n} catch (RemoteException ex) {\nSlog.e(TAG_WM, \"Boot completed: SurfaceFlinger is dead!\");\n}\nEventLog.writeEvent(EventLogTags.WM_BOOT_ANIMATION_DONE, SystemClock.uptimeMillis());\nTrace.asyncTraceEnd(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0);\nmDisplayEnabled = true;\nif (DEBUG_SCREEN_ON || DEBUG_BOOT) Slog.i(TAG_WM, \"******************** ENABLING SCREEN!\");\n\/\/ Enable input dispatch.\nmInputManagerCallback.setEventDispatchingLw(mEventDispatchingEnabled);\n}\ntry {\nmActivityManager.bootAnimationComplete();\n} catch (RemoteException e) {\n}\nmPolicy.enableScreenAfterBoot();\n\/\/ Make sure the last requested orientation has been applied.\nupdateRotationUnchecked(false, false);\n}\n\ndata.writeInterfaceToken(\"android.ui.ISurfaceComposer\");\nsurfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, \/\/ BOOT_FINISHED\ndata, null, 0);\ndata.recycle();\n}\n} catch (RemoteException ex) {\nSlog.e(TAG_WM, \"Boot completed: SurfaceFlinger is dead!\");\n}\nEventLog.writeEvent(EventLogTags.WM_BOOT_ANIMATION_DONE, SystemClock.uptimeMillis());\nTrace.asyncTraceEnd(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0);\nmDisplayEnabled = true;\nif (DEBUG_SCREEN_ON || DEBUG_BOOT) Slog.i(TAG_WM, \"******************** ENABLING SCREEN!\");\n\/\/ Enable input dispatch.\nmInputManagerCallback.setEventDispatchingLw(mEventDispatchingEnabled);\n}\ntry {\nmActivityManager.bootAnimationComplete();\n} catch (RemoteException e) {\n}\nmPolicy.enableScreenAfterBoot();\n\/\/ Make sure the last requested orientation has been applied.\nupdateRotationUnchecked(false, false);\n}","label":[1,0,0,0]}
{"id":8894,"original_code":"boolean viewServerGetFocusedWindow(Socket client) {\n        if (isSystemSecure()) {\n            return false;\n        }\n        boolean result = true;\n        WindowState focusedWindow = getFocusedWindow();\n        BufferedWriter out = null;\n        \/\/ Any uncaught exception will crash the system process\n        try {\n            OutputStream clientStream = client.getOutputStream();\n            out = new BufferedWriter(new OutputStreamWriter(clientStream), 8 * 1024);\n            if(focusedWindow != null) {\n                out.write(Integer.toHexString(System.identityHashCode(focusedWindow)));\n                out.write(' ');\n                out.append(focusedWindow.mAttrs.getTitle());\n            }\n            out.write('\\n');\n            out.flush();\n        } catch (Exception e) {\n            result = false;\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) {\n                    result = false;\n                }\n            }\n        }\n        return result;\n    }","code":"boolean viewServerGetFocusedWindow(Socket client) {\n        if (isSystemSecure()) {\n            return false;\n        }\n        boolean result = true;\n        WindowState focusedWindow = getFocusedWindow();\n        BufferedWriter out = null;\n       \n        try {\n            OutputStream clientStream = client.getOutputStream();\n            out = new BufferedWriter(new OutputStreamWriter(clientStream), 8 * 1024);\n            if(focusedWindow != null) {\n                out.write(Integer.toHexString(System.identityHashCode(focusedWindow)));\n                out.write(' ');\n                out.append(focusedWindow.mAttrs.getTitle());\n            }\n            out.write('\\n');\n            out.flush();\n        } catch (Exception e) {\n            result = false;\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) {\n                    result = false;\n                }\n            }\n        }\n        return result;\n    }","cleancode":"boolean viewservergetfocusedwindow(socket client) { if (issystemsecure()) { return false; } boolean result = true; windowstate focusedwindow = getfocusedwindow(); bufferedwriter out = null; try { outputstream clientstream = client.getoutputstream(); out = new bufferedwriter(new outputstreamwriter(clientstream), 8 * 1024); if(focusedwindow != null) { out.write(integer.tohexstring(system.identityhashcode(focusedwindow))); out.write(' '); out.append(focusedwindow.mattrs.gettitle()); } out.write('\\n'); out.flush(); } catch (exception e) { result = false; } finally { if (out != null) { try { out.close(); } catch (ioexception e) { result = false; } } } return result; }","comment":"\/\/ todo(multidisplay): extend to multiple displays. \/** * returns the focused window in the following format: * windowhashcodeinhexadecimal windowname * * @param client the remote client to send the listing to. * @return false if an error occurred, true otherwise. *\/\n\/\/ any uncaught exception will crash the system process","repo":"LynzhX\/android_frameworks_base-1","code_context_2":"boolean viewServerGetFocusedWindow(Socket client) {\nif (isSystemSecure()) {\nreturn false;\n}\nboolean result = true;\nWindowState focusedWindow = getFocusedWindow();\nBufferedWriter out = null;\n\/\/ Any uncaught exception will crash the system process\ntry {\nOutputStream clientStream = client.getOutputStream();\nout = new BufferedWriter(new OutputStreamWriter(clientStream), 8 * 1024);\nif(focusedWindow != null) {\nout.write(Integer.toHexString(System.identityHashCode(focusedWindow)));\nout.write(' ');\nout.append(focusedWindow.mAttrs.getTitle());\n}\nout.write('\\n');\nout.flush();\n} catch (Exception e) {\nresult = false;\n} finally {\nif (out != null) {\ntry {\nout.close();\n} catch (IOException e) {\nresult = false;\n}\n}\n}\nreturn result;\n}\n\nWindowState focusedWindow = getFocusedWindow();\nBufferedWriter out = null;\n\/\/ Any uncaught exception will crash the system process\ntry {\nOutputStream clientStream = client.getOutputStream();","code_context_10":"boolean viewServerGetFocusedWindow(Socket client) {\nif (isSystemSecure()) {\nreturn false;\n}\nboolean result = true;\nWindowState focusedWindow = getFocusedWindow();\nBufferedWriter out = null;\n\/\/ Any uncaught exception will crash the system process\ntry {\nOutputStream clientStream = client.getOutputStream();\nout = new BufferedWriter(new OutputStreamWriter(clientStream), 8 * 1024);\nif(focusedWindow != null) {\nout.write(Integer.toHexString(System.identityHashCode(focusedWindow)));\nout.write(' ');\nout.append(focusedWindow.mAttrs.getTitle());\n}\nout.write('\\n');\nout.flush();\n} catch (Exception e) {\nresult = false;\n} finally {\nif (out != null) {\ntry {\nout.close();\n} catch (IOException e) {\nresult = false;\n}\n}\n}\nreturn result;\n}\n\nboolean viewServerGetFocusedWindow(Socket client) {\nif (isSystemSecure()) {\nreturn false;\n}\nboolean result = true;\nWindowState focusedWindow = getFocusedWindow();\nBufferedWriter out = null;\n\/\/ Any uncaught exception will crash the system process\ntry {\nOutputStream clientStream = client.getOutputStream();\nout = new BufferedWriter(new OutputStreamWriter(clientStream), 8 * 1024);\nif(focusedWindow != null) {\nout.write(Integer.toHexString(System.identityHashCode(focusedWindow)));\nout.write(' ');\nout.append(focusedWindow.mAttrs.getTitle());\n}\nout.write('\\n');\nout.flush();","code_context_20":"boolean viewServerGetFocusedWindow(Socket client) {\nif (isSystemSecure()) {\nreturn false;\n}\nboolean result = true;\nWindowState focusedWindow = getFocusedWindow();\nBufferedWriter out = null;\n\/\/ Any uncaught exception will crash the system process\ntry {\nOutputStream clientStream = client.getOutputStream();\nout = new BufferedWriter(new OutputStreamWriter(clientStream), 8 * 1024);\nif(focusedWindow != null) {\nout.write(Integer.toHexString(System.identityHashCode(focusedWindow)));\nout.write(' ');\nout.append(focusedWindow.mAttrs.getTitle());\n}\nout.write('\\n');\nout.flush();\n} catch (Exception e) {\nresult = false;\n} finally {\nif (out != null) {\ntry {\nout.close();\n} catch (IOException e) {\nresult = false;\n}\n}\n}\nreturn result;\n}\n\nboolean viewServerGetFocusedWindow(Socket client) {\nif (isSystemSecure()) {\nreturn false;\n}\nboolean result = true;\nWindowState focusedWindow = getFocusedWindow();\nBufferedWriter out = null;\n\/\/ Any uncaught exception will crash the system process\ntry {\nOutputStream clientStream = client.getOutputStream();\nout = new BufferedWriter(new OutputStreamWriter(clientStream), 8 * 1024);\nif(focusedWindow != null) {\nout.write(Integer.toHexString(System.identityHashCode(focusedWindow)));\nout.write(' ');\nout.append(focusedWindow.mAttrs.getTitle());\n}\nout.write('\\n');\nout.flush();\n} catch (Exception e) {\nresult = false;\n} finally {\nif (out != null) {\ntry {\nout.close();\n} catch (IOException e) {\nresult = false;\n}\n}","label":[0,1,0,0]}
{"id":17124,"original_code":"@Test\n    public void simpleEndpointReturnsPostsWithoutTransformation() {\n        \/\/This unit-test class is the wrong place to test that behaviour, unless it becomes an integration test\n        \/\/Given\n        ForumPosts posts = generateTestPosts();\n        when(exampleApiService.getPosts()).thenReturn(posts);\n        \/\/When\n        ForumPosts controllerOutput = exerciseController.posts();\n        \/\/Then\n        assertEquals(controllerOutput.size(), 2);\n        assertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));\n    }","code":"@Test\n    public void simpleEndpointReturnsPostsWithoutTransformation() {\n       \n       \n        ForumPosts posts = generateTestPosts();\n        when(exampleApiService.getPosts()).thenReturn(posts);\n       \n        ForumPosts controllerOutput = exerciseController.posts();\n       \n        assertEquals(controllerOutput.size(), 2);\n        assertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));\n    }","cleancode":"@test public void simpleendpointreturnspostswithouttransformation() { forumposts posts = generatetestposts(); when(exampleapiservice.getposts()).thenreturn(posts); forumposts controlleroutput = exercisecontroller.posts(); assertequals(controlleroutput.size(), 2); asserttrue(controlleroutput.get(0).gettitle().contains(\"test\")); }","comment":"\/\/this unit-test class is the wrong place to test that behaviour, unless it becomes an integration test \/\/given\n\/\/when\n\/\/then","repo":"JoseAlban\/etc","code_context_2":"@Test\npublic void simpleEndpointReturnsPostsWithoutTransformation() {\n\/\/This unit-test class is the wrong place to test that behaviour, unless it becomes an integration test\n\/\/Given\nForumPosts posts = generateTestPosts();\nwhen(exampleApiService.getPosts()).thenReturn(posts);\n\nForumPosts posts = generateTestPosts();\nwhen(exampleApiService.getPosts()).thenReturn(posts);\n\/\/When\nForumPosts controllerOutput = exerciseController.posts();\n\/\/Then\n\n\/\/When\nForumPosts controllerOutput = exerciseController.posts();\n\/\/Then\nassertEquals(controllerOutput.size(), 2);\nassertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));","code_context_10":"@Test\npublic void simpleEndpointReturnsPostsWithoutTransformation() {\n\/\/This unit-test class is the wrong place to test that behaviour, unless it becomes an integration test\n\/\/Given\nForumPosts posts = generateTestPosts();\nwhen(exampleApiService.getPosts()).thenReturn(posts);\n\/\/When\nForumPosts controllerOutput = exerciseController.posts();\n\/\/Then\nassertEquals(controllerOutput.size(), 2);\nassertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));\n}\n\n@Test\npublic void simpleEndpointReturnsPostsWithoutTransformation() {\n\/\/This unit-test class is the wrong place to test that behaviour, unless it becomes an integration test\n\/\/Given\nForumPosts posts = generateTestPosts();\nwhen(exampleApiService.getPosts()).thenReturn(posts);\n\/\/When\nForumPosts controllerOutput = exerciseController.posts();\n\/\/Then\nassertEquals(controllerOutput.size(), 2);\nassertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));\n}\n\n@Test\npublic void simpleEndpointReturnsPostsWithoutTransformation() {\n\/\/This unit-test class is the wrong place to test that behaviour, unless it becomes an integration test\n\/\/Given\nForumPosts posts = generateTestPosts();\nwhen(exampleApiService.getPosts()).thenReturn(posts);\n\/\/When\nForumPosts controllerOutput = exerciseController.posts();\n\/\/Then\nassertEquals(controllerOutput.size(), 2);\nassertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));\n}","code_context_20":"@Test\npublic void simpleEndpointReturnsPostsWithoutTransformation() {\n\/\/This unit-test class is the wrong place to test that behaviour, unless it becomes an integration test\n\/\/Given\nForumPosts posts = generateTestPosts();\nwhen(exampleApiService.getPosts()).thenReturn(posts);\n\/\/When\nForumPosts controllerOutput = exerciseController.posts();\n\/\/Then\nassertEquals(controllerOutput.size(), 2);\nassertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));\n}\n\n@Test\npublic void simpleEndpointReturnsPostsWithoutTransformation() {\n\/\/This unit-test class is the wrong place to test that behaviour, unless it becomes an integration test\n\/\/Given\nForumPosts posts = generateTestPosts();\nwhen(exampleApiService.getPosts()).thenReturn(posts);\n\/\/When\nForumPosts controllerOutput = exerciseController.posts();\n\/\/Then\nassertEquals(controllerOutput.size(), 2);\nassertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));\n}\n\n@Test\npublic void simpleEndpointReturnsPostsWithoutTransformation() {\n\/\/This unit-test class is the wrong place to test that behaviour, unless it becomes an integration test\n\/\/Given\nForumPosts posts = generateTestPosts();\nwhen(exampleApiService.getPosts()).thenReturn(posts);\n\/\/When\nForumPosts controllerOutput = exerciseController.posts();\n\/\/Then\nassertEquals(controllerOutput.size(), 2);\nassertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));\n}","label":[0,0,0,1]}
{"id":17125,"original_code":"@Test\n    public void transformedEndpointReturnsPostsWithCurrentDate() {\n        \/\/This unit-test class is the wrong place to test that behaviour, unless it becomes an integration test\n        \/\/Given\n        TransformedForumPosts transformed = generateTransformedTestPosts();\n        when(exampleApiService.getTransformedPosts()).thenReturn(transformed);\n        \/\/When\n        TransformedForumPosts controllerOutput = exerciseController.transformed();\n        \/\/Then\n        assertEquals(controllerOutput.size(), 2);\n        assertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));\n        assertTrue(controllerOutput.get(0).getUppercaseTitle().contains(\"TEST\"));\n        assertTrue(controllerOutput.get(0).getPostDate().matches(\"\\\\d{4}-[01]\\\\d-[0-3]\\\\d\"));\n    }","code":"@Test\n    public void transformedEndpointReturnsPostsWithCurrentDate() {\n       \n       \n        TransformedForumPosts transformed = generateTransformedTestPosts();\n        when(exampleApiService.getTransformedPosts()).thenReturn(transformed);\n       \n        TransformedForumPosts controllerOutput = exerciseController.transformed();\n       \n        assertEquals(controllerOutput.size(), 2);\n        assertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));\n        assertTrue(controllerOutput.get(0).getUppercaseTitle().contains(\"TEST\"));\n        assertTrue(controllerOutput.get(0).getPostDate().matches(\"\\\\d{4}-[01]\\\\d-[0-3]\\\\d\"));\n    }","cleancode":"@test public void transformedendpointreturnspostswithcurrentdate() { transformedforumposts transformed = generatetransformedtestposts(); when(exampleapiservice.gettransformedposts()).thenreturn(transformed); transformedforumposts controlleroutput = exercisecontroller.transformed(); assertequals(controlleroutput.size(), 2); asserttrue(controlleroutput.get(0).gettitle().contains(\"test\")); asserttrue(controlleroutput.get(0).getuppercasetitle().contains(\"test\")); asserttrue(controlleroutput.get(0).getpostdate().matches(\"\\\\d{4}-[01]\\\\d-[0-3]\\\\d\")); }","comment":"\/\/this unit-test class is the wrong place to test that behaviour, unless it becomes an integration test \/\/given\n\/\/when\n\/\/then","repo":"JoseAlban\/etc","code_context_2":"@Test\npublic void transformedEndpointReturnsPostsWithCurrentDate() {\n\/\/This unit-test class is the wrong place to test that behaviour, unless it becomes an integration test\n\/\/Given\nTransformedForumPosts transformed = generateTransformedTestPosts();\nwhen(exampleApiService.getTransformedPosts()).thenReturn(transformed);\n\nTransformedForumPosts transformed = generateTransformedTestPosts();\nwhen(exampleApiService.getTransformedPosts()).thenReturn(transformed);\n\/\/When\nTransformedForumPosts controllerOutput = exerciseController.transformed();\n\/\/Then\n\n\/\/When\nTransformedForumPosts controllerOutput = exerciseController.transformed();\n\/\/Then\nassertEquals(controllerOutput.size(), 2);\nassertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));","code_context_10":"@Test\npublic void transformedEndpointReturnsPostsWithCurrentDate() {\n\/\/This unit-test class is the wrong place to test that behaviour, unless it becomes an integration test\n\/\/Given\nTransformedForumPosts transformed = generateTransformedTestPosts();\nwhen(exampleApiService.getTransformedPosts()).thenReturn(transformed);\n\/\/When\nTransformedForumPosts controllerOutput = exerciseController.transformed();\n\/\/Then\nassertEquals(controllerOutput.size(), 2);\nassertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));\nassertTrue(controllerOutput.get(0).getUppercaseTitle().contains(\"TEST\"));\nassertTrue(controllerOutput.get(0).getPostDate().matches(\"\\\\d{4}-[01]\\\\d-[0-3]\\\\d\"));\n}\n\n@Test\npublic void transformedEndpointReturnsPostsWithCurrentDate() {\n\/\/This unit-test class is the wrong place to test that behaviour, unless it becomes an integration test\n\/\/Given\nTransformedForumPosts transformed = generateTransformedTestPosts();\nwhen(exampleApiService.getTransformedPosts()).thenReturn(transformed);\n\/\/When\nTransformedForumPosts controllerOutput = exerciseController.transformed();\n\/\/Then\nassertEquals(controllerOutput.size(), 2);\nassertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));\nassertTrue(controllerOutput.get(0).getUppercaseTitle().contains(\"TEST\"));\nassertTrue(controllerOutput.get(0).getPostDate().matches(\"\\\\d{4}-[01]\\\\d-[0-3]\\\\d\"));\n}\n\n@Test\npublic void transformedEndpointReturnsPostsWithCurrentDate() {\n\/\/This unit-test class is the wrong place to test that behaviour, unless it becomes an integration test\n\/\/Given\nTransformedForumPosts transformed = generateTransformedTestPosts();\nwhen(exampleApiService.getTransformedPosts()).thenReturn(transformed);\n\/\/When\nTransformedForumPosts controllerOutput = exerciseController.transformed();\n\/\/Then\nassertEquals(controllerOutput.size(), 2);\nassertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));\nassertTrue(controllerOutput.get(0).getUppercaseTitle().contains(\"TEST\"));\nassertTrue(controllerOutput.get(0).getPostDate().matches(\"\\\\d{4}-[01]\\\\d-[0-3]\\\\d\"));\n}","code_context_20":"@Test\npublic void transformedEndpointReturnsPostsWithCurrentDate() {\n\/\/This unit-test class is the wrong place to test that behaviour, unless it becomes an integration test\n\/\/Given\nTransformedForumPosts transformed = generateTransformedTestPosts();\nwhen(exampleApiService.getTransformedPosts()).thenReturn(transformed);\n\/\/When\nTransformedForumPosts controllerOutput = exerciseController.transformed();\n\/\/Then\nassertEquals(controllerOutput.size(), 2);\nassertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));\nassertTrue(controllerOutput.get(0).getUppercaseTitle().contains(\"TEST\"));\nassertTrue(controllerOutput.get(0).getPostDate().matches(\"\\\\d{4}-[01]\\\\d-[0-3]\\\\d\"));\n}\n\n@Test\npublic void transformedEndpointReturnsPostsWithCurrentDate() {\n\/\/This unit-test class is the wrong place to test that behaviour, unless it becomes an integration test\n\/\/Given\nTransformedForumPosts transformed = generateTransformedTestPosts();\nwhen(exampleApiService.getTransformedPosts()).thenReturn(transformed);\n\/\/When\nTransformedForumPosts controllerOutput = exerciseController.transformed();\n\/\/Then\nassertEquals(controllerOutput.size(), 2);\nassertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));\nassertTrue(controllerOutput.get(0).getUppercaseTitle().contains(\"TEST\"));\nassertTrue(controllerOutput.get(0).getPostDate().matches(\"\\\\d{4}-[01]\\\\d-[0-3]\\\\d\"));\n}\n\n@Test\npublic void transformedEndpointReturnsPostsWithCurrentDate() {\n\/\/This unit-test class is the wrong place to test that behaviour, unless it becomes an integration test\n\/\/Given\nTransformedForumPosts transformed = generateTransformedTestPosts();\nwhen(exampleApiService.getTransformedPosts()).thenReturn(transformed);\n\/\/When\nTransformedForumPosts controllerOutput = exerciseController.transformed();\n\/\/Then\nassertEquals(controllerOutput.size(), 2);\nassertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));\nassertTrue(controllerOutput.get(0).getUppercaseTitle().contains(\"TEST\"));\nassertTrue(controllerOutput.get(0).getPostDate().matches(\"\\\\d{4}-[01]\\\\d-[0-3]\\\\d\"));\n}","label":[0,0,0,1]}
{"id":33512,"original_code":"@Override\n    public void doServerTick(World world)\n    {\n        super.doServerTick(world);\n        Entity rider = entity.getControllingPassenger();\n        pokemob.setGeneralState(GeneralStates.CONTROLLED, rider != null);\n        if (rider == null) return;\n        Config config = PokecubeCore.instance.getConfig();\n        boolean move = false;\n        entity.rotationYaw = pokemob.getHeading();\n        boolean shouldControl = entity.onGround || pokemob.floats();\n        boolean verticalControl = false;\n        boolean waterSpeed = false;\n        boolean airSpeed = !entity.onGround;\n        boolean canFly = pokemob.canUseFly();\n        boolean canSurf = pokemob.canUseSurf();\n        boolean canDive = pokemob.canUseDive();\n        if (rider instanceof EntityPlayerMP)\n        {\n            EntityPlayer player = (EntityPlayer) rider;\n            IPermissionHandler handler = PermissionAPI.getPermissionHandler();\n            PlayerContext context = new PlayerContext(player);\n            PokedexEntry entry = pokemob.getPokedexEntry();\n            if (config.permsFly && canFly\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.FLYPOKEMOB, context))\n            {\n                canFly = false;\n            }\n            if (config.permsFlySpecific && canFly\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.FLYSPECIFIC.get(entry), context))\n            {\n                canFly = false;\n            }\n            if (config.permsSurf && canSurf\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.SURFPOKEMOB, context))\n            {\n                canSurf = false;\n            }\n            if (config.permsSurfSpecific && canSurf\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.SURFSPECIFIC.get(entry), context))\n            {\n                canSurf = false;\n            }\n            if (config.permsDive && canDive\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.DIVEPOKEMOB, context))\n            {\n                canDive = false;\n            }\n            if (config.permsDiveSpecific && canDive\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.DIVESPECIFIC.get(entry), context))\n            {\n                canDive = false;\n            }\n        }\n        if (canFly) for (int i = 0; i < PokecubeMod.core.getConfig().flyDimBlacklist.length; i++)\n            if (PokecubeMod.core.getConfig().flyDimBlacklist[i] == world.provider.getDimension())\n            {\n                canFly = false;\n                break;\n            }\n        if (canFly) shouldControl = verticalControl = PokecubeMod.core.getConfig().flyEnabled || shouldControl;\n        if ((canSurf || canDive) && (waterSpeed = entity.isInWater()))\n            shouldControl = verticalControl = PokecubeMod.core.getConfig().surfEnabled || shouldControl;\n        if (waterSpeed) airSpeed = false;\n        Entity controller = rider;\n        if (pokemob.getPokedexEntry().shouldDive)\n        {\n            PotionEffect vision = new PotionEffect(Potion.getPotionFromResourceLocation(\"night_vision\"), 300, 1, true,\n                    false);\n            ItemStack stack = new ItemStack(Blocks.BARRIER);\n            vision.setCurativeItems(Lists.newArrayList(stack));\n            for (Entity e : entity.getRecursivePassengers())\n            {\n                if (e instanceof EntityLivingBase)\n                {\n                    if (entity.isInWater())\n                    {\n                        ((EntityLivingBase) e).addPotionEffect(vision);\n                        ((EntityLivingBase) e).setAir(300);\n                    }\n                    else((EntityLivingBase) e).curePotionEffects(stack);\n                }\n            }\n        }\n        float speedFactor = (float) (1 + Math.sqrt(pokemob.getPokedexEntry().getStatVIT()) \/ (10F));\n        float moveSpeed = (float) (0.25f * throttle * speedFactor);\n        if (forwardInputDown)\n        {\n            move = true;\n            float f = moveSpeed \/ 2;\n            if (airSpeed) f *= config.flySpeedFactor;\n            else if (waterSpeed) f *= config.surfSpeedFactor;\n            else f *= config.groundSpeedFactor;\n            if (shouldControl)\n            {\n                if (!entity.onGround) f *= 2;\n                entity.motionX += MathHelper.sin(-entity.rotationYaw * 0.017453292F) * f;\n                entity.motionZ += MathHelper.cos(entity.rotationYaw * 0.017453292F) * f;\n            }\n            else if (entity.isInLava() || entity.isInWater())\n            {\n                f *= 0.1;\n                entity.motionX += MathHelper.sin(-entity.rotationYaw * 0.017453292F) * f;\n                entity.motionZ += MathHelper.cos(entity.rotationYaw * 0.017453292F) * f;\n            }\n        }\n        if (backInputDown)\n        {\n            move = true;\n            float f = -moveSpeed \/ 4;\n            if (shouldControl)\n            {\n                if (airSpeed) f *= config.flySpeedFactor;\n                else if (waterSpeed) f *= config.surfSpeedFactor;\n                else f *= config.groundSpeedFactor;\n                entity.motionX += MathHelper.sin(-entity.rotationYaw * 0.017453292F) * f;\n                entity.motionZ += MathHelper.cos(entity.rotationYaw * 0.017453292F) * f;\n            }\n        }\n        if (upInputDown)\n        {\n            if (entity.onGround)\n            {\n                entity.getJumpHelper().setJumping();\n            }\n            else if (verticalControl)\n            {\n                entity.motionY += 0.1 * throttle;\n            }\n            else if (entity.isInLava() || entity.isInWater())\n            {\n                entity.motionY += 0.05 * throttle;\n            }\n        }\n        if (downInputDown)\n        {\n            if (verticalControl && !entity.onGround)\n            {\n                entity.motionY -= 0.1 * throttle;\n            }\n        }\n        else if (!verticalControl && !entity.onGround)\n        {\n            entity.motionY -= 0.1;\n        }\n        if (!followOwnerLook)\n        {\/\/ TODO some way to make this change based on how long button is held?\n            if (leftInputDown)\n            {\n                pokemob.setHeading(pokemob.getHeading() - 5);\n            }\n            if (rightInputDown)\n            {\n                pokemob.setHeading(pokemob.getHeading() + 5);\n            }\n        }\n        else if (!entity.getPassengers().isEmpty())\n        {\n            pokemob.setHeading(controller.rotationYaw);\n            float f = moveSpeed \/ 2;\n            if (leftInputDown)\n            {\n                move = true;\n                if (shouldControl)\n                {\n                    if (!entity.onGround) f *= 2;\n                    if (airSpeed) f *= config.flySpeedFactor;\n                    else if (waterSpeed) f *= config.surfSpeedFactor;\n                    else f *= config.groundSpeedFactor;\n                    entity.motionX += MathHelper.cos(-entity.rotationYaw * 0.017453292F) * f;\n                    entity.motionZ += MathHelper.sin(entity.rotationYaw * 0.017453292F) * f;\n                }\n                else if (entity.isInLava() || entity.isInWater())\n                {\n                    f *= 0.1;\n                    entity.motionX += MathHelper.cos(-entity.rotationYaw * 0.017453292F) * f;\n                    entity.motionZ += MathHelper.sin(entity.rotationYaw * 0.017453292F) * f;\n                }\n            }\n            if (rightInputDown)\n            {\n                move = true;\n                if (shouldControl)\n                {\n                    if (!entity.onGround) f *= 2;\n                    if (airSpeed) f *= config.flySpeedFactor;\n                    else if (waterSpeed) f *= config.surfSpeedFactor;\n                    else f *= config.groundSpeedFactor;\n                    entity.motionX -= MathHelper.cos(-entity.rotationYaw * 0.017453292F) * f;\n                    entity.motionZ -= MathHelper.sin(entity.rotationYaw * 0.017453292F) * f;\n                }\n                else if (entity.isInLava() || entity.isInWater())\n                {\n                    f *= 0.1;\n                    entity.motionX -= MathHelper.cos(-entity.rotationYaw * 0.017453292F) * f;\n                    entity.motionZ -= MathHelper.sin(entity.rotationYaw * 0.017453292F) * f;\n                }\n            }\n        }\n        if (!move)\n        {\n            entity.motionX *= 0.5;\n            entity.motionZ *= 0.5;\n        }\n        \/\/ Sync the rotations.\n        entity.setRenderYawOffset(pokemob.getHeading());\n        entity.setRotationYawHead(pokemob.getHeading());\n    }","code":"@Override\n    public void doServerTick(World world)\n    {\n        super.doServerTick(world);\n        Entity rider = entity.getControllingPassenger();\n        pokemob.setGeneralState(GeneralStates.CONTROLLED, rider != null);\n        if (rider == null) return;\n        Config config = PokecubeCore.instance.getConfig();\n        boolean move = false;\n        entity.rotationYaw = pokemob.getHeading();\n        boolean shouldControl = entity.onGround || pokemob.floats();\n        boolean verticalControl = false;\n        boolean waterSpeed = false;\n        boolean airSpeed = !entity.onGround;\n        boolean canFly = pokemob.canUseFly();\n        boolean canSurf = pokemob.canUseSurf();\n        boolean canDive = pokemob.canUseDive();\n        if (rider instanceof EntityPlayerMP)\n        {\n            EntityPlayer player = (EntityPlayer) rider;\n            IPermissionHandler handler = PermissionAPI.getPermissionHandler();\n            PlayerContext context = new PlayerContext(player);\n            PokedexEntry entry = pokemob.getPokedexEntry();\n            if (config.permsFly && canFly\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.FLYPOKEMOB, context))\n            {\n                canFly = false;\n            }\n            if (config.permsFlySpecific && canFly\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.FLYSPECIFIC.get(entry), context))\n            {\n                canFly = false;\n            }\n            if (config.permsSurf && canSurf\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.SURFPOKEMOB, context))\n            {\n                canSurf = false;\n            }\n            if (config.permsSurfSpecific && canSurf\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.SURFSPECIFIC.get(entry), context))\n            {\n                canSurf = false;\n            }\n            if (config.permsDive && canDive\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.DIVEPOKEMOB, context))\n            {\n                canDive = false;\n            }\n            if (config.permsDiveSpecific && canDive\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.DIVESPECIFIC.get(entry), context))\n            {\n                canDive = false;\n            }\n        }\n        if (canFly) for (int i = 0; i < PokecubeMod.core.getConfig().flyDimBlacklist.length; i++)\n            if (PokecubeMod.core.getConfig().flyDimBlacklist[i] == world.provider.getDimension())\n            {\n                canFly = false;\n                break;\n            }\n        if (canFly) shouldControl = verticalControl = PokecubeMod.core.getConfig().flyEnabled || shouldControl;\n        if ((canSurf || canDive) && (waterSpeed = entity.isInWater()))\n            shouldControl = verticalControl = PokecubeMod.core.getConfig().surfEnabled || shouldControl;\n        if (waterSpeed) airSpeed = false;\n        Entity controller = rider;\n        if (pokemob.getPokedexEntry().shouldDive)\n        {\n            PotionEffect vision = new PotionEffect(Potion.getPotionFromResourceLocation(\"night_vision\"), 300, 1, true,\n                    false);\n            ItemStack stack = new ItemStack(Blocks.BARRIER);\n            vision.setCurativeItems(Lists.newArrayList(stack));\n            for (Entity e : entity.getRecursivePassengers())\n            {\n                if (e instanceof EntityLivingBase)\n                {\n                    if (entity.isInWater())\n                    {\n                        ((EntityLivingBase) e).addPotionEffect(vision);\n                        ((EntityLivingBase) e).setAir(300);\n                    }\n                    else((EntityLivingBase) e).curePotionEffects(stack);\n                }\n            }\n        }\n        float speedFactor = (float) (1 + Math.sqrt(pokemob.getPokedexEntry().getStatVIT()) \/ (10F));\n        float moveSpeed = (float) (0.25f * throttle * speedFactor);\n        if (forwardInputDown)\n        {\n            move = true;\n            float f = moveSpeed \/ 2;\n            if (airSpeed) f *= config.flySpeedFactor;\n            else if (waterSpeed) f *= config.surfSpeedFactor;\n            else f *= config.groundSpeedFactor;\n            if (shouldControl)\n            {\n                if (!entity.onGround) f *= 2;\n                entity.motionX += MathHelper.sin(-entity.rotationYaw * 0.017453292F) * f;\n                entity.motionZ += MathHelper.cos(entity.rotationYaw * 0.017453292F) * f;\n            }\n            else if (entity.isInLava() || entity.isInWater())\n            {\n                f *= 0.1;\n                entity.motionX += MathHelper.sin(-entity.rotationYaw * 0.017453292F) * f;\n                entity.motionZ += MathHelper.cos(entity.rotationYaw * 0.017453292F) * f;\n            }\n        }\n        if (backInputDown)\n        {\n            move = true;\n            float f = -moveSpeed \/ 4;\n            if (shouldControl)\n            {\n                if (airSpeed) f *= config.flySpeedFactor;\n                else if (waterSpeed) f *= config.surfSpeedFactor;\n                else f *= config.groundSpeedFactor;\n                entity.motionX += MathHelper.sin(-entity.rotationYaw * 0.017453292F) * f;\n                entity.motionZ += MathHelper.cos(entity.rotationYaw * 0.017453292F) * f;\n            }\n        }\n        if (upInputDown)\n        {\n            if (entity.onGround)\n            {\n                entity.getJumpHelper().setJumping();\n            }\n            else if (verticalControl)\n            {\n                entity.motionY += 0.1 * throttle;\n            }\n            else if (entity.isInLava() || entity.isInWater())\n            {\n                entity.motionY += 0.05 * throttle;\n            }\n        }\n        if (downInputDown)\n        {\n            if (verticalControl && !entity.onGround)\n            {\n                entity.motionY -= 0.1 * throttle;\n            }\n        }\n        else if (!verticalControl && !entity.onGround)\n        {\n            entity.motionY -= 0.1;\n        }\n        if (!followOwnerLook)\n        \n            if (leftInputDown)\n            {\n                pokemob.setHeading(pokemob.getHeading() - 5);\n            }\n            if (rightInputDown)\n            {\n                pokemob.setHeading(pokemob.getHeading() + 5);\n            }\n        }\n        else if (!entity.getPassengers().isEmpty())\n        {\n            pokemob.setHeading(controller.rotationYaw);\n            float f = moveSpeed \/ 2;\n            if (leftInputDown)\n            {\n                move = true;\n                if (shouldControl)\n                {\n                    if (!entity.onGround) f *= 2;\n                    if (airSpeed) f *= config.flySpeedFactor;\n                    else if (waterSpeed) f *= config.surfSpeedFactor;\n                    else f *= config.groundSpeedFactor;\n                    entity.motionX += MathHelper.cos(-entity.rotationYaw * 0.017453292F) * f;\n                    entity.motionZ += MathHelper.sin(entity.rotationYaw * 0.017453292F) * f;\n                }\n                else if (entity.isInLava() || entity.isInWater())\n                {\n                    f *= 0.1;\n                    entity.motionX += MathHelper.cos(-entity.rotationYaw * 0.017453292F) * f;\n                    entity.motionZ += MathHelper.sin(entity.rotationYaw * 0.017453292F) * f;\n                }\n            }\n            if (rightInputDown)\n            {\n                move = true;\n                if (shouldControl)\n                {\n                    if (!entity.onGround) f *= 2;\n                    if (airSpeed) f *= config.flySpeedFactor;\n                    else if (waterSpeed) f *= config.surfSpeedFactor;\n                    else f *= config.groundSpeedFactor;\n                    entity.motionX -= MathHelper.cos(-entity.rotationYaw * 0.017453292F) * f;\n                    entity.motionZ -= MathHelper.sin(entity.rotationYaw * 0.017453292F) * f;\n                }\n                else if (entity.isInLava() || entity.isInWater())\n                {\n                    f *= 0.1;\n                    entity.motionX -= MathHelper.cos(-entity.rotationYaw * 0.017453292F) * f;\n                    entity.motionZ -= MathHelper.sin(entity.rotationYaw * 0.017453292F) * f;\n                }\n            }\n        }\n        if (!move)\n        {\n            entity.motionX *= 0.5;\n            entity.motionZ *= 0.5;\n        }\n       \n        entity.setRenderYawOffset(pokemob.getHeading());\n        entity.setRotationYawHead(pokemob.getHeading());\n    }","cleancode":"@override public void doservertick(world world) { super.doservertick(world); entity rider = entity.getcontrollingpassenger(); pokemob.setgeneralstate(generalstates.controlled, rider != null); if (rider == null) return; config config = pokecubecore.instance.getconfig(); boolean move = false; entity.rotationyaw = pokemob.getheading(); boolean shouldcontrol = entity.onground || pokemob.floats(); boolean verticalcontrol = false; boolean waterspeed = false; boolean airspeed = !entity.onground; boolean canfly = pokemob.canusefly(); boolean cansurf = pokemob.canusesurf(); boolean candive = pokemob.canusedive(); if (rider instanceof entityplayermp) { entityplayer player = (entityplayer) rider; ipermissionhandler handler = permissionapi.getpermissionhandler(); playercontext context = new playercontext(player); pokedexentry entry = pokemob.getpokedexentry(); if (config.permsfly && canfly && !handler.haspermission(player.getgameprofile(), permissions.flypokemob, context)) { canfly = false; } if (config.permsflyspecific && canfly && !handler.haspermission(player.getgameprofile(), permissions.flyspecific.get(entry), context)) { canfly = false; } if (config.permssurf && cansurf && !handler.haspermission(player.getgameprofile(), permissions.surfpokemob, context)) { cansurf = false; } if (config.permssurfspecific && cansurf && !handler.haspermission(player.getgameprofile(), permissions.surfspecific.get(entry), context)) { cansurf = false; } if (config.permsdive && candive && !handler.haspermission(player.getgameprofile(), permissions.divepokemob, context)) { candive = false; } if (config.permsdivespecific && candive && !handler.haspermission(player.getgameprofile(), permissions.divespecific.get(entry), context)) { candive = false; } } if (canfly) for (int i = 0; i < pokecubemod.core.getconfig().flydimblacklist.length; i++) if (pokecubemod.core.getconfig().flydimblacklist[i] == world.provider.getdimension()) { canfly = false; break; } if (canfly) shouldcontrol = verticalcontrol = pokecubemod.core.getconfig().flyenabled || shouldcontrol; if ((cansurf || candive) && (waterspeed = entity.isinwater())) shouldcontrol = verticalcontrol = pokecubemod.core.getconfig().surfenabled || shouldcontrol; if (waterspeed) airspeed = false; entity controller = rider; if (pokemob.getpokedexentry().shoulddive) { potioneffect vision = new potioneffect(potion.getpotionfromresourcelocation(\"night_vision\"), 300, 1, true, false); itemstack stack = new itemstack(blocks.barrier); vision.setcurativeitems(lists.newarraylist(stack)); for (entity e : entity.getrecursivepassengers()) { if (e instanceof entitylivingbase) { if (entity.isinwater()) { ((entitylivingbase) e).addpotioneffect(vision); ((entitylivingbase) e).setair(300); } else((entitylivingbase) e).curepotioneffects(stack); } } } float speedfactor = (float) (1 + math.sqrt(pokemob.getpokedexentry().getstatvit()) \/ (10f)); float movespeed = (float) (0.25f * throttle * speedfactor); if (forwardinputdown) { move = true; float f = movespeed \/ 2; if (airspeed) f *= config.flyspeedfactor; else if (waterspeed) f *= config.surfspeedfactor; else f *= config.groundspeedfactor; if (shouldcontrol) { if (!entity.onground) f *= 2; entity.motionx += mathhelper.sin(-entity.rotationyaw * 0.017453292f) * f; entity.motionz += mathhelper.cos(entity.rotationyaw * 0.017453292f) * f; } else if (entity.isinlava() || entity.isinwater()) { f *= 0.1; entity.motionx += mathhelper.sin(-entity.rotationyaw * 0.017453292f) * f; entity.motionz += mathhelper.cos(entity.rotationyaw * 0.017453292f) * f; } } if (backinputdown) { move = true; float f = -movespeed \/ 4; if (shouldcontrol) { if (airspeed) f *= config.flyspeedfactor; else if (waterspeed) f *= config.surfspeedfactor; else f *= config.groundspeedfactor; entity.motionx += mathhelper.sin(-entity.rotationyaw * 0.017453292f) * f; entity.motionz += mathhelper.cos(entity.rotationyaw * 0.017453292f) * f; } } if (upinputdown) { if (entity.onground) { entity.getjumphelper().setjumping(); } else if (verticalcontrol) { entity.motiony += 0.1 * throttle; } else if (entity.isinlava() || entity.isinwater()) { entity.motiony += 0.05 * throttle; } } if (downinputdown) { if (verticalcontrol && !entity.onground) { entity.motiony -= 0.1 * throttle; } } else if (!verticalcontrol && !entity.onground) { entity.motiony -= 0.1; } if (!followownerlook) if (leftinputdown) { pokemob.setheading(pokemob.getheading() - 5); } if (rightinputdown) { pokemob.setheading(pokemob.getheading() + 5); } } else if (!entity.getpassengers().isempty()) { pokemob.setheading(controller.rotationyaw); float f = movespeed \/ 2; if (leftinputdown) { move = true; if (shouldcontrol) { if (!entity.onground) f *= 2; if (airspeed) f *= config.flyspeedfactor; else if (waterspeed) f *= config.surfspeedfactor; else f *= config.groundspeedfactor; entity.motionx += mathhelper.cos(-entity.rotationyaw * 0.017453292f) * f; entity.motionz += mathhelper.sin(entity.rotationyaw * 0.017453292f) * f; } else if (entity.isinlava() || entity.isinwater()) { f *= 0.1; entity.motionx += mathhelper.cos(-entity.rotationyaw * 0.017453292f) * f; entity.motionz += mathhelper.sin(entity.rotationyaw * 0.017453292f) * f; } } if (rightinputdown) { move = true; if (shouldcontrol) { if (!entity.onground) f *= 2; if (airspeed) f *= config.flyspeedfactor; else if (waterspeed) f *= config.surfspeedfactor; else f *= config.groundspeedfactor; entity.motionx -= mathhelper.cos(-entity.rotationyaw * 0.017453292f) * f; entity.motionz -= mathhelper.sin(entity.rotationyaw * 0.017453292f) * f; } else if (entity.isinlava() || entity.isinwater()) { f *= 0.1; entity.motionx -= mathhelper.cos(-entity.rotationyaw * 0.017453292f) * f; entity.motionz -= mathhelper.sin(entity.rotationyaw * 0.017453292f) * f; } } } if (!move) { entity.motionx *= 0.5; entity.motionz *= 0.5; } entity.setrenderyawoffset(pokemob.getheading()); entity.setrotationyawhead(pokemob.getheading()); }","comment":"\/\/ todo some way to make this change based on how long button is held?\n\/\/ sync the rotations.","repo":"Pokecube-Development\/Pokecube-Core","code_context_2":"}\nif (!followOwnerLook)\n{\/\/ TODO some way to make this change based on how long button is held?\nif (leftInputDown)\n{\n\nentity.motionZ *= 0.5;\n}\n\/\/ Sync the rotations.\nentity.setRenderYawOffset(pokemob.getHeading());\nentity.setRotationYawHead(pokemob.getHeading());","code_context_10":"if (verticalControl && !entity.onGround)\n{\nentity.motionY -= 0.1 * throttle;\n}\n}\nelse if (!verticalControl && !entity.onGround)\n{\nentity.motionY -= 0.1;\n}\nif (!followOwnerLook)\n{\/\/ TODO some way to make this change based on how long button is held?\nif (leftInputDown)\n{\npokemob.setHeading(pokemob.getHeading() - 5);\n}\nif (rightInputDown)\n{\npokemob.setHeading(pokemob.getHeading() + 5);\n}\n}\nelse if (!entity.getPassengers().isEmpty())\n\nentity.motionX -= MathHelper.cos(-entity.rotationYaw * 0.017453292F) * f;\nentity.motionZ -= MathHelper.sin(entity.rotationYaw * 0.017453292F) * f;\n}\n}\n}\nif (!move)\n{\nentity.motionX *= 0.5;\nentity.motionZ *= 0.5;\n}\n\/\/ Sync the rotations.\nentity.setRenderYawOffset(pokemob.getHeading());\nentity.setRotationYawHead(pokemob.getHeading());\n}","code_context_20":"{\nentity.motionY += 0.1 * throttle;\n}\nelse if (entity.isInLava() || entity.isInWater())\n{\nentity.motionY += 0.05 * throttle;\n}\n}\nif (downInputDown)\n{\nif (verticalControl && !entity.onGround)\n{\nentity.motionY -= 0.1 * throttle;\n}\n}\nelse if (!verticalControl && !entity.onGround)\n{\nentity.motionY -= 0.1;\n}\nif (!followOwnerLook)\n{\/\/ TODO some way to make this change based on how long button is held?\nif (leftInputDown)\n{\npokemob.setHeading(pokemob.getHeading() - 5);\n}\nif (rightInputDown)\n{\npokemob.setHeading(pokemob.getHeading() + 5);\n}\n}\nelse if (!entity.getPassengers().isEmpty())\n{\npokemob.setHeading(controller.rotationYaw);\nfloat f = moveSpeed \/ 2;\nif (leftInputDown)\n{\nmove = true;\nif (shouldControl)\n{\nif (!entity.onGround) f *= 2;\nif (airSpeed) f *= config.flySpeedFactor;\n\nif (!entity.onGround) f *= 2;\nif (airSpeed) f *= config.flySpeedFactor;\nelse if (waterSpeed) f *= config.surfSpeedFactor;\nelse f *= config.groundSpeedFactor;\nentity.motionX -= MathHelper.cos(-entity.rotationYaw * 0.017453292F) * f;\nentity.motionZ -= MathHelper.sin(entity.rotationYaw * 0.017453292F) * f;\n}\nelse if (entity.isInLava() || entity.isInWater())\n{\nf *= 0.1;\nentity.motionX -= MathHelper.cos(-entity.rotationYaw * 0.017453292F) * f;\nentity.motionZ -= MathHelper.sin(entity.rotationYaw * 0.017453292F) * f;\n}\n}\n}\nif (!move)\n{\nentity.motionX *= 0.5;\nentity.motionZ *= 0.5;\n}\n\/\/ Sync the rotations.\nentity.setRenderYawOffset(pokemob.getHeading());\nentity.setRotationYawHead(pokemob.getHeading());\n}","label":[1,0,0,0]}
{"id":17267,"original_code":"public void split (FeatureSelection fs)\n\t\t{\n\t\t\tif (ilist == null)\n\t\t\t\tthrow new IllegalStateException (\"Frozen.  Cannot split.\");\n\t\t\tInstanceList ilist0 = new InstanceList (ilist.getPipe());\n\t\t\tInstanceList ilist1 = new InstanceList (ilist.getPipe());\n\t\t\tfor (int i = 0; i < ilist.size(); i++) {\n\t\t\t\tInstance instance = ilist.getInstance(i);\n\t\t\t\tFeatureVector fv = (FeatureVector) instance.getData ();\n\t\t\t\t\/\/ xxx What test should this be?  What to do with negative values?\n\t\t\t\t\t\/\/ Whatever is decided here should also go in InfoGain.calcInfoGains()\n\t\t\t\tif (fv.value (featureIndex) != 0) {\n\t\t\t\t\t\/\/System.out.println (\"list1 add \"+instance.getUri()+\" weight=\"+ilist.getInstanceWeight(i));\n\t\t\t\t\tilist1.add (instance, ilist.getInstanceWeight(i));\n\t\t\t\t} else {\n\t\t\t\t\t\/\/System.out.println (\"list0 add \"+instance.getUri()+\" weight=\"+ilist.getInstanceWeight(i));\n\t\t\t\t\tilist0.add (instance, ilist.getInstanceWeight(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tlogger.info(\"child0=\"+ilist0.size()+\" child1=\"+ilist1.size());\n\t\t\tchild0 = new Node (ilist0, this, fs);\n\t\t\tchild1 = new Node (ilist1, this, fs);\n\t\t}","code":"public void split (FeatureSelection fs)\n\t\t{\n\t\t\tif (ilist == null)\n\t\t\t\tthrow new IllegalStateException (\"Frozen.  Cannot split.\");\n\t\t\tInstanceList ilist0 = new InstanceList (ilist.getPipe());\n\t\t\tInstanceList ilist1 = new InstanceList (ilist.getPipe());\n\t\t\tfor (int i = 0; i < ilist.size(); i++) {\n\t\t\t\tInstance instance = ilist.getInstance(i);\n\t\t\t\tFeatureVector fv = (FeatureVector) instance.getData ();\n\t\t\t\n\t\t\t\t\n\t\t\t\tif (fv.value (featureIndex) != 0) {\n\t\t\t\t\n\t\t\t\t\tilist1.add (instance, ilist.getInstanceWeight(i));\n\t\t\t\t} else {\n\t\t\t\t\n\t\t\t\t\tilist0.add (instance, ilist.getInstanceWeight(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tlogger.info(\"child0=\"+ilist0.size()+\" child1=\"+ilist1.size());\n\t\t\tchild0 = new Node (ilist0, this, fs);\n\t\t\tchild1 = new Node (ilist1, this, fs);\n\t\t}","cleancode":"public void split (featureselection fs) { if (ilist == null) throw new illegalstateexception (\"frozen. cannot split.\"); instancelist ilist0 = new instancelist (ilist.getpipe()); instancelist ilist1 = new instancelist (ilist.getpipe()); for (int i = 0; i < ilist.size(); i++) { instance instance = ilist.getinstance(i); featurevector fv = (featurevector) instance.getdata (); if (fv.value (featureindex) != 0) { ilist1.add (instance, ilist.getinstanceweight(i)); } else { ilist0.add (instance, ilist.getinstanceweight(i)); } } logger.info(\"child0=\"+ilist0.size()+\" child1=\"+ilist1.size()); child0 = new node (ilist0, this, fs); child1 = new node (ilist1, this, fs); }","comment":"\/\/ xxx what test should this be? what to do with negative values? \/\/ whatever is decided here should also go in infogain.calcinfogains()\n\/\/system.out.println (\"list1 add \"+instance.geturi()+\" weight=\"+ilist.getinstanceweight(i));\n\/\/system.out.println (\"list0 add \"+instance.geturi()+\" weight=\"+ilist.getinstanceweight(i));","repo":"JULIELab\/jcore-dependencies","code_context_2":"Instance instance = ilist.getInstance(i);\nFeatureVector fv = (FeatureVector) instance.getData ();\n\/\/ xxx What test should this be? What to do with negative values?\n\/\/ Whatever is decided here should also go in InfoGain.calcInfoGains()\nif (fv.value (featureIndex) != 0) {\n\/\/System.out.println (\"list1 add \"+instance.getUri()+\" weight=\"+ilist.getInstanceWeight(i));\n\n\/\/ Whatever is decided here should also go in InfoGain.calcInfoGains()\nif (fv.value (featureIndex) != 0) {\n\/\/System.out.println (\"list1 add \"+instance.getUri()+\" weight=\"+ilist.getInstanceWeight(i));\nilist1.add (instance, ilist.getInstanceWeight(i));\n} else {\n\nilist1.add (instance, ilist.getInstanceWeight(i));\n} else {\n\/\/System.out.println (\"list0 add \"+instance.getUri()+\" weight=\"+ilist.getInstanceWeight(i));\nilist0.add (instance, ilist.getInstanceWeight(i));\n}","code_context_10":"public void split (FeatureSelection fs)\n{\nif (ilist == null)\nthrow new IllegalStateException (\"Frozen. Cannot split.\");\nInstanceList ilist0 = new InstanceList (ilist.getPipe());\nInstanceList ilist1 = new InstanceList (ilist.getPipe());\nfor (int i = 0; i < ilist.size(); i++) {\nInstance instance = ilist.getInstance(i);\nFeatureVector fv = (FeatureVector) instance.getData ();\n\/\/ xxx What test should this be? What to do with negative values?\n\/\/ Whatever is decided here should also go in InfoGain.calcInfoGains()\nif (fv.value (featureIndex) != 0) {\n\/\/System.out.println (\"list1 add \"+instance.getUri()+\" weight=\"+ilist.getInstanceWeight(i));\nilist1.add (instance, ilist.getInstanceWeight(i));\n} else {\n\/\/System.out.println (\"list0 add \"+instance.getUri()+\" weight=\"+ilist.getInstanceWeight(i));\nilist0.add (instance, ilist.getInstanceWeight(i));\n}\n}\nlogger.info(\"child0=\"+ilist0.size()+\" child1=\"+ilist1.size());\nchild0 = new Node (ilist0, this, fs);\n\nif (ilist == null)\nthrow new IllegalStateException (\"Frozen. Cannot split.\");\nInstanceList ilist0 = new InstanceList (ilist.getPipe());\nInstanceList ilist1 = new InstanceList (ilist.getPipe());\nfor (int i = 0; i < ilist.size(); i++) {\nInstance instance = ilist.getInstance(i);\nFeatureVector fv = (FeatureVector) instance.getData ();\n\/\/ xxx What test should this be? What to do with negative values?\n\/\/ Whatever is decided here should also go in InfoGain.calcInfoGains()\nif (fv.value (featureIndex) != 0) {\n\/\/System.out.println (\"list1 add \"+instance.getUri()+\" weight=\"+ilist.getInstanceWeight(i));\nilist1.add (instance, ilist.getInstanceWeight(i));\n} else {\n\/\/System.out.println (\"list0 add \"+instance.getUri()+\" weight=\"+ilist.getInstanceWeight(i));\nilist0.add (instance, ilist.getInstanceWeight(i));\n}\n}\nlogger.info(\"child0=\"+ilist0.size()+\" child1=\"+ilist1.size());\nchild0 = new Node (ilist0, this, fs);\nchild1 = new Node (ilist1, this, fs);\n}\n\nInstanceList ilist1 = new InstanceList (ilist.getPipe());\nfor (int i = 0; i < ilist.size(); i++) {\nInstance instance = ilist.getInstance(i);\nFeatureVector fv = (FeatureVector) instance.getData ();\n\/\/ xxx What test should this be? What to do with negative values?\n\/\/ Whatever is decided here should also go in InfoGain.calcInfoGains()\nif (fv.value (featureIndex) != 0) {\n\/\/System.out.println (\"list1 add \"+instance.getUri()+\" weight=\"+ilist.getInstanceWeight(i));\nilist1.add (instance, ilist.getInstanceWeight(i));\n} else {\n\/\/System.out.println (\"list0 add \"+instance.getUri()+\" weight=\"+ilist.getInstanceWeight(i));\nilist0.add (instance, ilist.getInstanceWeight(i));\n}\n}\nlogger.info(\"child0=\"+ilist0.size()+\" child1=\"+ilist1.size());\nchild0 = new Node (ilist0, this, fs);\nchild1 = new Node (ilist1, this, fs);\n}","code_context_20":"public void split (FeatureSelection fs)\n{\nif (ilist == null)\nthrow new IllegalStateException (\"Frozen. Cannot split.\");\nInstanceList ilist0 = new InstanceList (ilist.getPipe());\nInstanceList ilist1 = new InstanceList (ilist.getPipe());\nfor (int i = 0; i < ilist.size(); i++) {\nInstance instance = ilist.getInstance(i);\nFeatureVector fv = (FeatureVector) instance.getData ();\n\/\/ xxx What test should this be? What to do with negative values?\n\/\/ Whatever is decided here should also go in InfoGain.calcInfoGains()\nif (fv.value (featureIndex) != 0) {\n\/\/System.out.println (\"list1 add \"+instance.getUri()+\" weight=\"+ilist.getInstanceWeight(i));\nilist1.add (instance, ilist.getInstanceWeight(i));\n} else {\n\/\/System.out.println (\"list0 add \"+instance.getUri()+\" weight=\"+ilist.getInstanceWeight(i));\nilist0.add (instance, ilist.getInstanceWeight(i));\n}\n}\nlogger.info(\"child0=\"+ilist0.size()+\" child1=\"+ilist1.size());\nchild0 = new Node (ilist0, this, fs);\nchild1 = new Node (ilist1, this, fs);\n}\n\npublic void split (FeatureSelection fs)\n{\nif (ilist == null)\nthrow new IllegalStateException (\"Frozen. Cannot split.\");\nInstanceList ilist0 = new InstanceList (ilist.getPipe());\nInstanceList ilist1 = new InstanceList (ilist.getPipe());\nfor (int i = 0; i < ilist.size(); i++) {\nInstance instance = ilist.getInstance(i);\nFeatureVector fv = (FeatureVector) instance.getData ();\n\/\/ xxx What test should this be? What to do with negative values?\n\/\/ Whatever is decided here should also go in InfoGain.calcInfoGains()\nif (fv.value (featureIndex) != 0) {\n\/\/System.out.println (\"list1 add \"+instance.getUri()+\" weight=\"+ilist.getInstanceWeight(i));\nilist1.add (instance, ilist.getInstanceWeight(i));\n} else {\n\/\/System.out.println (\"list0 add \"+instance.getUri()+\" weight=\"+ilist.getInstanceWeight(i));\nilist0.add (instance, ilist.getInstanceWeight(i));\n}\n}\nlogger.info(\"child0=\"+ilist0.size()+\" child1=\"+ilist1.size());\nchild0 = new Node (ilist0, this, fs);\nchild1 = new Node (ilist1, this, fs);\n}\n\npublic void split (FeatureSelection fs)\n{\nif (ilist == null)\nthrow new IllegalStateException (\"Frozen. Cannot split.\");\nInstanceList ilist0 = new InstanceList (ilist.getPipe());\nInstanceList ilist1 = new InstanceList (ilist.getPipe());\nfor (int i = 0; i < ilist.size(); i++) {\nInstance instance = ilist.getInstance(i);\nFeatureVector fv = (FeatureVector) instance.getData ();\n\/\/ xxx What test should this be? What to do with negative values?\n\/\/ Whatever is decided here should also go in InfoGain.calcInfoGains()\nif (fv.value (featureIndex) != 0) {\n\/\/System.out.println (\"list1 add \"+instance.getUri()+\" weight=\"+ilist.getInstanceWeight(i));\nilist1.add (instance, ilist.getInstanceWeight(i));\n} else {\n\/\/System.out.println (\"list0 add \"+instance.getUri()+\" weight=\"+ilist.getInstanceWeight(i));\nilist0.add (instance, ilist.getInstanceWeight(i));\n}\n}\nlogger.info(\"child0=\"+ilist0.size()+\" child1=\"+ilist1.size());\nchild0 = new Node (ilist0, this, fs);\nchild1 = new Node (ilist1, this, fs);\n}","label":[0,0,0,1]}
{"id":25541,"original_code":"Uri findNext() {\n        \/\/ TODO: Unify with searchSubtitles()\n        if (mPrefs.scopeUri != null || isTvBox) {\n            DocumentFile video = null;\n            File videoRaw = null;\n            if (!isTvBox && mPrefs.scopeUri != null) {\n                if (\"com.android.externalstorage.documents\".equals(mPrefs.mediaUri.getHost())) {\n                    \/\/ Fast search based on path in uri\n                    video = SubtitleUtils.findUriInScope(this, mPrefs.scopeUri, mPrefs.mediaUri);\n                } else {\n                    \/\/ Slow search based on matching metadata, no path in uri\n                    \/\/ Provider \"com.android.providers.media.documents\" when using \"Videos\" tab in file picker\n                    DocumentFile fileScope = DocumentFile.fromTreeUri(this, mPrefs.scopeUri);\n                    DocumentFile fileMedia = DocumentFile.fromSingleUri(this, mPrefs.mediaUri);\n                    video = SubtitleUtils.findDocInScope(fileScope, fileMedia);\n                }\n            } else if (isTvBox) {\n                videoRaw = new File(mPrefs.mediaUri.getSchemeSpecificPart());\n                video = DocumentFile.fromFile(videoRaw);\n            }\n            if (video != null) {\n                DocumentFile next;\n                if (!isTvBox) {\n                    next = SubtitleUtils.findNext(video);\n                } else {\n                    File parentRaw = videoRaw.getParentFile();\n                    DocumentFile dir = DocumentFile.fromFile(parentRaw);\n                    next = SubtitleUtils.findNext(video, dir);\n                }\n                if (next != null) {\n                    return next.getUri();\n                }\n            }\n        }\n        return null;\n    }","code":"Uri findNext() {\n       \n        if (mPrefs.scopeUri != null || isTvBox) {\n            DocumentFile video = null;\n            File videoRaw = null;\n            if (!isTvBox && mPrefs.scopeUri != null) {\n                if (\"com.android.externalstorage.documents\".equals(mPrefs.mediaUri.getHost())) {\n                   \n                    video = SubtitleUtils.findUriInScope(this, mPrefs.scopeUri, mPrefs.mediaUri);\n                } else {\n                   \n                   \n                    DocumentFile fileScope = DocumentFile.fromTreeUri(this, mPrefs.scopeUri);\n                    DocumentFile fileMedia = DocumentFile.fromSingleUri(this, mPrefs.mediaUri);\n                    video = SubtitleUtils.findDocInScope(fileScope, fileMedia);\n                }\n            } else if (isTvBox) {\n                videoRaw = new File(mPrefs.mediaUri.getSchemeSpecificPart());\n                video = DocumentFile.fromFile(videoRaw);\n            }\n            if (video != null) {\n                DocumentFile next;\n                if (!isTvBox) {\n                    next = SubtitleUtils.findNext(video);\n                } else {\n                    File parentRaw = videoRaw.getParentFile();\n                    DocumentFile dir = DocumentFile.fromFile(parentRaw);\n                    next = SubtitleUtils.findNext(video, dir);\n                }\n                if (next != null) {\n                    return next.getUri();\n                }\n            }\n        }\n        return null;\n    }","cleancode":"uri findnext() { if (mprefs.scopeuri != null || istvbox) { documentfile video = null; file videoraw = null; if (!istvbox && mprefs.scopeuri != null) { if (\"com.android.externalstorage.documents\".equals(mprefs.mediauri.gethost())) { video = subtitleutils.finduriinscope(this, mprefs.scopeuri, mprefs.mediauri); } else { documentfile filescope = documentfile.fromtreeuri(this, mprefs.scopeuri); documentfile filemedia = documentfile.fromsingleuri(this, mprefs.mediauri); video = subtitleutils.finddocinscope(filescope, filemedia); } } else if (istvbox) { videoraw = new file(mprefs.mediauri.getschemespecificpart()); video = documentfile.fromfile(videoraw); } if (video != null) { documentfile next; if (!istvbox) { next = subtitleutils.findnext(video); } else { file parentraw = videoraw.getparentfile(); documentfile dir = documentfile.fromfile(parentraw); next = subtitleutils.findnext(video, dir); } if (next != null) { return next.geturi(); } } } return null; }","comment":"\/\/ todo: unify with searchsubtitles()\n\/\/ fast search based on path in uri\n\/\/ slow search based on matching metadata, no path in uri \/\/ provider \"com.android.providers.media.documents\" when using \"videos\" tab in file picker","repo":"Radfanyemen\/Player","code_context_2":"Uri findNext() {\n\/\/ TODO: Unify with searchSubtitles()\nif (mPrefs.scopeUri != null || isTvBox) {\nDocumentFile video = null;\n\nif (!isTvBox && mPrefs.scopeUri != null) {\nif (\"com.android.externalstorage.documents\".equals(mPrefs.mediaUri.getHost())) {\n\/\/ Fast search based on path in uri\nvideo = SubtitleUtils.findUriInScope(this, mPrefs.scopeUri, mPrefs.mediaUri);\n} else {\n\nvideo = SubtitleUtils.findUriInScope(this, mPrefs.scopeUri, mPrefs.mediaUri);\n} else {\n\/\/ Slow search based on matching metadata, no path in uri\n\/\/ Provider \"com.android.providers.media.documents\" when using \"Videos\" tab in file picker\nDocumentFile fileScope = DocumentFile.fromTreeUri(this, mPrefs.scopeUri);\nDocumentFile fileMedia = DocumentFile.fromSingleUri(this, mPrefs.mediaUri);","code_context_10":"Uri findNext() {\n\/\/ TODO: Unify with searchSubtitles()\nif (mPrefs.scopeUri != null || isTvBox) {\nDocumentFile video = null;\nFile videoRaw = null;\nif (!isTvBox && mPrefs.scopeUri != null) {\nif (\"com.android.externalstorage.documents\".equals(mPrefs.mediaUri.getHost())) {\n\/\/ Fast search based on path in uri\nvideo = SubtitleUtils.findUriInScope(this, mPrefs.scopeUri, mPrefs.mediaUri);\n} else {\n\/\/ Slow search based on matching metadata, no path in uri\n\/\/ Provider \"com.android.providers.media.documents\" when using \"Videos\" tab in file picker\n\nUri findNext() {\n\/\/ TODO: Unify with searchSubtitles()\nif (mPrefs.scopeUri != null || isTvBox) {\nDocumentFile video = null;\nFile videoRaw = null;\nif (!isTvBox && mPrefs.scopeUri != null) {\nif (\"com.android.externalstorage.documents\".equals(mPrefs.mediaUri.getHost())) {\n\/\/ Fast search based on path in uri\nvideo = SubtitleUtils.findUriInScope(this, mPrefs.scopeUri, mPrefs.mediaUri);\n} else {\n\/\/ Slow search based on matching metadata, no path in uri\n\/\/ Provider \"com.android.providers.media.documents\" when using \"Videos\" tab in file picker\nDocumentFile fileScope = DocumentFile.fromTreeUri(this, mPrefs.scopeUri);\nDocumentFile fileMedia = DocumentFile.fromSingleUri(this, mPrefs.mediaUri);\nvideo = SubtitleUtils.findDocInScope(fileScope, fileMedia);\n}\n} else if (isTvBox) {\nvideoRaw = new File(mPrefs.mediaUri.getSchemeSpecificPart());\n\nUri findNext() {\n\/\/ TODO: Unify with searchSubtitles()\nif (mPrefs.scopeUri != null || isTvBox) {\nDocumentFile video = null;\nFile videoRaw = null;\nif (!isTvBox && mPrefs.scopeUri != null) {\nif (\"com.android.externalstorage.documents\".equals(mPrefs.mediaUri.getHost())) {\n\/\/ Fast search based on path in uri\nvideo = SubtitleUtils.findUriInScope(this, mPrefs.scopeUri, mPrefs.mediaUri);\n} else {\n\/\/ Slow search based on matching metadata, no path in uri\n\/\/ Provider \"com.android.providers.media.documents\" when using \"Videos\" tab in file picker\nDocumentFile fileScope = DocumentFile.fromTreeUri(this, mPrefs.scopeUri);\nDocumentFile fileMedia = DocumentFile.fromSingleUri(this, mPrefs.mediaUri);\nvideo = SubtitleUtils.findDocInScope(fileScope, fileMedia);\n}\n} else if (isTvBox) {\nvideoRaw = new File(mPrefs.mediaUri.getSchemeSpecificPart());\nvideo = DocumentFile.fromFile(videoRaw);\n}\nif (video != null) {\nDocumentFile next;","code_context_20":"Uri findNext() {\n\/\/ TODO: Unify with searchSubtitles()\nif (mPrefs.scopeUri != null || isTvBox) {\nDocumentFile video = null;\nFile videoRaw = null;\nif (!isTvBox && mPrefs.scopeUri != null) {\nif (\"com.android.externalstorage.documents\".equals(mPrefs.mediaUri.getHost())) {\n\/\/ Fast search based on path in uri\nvideo = SubtitleUtils.findUriInScope(this, mPrefs.scopeUri, mPrefs.mediaUri);\n} else {\n\/\/ Slow search based on matching metadata, no path in uri\n\/\/ Provider \"com.android.providers.media.documents\" when using \"Videos\" tab in file picker\nDocumentFile fileScope = DocumentFile.fromTreeUri(this, mPrefs.scopeUri);\nDocumentFile fileMedia = DocumentFile.fromSingleUri(this, mPrefs.mediaUri);\nvideo = SubtitleUtils.findDocInScope(fileScope, fileMedia);\n}\n} else if (isTvBox) {\nvideoRaw = new File(mPrefs.mediaUri.getSchemeSpecificPart());\nvideo = DocumentFile.fromFile(videoRaw);\n}\nif (video != null) {\nDocumentFile next;\n\nUri findNext() {\n\/\/ TODO: Unify with searchSubtitles()\nif (mPrefs.scopeUri != null || isTvBox) {\nDocumentFile video = null;\nFile videoRaw = null;\nif (!isTvBox && mPrefs.scopeUri != null) {\nif (\"com.android.externalstorage.documents\".equals(mPrefs.mediaUri.getHost())) {\n\/\/ Fast search based on path in uri\nvideo = SubtitleUtils.findUriInScope(this, mPrefs.scopeUri, mPrefs.mediaUri);\n} else {\n\/\/ Slow search based on matching metadata, no path in uri\n\/\/ Provider \"com.android.providers.media.documents\" when using \"Videos\" tab in file picker\nDocumentFile fileScope = DocumentFile.fromTreeUri(this, mPrefs.scopeUri);\nDocumentFile fileMedia = DocumentFile.fromSingleUri(this, mPrefs.mediaUri);\nvideo = SubtitleUtils.findDocInScope(fileScope, fileMedia);\n}\n} else if (isTvBox) {\nvideoRaw = new File(mPrefs.mediaUri.getSchemeSpecificPart());\nvideo = DocumentFile.fromFile(videoRaw);\n}\nif (video != null) {\nDocumentFile next;\nif (!isTvBox) {\nnext = SubtitleUtils.findNext(video);\n} else {\nFile parentRaw = videoRaw.getParentFile();\nDocumentFile dir = DocumentFile.fromFile(parentRaw);\nnext = SubtitleUtils.findNext(video, dir);\n\nUri findNext() {\n\/\/ TODO: Unify with searchSubtitles()\nif (mPrefs.scopeUri != null || isTvBox) {\nDocumentFile video = null;\nFile videoRaw = null;\nif (!isTvBox && mPrefs.scopeUri != null) {\nif (\"com.android.externalstorage.documents\".equals(mPrefs.mediaUri.getHost())) {\n\/\/ Fast search based on path in uri\nvideo = SubtitleUtils.findUriInScope(this, mPrefs.scopeUri, mPrefs.mediaUri);\n} else {\n\/\/ Slow search based on matching metadata, no path in uri\n\/\/ Provider \"com.android.providers.media.documents\" when using \"Videos\" tab in file picker\nDocumentFile fileScope = DocumentFile.fromTreeUri(this, mPrefs.scopeUri);\nDocumentFile fileMedia = DocumentFile.fromSingleUri(this, mPrefs.mediaUri);\nvideo = SubtitleUtils.findDocInScope(fileScope, fileMedia);\n}\n} else if (isTvBox) {\nvideoRaw = new File(mPrefs.mediaUri.getSchemeSpecificPart());\nvideo = DocumentFile.fromFile(videoRaw);\n}\nif (video != null) {\nDocumentFile next;\nif (!isTvBox) {\nnext = SubtitleUtils.findNext(video);\n} else {\nFile parentRaw = videoRaw.getParentFile();\nDocumentFile dir = DocumentFile.fromFile(parentRaw);\nnext = SubtitleUtils.findNext(video, dir);\n}\nif (next != null) {\nreturn next.getUri();\n}","label":[0,1,0,0]}
{"id":17459,"original_code":"private void mOSActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_mOSActionPerformed\n        \/\/ TODO add your handling code here:\n      \/\/ new ViewOrdemServico().setVisible(true);\n    }","code":"private void mOSActionPerformed(java.awt.event.ActionEvent evt) {       \n     \n    }","cleancode":"private void mosactionperformed(java.awt.event.actionevent evt) { }","comment":"\/\/gen-first:event_mosactionperformed\n\/\/ todo add your handling code here: \/\/ new viewordemservico().setvisible(true);","repo":"LeandroDosSantosPereira\/sistemaBarbearia","code_context_2":"private void mOSActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_mOSActionPerformed\n\/\/ TODO add your handling code here:\n\/\/ new ViewOrdemServico().setVisible(true);\n\nprivate void mOSActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_mOSActionPerformed\n\/\/ TODO add your handling code here:\n\/\/ new ViewOrdemServico().setVisible(true);\n}","code_context_10":"private void mOSActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_mOSActionPerformed\n\/\/ TODO add your handling code here:\n\/\/ new ViewOrdemServico().setVisible(true);\n}\n\nprivate void mOSActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_mOSActionPerformed\n\/\/ TODO add your handling code here:\n\/\/ new ViewOrdemServico().setVisible(true);\n}","code_context_20":"private void mOSActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_mOSActionPerformed\n\/\/ TODO add your handling code here:\n\/\/ new ViewOrdemServico().setVisible(true);\n}\n\nprivate void mOSActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_mOSActionPerformed\n\/\/ TODO add your handling code here:\n\/\/ new ViewOrdemServico().setVisible(true);\n}","label":[0,1,0,0]}
{"id":9278,"original_code":"@SubscribeEvent(priority = EventPriority.NORMAL)\n\tpublic void onRenderOverlay(RenderGameOverlayEvent.Post event) {\n        \/*\n        if (event.getType() != RenderGameOverlayEvent.ElementType.CROSSHAIRS) {\n            return;\n        }\n        FIXME: still needed? if so, search for ported way\n         *\/\n\t\tItemStack activeStack = mc.player.getUseItem();\n\t\tif (activeStack.getItem() instanceof ModularCrossbowItem) {\n\t\t\tModularCrossbowItem item = (ModularCrossbowItem) activeStack.getItem();\n\t\t\tgui.setProgress(item.getProgress(activeStack, mc.player), 0);\n\t\t} else {\n\t\t\tgui.setProgress(0, 0);\n\t\t}\n\t\tgui.draw();\n\t}","code":"@SubscribeEvent(priority = EventPriority.NORMAL)\n\tpublic void onRenderOverlay(RenderGameOverlayEvent.Post event) {\n       \n\t\tItemStack activeStack = mc.player.getUseItem();\n\t\tif (activeStack.getItem() instanceof ModularCrossbowItem) {\n\t\t\tModularCrossbowItem item = (ModularCrossbowItem) activeStack.getItem();\n\t\t\tgui.setProgress(item.getProgress(activeStack, mc.player), 0);\n\t\t} else {\n\t\t\tgui.setProgress(0, 0);\n\t\t}\n\t\tgui.draw();\n\t}","cleancode":"@subscribeevent(priority = eventpriority.normal) public void onrenderoverlay(rendergameoverlayevent.post event) { itemstack activestack = mc.player.getuseitem(); if (activestack.getitem() instanceof modularcrossbowitem) { modularcrossbowitem item = (modularcrossbowitem) activestack.getitem(); gui.setprogress(item.getprogress(activestack, mc.player), 0); } else { gui.setprogress(0, 0); } gui.draw(); }","comment":"\/* if (event.gettype() != rendergameoverlayevent.elementtype.crosshairs) { return; } fixme: still needed? if so, search for ported way *\/","repo":"LordGrimmauld\/tetra","code_context_2":"@SubscribeEvent(priority = EventPriority.NORMAL)\npublic void onRenderOverlay(RenderGameOverlayEvent.Post event) {\n\/*\nif (event.getType() != RenderGameOverlayEvent.ElementType.CROSSHAIRS) {\nreturn;\n}\nFIXME: still needed? if so, search for ported way\n*\/\nItemStack activeStack = mc.player.getUseItem();\nif (activeStack.getItem() instanceof ModularCrossbowItem) {","code_context_10":"@SubscribeEvent(priority = EventPriority.NORMAL)\npublic void onRenderOverlay(RenderGameOverlayEvent.Post event) {\n\/*\nif (event.getType() != RenderGameOverlayEvent.ElementType.CROSSHAIRS) {\nreturn;\n}\nFIXME: still needed? if so, search for ported way\n*\/\nItemStack activeStack = mc.player.getUseItem();\nif (activeStack.getItem() instanceof ModularCrossbowItem) {\nModularCrossbowItem item = (ModularCrossbowItem) activeStack.getItem();\ngui.setProgress(item.getProgress(activeStack, mc.player), 0);\n} else {\ngui.setProgress(0, 0);\n}\ngui.draw();\n}","code_context_20":"@SubscribeEvent(priority = EventPriority.NORMAL)\npublic void onRenderOverlay(RenderGameOverlayEvent.Post event) {\n\/*\nif (event.getType() != RenderGameOverlayEvent.ElementType.CROSSHAIRS) {\nreturn;\n}\nFIXME: still needed? if so, search for ported way\n*\/\nItemStack activeStack = mc.player.getUseItem();\nif (activeStack.getItem() instanceof ModularCrossbowItem) {\nModularCrossbowItem item = (ModularCrossbowItem) activeStack.getItem();\ngui.setProgress(item.getProgress(activeStack, mc.player), 0);\n} else {\ngui.setProgress(0, 0);\n}\ngui.draw();\n}","label":[1,0,0,0]}
{"id":33945,"original_code":"public static boolean isAlphabetic(String s) {\n        if (isEmpty(s)) return defaultEmptyOK;\n        \/\/ Search through string's characters one by one\n        \/\/ until we find a non-alphabetic character.\n        \/\/ When we do, return false; if we don't, return true.\n        for (int i = 0; i < s.length(); i++) {\n            \/\/ Check that current character is letter.\n            char c = s.charAt(i);\n            if (!isLetter(c))\n                return false;\n        }\n        \/\/ All characters are letters.\n        return true;\n    }","code":"public static boolean isAlphabetic(String s) {\n        if (isEmpty(s)) return defaultEmptyOK;\n       \n       \n       \n        for (int i = 0; i < s.length(); i++) {\n           \n            char c = s.charAt(i);\n            if (!isLetter(c))\n                return false;\n        }\n       \n        return true;\n    }","cleancode":"public static boolean isalphabetic(string s) { if (isempty(s)) return defaultemptyok; for (int i = 0; i < s.length(); i++) { char c = s.charat(i); if (!isletter(c)) return false; } return true; }","comment":"\/** returns true if string s is letters only. * * note: this should handle i18n version to support european characters, etc. * since it now uses character.isletter() *\/\n\/\/ search through string's characters one by one \/\/ until we find a non-alphabetic character. \/\/ when we do, return false; if we don't, return true.\n\/\/ check that current character is letter.\n\/\/ all characters are letters.","repo":"Mark110\/e-commerce","code_context_2":"public static boolean isAlphabetic(String s) {\nif (isEmpty(s)) return defaultEmptyOK;\n\/\/ Search through string's characters one by one\n\/\/ until we find a non-alphabetic character.\n\/\/ When we do, return false; if we don't, return true.\nfor (int i = 0; i < s.length(); i++) {\n\/\/ Check that current character is letter.\nchar c = s.charAt(i);\nif (!isLetter(c))\nreturn false;\n}\n\/\/ All characters are letters.\nreturn true;\n}\n\npublic static boolean isAlphabetic(String s) {\nif (isEmpty(s)) return defaultEmptyOK;\n\/\/ Search through string's characters one by one\n\/\/ until we find a non-alphabetic character.\n\/\/ When we do, return false; if we don't, return true.\nfor (int i = 0; i < s.length(); i++) {\n\/\/ Check that current character is letter.\n\n\/\/ When we do, return false; if we don't, return true.\nfor (int i = 0; i < s.length(); i++) {\n\/\/ Check that current character is letter.\nchar c = s.charAt(i);\nif (!isLetter(c))\n\nreturn false;\n}\n\/\/ All characters are letters.\nreturn true;\n}","code_context_10":"public static boolean isAlphabetic(String s) {\nif (isEmpty(s)) return defaultEmptyOK;\n\/\/ Search through string's characters one by one\n\/\/ until we find a non-alphabetic character.\n\/\/ When we do, return false; if we don't, return true.\nfor (int i = 0; i < s.length(); i++) {\n\/\/ Check that current character is letter.\nchar c = s.charAt(i);\nif (!isLetter(c))\nreturn false;\n}\n\/\/ All characters are letters.\nreturn true;\n}\n\npublic static boolean isAlphabetic(String s) {\nif (isEmpty(s)) return defaultEmptyOK;\n\/\/ Search through string's characters one by one\n\/\/ until we find a non-alphabetic character.\n\/\/ When we do, return false; if we don't, return true.\nfor (int i = 0; i < s.length(); i++) {\n\/\/ Check that current character is letter.\nchar c = s.charAt(i);\nif (!isLetter(c))\nreturn false;\n}\n\/\/ All characters are letters.\nreturn true;\n}\n\npublic static boolean isAlphabetic(String s) {\nif (isEmpty(s)) return defaultEmptyOK;\n\/\/ Search through string's characters one by one\n\/\/ until we find a non-alphabetic character.\n\/\/ When we do, return false; if we don't, return true.\nfor (int i = 0; i < s.length(); i++) {\n\/\/ Check that current character is letter.\nchar c = s.charAt(i);\nif (!isLetter(c))\nreturn false;\n}\n\/\/ All characters are letters.\nreturn true;\n}\n\nif (isEmpty(s)) return defaultEmptyOK;\n\/\/ Search through string's characters one by one\n\/\/ until we find a non-alphabetic character.\n\/\/ When we do, return false; if we don't, return true.\nfor (int i = 0; i < s.length(); i++) {\n\/\/ Check that current character is letter.\nchar c = s.charAt(i);\nif (!isLetter(c))\nreturn false;\n}\n\/\/ All characters are letters.\nreturn true;\n}","code_context_20":"public static boolean isAlphabetic(String s) {\nif (isEmpty(s)) return defaultEmptyOK;\n\/\/ Search through string's characters one by one\n\/\/ until we find a non-alphabetic character.\n\/\/ When we do, return false; if we don't, return true.\nfor (int i = 0; i < s.length(); i++) {\n\/\/ Check that current character is letter.\nchar c = s.charAt(i);\nif (!isLetter(c))\nreturn false;\n}\n\/\/ All characters are letters.\nreturn true;\n}\n\npublic static boolean isAlphabetic(String s) {\nif (isEmpty(s)) return defaultEmptyOK;\n\/\/ Search through string's characters one by one\n\/\/ until we find a non-alphabetic character.\n\/\/ When we do, return false; if we don't, return true.\nfor (int i = 0; i < s.length(); i++) {\n\/\/ Check that current character is letter.\nchar c = s.charAt(i);\nif (!isLetter(c))\nreturn false;\n}\n\/\/ All characters are letters.\nreturn true;\n}\n\npublic static boolean isAlphabetic(String s) {\nif (isEmpty(s)) return defaultEmptyOK;\n\/\/ Search through string's characters one by one\n\/\/ until we find a non-alphabetic character.\n\/\/ When we do, return false; if we don't, return true.\nfor (int i = 0; i < s.length(); i++) {\n\/\/ Check that current character is letter.\nchar c = s.charAt(i);\nif (!isLetter(c))\nreturn false;\n}\n\/\/ All characters are letters.\nreturn true;\n}\n\npublic static boolean isAlphabetic(String s) {\nif (isEmpty(s)) return defaultEmptyOK;\n\/\/ Search through string's characters one by one\n\/\/ until we find a non-alphabetic character.\n\/\/ When we do, return false; if we don't, return true.\nfor (int i = 0; i < s.length(); i++) {\n\/\/ Check that current character is letter.\nchar c = s.charAt(i);\nif (!isLetter(c))\nreturn false;\n}\n\/\/ All characters are letters.\nreturn true;\n}","label":[1,0,0,0]}
{"id":17649,"original_code":"private void rollupParameters(TLParamGroup sourceParamGroup, TLParamGroup targetParamGroup,\n        RollupReferenceHandler referenceHandler, ModelElementCloner cloner) {\n        for (TLParameter sourceParam : sourceParamGroup.getParameters()) {\n            TLMemberField<?> sourceFieldRef = sourceParam.getFieldRef();\n            if (sourceFieldRef != null) {\n                TLParameter targetParam = targetParamGroup.getParameter( sourceFieldRef.getName() );\n                if (targetParam == null) {\n                    targetParam = cloner.clone( sourceParam ); \/\/ TODO: After cloning, targetParam.fieldRef is null\n                    targetParamGroup.addParameter( targetParam );\n                    referenceHandler.captureRollupReferences( targetParam );\n                }\n                if (targetParam.getDocumentation() == null) {\n                    targetParam.setDocumentation( cloner.clone( sourceParam.getDocumentation() ) );\n                }\n            }\n        }\n    }","code":"private void rollupParameters(TLParamGroup sourceParamGroup, TLParamGroup targetParamGroup,\n        RollupReferenceHandler referenceHandler, ModelElementCloner cloner) {\n        for (TLParameter sourceParam : sourceParamGroup.getParameters()) {\n            TLMemberField<?> sourceFieldRef = sourceParam.getFieldRef();\n            if (sourceFieldRef != null) {\n                TLParameter targetParam = targetParamGroup.getParameter( sourceFieldRef.getName() );\n                if (targetParam == null) {\n                    targetParam = cloner.clone( sourceParam );\n                    targetParamGroup.addParameter( targetParam );\n                    referenceHandler.captureRollupReferences( targetParam );\n                }\n                if (targetParam.getDocumentation() == null) {\n                    targetParam.setDocumentation( cloner.clone( sourceParam.getDocumentation() ) );\n                }\n            }\n        }\n    }","cleancode":"private void rollupparameters(tlparamgroup sourceparamgroup, tlparamgroup targetparamgroup, rollupreferencehandler referencehandler, modelelementcloner cloner) { for (tlparameter sourceparam : sourceparamgroup.getparameters()) { tlmemberfield<?> sourcefieldref = sourceparam.getfieldref(); if (sourcefieldref != null) { tlparameter targetparam = targetparamgroup.getparameter( sourcefieldref.getname() ); if (targetparam == null) { targetparam = cloner.clone( sourceparam ); targetparamgroup.addparameter( targetparam ); referencehandler.capturerollupreferences( targetparam ); } if (targetparam.getdocumentation() == null) { targetparam.setdocumentation( cloner.clone( sourceparam.getdocumentation() ) ); } } } }","comment":"\/** * rollup the parameters of the given source parameter group. * * @param sourceparamgroup the parameter group to be rolled up * @param targetparamgroup the group that will receive the rolled up content * @param referencehandler the rollup reference handler instance * @param cloner used for cloning model element as required *\/\n\/\/ todo: after cloning, targetparam.fieldref is null","repo":"OpenTravel\/OTM-DE-Compiler","code_context_2":"private void rollupParameters(TLParamGroup sourceParamGroup, TLParamGroup targetParamGroup,\nRollupReferenceHandler referenceHandler, ModelElementCloner cloner) {\nfor (TLParameter sourceParam : sourceParamGroup.getParameters()) {\nTLMemberField<?> sourceFieldRef = sourceParam.getFieldRef();\nif (sourceFieldRef != null) {\nTLParameter targetParam = targetParamGroup.getParameter( sourceFieldRef.getName() );\nif (targetParam == null) {\ntargetParam = cloner.clone( sourceParam ); \/\/ TODO: After cloning, targetParam.fieldRef is null\ntargetParamGroup.addParameter( targetParam );\nreferenceHandler.captureRollupReferences( targetParam );\n}\nif (targetParam.getDocumentation() == null) {\ntargetParam.setDocumentation( cloner.clone( sourceParam.getDocumentation() ) );\n}\n}\n}\n}\n\nTLParameter targetParam = targetParamGroup.getParameter( sourceFieldRef.getName() );\nif (targetParam == null) {\ntargetParam = cloner.clone( sourceParam ); \/\/ TODO: After cloning, targetParam.fieldRef is null\ntargetParamGroup.addParameter( targetParam );\nreferenceHandler.captureRollupReferences( targetParam );","code_context_10":"private void rollupParameters(TLParamGroup sourceParamGroup, TLParamGroup targetParamGroup,\nRollupReferenceHandler referenceHandler, ModelElementCloner cloner) {\nfor (TLParameter sourceParam : sourceParamGroup.getParameters()) {\nTLMemberField<?> sourceFieldRef = sourceParam.getFieldRef();\nif (sourceFieldRef != null) {\nTLParameter targetParam = targetParamGroup.getParameter( sourceFieldRef.getName() );\nif (targetParam == null) {\ntargetParam = cloner.clone( sourceParam ); \/\/ TODO: After cloning, targetParam.fieldRef is null\ntargetParamGroup.addParameter( targetParam );\nreferenceHandler.captureRollupReferences( targetParam );\n}\nif (targetParam.getDocumentation() == null) {\ntargetParam.setDocumentation( cloner.clone( sourceParam.getDocumentation() ) );\n}\n}\n}\n}\n\nprivate void rollupParameters(TLParamGroup sourceParamGroup, TLParamGroup targetParamGroup,\nRollupReferenceHandler referenceHandler, ModelElementCloner cloner) {\nfor (TLParameter sourceParam : sourceParamGroup.getParameters()) {\nTLMemberField<?> sourceFieldRef = sourceParam.getFieldRef();\nif (sourceFieldRef != null) {\nTLParameter targetParam = targetParamGroup.getParameter( sourceFieldRef.getName() );\nif (targetParam == null) {\ntargetParam = cloner.clone( sourceParam ); \/\/ TODO: After cloning, targetParam.fieldRef is null\ntargetParamGroup.addParameter( targetParam );\nreferenceHandler.captureRollupReferences( targetParam );\n}\nif (targetParam.getDocumentation() == null) {\ntargetParam.setDocumentation( cloner.clone( sourceParam.getDocumentation() ) );\n}\n}\n}\n}","code_context_20":"private void rollupParameters(TLParamGroup sourceParamGroup, TLParamGroup targetParamGroup,\nRollupReferenceHandler referenceHandler, ModelElementCloner cloner) {\nfor (TLParameter sourceParam : sourceParamGroup.getParameters()) {\nTLMemberField<?> sourceFieldRef = sourceParam.getFieldRef();\nif (sourceFieldRef != null) {\nTLParameter targetParam = targetParamGroup.getParameter( sourceFieldRef.getName() );\nif (targetParam == null) {\ntargetParam = cloner.clone( sourceParam ); \/\/ TODO: After cloning, targetParam.fieldRef is null\ntargetParamGroup.addParameter( targetParam );\nreferenceHandler.captureRollupReferences( targetParam );\n}\nif (targetParam.getDocumentation() == null) {\ntargetParam.setDocumentation( cloner.clone( sourceParam.getDocumentation() ) );\n}\n}\n}\n}\n\nprivate void rollupParameters(TLParamGroup sourceParamGroup, TLParamGroup targetParamGroup,\nRollupReferenceHandler referenceHandler, ModelElementCloner cloner) {\nfor (TLParameter sourceParam : sourceParamGroup.getParameters()) {\nTLMemberField<?> sourceFieldRef = sourceParam.getFieldRef();\nif (sourceFieldRef != null) {\nTLParameter targetParam = targetParamGroup.getParameter( sourceFieldRef.getName() );\nif (targetParam == null) {\ntargetParam = cloner.clone( sourceParam ); \/\/ TODO: After cloning, targetParam.fieldRef is null\ntargetParamGroup.addParameter( targetParam );\nreferenceHandler.captureRollupReferences( targetParam );\n}\nif (targetParam.getDocumentation() == null) {\ntargetParam.setDocumentation( cloner.clone( sourceParam.getDocumentation() ) );\n}\n}\n}\n}","label":[0,1,0,0]}
{"id":9475,"original_code":"private static List<TestConfiguration> getAdditionalConfigurations(Activity activity) {\n        List<TestConfiguration> additionalConfigurations = new ArrayList<>();\n        if (Constants.USE_GMS_CONFIGURATION) {\n            additionalConfigurations.add(new GmsPermissionConfiguration(activity));\n        }\n        \/\/ TODO: Any custom configurations that are intended to be run as part of this test should\n        \/\/ be added here.\n        return additionalConfigurations;\n    }","code":"private static List<TestConfiguration> getAdditionalConfigurations(Activity activity) {\n        List<TestConfiguration> additionalConfigurations = new ArrayList<>();\n        if (Constants.USE_GMS_CONFIGURATION) {\n            additionalConfigurations.add(new GmsPermissionConfiguration(activity));\n        }\n       \n       \n        return additionalConfigurations;\n    }","cleancode":"private static list<testconfiguration> getadditionalconfigurations(activity activity) { list<testconfiguration> additionalconfigurations = new arraylist<>(); if (constants.use_gms_configuration) { additionalconfigurations.add(new gmspermissionconfiguration(activity)); } return additionalconfigurations; }","comment":"\/** * returns a {@link list} of additional {@link testconfiguration} instances that should be run * along with the default {@code testconfiguration} instances. * * <p>this typically includes a configuration to test google play services (if available) and * any other device specific configurations. *\/\n\/\/ todo: any custom configurations that are intended to be run as part of this test should \/\/ be added here.","repo":"LaudateCorpus1\/security-certification-resources","code_context_2":"private static List<TestConfiguration> getAdditionalConfigurations(Activity activity) {\nList<TestConfiguration> additionalConfigurations = new ArrayList<>();\nif (Constants.USE_GMS_CONFIGURATION) {\nadditionalConfigurations.add(new GmsPermissionConfiguration(activity));\n}\n\/\/ TODO: Any custom configurations that are intended to be run as part of this test should\n\/\/ be added here.\nreturn additionalConfigurations;\n}\n\nadditionalConfigurations.add(new GmsPermissionConfiguration(activity));\n}\n\/\/ TODO: Any custom configurations that are intended to be run as part of this test should\n\/\/ be added here.\nreturn additionalConfigurations;\n}","code_context_10":"private static List<TestConfiguration> getAdditionalConfigurations(Activity activity) {\nList<TestConfiguration> additionalConfigurations = new ArrayList<>();\nif (Constants.USE_GMS_CONFIGURATION) {\nadditionalConfigurations.add(new GmsPermissionConfiguration(activity));\n}\n\/\/ TODO: Any custom configurations that are intended to be run as part of this test should\n\/\/ be added here.\nreturn additionalConfigurations;\n}\n\nprivate static List<TestConfiguration> getAdditionalConfigurations(Activity activity) {\nList<TestConfiguration> additionalConfigurations = new ArrayList<>();\nif (Constants.USE_GMS_CONFIGURATION) {\nadditionalConfigurations.add(new GmsPermissionConfiguration(activity));\n}\n\/\/ TODO: Any custom configurations that are intended to be run as part of this test should\n\/\/ be added here.\nreturn additionalConfigurations;\n}","code_context_20":"private static List<TestConfiguration> getAdditionalConfigurations(Activity activity) {\nList<TestConfiguration> additionalConfigurations = new ArrayList<>();\nif (Constants.USE_GMS_CONFIGURATION) {\nadditionalConfigurations.add(new GmsPermissionConfiguration(activity));\n}\n\/\/ TODO: Any custom configurations that are intended to be run as part of this test should\n\/\/ be added here.\nreturn additionalConfigurations;\n}\n\nprivate static List<TestConfiguration> getAdditionalConfigurations(Activity activity) {\nList<TestConfiguration> additionalConfigurations = new ArrayList<>();\nif (Constants.USE_GMS_CONFIGURATION) {\nadditionalConfigurations.add(new GmsPermissionConfiguration(activity));\n}\n\/\/ TODO: Any custom configurations that are intended to be run as part of this test should\n\/\/ be added here.\nreturn additionalConfigurations;\n}","label":[1,0,0,0]}
{"id":9644,"original_code":"@Override\n  public void simpleRender(RenderManager rm) {\n    \/\/TODO: add render code\n  }","code":"@Override\n  public void simpleRender(RenderManager rm) {\n   \n  }","cleancode":"@override public void simplerender(rendermanager rm) { }","comment":"\/\/todo: add render code","repo":"MeFisto94\/test-bot-1","code_context_2":"@Override\npublic void simpleRender(RenderManager rm) {\n\/\/TODO: add render code\n}","code_context_10":"@Override\npublic void simpleRender(RenderManager rm) {\n\/\/TODO: add render code\n}","code_context_20":"@Override\npublic void simpleRender(RenderManager rm) {\n\/\/TODO: add render code\n}","label":[0,1,0,0]}
{"id":9670,"original_code":"public int applyLayers(int[] data) {\n        checkNotNull(data);\n        BlockVector3 minY = region.getMinimumPoint();\n        int originX = minY.getBlockX();\n        int originZ = minY.getBlockZ();\n        int maxY = region.getMaximumPoint().getBlockY();\n        BlockState fillerAir = BlockTypes.AIR.getDefaultState();\n        int blocksChanged = 0;\n        BlockStateHolder<BlockState> tmpBlock = BlockTypes.AIR.getDefaultState();\n        int maxY4 = maxY << 4;\n        int index = 0;\n        \/\/ Apply heightmap\n        for (int z = 0; z < height; ++z) {\n            int zr = z + originZ;\n            for (int x = 0; x < width; ++x) {\n                if (this.invalid != null && this.invalid[index]) {\n                    continue;\n                }\n                int curHeight = this.data[index];\n                \/\/Clamp newHeight within the selection area\n                int newHeight = Math.min(maxY4, data[index++]);\n                int curBlock = (curHeight) >> 4;\n                int newBlock = (newHeight + 15) >> 4;\n                \/\/ Offset x,z to be 'real' coordinates\n                int xr = x + originX;\n                \/\/ Depending on growing or shrinking we need to start at the bottom or top\n                if (newHeight > curHeight) {\n                    \/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\n                    BlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n                    \/\/ Skip water\/lava\n                    if (existing.getBlockType().getMaterial().isMovementBlocker()) {\n                        \/\/ Grow -- start from 1 below top replacing airblocks\n                        for (int setY = newBlock - 1, getY = curBlock; setY >= curBlock; --setY, getY--) {\n                            BlockStateHolder<BlockState> get = session.getBlock(xr, getY, zr);\n                            if (get != BlockTypes.AIR.getDefaultState()) {\n                                tmpBlock = get;\n                            }\n                            session.setBlock(xr, setY, zr, tmpBlock);\n                            ++blocksChanged;\n                        }\n                        int setData = newHeight & 15;\n                        if (setData != 0) {\n                            existing = PropertyGroup.LEVEL.set(existing, setData - 1);\n                            session.setBlock(xr, newBlock, zr, existing);\n                            ++blocksChanged;\n                        } else {\n                            existing = PropertyGroup.LEVEL.set(existing, 15);\n                            session.setBlock(xr, newBlock, zr, existing);\n                            ++blocksChanged;\n                        }\n                    }\n                } else if (curHeight > newHeight) {\n                    \/\/ Fill rest with air\n                    for (int y = newBlock + 1; y <= ((curHeight + 15) >> 4); ++y) {\n                        session.setBlock(xr, y, zr, fillerAir);\n                        ++blocksChanged;\n                    }\n                    \/\/ Set the top block of the column to be the same type\n                    \/\/ (this could otherwise go wrong with rounding)\n                    int setData = newHeight & 15;\n                    BlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n                    if (setData != 0) {\n                        existing = PropertyGroup.LEVEL.set(existing, setData - 1);\n                        session.setBlock(xr, newBlock, zr, existing);\n                    } else {\n                        existing = PropertyGroup.LEVEL.set(existing, 15);\n                        session.setBlock(xr, newBlock, zr, existing);\n                    }\n                    ++blocksChanged;\n                }\n            }\n        }\n        return blocksChanged;\n    }","code":"public int applyLayers(int[] data) {\n        checkNotNull(data);\n        BlockVector3 minY = region.getMinimumPoint();\n        int originX = minY.getBlockX();\n        int originZ = minY.getBlockZ();\n        int maxY = region.getMaximumPoint().getBlockY();\n        BlockState fillerAir = BlockTypes.AIR.getDefaultState();\n        int blocksChanged = 0;\n        BlockStateHolder<BlockState> tmpBlock = BlockTypes.AIR.getDefaultState();\n        int maxY4 = maxY << 4;\n        int index = 0;\n       \n        for (int z = 0; z < height; ++z) {\n            int zr = z + originZ;\n            for (int x = 0; x < width; ++x) {\n                if (this.invalid != null && this.invalid[index]) {\n                    continue;\n                }\n                int curHeight = this.data[index];\n               \n                int newHeight = Math.min(maxY4, data[index++]);\n                int curBlock = (curHeight) >> 4;\n                int newBlock = (newHeight + 15) >> 4;\n               \n                int xr = x + originX;\n               \n                if (newHeight > curHeight) {\n                   \n                    BlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n                   \n                    if (existing.getBlockType().getMaterial().isMovementBlocker()) {\n                       \n                        for (int setY = newBlock - 1, getY = curBlock; setY >= curBlock; --setY, getY--) {\n                            BlockStateHolder<BlockState> get = session.getBlock(xr, getY, zr);\n                            if (get != BlockTypes.AIR.getDefaultState()) {\n                                tmpBlock = get;\n                            }\n                            session.setBlock(xr, setY, zr, tmpBlock);\n                            ++blocksChanged;\n                        }\n                        int setData = newHeight & 15;\n                        if (setData != 0) {\n                            existing = PropertyGroup.LEVEL.set(existing, setData - 1);\n                            session.setBlock(xr, newBlock, zr, existing);\n                            ++blocksChanged;\n                        } else {\n                            existing = PropertyGroup.LEVEL.set(existing, 15);\n                            session.setBlock(xr, newBlock, zr, existing);\n                            ++blocksChanged;\n                        }\n                    }\n                } else if (curHeight > newHeight) {\n                   \n                    for (int y = newBlock + 1; y <= ((curHeight + 15) >> 4); ++y) {\n                        session.setBlock(xr, y, zr, fillerAir);\n                        ++blocksChanged;\n                    }\n                   \n                   \n                    int setData = newHeight & 15;\n                    BlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n                    if (setData != 0) {\n                        existing = PropertyGroup.LEVEL.set(existing, setData - 1);\n                        session.setBlock(xr, newBlock, zr, existing);\n                    } else {\n                        existing = PropertyGroup.LEVEL.set(existing, 15);\n                        session.setBlock(xr, newBlock, zr, existing);\n                    }\n                    ++blocksChanged;\n                }\n            }\n        }\n        return blocksChanged;\n    }","cleancode":"public int applylayers(int[] data) { checknotnull(data); blockvector3 miny = region.getminimumpoint(); int originx = miny.getblockx(); int originz = miny.getblockz(); int maxy = region.getmaximumpoint().getblocky(); blockstate fillerair = blocktypes.air.getdefaultstate(); int blockschanged = 0; blockstateholder<blockstate> tmpblock = blocktypes.air.getdefaultstate(); int maxy4 = maxy << 4; int index = 0; for (int z = 0; z < height; ++z) { int zr = z + originz; for (int x = 0; x < width; ++x) { if (this.invalid != null && this.invalid[index]) { continue; } int curheight = this.data[index]; int newheight = math.min(maxy4, data[index++]); int curblock = (curheight) >> 4; int newblock = (newheight + 15) >> 4; int xr = x + originx; if (newheight > curheight) { blockstateholder<blockstate> existing = session.getblock(xr, curblock, zr); if (existing.getblocktype().getmaterial().ismovementblocker()) { for (int sety = newblock - 1, gety = curblock; sety >= curblock; --sety, gety--) { blockstateholder<blockstate> get = session.getblock(xr, gety, zr); if (get != blocktypes.air.getdefaultstate()) { tmpblock = get; } session.setblock(xr, sety, zr, tmpblock); ++blockschanged; } int setdata = newheight & 15; if (setdata != 0) { existing = propertygroup.level.set(existing, setdata - 1); session.setblock(xr, newblock, zr, existing); ++blockschanged; } else { existing = propertygroup.level.set(existing, 15); session.setblock(xr, newblock, zr, existing); ++blockschanged; } } } else if (curheight > newheight) { for (int y = newblock + 1; y <= ((curheight + 15) >> 4); ++y) { session.setblock(xr, y, zr, fillerair); ++blockschanged; } int setdata = newheight & 15; blockstateholder<blockstate> existing = session.getblock(xr, curblock, zr); if (setdata != 0) { existing = propertygroup.level.set(existing, setdata - 1); session.setblock(xr, newblock, zr, existing); } else { existing = propertygroup.level.set(existing, 15); session.setblock(xr, newblock, zr, existing); } ++blockschanged; } } } return blockschanged; }","comment":"\/\/ apply heightmap\n\/\/clamp newheight within the selection area\n\/\/ offset x,z to be 'real' coordinates\n\/\/ depending on growing or shrinking we need to start at the bottom or top\n\/\/ set the top block of the column to be the same type (this might go wrong with rounding)\n\/\/ skip water\/lava\n\/\/ grow -- start from 1 below top replacing airblocks\n\/\/ fill rest with air\n\/\/ set the top block of the column to be the same type \/\/ (this could otherwise go wrong with rounding)","repo":"IronApollo\/FastAsyncWorldEdit","code_context_2":"int maxY4 = maxY << 4;\nint index = 0;\n\/\/ Apply heightmap\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\n\n}\nint curHeight = this.data[index];\n\/\/Clamp newHeight within the selection area\nint newHeight = Math.min(maxY4, data[index++]);\nint curBlock = (curHeight) >> 4;\n\nint curBlock = (curHeight) >> 4;\nint newBlock = (newHeight + 15) >> 4;\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\n\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\n\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n\/\/ Skip water\/lava\n\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\n\/\/ Grow -- start from 1 below top replacing airblocks\n\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\n\/\/ Grow -- start from 1 below top replacing airblocks\nfor (int setY = newBlock - 1, getY = curBlock; setY >= curBlock; --setY, getY--) {\nBlockStateHolder<BlockState> get = session.getBlock(xr, getY, zr);\n\n}\n} else if (curHeight > newHeight) {\n\/\/ Fill rest with air\nfor (int y = newBlock + 1; y <= ((curHeight + 15) >> 4); ++y) {\nsession.setBlock(xr, y, zr, fillerAir);\n\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {","code_context_10":"checkNotNull(data);\nBlockVector3 minY = region.getMinimumPoint();\nint originX = minY.getBlockX();\nint originZ = minY.getBlockZ();\nint maxY = region.getMaximumPoint().getBlockY();\nBlockState fillerAir = BlockTypes.AIR.getDefaultState();\nint blocksChanged = 0;\nBlockStateHolder<BlockState> tmpBlock = BlockTypes.AIR.getDefaultState();\nint maxY4 = maxY << 4;\nint index = 0;\n\/\/ Apply heightmap\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/Clamp newHeight within the selection area\nint newHeight = Math.min(maxY4, data[index++]);\nint curBlock = (curHeight) >> 4;\n\nint maxY4 = maxY << 4;\nint index = 0;\n\/\/ Apply heightmap\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/Clamp newHeight within the selection area\nint newHeight = Math.min(maxY4, data[index++]);\nint curBlock = (curHeight) >> 4;\nint newBlock = (newHeight + 15) >> 4;\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n\/\/ Skip water\/lava\n\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/Clamp newHeight within the selection area\nint newHeight = Math.min(maxY4, data[index++]);\nint curBlock = (curHeight) >> 4;\nint newBlock = (newHeight + 15) >> 4;\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\n\/\/ Grow -- start from 1 below top replacing airblocks\nfor (int setY = newBlock - 1, getY = curBlock; setY >= curBlock; --setY, getY--) {\nBlockStateHolder<BlockState> get = session.getBlock(xr, getY, zr);\n\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/Clamp newHeight within the selection area\nint newHeight = Math.min(maxY4, data[index++]);\nint curBlock = (curHeight) >> 4;\nint newBlock = (newHeight + 15) >> 4;\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\n\/\/ Grow -- start from 1 below top replacing airblocks\nfor (int setY = newBlock - 1, getY = curBlock; setY >= curBlock; --setY, getY--) {\nBlockStateHolder<BlockState> get = session.getBlock(xr, getY, zr);\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n\n}\nint curHeight = this.data[index];\n\/\/Clamp newHeight within the selection area\nint newHeight = Math.min(maxY4, data[index++]);\nint curBlock = (curHeight) >> 4;\nint newBlock = (newHeight + 15) >> 4;\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\n\/\/ Grow -- start from 1 below top replacing airblocks\nfor (int setY = newBlock - 1, getY = curBlock; setY >= curBlock; --setY, getY--) {\nBlockStateHolder<BlockState> get = session.getBlock(xr, getY, zr);\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n\n\/\/Clamp newHeight within the selection area\nint newHeight = Math.min(maxY4, data[index++]);\nint curBlock = (curHeight) >> 4;\nint newBlock = (newHeight + 15) >> 4;\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\n\/\/ Grow -- start from 1 below top replacing airblocks\nfor (int setY = newBlock - 1, getY = curBlock; setY >= curBlock; --setY, getY--) {\nBlockStateHolder<BlockState> get = session.getBlock(xr, getY, zr);\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n++blocksChanged;\n}\n\nint curBlock = (curHeight) >> 4;\nint newBlock = (newHeight + 15) >> 4;\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\n\/\/ Grow -- start from 1 below top replacing airblocks\nfor (int setY = newBlock - 1, getY = curBlock; setY >= curBlock; --setY, getY--) {\nBlockStateHolder<BlockState> get = session.getBlock(xr, getY, zr);\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n++blocksChanged;\n}\nint setData = newHeight & 15;\nif (setData != 0) {\n\nexisting = PropertyGroup.LEVEL.set(existing, setData - 1);\nsession.setBlock(xr, newBlock, zr, existing);\n++blocksChanged;\n} else {\nexisting = PropertyGroup.LEVEL.set(existing, 15);\nsession.setBlock(xr, newBlock, zr, existing);\n++blocksChanged;\n}\n}\n} else if (curHeight > newHeight) {\n\/\/ Fill rest with air\nfor (int y = newBlock + 1; y <= ((curHeight + 15) >> 4); ++y) {\nsession.setBlock(xr, y, zr, fillerAir);\n++blocksChanged;\n}\n\/\/ Set the top block of the column to be the same type\n\/\/ (this could otherwise go wrong with rounding)\nint setData = newHeight & 15;\nBlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\nif (setData != 0) {\nexisting = PropertyGroup.LEVEL.set(existing, setData - 1);\n\n}\nint curHeight = this.data[index];\n\/\/Clamp newHeight within the selection area\nint newHeight = Math.min(maxY4, data[index++]);\nint curBlock = (curHeight) >> 4;\nint newBlock = (newHeight + 15) >> 4;\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\n\/\/ Grow -- start from 1 below top replacing airblocks\nfor (int setY = newBlock - 1, getY = curBlock; setY >= curBlock; --setY, getY--) {\nBlockStateHolder<BlockState> get = session.getBlock(xr, getY, zr);\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n++blocksChanged;","code_context_20":"public int applyLayers(int[] data) {\ncheckNotNull(data);\nBlockVector3 minY = region.getMinimumPoint();\nint originX = minY.getBlockX();\nint originZ = minY.getBlockZ();\nint maxY = region.getMaximumPoint().getBlockY();\nBlockState fillerAir = BlockTypes.AIR.getDefaultState();\nint blocksChanged = 0;\nBlockStateHolder<BlockState> tmpBlock = BlockTypes.AIR.getDefaultState();\nint maxY4 = maxY << 4;\nint index = 0;\n\/\/ Apply heightmap\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/Clamp newHeight within the selection area\nint newHeight = Math.min(maxY4, data[index++]);\nint curBlock = (curHeight) >> 4;\nint newBlock = (newHeight + 15) >> 4;\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\n\/\/ Grow -- start from 1 below top replacing airblocks\n\npublic int applyLayers(int[] data) {\ncheckNotNull(data);\nBlockVector3 minY = region.getMinimumPoint();\nint originX = minY.getBlockX();\nint originZ = minY.getBlockZ();\nint maxY = region.getMaximumPoint().getBlockY();\nBlockState fillerAir = BlockTypes.AIR.getDefaultState();\nint blocksChanged = 0;\nBlockStateHolder<BlockState> tmpBlock = BlockTypes.AIR.getDefaultState();\nint maxY4 = maxY << 4;\nint index = 0;\n\/\/ Apply heightmap\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/Clamp newHeight within the selection area\nint newHeight = Math.min(maxY4, data[index++]);\nint curBlock = (curHeight) >> 4;\nint newBlock = (newHeight + 15) >> 4;\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\n\/\/ Grow -- start from 1 below top replacing airblocks\nfor (int setY = newBlock - 1, getY = curBlock; setY >= curBlock; --setY, getY--) {\nBlockStateHolder<BlockState> get = session.getBlock(xr, getY, zr);\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n++blocksChanged;\n}\n\nint originX = minY.getBlockX();\nint originZ = minY.getBlockZ();\nint maxY = region.getMaximumPoint().getBlockY();\nBlockState fillerAir = BlockTypes.AIR.getDefaultState();\nint blocksChanged = 0;\nBlockStateHolder<BlockState> tmpBlock = BlockTypes.AIR.getDefaultState();\nint maxY4 = maxY << 4;\nint index = 0;\n\/\/ Apply heightmap\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/Clamp newHeight within the selection area\nint newHeight = Math.min(maxY4, data[index++]);\nint curBlock = (curHeight) >> 4;\nint newBlock = (newHeight + 15) >> 4;\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\n\/\/ Grow -- start from 1 below top replacing airblocks\nfor (int setY = newBlock - 1, getY = curBlock; setY >= curBlock; --setY, getY--) {\nBlockStateHolder<BlockState> get = session.getBlock(xr, getY, zr);\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n++blocksChanged;\n}\nint setData = newHeight & 15;\nif (setData != 0) {\nexisting = PropertyGroup.LEVEL.set(existing, setData - 1);\nsession.setBlock(xr, newBlock, zr, existing);\n\nint maxY = region.getMaximumPoint().getBlockY();\nBlockState fillerAir = BlockTypes.AIR.getDefaultState();\nint blocksChanged = 0;\nBlockStateHolder<BlockState> tmpBlock = BlockTypes.AIR.getDefaultState();\nint maxY4 = maxY << 4;\nint index = 0;\n\/\/ Apply heightmap\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/Clamp newHeight within the selection area\nint newHeight = Math.min(maxY4, data[index++]);\nint curBlock = (curHeight) >> 4;\nint newBlock = (newHeight + 15) >> 4;\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\n\/\/ Grow -- start from 1 below top replacing airblocks\nfor (int setY = newBlock - 1, getY = curBlock; setY >= curBlock; --setY, getY--) {\nBlockStateHolder<BlockState> get = session.getBlock(xr, getY, zr);\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n++blocksChanged;\n}\nint setData = newHeight & 15;\nif (setData != 0) {\nexisting = PropertyGroup.LEVEL.set(existing, setData - 1);\nsession.setBlock(xr, newBlock, zr, existing);\n++blocksChanged;\n} else {\n\nint blocksChanged = 0;\nBlockStateHolder<BlockState> tmpBlock = BlockTypes.AIR.getDefaultState();\nint maxY4 = maxY << 4;\nint index = 0;\n\/\/ Apply heightmap\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/Clamp newHeight within the selection area\nint newHeight = Math.min(maxY4, data[index++]);\nint curBlock = (curHeight) >> 4;\nint newBlock = (newHeight + 15) >> 4;\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\n\/\/ Grow -- start from 1 below top replacing airblocks\nfor (int setY = newBlock - 1, getY = curBlock; setY >= curBlock; --setY, getY--) {\nBlockStateHolder<BlockState> get = session.getBlock(xr, getY, zr);\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n++blocksChanged;\n}\nint setData = newHeight & 15;\nif (setData != 0) {\nexisting = PropertyGroup.LEVEL.set(existing, setData - 1);\nsession.setBlock(xr, newBlock, zr, existing);\n++blocksChanged;\n} else {\nexisting = PropertyGroup.LEVEL.set(existing, 15);\nsession.setBlock(xr, newBlock, zr, existing);\n\nint maxY4 = maxY << 4;\nint index = 0;\n\/\/ Apply heightmap\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/Clamp newHeight within the selection area\nint newHeight = Math.min(maxY4, data[index++]);\nint curBlock = (curHeight) >> 4;\nint newBlock = (newHeight + 15) >> 4;\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\n\/\/ Grow -- start from 1 below top replacing airblocks\nfor (int setY = newBlock - 1, getY = curBlock; setY >= curBlock; --setY, getY--) {\nBlockStateHolder<BlockState> get = session.getBlock(xr, getY, zr);\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n++blocksChanged;\n}\nint setData = newHeight & 15;\nif (setData != 0) {\nexisting = PropertyGroup.LEVEL.set(existing, setData - 1);\nsession.setBlock(xr, newBlock, zr, existing);\n++blocksChanged;\n} else {\nexisting = PropertyGroup.LEVEL.set(existing, 15);\nsession.setBlock(xr, newBlock, zr, existing);\n++blocksChanged;\n}\n\n\/\/ Apply heightmap\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/Clamp newHeight within the selection area\nint newHeight = Math.min(maxY4, data[index++]);\nint curBlock = (curHeight) >> 4;\nint newBlock = (newHeight + 15) >> 4;\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\n\/\/ Grow -- start from 1 below top replacing airblocks\nfor (int setY = newBlock - 1, getY = curBlock; setY >= curBlock; --setY, getY--) {\nBlockStateHolder<BlockState> get = session.getBlock(xr, getY, zr);\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n++blocksChanged;\n}\nint setData = newHeight & 15;\nif (setData != 0) {\nexisting = PropertyGroup.LEVEL.set(existing, setData - 1);\nsession.setBlock(xr, newBlock, zr, existing);\n++blocksChanged;\n} else {\nexisting = PropertyGroup.LEVEL.set(existing, 15);\nsession.setBlock(xr, newBlock, zr, existing);\n++blocksChanged;\n}\n}\n} else if (curHeight > newHeight) {\n\nfor (int setY = newBlock - 1, getY = curBlock; setY >= curBlock; --setY, getY--) {\nBlockStateHolder<BlockState> get = session.getBlock(xr, getY, zr);\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n++blocksChanged;\n}\nint setData = newHeight & 15;\nif (setData != 0) {\nexisting = PropertyGroup.LEVEL.set(existing, setData - 1);\nsession.setBlock(xr, newBlock, zr, existing);\n++blocksChanged;\n} else {\nexisting = PropertyGroup.LEVEL.set(existing, 15);\nsession.setBlock(xr, newBlock, zr, existing);\n++blocksChanged;\n}\n}\n} else if (curHeight > newHeight) {\n\/\/ Fill rest with air\nfor (int y = newBlock + 1; y <= ((curHeight + 15) >> 4); ++y) {\nsession.setBlock(xr, y, zr, fillerAir);\n++blocksChanged;\n}\n\/\/ Set the top block of the column to be the same type\n\/\/ (this could otherwise go wrong with rounding)\nint setData = newHeight & 15;\nBlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\nif (setData != 0) {\nexisting = PropertyGroup.LEVEL.set(existing, setData - 1);\nsession.setBlock(xr, newBlock, zr, existing);\n} else {\nexisting = PropertyGroup.LEVEL.set(existing, 15);\nsession.setBlock(xr, newBlock, zr, existing);\n}\n++blocksChanged;\n}\n}\n}\nreturn blocksChanged;\n\nint blocksChanged = 0;\nBlockStateHolder<BlockState> tmpBlock = BlockTypes.AIR.getDefaultState();\nint maxY4 = maxY << 4;\nint index = 0;\n\/\/ Apply heightmap\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/Clamp newHeight within the selection area\nint newHeight = Math.min(maxY4, data[index++]);\nint curBlock = (curHeight) >> 4;\nint newBlock = (newHeight + 15) >> 4;\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\n\/\/ Grow -- start from 1 below top replacing airblocks\nfor (int setY = newBlock - 1, getY = curBlock; setY >= curBlock; --setY, getY--) {\nBlockStateHolder<BlockState> get = session.getBlock(xr, getY, zr);\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n++blocksChanged;\n}\nint setData = newHeight & 15;\nif (setData != 0) {\nexisting = PropertyGroup.LEVEL.set(existing, setData - 1);\nsession.setBlock(xr, newBlock, zr, existing);\n++blocksChanged;\n} else {\nexisting = PropertyGroup.LEVEL.set(existing, 15);\nsession.setBlock(xr, newBlock, zr, existing);\n++blocksChanged;","label":[0,1,0,0]}
{"id":9671,"original_code":"public int apply(int[] data) throws MaxChangedBlocksException {\n        checkNotNull(data);\n        BlockVector3 minY = region.getMinimumPoint();\n        int originX = minY.getBlockX();\n        int originY = minY.getBlockY();\n        int originZ = minY.getBlockZ();\n        int maxY = region.getMaximumPoint().getBlockY();\n        BlockState fillerAir = BlockTypes.AIR.getDefaultState();\n        int blocksChanged = 0;\n        BlockState tmpBlock = BlockTypes.AIR.getDefaultState();\n        \/\/ Apply heightmap\n        int index = 0;\n        for (int z = 0; z < height; ++z) {\n            int zr = z + originZ;\n            for (int x = 0; x < width; ++x, index++) {\n                if (this.invalid != null && this.invalid[index]) {\n                    continue;\n                }\n                int curHeight = this.data[index];\n                \/\/ Clamp newHeight within the selection area\n                int newHeight = Math.min(maxY, data[index]);\n                \/\/ Offset x,z to be 'real' coordinates\n                int xr = x + originX;\n                \/\/ Depending on growing or shrinking we need to start at the bottom or top\n                if (newHeight > curHeight) {\n                    \/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\n                    BlockState existing = session.getBlock(xr, curHeight, zr);\n                    \/\/ Skip water\/lava\n                    if (existing.getBlockType().getMaterial().isMovementBlocker()) {\n                        int y0 = newHeight - 1;\n                        for (int setY = y0, getY = curHeight - 1; setY >= curHeight; setY--, getY--) {\n                            BlockState get;\n                            if (getY >= 0 && getY < 256) {\n                                get = session.getBlock(xr, getY, zr);\n                            } else {\n                                get = BlockTypes.AIR.getDefaultState();\n                            }\n                            if (get != BlockTypes.AIR.getDefaultState()) {\n                                tmpBlock = get;\n                            }\n                            session.setBlock(xr, setY, zr, tmpBlock);\n                            ++blocksChanged;\n                        }\n                        session.setBlock(xr, newHeight, zr, existing);\n                        ++blocksChanged;\n                    }\n                } else if (curHeight > newHeight) {\n                    \/\/ Set the top block of the column to be the same type\n                    \/\/ (this could otherwise go wrong with rounding)\n                    session.setBlock(xr, newHeight, zr, session.getBlock(xr, curHeight, zr));\n                    ++blocksChanged;\n                    \/\/ Fill rest with air\n                    for (int y = newHeight + 1; y <= curHeight; ++y) {\n                        session.setBlock(xr, y, zr, fillerAir);\n                        ++blocksChanged;\n                    }\n                }\n            }\n        }\n        \/\/ Drop trees to the floor -- TODO\n        return blocksChanged;\n    }","code":"public int apply(int[] data) throws MaxChangedBlocksException {\n        checkNotNull(data);\n        BlockVector3 minY = region.getMinimumPoint();\n        int originX = minY.getBlockX();\n        int originY = minY.getBlockY();\n        int originZ = minY.getBlockZ();\n        int maxY = region.getMaximumPoint().getBlockY();\n        BlockState fillerAir = BlockTypes.AIR.getDefaultState();\n        int blocksChanged = 0;\n        BlockState tmpBlock = BlockTypes.AIR.getDefaultState();\n       \n        int index = 0;\n        for (int z = 0; z < height; ++z) {\n            int zr = z + originZ;\n            for (int x = 0; x < width; ++x, index++) {\n                if (this.invalid != null && this.invalid[index]) {\n                    continue;\n                }\n                int curHeight = this.data[index];\n               \n                int newHeight = Math.min(maxY, data[index]);\n               \n                int xr = x + originX;\n               \n                if (newHeight > curHeight) {\n                   \n                    BlockState existing = session.getBlock(xr, curHeight, zr);\n                   \n                    if (existing.getBlockType().getMaterial().isMovementBlocker()) {\n                        int y0 = newHeight - 1;\n                        for (int setY = y0, getY = curHeight - 1; setY >= curHeight; setY--, getY--) {\n                            BlockState get;\n                            if (getY >= 0 && getY < 256) {\n                                get = session.getBlock(xr, getY, zr);\n                            } else {\n                                get = BlockTypes.AIR.getDefaultState();\n                            }\n                            if (get != BlockTypes.AIR.getDefaultState()) {\n                                tmpBlock = get;\n                            }\n                            session.setBlock(xr, setY, zr, tmpBlock);\n                            ++blocksChanged;\n                        }\n                        session.setBlock(xr, newHeight, zr, existing);\n                        ++blocksChanged;\n                    }\n                } else if (curHeight > newHeight) {\n                   \n                   \n                    session.setBlock(xr, newHeight, zr, session.getBlock(xr, curHeight, zr));\n                    ++blocksChanged;\n                   \n                    for (int y = newHeight + 1; y <= curHeight; ++y) {\n                        session.setBlock(xr, y, zr, fillerAir);\n                        ++blocksChanged;\n                    }\n                }\n            }\n        }\n       \n        return blocksChanged;\n    }","cleancode":"public int apply(int[] data) throws maxchangedblocksexception { checknotnull(data); blockvector3 miny = region.getminimumpoint(); int originx = miny.getblockx(); int originy = miny.getblocky(); int originz = miny.getblockz(); int maxy = region.getmaximumpoint().getblocky(); blockstate fillerair = blocktypes.air.getdefaultstate(); int blockschanged = 0; blockstate tmpblock = blocktypes.air.getdefaultstate(); int index = 0; for (int z = 0; z < height; ++z) { int zr = z + originz; for (int x = 0; x < width; ++x, index++) { if (this.invalid != null && this.invalid[index]) { continue; } int curheight = this.data[index]; int newheight = math.min(maxy, data[index]); int xr = x + originx; if (newheight > curheight) { blockstate existing = session.getblock(xr, curheight, zr); if (existing.getblocktype().getmaterial().ismovementblocker()) { int y0 = newheight - 1; for (int sety = y0, gety = curheight - 1; sety >= curheight; sety--, gety--) { blockstate get; if (gety >= 0 && gety < 256) { get = session.getblock(xr, gety, zr); } else { get = blocktypes.air.getdefaultstate(); } if (get != blocktypes.air.getdefaultstate()) { tmpblock = get; } session.setblock(xr, sety, zr, tmpblock); ++blockschanged; } session.setblock(xr, newheight, zr, existing); ++blockschanged; } } else if (curheight > newheight) { session.setblock(xr, newheight, zr, session.getblock(xr, curheight, zr)); ++blockschanged; for (int y = newheight + 1; y <= curheight; ++y) { session.setblock(xr, y, zr, fillerair); ++blockschanged; } } } } return blockschanged; }","comment":"\/** * apply a raw heightmap to the region. * * @param data the data * @return number of blocks affected * @throws maxchangedblocksexception if the maximum block change limit is exceeded *\/\n\/\/ apply heightmap\n\/\/ clamp newheight within the selection area\n\/\/ offset x,z to be 'real' coordinates\n\/\/ depending on growing or shrinking we need to start at the bottom or top\n\/\/ set the top block of the column to be the same type (this might go wrong with rounding)\n\/\/ skip water\/lava\n\/\/ set the top block of the column to be the same type \/\/ (this could otherwise go wrong with rounding)\n\/\/ fill rest with air\n\/\/ drop trees to the floor -- todo","repo":"IronApollo\/FastAsyncWorldEdit","code_context_2":"public int apply(int[] data) throws MaxChangedBlocksException {\ncheckNotNull(data);\nBlockVector3 minY = region.getMinimumPoint();\nint originX = minY.getBlockX();\nint originY = minY.getBlockY();\nint originZ = minY.getBlockZ();\nint maxY = region.getMaximumPoint().getBlockY();\nBlockState fillerAir = BlockTypes.AIR.getDefaultState();\nint blocksChanged = 0;\nBlockState tmpBlock = BlockTypes.AIR.getDefaultState();\n\/\/ Apply heightmap\nint index = 0;\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x, index++) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/ Clamp newHeight within the selection area\nint newHeight = Math.min(maxY, data[index]);\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockState existing = session.getBlock(xr, curHeight, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\nint y0 = newHeight - 1;\nfor (int setY = y0, getY = curHeight - 1; setY >= curHeight; setY--, getY--) {\nBlockState get;\nif (getY >= 0 && getY < 256) {\nget = session.getBlock(xr, getY, zr);\n} else {\nget = BlockTypes.AIR.getDefaultState();\n}\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n++blocksChanged;\n}\nsession.setBlock(xr, newHeight, zr, existing);\n++blocksChanged;\n}\n} else if (curHeight > newHeight) {\n\/\/ Set the top block of the column to be the same type\n\/\/ (this could otherwise go wrong with rounding)\nsession.setBlock(xr, newHeight, zr, session.getBlock(xr, curHeight, zr));\n++blocksChanged;\n\/\/ Fill rest with air\nfor (int y = newHeight + 1; y <= curHeight; ++y) {\nsession.setBlock(xr, y, zr, fillerAir);\n++blocksChanged;\n}\n}\n}\n}\n\/\/ Drop trees to the floor -- TODO\nreturn blocksChanged;\n}\n\nint blocksChanged = 0;\nBlockState tmpBlock = BlockTypes.AIR.getDefaultState();\n\/\/ Apply heightmap\nint index = 0;\nfor (int z = 0; z < height; ++z) {\n\n}\nint curHeight = this.data[index];\n\/\/ Clamp newHeight within the selection area\nint newHeight = Math.min(maxY, data[index]);\n\/\/ Offset x,z to be 'real' coordinates\n\n\/\/ Clamp newHeight within the selection area\nint newHeight = Math.min(maxY, data[index]);\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\n\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\n\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockState existing = session.getBlock(xr, curHeight, zr);\n\/\/ Skip water\/lava\n\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockState existing = session.getBlock(xr, curHeight, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\nint y0 = newHeight - 1;\n\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockState existing = session.getBlock(xr, curHeight, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\n\nsession.setBlock(xr, newHeight, zr, session.getBlock(xr, curHeight, zr));\n++blocksChanged;\n\/\/ Fill rest with air\nfor (int y = newHeight + 1; y <= curHeight; ++y) {\nsession.setBlock(xr, y, zr, fillerAir);\n\n}\n}\n\/\/ Drop trees to the floor -- TODO\nreturn blocksChanged;\n}","code_context_10":"public int apply(int[] data) throws MaxChangedBlocksException {\ncheckNotNull(data);\nBlockVector3 minY = region.getMinimumPoint();\nint originX = minY.getBlockX();\nint originY = minY.getBlockY();\nint originZ = minY.getBlockZ();\nint maxY = region.getMaximumPoint().getBlockY();\nBlockState fillerAir = BlockTypes.AIR.getDefaultState();\nint blocksChanged = 0;\nBlockState tmpBlock = BlockTypes.AIR.getDefaultState();\n\/\/ Apply heightmap\nint index = 0;\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x, index++) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/ Clamp newHeight within the selection area\nint newHeight = Math.min(maxY, data[index]);\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockState existing = session.getBlock(xr, curHeight, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\nint y0 = newHeight - 1;\nfor (int setY = y0, getY = curHeight - 1; setY >= curHeight; setY--, getY--) {\nBlockState get;\nif (getY >= 0 && getY < 256) {\nget = session.getBlock(xr, getY, zr);\n} else {\nget = BlockTypes.AIR.getDefaultState();\n}\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n++blocksChanged;\n}\nsession.setBlock(xr, newHeight, zr, existing);\n++blocksChanged;\n}\n} else if (curHeight > newHeight) {\n\/\/ Set the top block of the column to be the same type\n\/\/ (this could otherwise go wrong with rounding)\nsession.setBlock(xr, newHeight, zr, session.getBlock(xr, curHeight, zr));\n++blocksChanged;\n\/\/ Fill rest with air\nfor (int y = newHeight + 1; y <= curHeight; ++y) {\nsession.setBlock(xr, y, zr, fillerAir);\n++blocksChanged;\n}\n}\n}\n}\n\/\/ Drop trees to the floor -- TODO\nreturn blocksChanged;\n}\n\npublic int apply(int[] data) throws MaxChangedBlocksException {\ncheckNotNull(data);\nBlockVector3 minY = region.getMinimumPoint();\nint originX = minY.getBlockX();\nint originY = minY.getBlockY();\nint originZ = minY.getBlockZ();\nint maxY = region.getMaximumPoint().getBlockY();\nBlockState fillerAir = BlockTypes.AIR.getDefaultState();\nint blocksChanged = 0;\nBlockState tmpBlock = BlockTypes.AIR.getDefaultState();\n\/\/ Apply heightmap\nint index = 0;\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x, index++) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/ Clamp newHeight within the selection area\nint newHeight = Math.min(maxY, data[index]);\n\nBlockState tmpBlock = BlockTypes.AIR.getDefaultState();\n\/\/ Apply heightmap\nint index = 0;\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x, index++) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/ Clamp newHeight within the selection area\nint newHeight = Math.min(maxY, data[index]);\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockState existing = session.getBlock(xr, curHeight, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\nint y0 = newHeight - 1;\n\nint index = 0;\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x, index++) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/ Clamp newHeight within the selection area\nint newHeight = Math.min(maxY, data[index]);\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockState existing = session.getBlock(xr, curHeight, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\nint y0 = newHeight - 1;\nfor (int setY = y0, getY = curHeight - 1; setY >= curHeight; setY--, getY--) {\nBlockState get;\n\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x, index++) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/ Clamp newHeight within the selection area\nint newHeight = Math.min(maxY, data[index]);\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockState existing = session.getBlock(xr, curHeight, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\nint y0 = newHeight - 1;\nfor (int setY = y0, getY = curHeight - 1; setY >= curHeight; setY--, getY--) {\nBlockState get;\nif (getY >= 0 && getY < 256) {\nget = session.getBlock(xr, getY, zr);\n\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/ Clamp newHeight within the selection area\nint newHeight = Math.min(maxY, data[index]);\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockState existing = session.getBlock(xr, curHeight, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\nint y0 = newHeight - 1;\nfor (int setY = y0, getY = curHeight - 1; setY >= curHeight; setY--, getY--) {\nBlockState get;\nif (getY >= 0 && getY < 256) {\nget = session.getBlock(xr, getY, zr);\n} else {\nget = BlockTypes.AIR.getDefaultState();\n\n}\nint curHeight = this.data[index];\n\/\/ Clamp newHeight within the selection area\nint newHeight = Math.min(maxY, data[index]);\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockState existing = session.getBlock(xr, curHeight, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\nint y0 = newHeight - 1;\nfor (int setY = y0, getY = curHeight - 1; setY >= curHeight; setY--, getY--) {\nBlockState get;\nif (getY >= 0 && getY < 256) {\nget = session.getBlock(xr, getY, zr);\n} else {\nget = BlockTypes.AIR.getDefaultState();\n}\nif (get != BlockTypes.AIR.getDefaultState()) {\n\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/ Clamp newHeight within the selection area\nint newHeight = Math.min(maxY, data[index]);\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockState existing = session.getBlock(xr, curHeight, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\nint y0 = newHeight - 1;\nfor (int setY = y0, getY = curHeight - 1; setY >= curHeight; setY--, getY--) {\nBlockState get;\nif (getY >= 0 && getY < 256) {\nget = session.getBlock(xr, getY, zr);\n} else {\nget = BlockTypes.AIR.getDefaultState();\n}\n\n++blocksChanged;\n}\nsession.setBlock(xr, newHeight, zr, existing);\n++blocksChanged;\n}\n} else if (curHeight > newHeight) {\n\/\/ Set the top block of the column to be the same type\n\/\/ (this could otherwise go wrong with rounding)\nsession.setBlock(xr, newHeight, zr, session.getBlock(xr, curHeight, zr));\n++blocksChanged;\n\/\/ Fill rest with air\nfor (int y = newHeight + 1; y <= curHeight; ++y) {\nsession.setBlock(xr, y, zr, fillerAir);\n++blocksChanged;\n}\n}\n}\n}\n\/\/ Drop trees to the floor -- TODO\nreturn blocksChanged;\n}\n\nsession.setBlock(xr, newHeight, zr, session.getBlock(xr, curHeight, zr));\n++blocksChanged;\n\/\/ Fill rest with air\nfor (int y = newHeight + 1; y <= curHeight; ++y) {\nsession.setBlock(xr, y, zr, fillerAir);\n++blocksChanged;\n}\n}\n}\n}\n\/\/ Drop trees to the floor -- TODO\nreturn blocksChanged;\n}","code_context_20":"public int apply(int[] data) throws MaxChangedBlocksException {\ncheckNotNull(data);\nBlockVector3 minY = region.getMinimumPoint();\nint originX = minY.getBlockX();\nint originY = minY.getBlockY();\nint originZ = minY.getBlockZ();\nint maxY = region.getMaximumPoint().getBlockY();\nBlockState fillerAir = BlockTypes.AIR.getDefaultState();\nint blocksChanged = 0;\nBlockState tmpBlock = BlockTypes.AIR.getDefaultState();\n\/\/ Apply heightmap\nint index = 0;\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x, index++) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/ Clamp newHeight within the selection area\nint newHeight = Math.min(maxY, data[index]);\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockState existing = session.getBlock(xr, curHeight, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\nint y0 = newHeight - 1;\nfor (int setY = y0, getY = curHeight - 1; setY >= curHeight; setY--, getY--) {\nBlockState get;\nif (getY >= 0 && getY < 256) {\nget = session.getBlock(xr, getY, zr);\n} else {\nget = BlockTypes.AIR.getDefaultState();\n}\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n++blocksChanged;\n}\nsession.setBlock(xr, newHeight, zr, existing);\n++blocksChanged;\n}\n} else if (curHeight > newHeight) {\n\/\/ Set the top block of the column to be the same type\n\/\/ (this could otherwise go wrong with rounding)\nsession.setBlock(xr, newHeight, zr, session.getBlock(xr, curHeight, zr));\n++blocksChanged;\n\/\/ Fill rest with air\nfor (int y = newHeight + 1; y <= curHeight; ++y) {\nsession.setBlock(xr, y, zr, fillerAir);\n++blocksChanged;\n}\n}\n}\n}\n\/\/ Drop trees to the floor -- TODO\nreturn blocksChanged;\n}\n\npublic int apply(int[] data) throws MaxChangedBlocksException {\ncheckNotNull(data);\nBlockVector3 minY = region.getMinimumPoint();\nint originX = minY.getBlockX();\nint originY = minY.getBlockY();\nint originZ = minY.getBlockZ();\nint maxY = region.getMaximumPoint().getBlockY();\nBlockState fillerAir = BlockTypes.AIR.getDefaultState();\nint blocksChanged = 0;\nBlockState tmpBlock = BlockTypes.AIR.getDefaultState();\n\/\/ Apply heightmap\nint index = 0;\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x, index++) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/ Clamp newHeight within the selection area\nint newHeight = Math.min(maxY, data[index]);\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockState existing = session.getBlock(xr, curHeight, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\nint y0 = newHeight - 1;\nfor (int setY = y0, getY = curHeight - 1; setY >= curHeight; setY--, getY--) {\n\npublic int apply(int[] data) throws MaxChangedBlocksException {\ncheckNotNull(data);\nBlockVector3 minY = region.getMinimumPoint();\nint originX = minY.getBlockX();\nint originY = minY.getBlockY();\nint originZ = minY.getBlockZ();\nint maxY = region.getMaximumPoint().getBlockY();\nBlockState fillerAir = BlockTypes.AIR.getDefaultState();\nint blocksChanged = 0;\nBlockState tmpBlock = BlockTypes.AIR.getDefaultState();\n\/\/ Apply heightmap\nint index = 0;\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x, index++) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/ Clamp newHeight within the selection area\nint newHeight = Math.min(maxY, data[index]);\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockState existing = session.getBlock(xr, curHeight, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\nint y0 = newHeight - 1;\nfor (int setY = y0, getY = curHeight - 1; setY >= curHeight; setY--, getY--) {\nBlockState get;\nif (getY >= 0 && getY < 256) {\nget = session.getBlock(xr, getY, zr);\n} else {\nget = BlockTypes.AIR.getDefaultState();\n}\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\n\ncheckNotNull(data);\nBlockVector3 minY = region.getMinimumPoint();\nint originX = minY.getBlockX();\nint originY = minY.getBlockY();\nint originZ = minY.getBlockZ();\nint maxY = region.getMaximumPoint().getBlockY();\nBlockState fillerAir = BlockTypes.AIR.getDefaultState();\nint blocksChanged = 0;\nBlockState tmpBlock = BlockTypes.AIR.getDefaultState();\n\/\/ Apply heightmap\nint index = 0;\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x, index++) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/ Clamp newHeight within the selection area\nint newHeight = Math.min(maxY, data[index]);\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockState existing = session.getBlock(xr, curHeight, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\nint y0 = newHeight - 1;\nfor (int setY = y0, getY = curHeight - 1; setY >= curHeight; setY--, getY--) {\nBlockState get;\nif (getY >= 0 && getY < 256) {\nget = session.getBlock(xr, getY, zr);\n} else {\nget = BlockTypes.AIR.getDefaultState();\n}\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n++blocksChanged;\n\nint originX = minY.getBlockX();\nint originY = minY.getBlockY();\nint originZ = minY.getBlockZ();\nint maxY = region.getMaximumPoint().getBlockY();\nBlockState fillerAir = BlockTypes.AIR.getDefaultState();\nint blocksChanged = 0;\nBlockState tmpBlock = BlockTypes.AIR.getDefaultState();\n\/\/ Apply heightmap\nint index = 0;\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x, index++) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/ Clamp newHeight within the selection area\nint newHeight = Math.min(maxY, data[index]);\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockState existing = session.getBlock(xr, curHeight, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\nint y0 = newHeight - 1;\nfor (int setY = y0, getY = curHeight - 1; setY >= curHeight; setY--, getY--) {\nBlockState get;\nif (getY >= 0 && getY < 256) {\nget = session.getBlock(xr, getY, zr);\n} else {\nget = BlockTypes.AIR.getDefaultState();\n}\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n++blocksChanged;\n}\nsession.setBlock(xr, newHeight, zr, existing);\n\nint originZ = minY.getBlockZ();\nint maxY = region.getMaximumPoint().getBlockY();\nBlockState fillerAir = BlockTypes.AIR.getDefaultState();\nint blocksChanged = 0;\nBlockState tmpBlock = BlockTypes.AIR.getDefaultState();\n\/\/ Apply heightmap\nint index = 0;\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x, index++) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/ Clamp newHeight within the selection area\nint newHeight = Math.min(maxY, data[index]);\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockState existing = session.getBlock(xr, curHeight, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\nint y0 = newHeight - 1;\nfor (int setY = y0, getY = curHeight - 1; setY >= curHeight; setY--, getY--) {\nBlockState get;\nif (getY >= 0 && getY < 256) {\nget = session.getBlock(xr, getY, zr);\n} else {\nget = BlockTypes.AIR.getDefaultState();\n}\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n++blocksChanged;\n}\nsession.setBlock(xr, newHeight, zr, existing);\n++blocksChanged;\n}\n\nBlockState fillerAir = BlockTypes.AIR.getDefaultState();\nint blocksChanged = 0;\nBlockState tmpBlock = BlockTypes.AIR.getDefaultState();\n\/\/ Apply heightmap\nint index = 0;\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x, index++) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/ Clamp newHeight within the selection area\nint newHeight = Math.min(maxY, data[index]);\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockState existing = session.getBlock(xr, curHeight, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\nint y0 = newHeight - 1;\nfor (int setY = y0, getY = curHeight - 1; setY >= curHeight; setY--, getY--) {\nBlockState get;\nif (getY >= 0 && getY < 256) {\nget = session.getBlock(xr, getY, zr);\n} else {\nget = BlockTypes.AIR.getDefaultState();\n}\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n++blocksChanged;\n}\nsession.setBlock(xr, newHeight, zr, existing);\n++blocksChanged;\n}\n} else if (curHeight > newHeight) {\n\/\/ Set the top block of the column to be the same type\n\nint originZ = minY.getBlockZ();\nint maxY = region.getMaximumPoint().getBlockY();\nBlockState fillerAir = BlockTypes.AIR.getDefaultState();\nint blocksChanged = 0;\nBlockState tmpBlock = BlockTypes.AIR.getDefaultState();\n\/\/ Apply heightmap\nint index = 0;\nfor (int z = 0; z < height; ++z) {\nint zr = z + originZ;\nfor (int x = 0; x < width; ++x, index++) {\nif (this.invalid != null && this.invalid[index]) {\ncontinue;\n}\nint curHeight = this.data[index];\n\/\/ Clamp newHeight within the selection area\nint newHeight = Math.min(maxY, data[index]);\n\/\/ Offset x,z to be 'real' coordinates\nint xr = x + originX;\n\/\/ Depending on growing or shrinking we need to start at the bottom or top\nif (newHeight > curHeight) {\n\/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\nBlockState existing = session.getBlock(xr, curHeight, zr);\n\/\/ Skip water\/lava\nif (existing.getBlockType().getMaterial().isMovementBlocker()) {\nint y0 = newHeight - 1;\nfor (int setY = y0, getY = curHeight - 1; setY >= curHeight; setY--, getY--) {\nBlockState get;\nif (getY >= 0 && getY < 256) {\nget = session.getBlock(xr, getY, zr);\n} else {\nget = BlockTypes.AIR.getDefaultState();\n}\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n++blocksChanged;\n}\nsession.setBlock(xr, newHeight, zr, existing);\n++blocksChanged;\n}\n} else if (curHeight > newHeight) {\n\nBlockState get;\nif (getY >= 0 && getY < 256) {\nget = session.getBlock(xr, getY, zr);\n} else {\nget = BlockTypes.AIR.getDefaultState();\n}\nif (get != BlockTypes.AIR.getDefaultState()) {\ntmpBlock = get;\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n++blocksChanged;\n}\nsession.setBlock(xr, newHeight, zr, existing);\n++blocksChanged;\n}\n} else if (curHeight > newHeight) {\n\/\/ Set the top block of the column to be the same type\n\/\/ (this could otherwise go wrong with rounding)\nsession.setBlock(xr, newHeight, zr, session.getBlock(xr, curHeight, zr));\n++blocksChanged;\n\/\/ Fill rest with air\nfor (int y = newHeight + 1; y <= curHeight; ++y) {\nsession.setBlock(xr, y, zr, fillerAir);\n++blocksChanged;\n}\n}\n}\n}\n\/\/ Drop trees to the floor -- TODO\nreturn blocksChanged;\n}\n\n}\nsession.setBlock(xr, setY, zr, tmpBlock);\n++blocksChanged;\n}\nsession.setBlock(xr, newHeight, zr, existing);\n++blocksChanged;\n}\n} else if (curHeight > newHeight) {\n\/\/ Set the top block of the column to be the same type\n\/\/ (this could otherwise go wrong with rounding)\nsession.setBlock(xr, newHeight, zr, session.getBlock(xr, curHeight, zr));\n++blocksChanged;\n\/\/ Fill rest with air\nfor (int y = newHeight + 1; y <= curHeight; ++y) {\nsession.setBlock(xr, y, zr, fillerAir);\n++blocksChanged;\n}\n}\n}\n}\n\/\/ Drop trees to the floor -- TODO\nreturn blocksChanged;\n}","label":[0,1,0,0]}
{"id":1494,"original_code":"private void initialization(int minXSize, int maxXSize) {\n        \/\/ TODO: current implementation is less elegant. code refactoring may be needed.\n        dfaConfig = new DFAConfig(); \/\/ allocates a new config every time.\n        Random r = new Random();\n        dfaConfig.stateSize = r.nextInt((maxXSize - minXSize) + 1) + minXSize;\n        dfaConfig.faultyStateSize = Math.max(dfaConfig.stateSize \/ 10, 4);\n        LOGGER.debug(\"Generated overall state size and faulty state size: {}, {}\",\n                dfaConfig.stateSize, dfaConfig.faultyStateSize);\n        dfaConfig.states = new int[dfaConfig.stateSize];\n        for (int i = 0; i < dfaConfig.stateSize; i++) {\n            dfaConfig.states[i] = i;\n        }\n        \/\/ alphabet size: range[6 ~ 16] or [10, 20]\n        int base = dfaConfig.stateSize > 20 ? 10 : 6;\n        int alphabetSize = r.nextInt(11) + base;\n        dfaConfig.alphabet = new char[alphabetSize];\n        LOGGER.debug(\"Chosen alphabet size is {}\", alphabetSize);\n        \/\/ randomly fill the alphabet\n        int alphabetSpaceLen = dfaConfig.alphabetSpace.length();\n        boolean[] tempFlags = new boolean[alphabetSpaceLen];\n        int tempIndex;\n        for (int i = 0; i < dfaConfig.alphabet.length; i++) {\n            tempIndex = r.nextInt(alphabetSpaceLen);\n            while (tempFlags[tempIndex]) {\n                tempIndex = r.nextInt(alphabetSpaceLen);\n            }\n            tempFlags[tempIndex] = true;\n            dfaConfig.alphabet[i] = dfaConfig.alphabetSpace.charAt(tempIndex);\n        }\n        \/\/ faulty event size (make sure it less than a half of alphabet size)\n        int faultEventSize = Math.max(dfaConfig.faultyStateSize \/ 2, 2);\n        faultEventSize = faultEventSize >= 5 ? 4 : faultEventSize;\n        if (alphabetSize > 15 && (dfaConfig.faultyStateSize \/ faultEventSize) > 3) {\n            faultEventSize = faultEventSize + r.nextInt(2) + 1;\n        }\n        dfaConfig.faultyEvents = new int[faultEventSize];\n        LOGGER.debug(\"Chosen faulty event size: {}\", faultEventSize);\n        boolean[] chosenFaultMarks = new boolean[alphabetSize];\n        int choose;\n        for (int i = 0; i < faultEventSize; i++) {\n            choose = r.nextInt(alphabetSize);\n            while (chosenFaultMarks[choose])\n                choose = r.nextInt(alphabetSize);\n            chosenFaultMarks[choose] = true;\n            dfaConfig.faultyEvents[i] = choose;\n        }\n        LOGGER.debug(\"Generated alphabet set: {}\", Arrays.toString(dfaConfig.alphabet));\n        LOGGER.debug(\"Faulty events (index): {}\", Arrays.toString(dfaConfig.faultyEvents));\n        Set<Integer> faultyEventIndexSet = new HashSet<>();\n        for (int fi : dfaConfig.faultyEvents)\n            faultyEventIndexSet.add(fi);\n        int ui = 0;\n        int oi = 0;\n        dfaConfig.observableEvents = new char[alphabetSize - faultEventSize];\n        dfaConfig.unobservableEvents = new char[faultEventSize];\n        for (int i = 0; i < alphabetSize; i++) {\n            if (faultyEventIndexSet.contains(i))\n                dfaConfig.unobservableEvents[ui++] = dfaConfig.alphabet[i];\n            else\n                dfaConfig.observableEvents[oi++] = dfaConfig.alphabet[i];\n        }\n        LOGGER.debug(\"selected observable events : {}\", Arrays.toString(dfaConfig.observableEvents));\n        LOGGER.debug(\"selected unobservable events : {}\", Arrays.toString(dfaConfig.unobservableEvents));\n    }","code":"private void initialization(int minXSize, int maxXSize) {\n       \n        dfaConfig = new DFAConfig();\n        Random r = new Random();\n        dfaConfig.stateSize = r.nextInt((maxXSize - minXSize) + 1) + minXSize;\n        dfaConfig.faultyStateSize = Math.max(dfaConfig.stateSize \/ 10, 4);\n        LOGGER.debug(\"Generated overall state size and faulty state size: {}, {}\",\n                dfaConfig.stateSize, dfaConfig.faultyStateSize);\n        dfaConfig.states = new int[dfaConfig.stateSize];\n        for (int i = 0; i < dfaConfig.stateSize; i++) {\n            dfaConfig.states[i] = i;\n        }\n       \n        int base = dfaConfig.stateSize > 20 ? 10 : 6;\n        int alphabetSize = r.nextInt(11) + base;\n        dfaConfig.alphabet = new char[alphabetSize];\n        LOGGER.debug(\"Chosen alphabet size is {}\", alphabetSize);\n       \n        int alphabetSpaceLen = dfaConfig.alphabetSpace.length();\n        boolean[] tempFlags = new boolean[alphabetSpaceLen];\n        int tempIndex;\n        for (int i = 0; i < dfaConfig.alphabet.length; i++) {\n            tempIndex = r.nextInt(alphabetSpaceLen);\n            while (tempFlags[tempIndex]) {\n                tempIndex = r.nextInt(alphabetSpaceLen);\n            }\n            tempFlags[tempIndex] = true;\n            dfaConfig.alphabet[i] = dfaConfig.alphabetSpace.charAt(tempIndex);\n        }\n       \n        int faultEventSize = Math.max(dfaConfig.faultyStateSize \/ 2, 2);\n        faultEventSize = faultEventSize >= 5 ? 4 : faultEventSize;\n        if (alphabetSize > 15 && (dfaConfig.faultyStateSize \/ faultEventSize) > 3) {\n            faultEventSize = faultEventSize + r.nextInt(2) + 1;\n        }\n        dfaConfig.faultyEvents = new int[faultEventSize];\n        LOGGER.debug(\"Chosen faulty event size: {}\", faultEventSize);\n        boolean[] chosenFaultMarks = new boolean[alphabetSize];\n        int choose;\n        for (int i = 0; i < faultEventSize; i++) {\n            choose = r.nextInt(alphabetSize);\n            while (chosenFaultMarks[choose])\n                choose = r.nextInt(alphabetSize);\n            chosenFaultMarks[choose] = true;\n            dfaConfig.faultyEvents[i] = choose;\n        }\n        LOGGER.debug(\"Generated alphabet set: {}\", Arrays.toString(dfaConfig.alphabet));\n        LOGGER.debug(\"Faulty events (index): {}\", Arrays.toString(dfaConfig.faultyEvents));\n        Set<Integer> faultyEventIndexSet = new HashSet<>();\n        for (int fi : dfaConfig.faultyEvents)\n            faultyEventIndexSet.add(fi);\n        int ui = 0;\n        int oi = 0;\n        dfaConfig.observableEvents = new char[alphabetSize - faultEventSize];\n        dfaConfig.unobservableEvents = new char[faultEventSize];\n        for (int i = 0; i < alphabetSize; i++) {\n            if (faultyEventIndexSet.contains(i))\n                dfaConfig.unobservableEvents[ui++] = dfaConfig.alphabet[i];\n            else\n                dfaConfig.observableEvents[oi++] = dfaConfig.alphabet[i];\n        }\n        LOGGER.debug(\"selected observable events : {}\", Arrays.toString(dfaConfig.observableEvents));\n        LOGGER.debug(\"selected unobservable events : {}\", Arrays.toString(dfaConfig.unobservableEvents));\n    }","cleancode":"private void initialization(int minxsize, int maxxsize) { dfaconfig = new dfaconfig(); random r = new random(); dfaconfig.statesize = r.nextint((maxxsize - minxsize) + 1) + minxsize; dfaconfig.faultystatesize = math.max(dfaconfig.statesize \/ 10, 4); logger.debug(\"generated overall state size and faulty state size: {}, {}\", dfaconfig.statesize, dfaconfig.faultystatesize); dfaconfig.states = new int[dfaconfig.statesize]; for (int i = 0; i < dfaconfig.statesize; i++) { dfaconfig.states[i] = i; } int base = dfaconfig.statesize > 20 ? 10 : 6; int alphabetsize = r.nextint(11) + base; dfaconfig.alphabet = new char[alphabetsize]; logger.debug(\"chosen alphabet size is {}\", alphabetsize); int alphabetspacelen = dfaconfig.alphabetspace.length(); boolean[] tempflags = new boolean[alphabetspacelen]; int tempindex; for (int i = 0; i < dfaconfig.alphabet.length; i++) { tempindex = r.nextint(alphabetspacelen); while (tempflags[tempindex]) { tempindex = r.nextint(alphabetspacelen); } tempflags[tempindex] = true; dfaconfig.alphabet[i] = dfaconfig.alphabetspace.charat(tempindex); } int faulteventsize = math.max(dfaconfig.faultystatesize \/ 2, 2); faulteventsize = faulteventsize >= 5 ? 4 : faulteventsize; if (alphabetsize > 15 && (dfaconfig.faultystatesize \/ faulteventsize) > 3) { faulteventsize = faulteventsize + r.nextint(2) + 1; } dfaconfig.faultyevents = new int[faulteventsize]; logger.debug(\"chosen faulty event size: {}\", faulteventsize); boolean[] chosenfaultmarks = new boolean[alphabetsize]; int choose; for (int i = 0; i < faulteventsize; i++) { choose = r.nextint(alphabetsize); while (chosenfaultmarks[choose]) choose = r.nextint(alphabetsize); chosenfaultmarks[choose] = true; dfaconfig.faultyevents[i] = choose; } logger.debug(\"generated alphabet set: {}\", arrays.tostring(dfaconfig.alphabet)); logger.debug(\"faulty events (index): {}\", arrays.tostring(dfaconfig.faultyevents)); set<integer> faultyeventindexset = new hashset<>(); for (int fi : dfaconfig.faultyevents) faultyeventindexset.add(fi); int ui = 0; int oi = 0; dfaconfig.observableevents = new char[alphabetsize - faulteventsize]; dfaconfig.unobservableevents = new char[faulteventsize]; for (int i = 0; i < alphabetsize; i++) { if (faultyeventindexset.contains(i)) dfaconfig.unobservableevents[ui++] = dfaconfig.alphabet[i]; else dfaconfig.observableevents[oi++] = dfaconfig.alphabet[i]; } logger.debug(\"selected observable events : {}\", arrays.tostring(dfaconfig.observableevents)); logger.debug(\"selected unobservable events : {}\", arrays.tostring(dfaconfig.unobservableevents)); }","comment":"\/** * initialization is needed before constructing dfa. * * @param minxsize maximum number of the states * @param maxxsize minimum number of the states *\/\n\/\/ todo: current implementation is less elegant. code refactoring may be needed.\n\/\/ allocates a new config every time.\n\/\/ alphabet size: range[6 ~ 16] or [10, 20]\n\/\/ randomly fill the alphabet\n\/\/ faulty event size (make sure it less than a half of alphabet size)","repo":"OES2018\/randomly-generation-of-diagnosable-dfa","code_context_2":"private void initialization(int minXSize, int maxXSize) {\n\/\/ TODO: current implementation is less elegant. code refactoring may be needed.\ndfaConfig = new DFAConfig(); \/\/ allocates a new config every time.\nRandom r = new Random();\ndfaConfig.stateSize = r.nextInt((maxXSize - minXSize) + 1) + minXSize;\ndfaConfig.faultyStateSize = Math.max(dfaConfig.stateSize \/ 10, 4);\nLOGGER.debug(\"Generated overall state size and faulty state size: {}, {}\",\ndfaConfig.stateSize, dfaConfig.faultyStateSize);\ndfaConfig.states = new int[dfaConfig.stateSize];\nfor (int i = 0; i < dfaConfig.stateSize; i++) {\ndfaConfig.states[i] = i;\n}\n\/\/ alphabet size: range[6 ~ 16] or [10, 20]\nint base = dfaConfig.stateSize > 20 ? 10 : 6;\nint alphabetSize = r.nextInt(11) + base;\ndfaConfig.alphabet = new char[alphabetSize];\nLOGGER.debug(\"Chosen alphabet size is {}\", alphabetSize);\n\/\/ randomly fill the alphabet\nint alphabetSpaceLen = dfaConfig.alphabetSpace.length();\nboolean[] tempFlags = new boolean[alphabetSpaceLen];\nint tempIndex;\nfor (int i = 0; i < dfaConfig.alphabet.length; i++) {\ntempIndex = r.nextInt(alphabetSpaceLen);\nwhile (tempFlags[tempIndex]) {\ntempIndex = r.nextInt(alphabetSpaceLen);\n}\ntempFlags[tempIndex] = true;\ndfaConfig.alphabet[i] = dfaConfig.alphabetSpace.charAt(tempIndex);\n}\n\/\/ faulty event size (make sure it less than a half of alphabet size)\nint faultEventSize = Math.max(dfaConfig.faultyStateSize \/ 2, 2);\nfaultEventSize = faultEventSize >= 5 ? 4 : faultEventSize;\nif (alphabetSize > 15 && (dfaConfig.faultyStateSize \/ faultEventSize) > 3) {\nfaultEventSize = faultEventSize + r.nextInt(2) + 1;\n}\ndfaConfig.faultyEvents = new int[faultEventSize];\nLOGGER.debug(\"Chosen faulty event size: {}\", faultEventSize);\nboolean[] chosenFaultMarks = new boolean[alphabetSize];\nint choose;\nfor (int i = 0; i < faultEventSize; i++) {\nchoose = r.nextInt(alphabetSize);\nwhile (chosenFaultMarks[choose])\nchoose = r.nextInt(alphabetSize);\nchosenFaultMarks[choose] = true;\ndfaConfig.faultyEvents[i] = choose;\n}\nLOGGER.debug(\"Generated alphabet set: {}\", Arrays.toString(dfaConfig.alphabet));\nLOGGER.debug(\"Faulty events (index): {}\", Arrays.toString(dfaConfig.faultyEvents));\nSet<Integer> faultyEventIndexSet = new HashSet<>();\nfor (int fi : dfaConfig.faultyEvents)\nfaultyEventIndexSet.add(fi);\nint ui = 0;\nint oi = 0;\ndfaConfig.observableEvents = new char[alphabetSize - faultEventSize];\ndfaConfig.unobservableEvents = new char[faultEventSize];\nfor (int i = 0; i < alphabetSize; i++) {\nif (faultyEventIndexSet.contains(i))\ndfaConfig.unobservableEvents[ui++] = dfaConfig.alphabet[i];\nelse\ndfaConfig.observableEvents[oi++] = dfaConfig.alphabet[i];\n}\nLOGGER.debug(\"selected observable events : {}\", Arrays.toString(dfaConfig.observableEvents));\nLOGGER.debug(\"selected unobservable events : {}\", Arrays.toString(dfaConfig.unobservableEvents));\n}\n\nprivate void initialization(int minXSize, int maxXSize) {\n\/\/ TODO: current implementation is less elegant. code refactoring may be needed.\ndfaConfig = new DFAConfig(); \/\/ allocates a new config every time.\nRandom r = new Random();\n\nprivate void initialization(int minXSize, int maxXSize) {\n\/\/ TODO: current implementation is less elegant. code refactoring may be needed.\ndfaConfig = new DFAConfig(); \/\/ allocates a new config every time.\nRandom r = new Random();\ndfaConfig.stateSize = r.nextInt((maxXSize - minXSize) + 1) + minXSize;\n\ndfaConfig.states[i] = i;\n}\n\/\/ alphabet size: range[6 ~ 16] or [10, 20]\nint base = dfaConfig.stateSize > 20 ? 10 : 6;\nint alphabetSize = r.nextInt(11) + base;\n\ndfaConfig.alphabet = new char[alphabetSize];\nLOGGER.debug(\"Chosen alphabet size is {}\", alphabetSize);\n\/\/ randomly fill the alphabet\nint alphabetSpaceLen = dfaConfig.alphabetSpace.length();\nboolean[] tempFlags = new boolean[alphabetSpaceLen];\n\ndfaConfig.alphabet[i] = dfaConfig.alphabetSpace.charAt(tempIndex);\n}\n\/\/ faulty event size (make sure it less than a half of alphabet size)\nint faultEventSize = Math.max(dfaConfig.faultyStateSize \/ 2, 2);\nfaultEventSize = faultEventSize >= 5 ? 4 : faultEventSize;","code_context_10":"private void initialization(int minXSize, int maxXSize) {\n\/\/ TODO: current implementation is less elegant. code refactoring may be needed.\ndfaConfig = new DFAConfig(); \/\/ allocates a new config every time.\nRandom r = new Random();\ndfaConfig.stateSize = r.nextInt((maxXSize - minXSize) + 1) + minXSize;\ndfaConfig.faultyStateSize = Math.max(dfaConfig.stateSize \/ 10, 4);\nLOGGER.debug(\"Generated overall state size and faulty state size: {}, {}\",\ndfaConfig.stateSize, dfaConfig.faultyStateSize);\ndfaConfig.states = new int[dfaConfig.stateSize];\nfor (int i = 0; i < dfaConfig.stateSize; i++) {\ndfaConfig.states[i] = i;\n}\n\/\/ alphabet size: range[6 ~ 16] or [10, 20]\nint base = dfaConfig.stateSize > 20 ? 10 : 6;\nint alphabetSize = r.nextInt(11) + base;\ndfaConfig.alphabet = new char[alphabetSize];\nLOGGER.debug(\"Chosen alphabet size is {}\", alphabetSize);\n\/\/ randomly fill the alphabet\nint alphabetSpaceLen = dfaConfig.alphabetSpace.length();\nboolean[] tempFlags = new boolean[alphabetSpaceLen];\nint tempIndex;\nfor (int i = 0; i < dfaConfig.alphabet.length; i++) {\ntempIndex = r.nextInt(alphabetSpaceLen);\nwhile (tempFlags[tempIndex]) {\ntempIndex = r.nextInt(alphabetSpaceLen);\n}\ntempFlags[tempIndex] = true;\ndfaConfig.alphabet[i] = dfaConfig.alphabetSpace.charAt(tempIndex);\n}\n\/\/ faulty event size (make sure it less than a half of alphabet size)\nint faultEventSize = Math.max(dfaConfig.faultyStateSize \/ 2, 2);\nfaultEventSize = faultEventSize >= 5 ? 4 : faultEventSize;\nif (alphabetSize > 15 && (dfaConfig.faultyStateSize \/ faultEventSize) > 3) {\nfaultEventSize = faultEventSize + r.nextInt(2) + 1;\n}\ndfaConfig.faultyEvents = new int[faultEventSize];\nLOGGER.debug(\"Chosen faulty event size: {}\", faultEventSize);\nboolean[] chosenFaultMarks = new boolean[alphabetSize];\nint choose;\nfor (int i = 0; i < faultEventSize; i++) {\nchoose = r.nextInt(alphabetSize);\nwhile (chosenFaultMarks[choose])\nchoose = r.nextInt(alphabetSize);\nchosenFaultMarks[choose] = true;\ndfaConfig.faultyEvents[i] = choose;\n}\nLOGGER.debug(\"Generated alphabet set: {}\", Arrays.toString(dfaConfig.alphabet));\nLOGGER.debug(\"Faulty events (index): {}\", Arrays.toString(dfaConfig.faultyEvents));\nSet<Integer> faultyEventIndexSet = new HashSet<>();\nfor (int fi : dfaConfig.faultyEvents)\nfaultyEventIndexSet.add(fi);\nint ui = 0;\nint oi = 0;\ndfaConfig.observableEvents = new char[alphabetSize - faultEventSize];\ndfaConfig.unobservableEvents = new char[faultEventSize];\nfor (int i = 0; i < alphabetSize; i++) {\nif (faultyEventIndexSet.contains(i))\ndfaConfig.unobservableEvents[ui++] = dfaConfig.alphabet[i];\nelse\ndfaConfig.observableEvents[oi++] = dfaConfig.alphabet[i];\n}\nLOGGER.debug(\"selected observable events : {}\", Arrays.toString(dfaConfig.observableEvents));\nLOGGER.debug(\"selected unobservable events : {}\", Arrays.toString(dfaConfig.unobservableEvents));\n}\n\nprivate void initialization(int minXSize, int maxXSize) {\n\/\/ TODO: current implementation is less elegant. code refactoring may be needed.\ndfaConfig = new DFAConfig(); \/\/ allocates a new config every time.\nRandom r = new Random();\ndfaConfig.stateSize = r.nextInt((maxXSize - minXSize) + 1) + minXSize;\ndfaConfig.faultyStateSize = Math.max(dfaConfig.stateSize \/ 10, 4);\nLOGGER.debug(\"Generated overall state size and faulty state size: {}, {}\",\ndfaConfig.stateSize, dfaConfig.faultyStateSize);\ndfaConfig.states = new int[dfaConfig.stateSize];\nfor (int i = 0; i < dfaConfig.stateSize; i++) {\ndfaConfig.states[i] = i;\n}\n\nprivate void initialization(int minXSize, int maxXSize) {\n\/\/ TODO: current implementation is less elegant. code refactoring may be needed.\ndfaConfig = new DFAConfig(); \/\/ allocates a new config every time.\nRandom r = new Random();\ndfaConfig.stateSize = r.nextInt((maxXSize - minXSize) + 1) + minXSize;\ndfaConfig.faultyStateSize = Math.max(dfaConfig.stateSize \/ 10, 4);\nLOGGER.debug(\"Generated overall state size and faulty state size: {}, {}\",\ndfaConfig.stateSize, dfaConfig.faultyStateSize);\ndfaConfig.states = new int[dfaConfig.stateSize];\nfor (int i = 0; i < dfaConfig.stateSize; i++) {\ndfaConfig.states[i] = i;\n}\n\/\/ alphabet size: range[6 ~ 16] or [10, 20]\n\ndfaConfig = new DFAConfig(); \/\/ allocates a new config every time.\nRandom r = new Random();\ndfaConfig.stateSize = r.nextInt((maxXSize - minXSize) + 1) + minXSize;\ndfaConfig.faultyStateSize = Math.max(dfaConfig.stateSize \/ 10, 4);\nLOGGER.debug(\"Generated overall state size and faulty state size: {}, {}\",\ndfaConfig.stateSize, dfaConfig.faultyStateSize);\ndfaConfig.states = new int[dfaConfig.stateSize];\nfor (int i = 0; i < dfaConfig.stateSize; i++) {\ndfaConfig.states[i] = i;\n}\n\/\/ alphabet size: range[6 ~ 16] or [10, 20]\nint base = dfaConfig.stateSize > 20 ? 10 : 6;\nint alphabetSize = r.nextInt(11) + base;\ndfaConfig.alphabet = new char[alphabetSize];\nLOGGER.debug(\"Chosen alphabet size is {}\", alphabetSize);\n\/\/ randomly fill the alphabet\nint alphabetSpaceLen = dfaConfig.alphabetSpace.length();\nboolean[] tempFlags = new boolean[alphabetSpaceLen];\nint tempIndex;\nfor (int i = 0; i < dfaConfig.alphabet.length; i++) {\ntempIndex = r.nextInt(alphabetSpaceLen);\n\ndfaConfig.stateSize, dfaConfig.faultyStateSize);\ndfaConfig.states = new int[dfaConfig.stateSize];\nfor (int i = 0; i < dfaConfig.stateSize; i++) {\ndfaConfig.states[i] = i;\n}\n\/\/ alphabet size: range[6 ~ 16] or [10, 20]\nint base = dfaConfig.stateSize > 20 ? 10 : 6;\nint alphabetSize = r.nextInt(11) + base;\ndfaConfig.alphabet = new char[alphabetSize];\nLOGGER.debug(\"Chosen alphabet size is {}\", alphabetSize);\n\/\/ randomly fill the alphabet\nint alphabetSpaceLen = dfaConfig.alphabetSpace.length();\nboolean[] tempFlags = new boolean[alphabetSpaceLen];\nint tempIndex;\nfor (int i = 0; i < dfaConfig.alphabet.length; i++) {\ntempIndex = r.nextInt(alphabetSpaceLen);\nwhile (tempFlags[tempIndex]) {\ntempIndex = r.nextInt(alphabetSpaceLen);\n}\ntempFlags[tempIndex] = true;\ndfaConfig.alphabet[i] = dfaConfig.alphabetSpace.charAt(tempIndex);\n\nboolean[] tempFlags = new boolean[alphabetSpaceLen];\nint tempIndex;\nfor (int i = 0; i < dfaConfig.alphabet.length; i++) {\ntempIndex = r.nextInt(alphabetSpaceLen);\nwhile (tempFlags[tempIndex]) {\ntempIndex = r.nextInt(alphabetSpaceLen);\n}\ntempFlags[tempIndex] = true;\ndfaConfig.alphabet[i] = dfaConfig.alphabetSpace.charAt(tempIndex);\n}\n\/\/ faulty event size (make sure it less than a half of alphabet size)\nint faultEventSize = Math.max(dfaConfig.faultyStateSize \/ 2, 2);\nfaultEventSize = faultEventSize >= 5 ? 4 : faultEventSize;\nif (alphabetSize > 15 && (dfaConfig.faultyStateSize \/ faultEventSize) > 3) {\nfaultEventSize = faultEventSize + r.nextInt(2) + 1;\n}\ndfaConfig.faultyEvents = new int[faultEventSize];\nLOGGER.debug(\"Chosen faulty event size: {}\", faultEventSize);\nboolean[] chosenFaultMarks = new boolean[alphabetSize];\nint choose;\nfor (int i = 0; i < faultEventSize; i++) {","code_context_20":"private void initialization(int minXSize, int maxXSize) {\n\/\/ TODO: current implementation is less elegant. code refactoring may be needed.\ndfaConfig = new DFAConfig(); \/\/ allocates a new config every time.\nRandom r = new Random();\ndfaConfig.stateSize = r.nextInt((maxXSize - minXSize) + 1) + minXSize;\ndfaConfig.faultyStateSize = Math.max(dfaConfig.stateSize \/ 10, 4);\nLOGGER.debug(\"Generated overall state size and faulty state size: {}, {}\",\ndfaConfig.stateSize, dfaConfig.faultyStateSize);\ndfaConfig.states = new int[dfaConfig.stateSize];\nfor (int i = 0; i < dfaConfig.stateSize; i++) {\ndfaConfig.states[i] = i;\n}\n\/\/ alphabet size: range[6 ~ 16] or [10, 20]\nint base = dfaConfig.stateSize > 20 ? 10 : 6;\nint alphabetSize = r.nextInt(11) + base;\ndfaConfig.alphabet = new char[alphabetSize];\nLOGGER.debug(\"Chosen alphabet size is {}\", alphabetSize);\n\/\/ randomly fill the alphabet\nint alphabetSpaceLen = dfaConfig.alphabetSpace.length();\nboolean[] tempFlags = new boolean[alphabetSpaceLen];\nint tempIndex;\nfor (int i = 0; i < dfaConfig.alphabet.length; i++) {\ntempIndex = r.nextInt(alphabetSpaceLen);\nwhile (tempFlags[tempIndex]) {\ntempIndex = r.nextInt(alphabetSpaceLen);\n}\ntempFlags[tempIndex] = true;\ndfaConfig.alphabet[i] = dfaConfig.alphabetSpace.charAt(tempIndex);\n}\n\/\/ faulty event size (make sure it less than a half of alphabet size)\nint faultEventSize = Math.max(dfaConfig.faultyStateSize \/ 2, 2);\nfaultEventSize = faultEventSize >= 5 ? 4 : faultEventSize;\nif (alphabetSize > 15 && (dfaConfig.faultyStateSize \/ faultEventSize) > 3) {\nfaultEventSize = faultEventSize + r.nextInt(2) + 1;\n}\ndfaConfig.faultyEvents = new int[faultEventSize];\nLOGGER.debug(\"Chosen faulty event size: {}\", faultEventSize);\nboolean[] chosenFaultMarks = new boolean[alphabetSize];\nint choose;\nfor (int i = 0; i < faultEventSize; i++) {\nchoose = r.nextInt(alphabetSize);\nwhile (chosenFaultMarks[choose])\nchoose = r.nextInt(alphabetSize);\nchosenFaultMarks[choose] = true;\ndfaConfig.faultyEvents[i] = choose;\n}\nLOGGER.debug(\"Generated alphabet set: {}\", Arrays.toString(dfaConfig.alphabet));\nLOGGER.debug(\"Faulty events (index): {}\", Arrays.toString(dfaConfig.faultyEvents));\nSet<Integer> faultyEventIndexSet = new HashSet<>();\nfor (int fi : dfaConfig.faultyEvents)\nfaultyEventIndexSet.add(fi);\nint ui = 0;\nint oi = 0;\ndfaConfig.observableEvents = new char[alphabetSize - faultEventSize];\ndfaConfig.unobservableEvents = new char[faultEventSize];\nfor (int i = 0; i < alphabetSize; i++) {\nif (faultyEventIndexSet.contains(i))\ndfaConfig.unobservableEvents[ui++] = dfaConfig.alphabet[i];\nelse\ndfaConfig.observableEvents[oi++] = dfaConfig.alphabet[i];\n}\nLOGGER.debug(\"selected observable events : {}\", Arrays.toString(dfaConfig.observableEvents));\nLOGGER.debug(\"selected unobservable events : {}\", Arrays.toString(dfaConfig.unobservableEvents));\n}\n\nprivate void initialization(int minXSize, int maxXSize) {\n\/\/ TODO: current implementation is less elegant. code refactoring may be needed.\ndfaConfig = new DFAConfig(); \/\/ allocates a new config every time.\nRandom r = new Random();\ndfaConfig.stateSize = r.nextInt((maxXSize - minXSize) + 1) + minXSize;\ndfaConfig.faultyStateSize = Math.max(dfaConfig.stateSize \/ 10, 4);\nLOGGER.debug(\"Generated overall state size and faulty state size: {}, {}\",\ndfaConfig.stateSize, dfaConfig.faultyStateSize);\ndfaConfig.states = new int[dfaConfig.stateSize];\nfor (int i = 0; i < dfaConfig.stateSize; i++) {\ndfaConfig.states[i] = i;\n}\n\/\/ alphabet size: range[6 ~ 16] or [10, 20]\nint base = dfaConfig.stateSize > 20 ? 10 : 6;\nint alphabetSize = r.nextInt(11) + base;\ndfaConfig.alphabet = new char[alphabetSize];\nLOGGER.debug(\"Chosen alphabet size is {}\", alphabetSize);\n\/\/ randomly fill the alphabet\nint alphabetSpaceLen = dfaConfig.alphabetSpace.length();\nboolean[] tempFlags = new boolean[alphabetSpaceLen];\nint tempIndex;\nfor (int i = 0; i < dfaConfig.alphabet.length; i++) {\n\nprivate void initialization(int minXSize, int maxXSize) {\n\/\/ TODO: current implementation is less elegant. code refactoring may be needed.\ndfaConfig = new DFAConfig(); \/\/ allocates a new config every time.\nRandom r = new Random();\ndfaConfig.stateSize = r.nextInt((maxXSize - minXSize) + 1) + minXSize;\ndfaConfig.faultyStateSize = Math.max(dfaConfig.stateSize \/ 10, 4);\nLOGGER.debug(\"Generated overall state size and faulty state size: {}, {}\",\ndfaConfig.stateSize, dfaConfig.faultyStateSize);\ndfaConfig.states = new int[dfaConfig.stateSize];\nfor (int i = 0; i < dfaConfig.stateSize; i++) {\ndfaConfig.states[i] = i;\n}\n\/\/ alphabet size: range[6 ~ 16] or [10, 20]\nint base = dfaConfig.stateSize > 20 ? 10 : 6;\nint alphabetSize = r.nextInt(11) + base;\ndfaConfig.alphabet = new char[alphabetSize];\nLOGGER.debug(\"Chosen alphabet size is {}\", alphabetSize);\n\/\/ randomly fill the alphabet\nint alphabetSpaceLen = dfaConfig.alphabetSpace.length();\nboolean[] tempFlags = new boolean[alphabetSpaceLen];\nint tempIndex;\nfor (int i = 0; i < dfaConfig.alphabet.length; i++) {\ntempIndex = r.nextInt(alphabetSpaceLen);\n\nprivate void initialization(int minXSize, int maxXSize) {\n\/\/ TODO: current implementation is less elegant. code refactoring may be needed.\ndfaConfig = new DFAConfig(); \/\/ allocates a new config every time.\nRandom r = new Random();\ndfaConfig.stateSize = r.nextInt((maxXSize - minXSize) + 1) + minXSize;\ndfaConfig.faultyStateSize = Math.max(dfaConfig.stateSize \/ 10, 4);\nLOGGER.debug(\"Generated overall state size and faulty state size: {}, {}\",\ndfaConfig.stateSize, dfaConfig.faultyStateSize);\ndfaConfig.states = new int[dfaConfig.stateSize];\nfor (int i = 0; i < dfaConfig.stateSize; i++) {\ndfaConfig.states[i] = i;\n}\n\/\/ alphabet size: range[6 ~ 16] or [10, 20]\nint base = dfaConfig.stateSize > 20 ? 10 : 6;\nint alphabetSize = r.nextInt(11) + base;\ndfaConfig.alphabet = new char[alphabetSize];\nLOGGER.debug(\"Chosen alphabet size is {}\", alphabetSize);\n\/\/ randomly fill the alphabet\nint alphabetSpaceLen = dfaConfig.alphabetSpace.length();\nboolean[] tempFlags = new boolean[alphabetSpaceLen];\nint tempIndex;\nfor (int i = 0; i < dfaConfig.alphabet.length; i++) {\ntempIndex = r.nextInt(alphabetSpaceLen);\nwhile (tempFlags[tempIndex]) {\ntempIndex = r.nextInt(alphabetSpaceLen);\n}\ntempFlags[tempIndex] = true;\ndfaConfig.alphabet[i] = dfaConfig.alphabetSpace.charAt(tempIndex);\n}\n\/\/ faulty event size (make sure it less than a half of alphabet size)\nint faultEventSize = Math.max(dfaConfig.faultyStateSize \/ 2, 2);\nfaultEventSize = faultEventSize >= 5 ? 4 : faultEventSize;\nif (alphabetSize > 15 && (dfaConfig.faultyStateSize \/ faultEventSize) > 3) {\n\nprivate void initialization(int minXSize, int maxXSize) {\n\/\/ TODO: current implementation is less elegant. code refactoring may be needed.\ndfaConfig = new DFAConfig(); \/\/ allocates a new config every time.\nRandom r = new Random();\ndfaConfig.stateSize = r.nextInt((maxXSize - minXSize) + 1) + minXSize;\ndfaConfig.faultyStateSize = Math.max(dfaConfig.stateSize \/ 10, 4);\nLOGGER.debug(\"Generated overall state size and faulty state size: {}, {}\",\ndfaConfig.stateSize, dfaConfig.faultyStateSize);\ndfaConfig.states = new int[dfaConfig.stateSize];\nfor (int i = 0; i < dfaConfig.stateSize; i++) {\ndfaConfig.states[i] = i;\n}\n\/\/ alphabet size: range[6 ~ 16] or [10, 20]\nint base = dfaConfig.stateSize > 20 ? 10 : 6;\nint alphabetSize = r.nextInt(11) + base;\ndfaConfig.alphabet = new char[alphabetSize];\nLOGGER.debug(\"Chosen alphabet size is {}\", alphabetSize);\n\/\/ randomly fill the alphabet\nint alphabetSpaceLen = dfaConfig.alphabetSpace.length();\nboolean[] tempFlags = new boolean[alphabetSpaceLen];\nint tempIndex;\nfor (int i = 0; i < dfaConfig.alphabet.length; i++) {\ntempIndex = r.nextInt(alphabetSpaceLen);\nwhile (tempFlags[tempIndex]) {\ntempIndex = r.nextInt(alphabetSpaceLen);\n}\ntempFlags[tempIndex] = true;\ndfaConfig.alphabet[i] = dfaConfig.alphabetSpace.charAt(tempIndex);\n}\n\/\/ faulty event size (make sure it less than a half of alphabet size)\nint faultEventSize = Math.max(dfaConfig.faultyStateSize \/ 2, 2);\nfaultEventSize = faultEventSize >= 5 ? 4 : faultEventSize;\nif (alphabetSize > 15 && (dfaConfig.faultyStateSize \/ faultEventSize) > 3) {\nfaultEventSize = faultEventSize + r.nextInt(2) + 1;\n}\ndfaConfig.faultyEvents = new int[faultEventSize];\nLOGGER.debug(\"Chosen faulty event size: {}\", faultEventSize);\nboolean[] chosenFaultMarks = new boolean[alphabetSize];\n\nfor (int i = 0; i < dfaConfig.stateSize; i++) {\ndfaConfig.states[i] = i;\n}\n\/\/ alphabet size: range[6 ~ 16] or [10, 20]\nint base = dfaConfig.stateSize > 20 ? 10 : 6;\nint alphabetSize = r.nextInt(11) + base;\ndfaConfig.alphabet = new char[alphabetSize];\nLOGGER.debug(\"Chosen alphabet size is {}\", alphabetSize);\n\/\/ randomly fill the alphabet\nint alphabetSpaceLen = dfaConfig.alphabetSpace.length();\nboolean[] tempFlags = new boolean[alphabetSpaceLen];\nint tempIndex;\nfor (int i = 0; i < dfaConfig.alphabet.length; i++) {\ntempIndex = r.nextInt(alphabetSpaceLen);\nwhile (tempFlags[tempIndex]) {\ntempIndex = r.nextInt(alphabetSpaceLen);\n}\ntempFlags[tempIndex] = true;\ndfaConfig.alphabet[i] = dfaConfig.alphabetSpace.charAt(tempIndex);\n}\n\/\/ faulty event size (make sure it less than a half of alphabet size)\nint faultEventSize = Math.max(dfaConfig.faultyStateSize \/ 2, 2);\nfaultEventSize = faultEventSize >= 5 ? 4 : faultEventSize;\nif (alphabetSize > 15 && (dfaConfig.faultyStateSize \/ faultEventSize) > 3) {\nfaultEventSize = faultEventSize + r.nextInt(2) + 1;\n}\ndfaConfig.faultyEvents = new int[faultEventSize];\nLOGGER.debug(\"Chosen faulty event size: {}\", faultEventSize);\nboolean[] chosenFaultMarks = new boolean[alphabetSize];\nint choose;\nfor (int i = 0; i < faultEventSize; i++) {\nchoose = r.nextInt(alphabetSize);\nwhile (chosenFaultMarks[choose])\nchoose = r.nextInt(alphabetSize);\nchosenFaultMarks[choose] = true;\ndfaConfig.faultyEvents[i] = choose;\n}\nLOGGER.debug(\"Generated alphabet set: {}\", Arrays.toString(dfaConfig.alphabet));\nLOGGER.debug(\"Faulty events (index): {}\", Arrays.toString(dfaConfig.faultyEvents));\nSet<Integer> faultyEventIndexSet = new HashSet<>();\nfor (int fi : dfaConfig.faultyEvents)","label":[1,0,0,0]}
{"id":34283,"original_code":"@Override\n    public BiomeProvider load(AnnotatedType t, Object c, ConfigLoader loader) throws LoadException {\n        return loader.loadType(BiomePipelineProvider.class, c); \/\/ TODO: actually implement this lol\n    }","code":"@Override\n    public BiomeProvider load(AnnotatedType t, Object c, ConfigLoader loader) throws LoadException {\n        return loader.loadType(BiomePipelineProvider.class, c);\n    }","cleancode":"@override public biomeprovider load(annotatedtype t, object c, configloader loader) throws loadexception { return loader.loadtype(biomepipelineprovider.class, c); }","comment":"\/\/ todo: actually implement this lol","repo":"PolyhedralDev\/Terra-biome-provider-pipeline","code_context_2":"@Override\npublic BiomeProvider load(AnnotatedType t, Object c, ConfigLoader loader) throws LoadException {\nreturn loader.loadType(BiomePipelineProvider.class, c); \/\/ TODO: actually implement this lol\n}","code_context_10":"@Override\npublic BiomeProvider load(AnnotatedType t, Object c, ConfigLoader loader) throws LoadException {\nreturn loader.loadType(BiomePipelineProvider.class, c); \/\/ TODO: actually implement this lol\n}","code_context_20":"@Override\npublic BiomeProvider load(AnnotatedType t, Object c, ConfigLoader loader) throws LoadException {\nreturn loader.loadType(BiomePipelineProvider.class, c); \/\/ TODO: actually implement this lol\n}","label":[0,1,0,0]}
{"id":34349,"original_code":"public List<List<String>> rows() {\n    try {\n      List<List<String>> results = new ArrayList<>();\n      for (BaseWork baseWork : topSortedWork) {\n        String vertexName = baseWork.getName();\n        VertexProgress progress = progressCountsMap.get(vertexName);\n        if (progress != null) {\n          \/\/ Map 1 .......... container  SUCCEEDED      7          7        0        0       0       0\n          \/\/ TODO: can we pass custom things thru the progress?\n          results.add(\n            Arrays.asList(\n              getNameWithProgress(vertexName, progress.succeededTaskCount, progress.totalTaskCount),\n              getMode(baseWork),\n              progress.vertexStatus(vertexStatusMap.get(vertexName)),\n              progress.total(),\n              progress.completed(),\n              progress.running(),\n              progress.pending(),\n              progress.failed(),\n              progress.killed()\n            )\n          );\n        }\n      }\n      return results;\n    } catch (Exception e) {\n      console.printInfo(\n          \"Getting  Progress Bar table rows failed: \" + e.getMessage() + \" stack trace: \" + Arrays\n              .toString(e.getStackTrace())\n      );\n    }\n    return Collections.emptyList();\n  }","code":"public List<List<String>> rows() {\n    try {\n      List<List<String>> results = new ArrayList<>();\n      for (BaseWork baseWork : topSortedWork) {\n        String vertexName = baseWork.getName();\n        VertexProgress progress = progressCountsMap.get(vertexName);\n        if (progress != null) {\n         \n         \n          results.add(\n            Arrays.asList(\n              getNameWithProgress(vertexName, progress.succeededTaskCount, progress.totalTaskCount),\n              getMode(baseWork),\n              progress.vertexStatus(vertexStatusMap.get(vertexName)),\n              progress.total(),\n              progress.completed(),\n              progress.running(),\n              progress.pending(),\n              progress.failed(),\n              progress.killed()\n            )\n          );\n        }\n      }\n      return results;\n    } catch (Exception e) {\n      console.printInfo(\n          \"Getting  Progress Bar table rows failed: \" + e.getMessage() + \" stack trace: \" + Arrays\n              .toString(e.getStackTrace())\n      );\n    }\n    return Collections.emptyList();\n  }","cleancode":"public list<list<string>> rows() { try { list<list<string>> results = new arraylist<>(); for (basework basework : topsortedwork) { string vertexname = basework.getname(); vertexprogress progress = progresscountsmap.get(vertexname); if (progress != null) { results.add( arrays.aslist( getnamewithprogress(vertexname, progress.succeededtaskcount, progress.totaltaskcount), getmode(basework), progress.vertexstatus(vertexstatusmap.get(vertexname)), progress.total(), progress.completed(), progress.running(), progress.pending(), progress.failed(), progress.killed() ) ); } } return results; } catch (exception e) { console.printinfo( \"getting progress bar table rows failed: \" + e.getmessage() + \" stack trace: \" + arrays .tostring(e.getstacktrace()) ); } return collections.emptylist(); }","comment":"\/\/ map 1 .......... container succeeded 7 7 0 0 0 0 \/\/ todo: can we pass custom things thru the progress?","repo":"JSA-Insubria\/hive","code_context_2":"VertexProgress progress = progressCountsMap.get(vertexName);\nif (progress != null) {\n\/\/ Map 1 .......... container SUCCEEDED 7 7 0 0 0 0\n\/\/ TODO: can we pass custom things thru the progress?\nresults.add(\nArrays.asList(","code_context_10":"public List<List<String>> rows() {\ntry {\nList<List<String>> results = new ArrayList<>();\nfor (BaseWork baseWork : topSortedWork) {\nString vertexName = baseWork.getName();\nVertexProgress progress = progressCountsMap.get(vertexName);\nif (progress != null) {\n\/\/ Map 1 .......... container SUCCEEDED 7 7 0 0 0 0\n\/\/ TODO: can we pass custom things thru the progress?\nresults.add(\nArrays.asList(\ngetNameWithProgress(vertexName, progress.succeededTaskCount, progress.totalTaskCount),\ngetMode(baseWork),\nprogress.vertexStatus(vertexStatusMap.get(vertexName)),\nprogress.total(),\nprogress.completed(),\nprogress.running(),\nprogress.pending(),\nprogress.failed(),","code_context_20":"public List<List<String>> rows() {\ntry {\nList<List<String>> results = new ArrayList<>();\nfor (BaseWork baseWork : topSortedWork) {\nString vertexName = baseWork.getName();\nVertexProgress progress = progressCountsMap.get(vertexName);\nif (progress != null) {\n\/\/ Map 1 .......... container SUCCEEDED 7 7 0 0 0 0\n\/\/ TODO: can we pass custom things thru the progress?\nresults.add(\nArrays.asList(\ngetNameWithProgress(vertexName, progress.succeededTaskCount, progress.totalTaskCount),\ngetMode(baseWork),\nprogress.vertexStatus(vertexStatusMap.get(vertexName)),\nprogress.total(),\nprogress.completed(),\nprogress.running(),\nprogress.pending(),\nprogress.failed(),\nprogress.killed()\n)\n);\n}\n}\nreturn results;\n} catch (Exception e) {\nconsole.printInfo(\n\"Getting Progress Bar table rows failed: \" + e.getMessage() + \" stack trace: \" + Arrays\n.toString(e.getStackTrace())","label":[1,0,0,0]}
{"id":9779,"original_code":"Statement compileSQLProcedureStatementOrNull(Routine routine,\n            StatementCompound context) {\n        Statement cs    = null;\n        HsqlName  label = null;\n        RangeVariable[] rangeVariables = context == null\n                                         ? routine.getParameterRangeVariables()\n                                         : context.getRangeVariables();\n        if (!routine.isTrigger() && isSimpleName() && !isReservedKey()) {\n            label = readNewSchemaObjectName(SchemaObject.LABEL, false);\n            \/\/ todo - improved error message\n            if (token.tokenType != Tokens.COLON) {\n                throw unexpectedToken(label.getNameString());\n            }\n            readThis(Tokens.COLON);\n        }\n        compileContext.reset();\n        HsqlName oldSchema = session.getCurrentSchemaHsqlName();\n        session.setCurrentSchemaHsqlName(routine.getSchemaName());\n        try {\n            switch (token.tokenType) {\n                \/\/ data\n                case Tokens.OPEN : {\n                    if (routine.dataImpact == Routine.CONTAINS_SQL) {\n                        throw Error.error(ErrorCode.X_42602,\n                                          routine.getDataImpactString());\n                    }\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileOpenCursorStatement(context);\n                    break;\n                }\n                case Tokens.SELECT : {\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileSelectSingleRowStatement(rangeVariables);\n                    break;\n                }\n                \/\/ data change\n                case Tokens.INSERT :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileInsertStatement(rangeVariables);\n                    break;\n                case Tokens.UPDATE :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileUpdateStatement(rangeVariables);\n                    break;\n                case Tokens.DELETE :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileDeleteStatement(rangeVariables);\n                    break;\n                case Tokens.TRUNCATE :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileTruncateStatement();\n                    break;\n                case Tokens.MERGE :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileMergeStatement(rangeVariables);\n                    break;\n                case Tokens.SET :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    if (routine.isTrigger()) {\n                        if (routine.triggerOperation\n                                == StatementTypes.DELETE_WHERE) {\n                            cs = compileSetStatement(rangeVariables);\n                            break;\n                        }\n                        if (routine.triggerType != TriggerDef.BEFORE) {\n                            cs = compileSetStatement(rangeVariables);\n                            break;\n                        }\n                        int position = super.getPosition();\n                        try {\n                            cs = compileTriggerSetStatement(\n                                routine.triggerTable, rangeVariables);\n                        } catch (HsqlException e) {\n                            rewind(position);\n                            cs = compileSetStatement(rangeVariables);\n                        }\n                    } else {\n                        cs = compileSetStatement(rangeVariables);\n                    }\n                    break;\n                case Tokens.GET :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = this.compileGetStatement(rangeVariables);\n                    break;\n                \/\/ control\n                case Tokens.CALL : {\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileCallStatement(rangeVariables, true);\n                    Routine proc = ((StatementProcedure) cs).procedure;\n                    if (proc != null) {\n                        switch (routine.dataImpact) {\n                            case Routine.CONTAINS_SQL : {\n                                if (proc.dataImpact == Routine.READS_SQL\n                                        || proc.dataImpact\n                                           == Routine.MODIFIES_SQL) {\n                                    throw Error.error(\n                                        ErrorCode.X_42602,\n                                        routine.getDataImpactString());\n                                }\n                                break;\n                            }\n                            case Routine.READS_SQL : {\n                                if (proc.dataImpact == Routine.MODIFIES_SQL) {\n                                    throw Error.error(\n                                        ErrorCode.X_42602,\n                                        routine.getDataImpactString());\n                                }\n                                break;\n                            }\n                        }\n                    }\n                    break;\n                }\n                case Tokens.RETURN : {\n                    if (routine.isTrigger() || label != null) {\n                        throw unexpectedToken();\n                    }\n                    read();\n                    cs = compileReturnValue(routine, context);\n                    break;\n                }\n                case Tokens.BEGIN : {\n                    cs = compileCompoundStatement(routine, context, label);\n                    break;\n                }\n                case Tokens.WHILE : {\n                    if (routine.isTrigger()) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileWhile(routine, context, label);\n                    break;\n                }\n                case Tokens.REPEAT : {\n                    cs = compileRepeat(routine, context, label);\n                    break;\n                }\n                case Tokens.LOOP : {\n                    cs = compileLoop(routine, context, label);\n                    break;\n                }\n                case Tokens.FOR : {\n                    cs = compileFor(routine, context, label);\n                    break;\n                }\n                case Tokens.ITERATE : {\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileIterate();\n                    break;\n                }\n                case Tokens.LEAVE : {\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileLeave(routine, context);\n                    break;\n                }\n                case Tokens.IF : {\n                    cs = compileIf(routine, context);\n                    break;\n                }\n                case Tokens.CASE : {\n                    cs = compileCase(routine, context);\n                    break;\n                }\n                case Tokens.SIGNAL : {\n                    cs = compileSignal(routine, context, label);\n                    break;\n                }\n                case Tokens.RESIGNAL : {\n                    cs = compileResignal(routine, context, label);\n                    break;\n                }\n                default :\n                    return null;\n            }\n            cs.setRoot(routine);\n            cs.setParent(context);\n            return cs;\n        } finally {\n            session.setCurrentSchemaHsqlName(oldSchema);\n        }\n    }","code":"Statement compileSQLProcedureStatementOrNull(Routine routine,\n            StatementCompound context) {\n        Statement cs    = null;\n        HsqlName  label = null;\n        RangeVariable[] rangeVariables = context == null\n                                         ? routine.getParameterRangeVariables()\n                                         : context.getRangeVariables();\n        if (!routine.isTrigger() && isSimpleName() && !isReservedKey()) {\n            label = readNewSchemaObjectName(SchemaObject.LABEL, false);\n           \n            if (token.tokenType != Tokens.COLON) {\n                throw unexpectedToken(label.getNameString());\n            }\n            readThis(Tokens.COLON);\n        }\n        compileContext.reset();\n        HsqlName oldSchema = session.getCurrentSchemaHsqlName();\n        session.setCurrentSchemaHsqlName(routine.getSchemaName());\n        try {\n            switch (token.tokenType) {\n               \n                case Tokens.OPEN : {\n                    if (routine.dataImpact == Routine.CONTAINS_SQL) {\n                        throw Error.error(ErrorCode.X_42602,\n                                          routine.getDataImpactString());\n                    }\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileOpenCursorStatement(context);\n                    break;\n                }\n                case Tokens.SELECT : {\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileSelectSingleRowStatement(rangeVariables);\n                    break;\n                }\n               \n                case Tokens.INSERT :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileInsertStatement(rangeVariables);\n                    break;\n                case Tokens.UPDATE :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileUpdateStatement(rangeVariables);\n                    break;\n                case Tokens.DELETE :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileDeleteStatement(rangeVariables);\n                    break;\n                case Tokens.TRUNCATE :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileTruncateStatement();\n                    break;\n                case Tokens.MERGE :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileMergeStatement(rangeVariables);\n                    break;\n                case Tokens.SET :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    if (routine.isTrigger()) {\n                        if (routine.triggerOperation\n                                == StatementTypes.DELETE_WHERE) {\n                            cs = compileSetStatement(rangeVariables);\n                            break;\n                        }\n                        if (routine.triggerType != TriggerDef.BEFORE) {\n                            cs = compileSetStatement(rangeVariables);\n                            break;\n                        }\n                        int position = super.getPosition();\n                        try {\n                            cs = compileTriggerSetStatement(\n                                routine.triggerTable, rangeVariables);\n                        } catch (HsqlException e) {\n                            rewind(position);\n                            cs = compileSetStatement(rangeVariables);\n                        }\n                    } else {\n                        cs = compileSetStatement(rangeVariables);\n                    }\n                    break;\n                case Tokens.GET :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = this.compileGetStatement(rangeVariables);\n                    break;\n               \n                case Tokens.CALL : {\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileCallStatement(rangeVariables, true);\n                    Routine proc = ((StatementProcedure) cs).procedure;\n                    if (proc != null) {\n                        switch (routine.dataImpact) {\n                            case Routine.CONTAINS_SQL : {\n                                if (proc.dataImpact == Routine.READS_SQL\n                                        || proc.dataImpact\n                                           == Routine.MODIFIES_SQL) {\n                                    throw Error.error(\n                                        ErrorCode.X_42602,\n                                        routine.getDataImpactString());\n                                }\n                                break;\n                            }\n                            case Routine.READS_SQL : {\n                                if (proc.dataImpact == Routine.MODIFIES_SQL) {\n                                    throw Error.error(\n                                        ErrorCode.X_42602,\n                                        routine.getDataImpactString());\n                                }\n                                break;\n                            }\n                        }\n                    }\n                    break;\n                }\n                case Tokens.RETURN : {\n                    if (routine.isTrigger() || label != null) {\n                        throw unexpectedToken();\n                    }\n                    read();\n                    cs = compileReturnValue(routine, context);\n                    break;\n                }\n                case Tokens.BEGIN : {\n                    cs = compileCompoundStatement(routine, context, label);\n                    break;\n                }\n                case Tokens.WHILE : {\n                    if (routine.isTrigger()) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileWhile(routine, context, label);\n                    break;\n                }\n                case Tokens.REPEAT : {\n                    cs = compileRepeat(routine, context, label);\n                    break;\n                }\n                case Tokens.LOOP : {\n                    cs = compileLoop(routine, context, label);\n                    break;\n                }\n                case Tokens.FOR : {\n                    cs = compileFor(routine, context, label);\n                    break;\n                }\n                case Tokens.ITERATE : {\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileIterate();\n                    break;\n                }\n                case Tokens.LEAVE : {\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileLeave(routine, context);\n                    break;\n                }\n                case Tokens.IF : {\n                    cs = compileIf(routine, context);\n                    break;\n                }\n                case Tokens.CASE : {\n                    cs = compileCase(routine, context);\n                    break;\n                }\n                case Tokens.SIGNAL : {\n                    cs = compileSignal(routine, context, label);\n                    break;\n                }\n                case Tokens.RESIGNAL : {\n                    cs = compileResignal(routine, context, label);\n                    break;\n                }\n                default :\n                    return null;\n            }\n            cs.setRoot(routine);\n            cs.setParent(context);\n            return cs;\n        } finally {\n            session.setCurrentSchemaHsqlName(oldSchema);\n        }\n    }","cleancode":"statement compilesqlprocedurestatementornull(routine routine, statementcompound context) { statement cs = null; hsqlname label = null; rangevariable[] rangevariables = context == null ? routine.getparameterrangevariables() : context.getrangevariables(); if (!routine.istrigger() && issimplename() && !isreservedkey()) { label = readnewschemaobjectname(schemaobject.label, false); if (token.tokentype != tokens.colon) { throw unexpectedtoken(label.getnamestring()); } readthis(tokens.colon); } compilecontext.reset(); hsqlname oldschema = session.getcurrentschemahsqlname(); session.setcurrentschemahsqlname(routine.getschemaname()); try { switch (token.tokentype) { case tokens.open : { if (routine.dataimpact == routine.contains_sql) { throw error.error(errorcode.x_42602, routine.getdataimpactstring()); } if (label != null) { throw unexpectedtoken(); } cs = compileopencursorstatement(context); break; } case tokens.select : { if (label != null) { throw unexpectedtoken(); } cs = compileselectsinglerowstatement(rangevariables); break; } case tokens.insert : if (label != null) { throw unexpectedtoken(); } cs = compileinsertstatement(rangevariables); break; case tokens.update : if (label != null) { throw unexpectedtoken(); } cs = compileupdatestatement(rangevariables); break; case tokens.delete : if (label != null) { throw unexpectedtoken(); } cs = compiledeletestatement(rangevariables); break; case tokens.truncate : if (label != null) { throw unexpectedtoken(); } cs = compiletruncatestatement(); break; case tokens.merge : if (label != null) { throw unexpectedtoken(); } cs = compilemergestatement(rangevariables); break; case tokens.set : if (label != null) { throw unexpectedtoken(); } if (routine.istrigger()) { if (routine.triggeroperation == statementtypes.delete_where) { cs = compilesetstatement(rangevariables); break; } if (routine.triggertype != triggerdef.before) { cs = compilesetstatement(rangevariables); break; } int position = super.getposition(); try { cs = compiletriggersetstatement( routine.triggertable, rangevariables); } catch (hsqlexception e) { rewind(position); cs = compilesetstatement(rangevariables); } } else { cs = compilesetstatement(rangevariables); } break; case tokens.get : if (label != null) { throw unexpectedtoken(); } cs = this.compilegetstatement(rangevariables); break; case tokens.call : { if (label != null) { throw unexpectedtoken(); } cs = compilecallstatement(rangevariables, true); routine proc = ((statementprocedure) cs).procedure; if (proc != null) { switch (routine.dataimpact) { case routine.contains_sql : { if (proc.dataimpact == routine.reads_sql || proc.dataimpact == routine.modifies_sql) { throw error.error( errorcode.x_42602, routine.getdataimpactstring()); } break; } case routine.reads_sql : { if (proc.dataimpact == routine.modifies_sql) { throw error.error( errorcode.x_42602, routine.getdataimpactstring()); } break; } } } break; } case tokens.return : { if (routine.istrigger() || label != null) { throw unexpectedtoken(); } read(); cs = compilereturnvalue(routine, context); break; } case tokens.begin : { cs = compilecompoundstatement(routine, context, label); break; } case tokens.while : { if (routine.istrigger()) { throw unexpectedtoken(); } cs = compilewhile(routine, context, label); break; } case tokens.repeat : { cs = compilerepeat(routine, context, label); break; } case tokens.loop : { cs = compileloop(routine, context, label); break; } case tokens.for : { cs = compilefor(routine, context, label); break; } case tokens.iterate : { if (label != null) { throw unexpectedtoken(); } cs = compileiterate(); break; } case tokens.leave : { if (label != null) { throw unexpectedtoken(); } cs = compileleave(routine, context); break; } case tokens.if : { cs = compileif(routine, context); break; } case tokens.case : { cs = compilecase(routine, context); break; } case tokens.signal : { cs = compilesignal(routine, context, label); break; } case tokens.resignal : { cs = compileresignal(routine, context, label); break; } default : return null; } cs.setroot(routine); cs.setparent(context); return cs; } finally { session.setcurrentschemahsqlname(oldschema); } }","comment":"\/\/ todo - improved error message\n\/\/ data\n\/\/ data change\n\/\/ control","repo":"RabadanLab\/Pegasus","code_context_2":"if (!routine.isTrigger() && isSimpleName() && !isReservedKey()) {\nlabel = readNewSchemaObjectName(SchemaObject.LABEL, false);\n\/\/ todo - improved error message\nif (token.tokenType != Tokens.COLON) {\nthrow unexpectedToken(label.getNameString());\n\ntry {\nswitch (token.tokenType) {\n\/\/ data\ncase Tokens.OPEN : {\nif (routine.dataImpact == Routine.CONTAINS_SQL) {\n\nbreak;\n}\n\/\/ data change\ncase Tokens.INSERT :\nif (label != null) {\n\ncs = this.compileGetStatement(rangeVariables);\nbreak;\n\/\/ control\ncase Tokens.CALL : {\nif (label != null) {","code_context_10":"Statement compileSQLProcedureStatementOrNull(Routine routine,\nStatementCompound context) {\nStatement cs = null;\nHsqlName label = null;\nRangeVariable[] rangeVariables = context == null\n? routine.getParameterRangeVariables()\n: context.getRangeVariables();\nif (!routine.isTrigger() && isSimpleName() && !isReservedKey()) {\nlabel = readNewSchemaObjectName(SchemaObject.LABEL, false);\n\/\/ todo - improved error message\nif (token.tokenType != Tokens.COLON) {\nthrow unexpectedToken(label.getNameString());\n}\nreadThis(Tokens.COLON);\n}\ncompileContext.reset();\nHsqlName oldSchema = session.getCurrentSchemaHsqlName();\nsession.setCurrentSchemaHsqlName(routine.getSchemaName());\ntry {\nswitch (token.tokenType) {\n\nif (token.tokenType != Tokens.COLON) {\nthrow unexpectedToken(label.getNameString());\n}\nreadThis(Tokens.COLON);\n}\ncompileContext.reset();\nHsqlName oldSchema = session.getCurrentSchemaHsqlName();\nsession.setCurrentSchemaHsqlName(routine.getSchemaName());\ntry {\nswitch (token.tokenType) {\n\/\/ data\ncase Tokens.OPEN : {\nif (routine.dataImpact == Routine.CONTAINS_SQL) {\nthrow Error.error(ErrorCode.X_42602,\nroutine.getDataImpactString());\n}\nif (label != null) {\nthrow unexpectedToken();\n}\ncs = compileOpenCursorStatement(context);\nbreak;\n\ncs = compileOpenCursorStatement(context);\nbreak;\n}\ncase Tokens.SELECT : {\nif (label != null) {\nthrow unexpectedToken();\n}\ncs = compileSelectSingleRowStatement(rangeVariables);\nbreak;\n}\n\/\/ data change\ncase Tokens.INSERT :\nif (label != null) {\nthrow unexpectedToken();\n}\ncs = compileInsertStatement(rangeVariables);\nbreak;\ncase Tokens.UPDATE :\nif (label != null) {\nthrow unexpectedToken();\n}\n\n} else {\ncs = compileSetStatement(rangeVariables);\n}\nbreak;\ncase Tokens.GET :\nif (label != null) {\nthrow unexpectedToken();\n}\ncs = this.compileGetStatement(rangeVariables);\nbreak;\n\/\/ control\ncase Tokens.CALL : {\nif (label != null) {\nthrow unexpectedToken();\n}\ncs = compileCallStatement(rangeVariables, true);\nRoutine proc = ((StatementProcedure) cs).procedure;\nif (proc != null) {\nswitch (routine.dataImpact) {\ncase Routine.CONTAINS_SQL : {\nif (proc.dataImpact == Routine.READS_SQL","code_context_20":"Statement compileSQLProcedureStatementOrNull(Routine routine,\nStatementCompound context) {\nStatement cs = null;\nHsqlName label = null;\nRangeVariable[] rangeVariables = context == null\n? routine.getParameterRangeVariables()\n: context.getRangeVariables();\nif (!routine.isTrigger() && isSimpleName() && !isReservedKey()) {\nlabel = readNewSchemaObjectName(SchemaObject.LABEL, false);\n\/\/ todo - improved error message\nif (token.tokenType != Tokens.COLON) {\nthrow unexpectedToken(label.getNameString());\n}\nreadThis(Tokens.COLON);\n}\ncompileContext.reset();\nHsqlName oldSchema = session.getCurrentSchemaHsqlName();\nsession.setCurrentSchemaHsqlName(routine.getSchemaName());\ntry {\nswitch (token.tokenType) {\n\/\/ data\ncase Tokens.OPEN : {\nif (routine.dataImpact == Routine.CONTAINS_SQL) {\nthrow Error.error(ErrorCode.X_42602,\nroutine.getDataImpactString());\n}\nif (label != null) {\nthrow unexpectedToken();\n}\ncs = compileOpenCursorStatement(context);\n\nStatement compileSQLProcedureStatementOrNull(Routine routine,\nStatementCompound context) {\nStatement cs = null;\nHsqlName label = null;\nRangeVariable[] rangeVariables = context == null\n? routine.getParameterRangeVariables()\n: context.getRangeVariables();\nif (!routine.isTrigger() && isSimpleName() && !isReservedKey()) {\nlabel = readNewSchemaObjectName(SchemaObject.LABEL, false);\n\/\/ todo - improved error message\nif (token.tokenType != Tokens.COLON) {\nthrow unexpectedToken(label.getNameString());\n}\nreadThis(Tokens.COLON);\n}\ncompileContext.reset();\nHsqlName oldSchema = session.getCurrentSchemaHsqlName();\nsession.setCurrentSchemaHsqlName(routine.getSchemaName());\ntry {\nswitch (token.tokenType) {\n\/\/ data\ncase Tokens.OPEN : {\nif (routine.dataImpact == Routine.CONTAINS_SQL) {\nthrow Error.error(ErrorCode.X_42602,\nroutine.getDataImpactString());\n}\nif (label != null) {\nthrow unexpectedToken();\n}\ncs = compileOpenCursorStatement(context);\nbreak;\n}\ncase Tokens.SELECT : {\nif (label != null) {\nthrow unexpectedToken();\n}\ncs = compileSelectSingleRowStatement(rangeVariables);\nbreak;\n}\n\/\/ data change\ncase Tokens.INSERT :\n\nswitch (token.tokenType) {\n\/\/ data\ncase Tokens.OPEN : {\nif (routine.dataImpact == Routine.CONTAINS_SQL) {\nthrow Error.error(ErrorCode.X_42602,\nroutine.getDataImpactString());\n}\nif (label != null) {\nthrow unexpectedToken();\n}\ncs = compileOpenCursorStatement(context);\nbreak;\n}\ncase Tokens.SELECT : {\nif (label != null) {\nthrow unexpectedToken();\n}\ncs = compileSelectSingleRowStatement(rangeVariables);\nbreak;\n}\n\/\/ data change\ncase Tokens.INSERT :\nif (label != null) {\nthrow unexpectedToken();\n}\ncs = compileInsertStatement(rangeVariables);\nbreak;\ncase Tokens.UPDATE :\nif (label != null) {\nthrow unexpectedToken();\n}\ncs = compileUpdateStatement(rangeVariables);\nbreak;\ncase Tokens.DELETE :\nif (label != null) {\nthrow unexpectedToken();\n}\ncs = compileDeleteStatement(rangeVariables);\nbreak;\ncase Tokens.TRUNCATE :\nif (label != null) {\n\nbreak;\n}\nint position = super.getPosition();\ntry {\ncs = compileTriggerSetStatement(\nroutine.triggerTable, rangeVariables);\n} catch (HsqlException e) {\nrewind(position);\ncs = compileSetStatement(rangeVariables);\n}\n} else {\ncs = compileSetStatement(rangeVariables);\n}\nbreak;\ncase Tokens.GET :\nif (label != null) {\nthrow unexpectedToken();\n}\ncs = this.compileGetStatement(rangeVariables);\nbreak;\n\/\/ control\ncase Tokens.CALL : {\nif (label != null) {\nthrow unexpectedToken();\n}\ncs = compileCallStatement(rangeVariables, true);\nRoutine proc = ((StatementProcedure) cs).procedure;\nif (proc != null) {\nswitch (routine.dataImpact) {\ncase Routine.CONTAINS_SQL : {\nif (proc.dataImpact == Routine.READS_SQL\n|| proc.dataImpact\n== Routine.MODIFIES_SQL) {\nthrow Error.error(\nErrorCode.X_42602,\nroutine.getDataImpactString());\n}\nbreak;\n}\ncase Routine.READS_SQL : {\nif (proc.dataImpact == Routine.MODIFIES_SQL) {","label":[0,1,0,0]}
{"id":34400,"original_code":"public int pcToLine(int pc) {\n        \/*\n         * Line number entries don't have to appear in any particular\n         * order, so we have to do a linear search. TODO: If\n         * this turns out to be a bottleneck, consider sorting the\n         * list prior to use.\n         *\/\n        int sz = size();\n        int bestPc = -1;\n        int bestLine = -1;\n        for (int i = 0; i < sz; i++) {\n            Item one = get(i);\n            int onePc = one.getStartPc();\n            if ((onePc <= pc) && (onePc > bestPc)) {\n                bestPc = onePc;\n                bestLine = one.getLineNumber();\n                if (bestPc == pc) {\n                    \/\/ We can't do better than this\n                    break;\n                }\n            }\n        }\n        return bestLine;\n    }","code":"public int pcToLine(int pc) {\n       \n        int sz = size();\n        int bestPc = -1;\n        int bestLine = -1;\n        for (int i = 0; i < sz; i++) {\n            Item one = get(i);\n            int onePc = one.getStartPc();\n            if ((onePc <= pc) && (onePc > bestPc)) {\n                bestPc = onePc;\n                bestLine = one.getLineNumber();\n                if (bestPc == pc) {\n                   \n                    break;\n                }\n            }\n        }\n        return bestLine;\n    }","cleancode":"public int pctoline(int pc) { int sz = size(); int bestpc = -1; int bestline = -1; for (int i = 0; i < sz; i++) { item one = get(i); int onepc = one.getstartpc(); if ((onepc <= pc) && (onepc > bestpc)) { bestpc = onepc; bestline = one.getlinenumber(); if (bestpc == pc) { break; } } } return bestline; }","comment":"\/** * gets the line number associated with the given address. * * @param pc {@code >= 0;} the address to look up * @return {@code >= -1;} the associated line number, or {@code -1} if * none is known *\/\n\/* * line number entries don't have to appear in any particular * order, so we have to do a linear search. todo: if * this turns out to be a bottleneck, consider sorting the * list prior to use. *\/\n\/\/ we can't do better than this","repo":"MaTriXy\/atlas","code_context_2":"public int pcToLine(int pc) {\n\/*\n* Line number entries don't have to appear in any particular\n* order, so we have to do a linear search. TODO: If\n* this turns out to be a bottleneck, consider sorting the\n* list prior to use.\n*\/\nint sz = size();\nint bestPc = -1;\nint bestLine = -1;\nfor (int i = 0; i < sz; i++) {\nItem one = get(i);\nint onePc = one.getStartPc();\nif ((onePc <= pc) && (onePc > bestPc)) {\nbestPc = onePc;\nbestLine = one.getLineNumber();\nif (bestPc == pc) {\n\/\/ We can't do better than this\nbreak;\n}\n}\n}\nreturn bestLine;\n}\n\npublic int pcToLine(int pc) {\n\/*\n* Line number entries don't have to appear in any particular\n* order, so we have to do a linear search. TODO: If\n* this turns out to be a bottleneck, consider sorting the\n* list prior to use.\n*\/\nint sz = size();\nint bestPc = -1;\n\nbestLine = one.getLineNumber();\nif (bestPc == pc) {\n\/\/ We can't do better than this\nbreak;\n}","code_context_10":"public int pcToLine(int pc) {\n\/*\n* Line number entries don't have to appear in any particular\n* order, so we have to do a linear search. TODO: If\n* this turns out to be a bottleneck, consider sorting the\n* list prior to use.\n*\/\nint sz = size();\nint bestPc = -1;\nint bestLine = -1;\nfor (int i = 0; i < sz; i++) {\nItem one = get(i);\nint onePc = one.getStartPc();\nif ((onePc <= pc) && (onePc > bestPc)) {\nbestPc = onePc;\nbestLine = one.getLineNumber();\nif (bestPc == pc) {\n\/\/ We can't do better than this\nbreak;\n}\n}\n}\nreturn bestLine;\n}\n\npublic int pcToLine(int pc) {\n\/*\n* Line number entries don't have to appear in any particular\n* order, so we have to do a linear search. TODO: If\n* this turns out to be a bottleneck, consider sorting the\n* list prior to use.\n*\/\nint sz = size();\nint bestPc = -1;\nint bestLine = -1;\nfor (int i = 0; i < sz; i++) {\nItem one = get(i);\nint onePc = one.getStartPc();\nif ((onePc <= pc) && (onePc > bestPc)) {\nbestPc = onePc;\nbestLine = one.getLineNumber();\nif (bestPc == pc) {\n\nint sz = size();\nint bestPc = -1;\nint bestLine = -1;\nfor (int i = 0; i < sz; i++) {\nItem one = get(i);\nint onePc = one.getStartPc();\nif ((onePc <= pc) && (onePc > bestPc)) {\nbestPc = onePc;\nbestLine = one.getLineNumber();\nif (bestPc == pc) {\n\/\/ We can't do better than this\nbreak;\n}\n}\n}\nreturn bestLine;\n}","code_context_20":"public int pcToLine(int pc) {\n\/*\n* Line number entries don't have to appear in any particular\n* order, so we have to do a linear search. TODO: If\n* this turns out to be a bottleneck, consider sorting the\n* list prior to use.\n*\/\nint sz = size();\nint bestPc = -1;\nint bestLine = -1;\nfor (int i = 0; i < sz; i++) {\nItem one = get(i);\nint onePc = one.getStartPc();\nif ((onePc <= pc) && (onePc > bestPc)) {\nbestPc = onePc;\nbestLine = one.getLineNumber();\nif (bestPc == pc) {\n\/\/ We can't do better than this\nbreak;\n}\n}\n}\nreturn bestLine;\n}\n\npublic int pcToLine(int pc) {\n\/*\n* Line number entries don't have to appear in any particular\n* order, so we have to do a linear search. TODO: If\n* this turns out to be a bottleneck, consider sorting the\n* list prior to use.\n*\/\nint sz = size();\nint bestPc = -1;\nint bestLine = -1;\nfor (int i = 0; i < sz; i++) {\nItem one = get(i);\nint onePc = one.getStartPc();\nif ((onePc <= pc) && (onePc > bestPc)) {\nbestPc = onePc;\nbestLine = one.getLineNumber();\nif (bestPc == pc) {\n\/\/ We can't do better than this\nbreak;\n}\n}\n}\nreturn bestLine;\n}\n\npublic int pcToLine(int pc) {\n\/*\n* Line number entries don't have to appear in any particular\n* order, so we have to do a linear search. TODO: If\n* this turns out to be a bottleneck, consider sorting the\n* list prior to use.\n*\/\nint sz = size();\nint bestPc = -1;\nint bestLine = -1;\nfor (int i = 0; i < sz; i++) {\nItem one = get(i);\nint onePc = one.getStartPc();\nif ((onePc <= pc) && (onePc > bestPc)) {\nbestPc = onePc;\nbestLine = one.getLineNumber();\nif (bestPc == pc) {\n\/\/ We can't do better than this\nbreak;\n}\n}\n}\nreturn bestLine;\n}","label":[1,0,0,0]}
{"id":9846,"original_code":"public void free()\n  {\n    currState = NO_STATE;\n    if (Sage.DBG) System.out.println(\"Closing down mplayer\");\n    if (uiMgr != null)\n      uiMgr.putFloat(\"mplayer\/last_volume\", currVolume);\n    timeGuessMillis = 0;\n    guessTimestamp = 0;\n    currVolume = 1.0f;\n    if (mpStdin != null && isMPlayerRunning())\n    {\n      \/\/ Be sure to clear the active file bit in case MPlayer is waiting for more data\n      \/\/ Be sure we don't close the stdin connection before we send the quit message, but don't\n      \/\/ hang waiting for the quit to be processed\n      \/\/\t\t\tinactiveFile();\n      \/\/\t\t\tstop();\n      Thread t = new Thread(\"PlayerSendCmd\")\n      {\n        public void run()\n        {\n          if (Sage.DBG) System.out.println(\"Waiting for the cmd queue to clear...\");\n          synchronized (sendCmdQueue)\n          {\n            while (!sendCmdQueue.isEmpty())\n            {\n              try\n              {\n                sendCmdQueue.wait(50);\n              }\n              catch (InterruptedException e){}\n              continue;\n            }\n          }\n          if (Sage.DBG) System.out.println(\"Sending mplayer command: quit\");\n          if (!fileDeactivated)\n          {\n            fileDeactivated = true;\n            synchronized (mpStdin)\n            {\n              mpStdin.println(\"inactive_file\");\n            }\n          }\n          if (currState == PLAY_STATE && !eos)\n          {\n            synchronized (mpStdin)\n            {\n              mpStdin.println(\"pause\");\n            }\n            currState = STOPPED_STATE;\n          }\n          else\n            currState = STOPPED_STATE;\n          synchronized (mpStdin)\n          {\n            mpStdin.println(\"quit\");\n          }\n          mpStdin.close();\n          mpStdin = null;\n          if (mpStdout != null)\n          {\n            try { mpStdout.close(); } catch (java.io.IOException e) {}\n            mpStdout = null;\n          }\n          if (mpStderr != null)\n          {\n            try { mpStderr.close(); } catch (java.io.IOException e) {}\n            mpStderr = null;\n          }\n        }\n      };\n      t.setPriority(Thread.currentThread().getPriority());\n      t.setDaemon(true);\n      t.start();\n    }\n    if (mpProc != null)\n    {\n      long startWait = Sage.eventTime();\n      \/\/ FIXME: temp crutch, in testing on Mac OS X mplayer either terminates immediately or hangs, there is no in-between...\n      long killDelay = (Sage.MAC_OS_X ? 2000 : 15000);\n      while (true)\n      {\n        try\n        {\n          int exitValue = mpProc.exitValue();\n          if (Sage.DBG) System.out.println(\"MPlayer process exit code:\" + exitValue);\n          break;\n        }\n        catch (IllegalThreadStateException e)\n        {\n          if (Sage.DBG) System.out.println(\"MPlayer process has not exited yet...\");\n          try{Thread.sleep(100);}catch(Exception e1){}\n          if (Sage.eventTime() - startWait > killDelay)\n          {\n            if (Sage.DBG) System.out.println(\"Forcibly killing MPlayer process!\");\n            mpProc.destroy();\n            break;\n          }\n        }\n      }\n      mpProc = null;\n    }\n    if (launchedAsyncRenderThread)\n      ((DirectX9SageRenderer)uiMgr.getRootPanel().getRenderEngine()).asyncVideoRender(null);\n    if (releaseServerAccessVobSubBase != null)\n    {\n      NetworkClient.getSN().requestMediaServerAccess(new java.io.File(releaseServerAccessVobSubBase + \".idx\"), false);\n      NetworkClient.getSN().requestMediaServerAccess(new java.io.File(releaseServerAccessVobSubBase + \".sub\"), false);\n      releaseServerAccessVobSubBase = null;\n    }\n  }","code":"public void free()\n  {\n    currState = NO_STATE;\n    if (Sage.DBG) System.out.println(\"Closing down mplayer\");\n    if (uiMgr != null)\n      uiMgr.putFloat(\"mplayer\/last_volume\", currVolume);\n    timeGuessMillis = 0;\n    guessTimestamp = 0;\n    currVolume = 1.0f;\n    if (mpStdin != null && isMPlayerRunning())\n    {\n     \n     \n     \n     \n     \n      Thread t = new Thread(\"PlayerSendCmd\")\n      {\n        public void run()\n        {\n          if (Sage.DBG) System.out.println(\"Waiting for the cmd queue to clear...\");\n          synchronized (sendCmdQueue)\n          {\n            while (!sendCmdQueue.isEmpty())\n            {\n              try\n              {\n                sendCmdQueue.wait(50);\n              }\n              catch (InterruptedException e){}\n              continue;\n            }\n          }\n          if (Sage.DBG) System.out.println(\"Sending mplayer command: quit\");\n          if (!fileDeactivated)\n          {\n            fileDeactivated = true;\n            synchronized (mpStdin)\n            {\n              mpStdin.println(\"inactive_file\");\n            }\n          }\n          if (currState == PLAY_STATE && !eos)\n          {\n            synchronized (mpStdin)\n            {\n              mpStdin.println(\"pause\");\n            }\n            currState = STOPPED_STATE;\n          }\n          else\n            currState = STOPPED_STATE;\n          synchronized (mpStdin)\n          {\n            mpStdin.println(\"quit\");\n          }\n          mpStdin.close();\n          mpStdin = null;\n          if (mpStdout != null)\n          {\n            try { mpStdout.close(); } catch (java.io.IOException e) {}\n            mpStdout = null;\n          }\n          if (mpStderr != null)\n          {\n            try { mpStderr.close(); } catch (java.io.IOException e) {}\n            mpStderr = null;\n          }\n        }\n      };\n      t.setPriority(Thread.currentThread().getPriority());\n      t.setDaemon(true);\n      t.start();\n    }\n    if (mpProc != null)\n    {\n      long startWait = Sage.eventTime();\n     \n      long killDelay = (Sage.MAC_OS_X ? 2000 : 15000);\n      while (true)\n      {\n        try\n        {\n          int exitValue = mpProc.exitValue();\n          if (Sage.DBG) System.out.println(\"MPlayer process exit code:\" + exitValue);\n          break;\n        }\n        catch (IllegalThreadStateException e)\n        {\n          if (Sage.DBG) System.out.println(\"MPlayer process has not exited yet...\");\n          try{Thread.sleep(100);}catch(Exception e1){}\n          if (Sage.eventTime() - startWait > killDelay)\n          {\n            if (Sage.DBG) System.out.println(\"Forcibly killing MPlayer process!\");\n            mpProc.destroy();\n            break;\n          }\n        }\n      }\n      mpProc = null;\n    }\n    if (launchedAsyncRenderThread)\n      ((DirectX9SageRenderer)uiMgr.getRootPanel().getRenderEngine()).asyncVideoRender(null);\n    if (releaseServerAccessVobSubBase != null)\n    {\n      NetworkClient.getSN().requestMediaServerAccess(new java.io.File(releaseServerAccessVobSubBase + \".idx\"), false);\n      NetworkClient.getSN().requestMediaServerAccess(new java.io.File(releaseServerAccessVobSubBase + \".sub\"), false);\n      releaseServerAccessVobSubBase = null;\n    }\n  }","cleancode":"public void free() { currstate = no_state; if (sage.dbg) system.out.println(\"closing down mplayer\"); if (uimgr != null) uimgr.putfloat(\"mplayer\/last_volume\", currvolume); timeguessmillis = 0; guesstimestamp = 0; currvolume = 1.0f; if (mpstdin != null && ismplayerrunning()) { thread t = new thread(\"playersendcmd\") { public void run() { if (sage.dbg) system.out.println(\"waiting for the cmd queue to clear...\"); synchronized (sendcmdqueue) { while (!sendcmdqueue.isempty()) { try { sendcmdqueue.wait(50); } catch (interruptedexception e){} continue; } } if (sage.dbg) system.out.println(\"sending mplayer command: quit\"); if (!filedeactivated) { filedeactivated = true; synchronized (mpstdin) { mpstdin.println(\"inactive_file\"); } } if (currstate == play_state && !eos) { synchronized (mpstdin) { mpstdin.println(\"pause\"); } currstate = stopped_state; } else currstate = stopped_state; synchronized (mpstdin) { mpstdin.println(\"quit\"); } mpstdin.close(); mpstdin = null; if (mpstdout != null) { try { mpstdout.close(); } catch (java.io.ioexception e) {} mpstdout = null; } if (mpstderr != null) { try { mpstderr.close(); } catch (java.io.ioexception e) {} mpstderr = null; } } }; t.setpriority(thread.currentthread().getpriority()); t.setdaemon(true); t.start(); } if (mpproc != null) { long startwait = sage.eventtime(); long killdelay = (sage.mac_os_x ? 2000 : 15000); while (true) { try { int exitvalue = mpproc.exitvalue(); if (sage.dbg) system.out.println(\"mplayer process exit code:\" + exitvalue); break; } catch (illegalthreadstateexception e) { if (sage.dbg) system.out.println(\"mplayer process has not exited yet...\"); try{thread.sleep(100);}catch(exception e1){} if (sage.eventtime() - startwait > killdelay) { if (sage.dbg) system.out.println(\"forcibly killing mplayer process!\"); mpproc.destroy(); break; } } } mpproc = null; } if (launchedasyncrenderthread) ((directx9sagerenderer)uimgr.getrootpanel().getrenderengine()).asyncvideorender(null); if (releaseserveraccessvobsubbase != null) { networkclient.getsn().requestmediaserveraccess(new java.io.file(releaseserveraccessvobsubbase + \".idx\"), false); networkclient.getsn().requestmediaserveraccess(new java.io.file(releaseserveraccessvobsubbase + \".sub\"), false); releaseserveraccessvobsubbase = null; } }","comment":"\/\/ be sure to clear the active file bit in case mplayer is waiting for more data \/\/ be sure we don't close the stdin connection before we send the quit message, but don't \/\/ hang waiting for the quit to be processed \/\/ inactivefile(); \/\/ stop();\n\/\/ fixme: temp crutch, in testing on mac os x mplayer either terminates immediately or hangs, there is no in-between...","repo":"Narflex\/sagetv","code_context_2":"if (mpStdin != null && isMPlayerRunning())\n{\n\/\/ Be sure to clear the active file bit in case MPlayer is waiting for more data\n\/\/ Be sure we don't close the stdin connection before we send the quit message, but don't\n\/\/ hang waiting for the quit to be processed\n\/\/ inactiveFile();\n\/\/ stop();\nThread t = new Thread(\"PlayerSendCmd\")\n{\n\n{\nlong startWait = Sage.eventTime();\n\/\/ FIXME: temp crutch, in testing on Mac OS X mplayer either terminates immediately or hangs, there is no in-between...\nlong killDelay = (Sage.MAC_OS_X ? 2000 : 15000);\nwhile (true)","code_context_10":"{\ncurrState = NO_STATE;\nif (Sage.DBG) System.out.println(\"Closing down mplayer\");\nif (uiMgr != null)\nuiMgr.putFloat(\"mplayer\/last_volume\", currVolume);\ntimeGuessMillis = 0;\nguessTimestamp = 0;\ncurrVolume = 1.0f;\nif (mpStdin != null && isMPlayerRunning())\n{\n\/\/ Be sure to clear the active file bit in case MPlayer is waiting for more data\n\/\/ Be sure we don't close the stdin connection before we send the quit message, but don't\n\/\/ hang waiting for the quit to be processed\n\/\/ inactiveFile();\n\/\/ stop();\nThread t = new Thread(\"PlayerSendCmd\")\n{\npublic void run()\n{\nif (Sage.DBG) System.out.println(\"Waiting for the cmd queue to clear...\");\nsynchronized (sendCmdQueue)\n{\nwhile (!sendCmdQueue.isEmpty())\n{\ntry\n\n}\n}\n};\nt.setPriority(Thread.currentThread().getPriority());\nt.setDaemon(true);\nt.start();\n}\nif (mpProc != null)\n{\nlong startWait = Sage.eventTime();\n\/\/ FIXME: temp crutch, in testing on Mac OS X mplayer either terminates immediately or hangs, there is no in-between...\nlong killDelay = (Sage.MAC_OS_X ? 2000 : 15000);\nwhile (true)\n{\ntry\n{\nint exitValue = mpProc.exitValue();\nif (Sage.DBG) System.out.println(\"MPlayer process exit code:\" + exitValue);\nbreak;\n}\ncatch (IllegalThreadStateException e)","code_context_20":"public void free()\n{\ncurrState = NO_STATE;\nif (Sage.DBG) System.out.println(\"Closing down mplayer\");\nif (uiMgr != null)\nuiMgr.putFloat(\"mplayer\/last_volume\", currVolume);\ntimeGuessMillis = 0;\nguessTimestamp = 0;\ncurrVolume = 1.0f;\nif (mpStdin != null && isMPlayerRunning())\n{\n\/\/ Be sure to clear the active file bit in case MPlayer is waiting for more data\n\/\/ Be sure we don't close the stdin connection before we send the quit message, but don't\n\/\/ hang waiting for the quit to be processed\n\/\/ inactiveFile();\n\/\/ stop();\nThread t = new Thread(\"PlayerSendCmd\")\n{\npublic void run()\n{\nif (Sage.DBG) System.out.println(\"Waiting for the cmd queue to clear...\");\nsynchronized (sendCmdQueue)\n{\nwhile (!sendCmdQueue.isEmpty())\n{\ntry\n{\nsendCmdQueue.wait(50);\n}\ncatch (InterruptedException e){}\ncontinue;\n}\n}\nif (Sage.DBG) System.out.println(\"Sending mplayer command: quit\");\nif (!fileDeactivated)\n{\n\nmpStdin = null;\nif (mpStdout != null)\n{\ntry { mpStdout.close(); } catch (java.io.IOException e) {}\nmpStdout = null;\n}\nif (mpStderr != null)\n{\ntry { mpStderr.close(); } catch (java.io.IOException e) {}\nmpStderr = null;\n}\n}\n};\nt.setPriority(Thread.currentThread().getPriority());\nt.setDaemon(true);\nt.start();\n}\nif (mpProc != null)\n{\nlong startWait = Sage.eventTime();\n\/\/ FIXME: temp crutch, in testing on Mac OS X mplayer either terminates immediately or hangs, there is no in-between...\nlong killDelay = (Sage.MAC_OS_X ? 2000 : 15000);\nwhile (true)\n{\ntry\n{\nint exitValue = mpProc.exitValue();\nif (Sage.DBG) System.out.println(\"MPlayer process exit code:\" + exitValue);\nbreak;\n}\ncatch (IllegalThreadStateException e)\n{\nif (Sage.DBG) System.out.println(\"MPlayer process has not exited yet...\");\ntry{Thread.sleep(100);}catch(Exception e1){}\nif (Sage.eventTime() - startWait > killDelay)\n{\nif (Sage.DBG) System.out.println(\"Forcibly killing MPlayer process!\");\nmpProc.destroy();\nbreak;\n}\n}","label":[0,0,1,0]}
{"id":26236,"original_code":"@Test\n    public void testNullValueDisallowed() throws Exception {\n        {\n            String str = \"{ \\\"id\\\": 123, \\\"petId\\\": 345, \\\"quantity\\\": 100, \\\"status\\\": \\\"placed\\\" }\";\n            org.openapitools.client.model.Order o = json.getContext(null).readValue(str, org.openapitools.client.model.Order.class);\n            assertEquals(100L, (long)o.getQuantity());\n            assertEquals(org.openapitools.client.model.Order.StatusEnum.PLACED, o.getStatus());\n        }\n        {\n            String str = \"{ \\\"id\\\": 123, \\\"petId\\\": 345, \\\"quantity\\\": null }\";\n            org.openapitools.client.model.Order o = json.getContext(null).readValue(str, org.openapitools.client.model.Order.class);\n            \/\/ TODO: the null value is not allowed per OAS document.\n            \/\/ The deserialization should fail.\n            assertNull(o.getQuantity());\n        }\n    }","code":"@Test\n    public void testNullValueDisallowed() throws Exception {\n        {\n            String str = \"{ \\\"id\\\": 123, \\\"petId\\\": 345, \\\"quantity\\\": 100, \\\"status\\\": \\\"placed\\\" }\";\n            org.openapitools.client.model.Order o = json.getContext(null).readValue(str, org.openapitools.client.model.Order.class);\n            assertEquals(100L, (long)o.getQuantity());\n            assertEquals(org.openapitools.client.model.Order.StatusEnum.PLACED, o.getStatus());\n        }\n        {\n            String str = \"{ \\\"id\\\": 123, \\\"petId\\\": 345, \\\"quantity\\\": null }\";\n            org.openapitools.client.model.Order o = json.getContext(null).readValue(str, org.openapitools.client.model.Order.class);\n           \n           \n            assertNull(o.getQuantity());\n        }\n    }","cleancode":"@test public void testnullvaluedisallowed() throws exception { { string str = \"{ \\\"id\\\": 123, \\\"petid\\\": 345, \\\"quantity\\\": 100, \\\"status\\\": \\\"placed\\\" }\"; org.openapitools.client.model.order o = json.getcontext(null).readvalue(str, org.openapitools.client.model.order.class); assertequals(100l, (long)o.getquantity()); assertequals(org.openapitools.client.model.order.statusenum.placed, o.getstatus()); } { string str = \"{ \\\"id\\\": 123, \\\"petid\\\": 345, \\\"quantity\\\": null }\"; org.openapitools.client.model.order o = json.getcontext(null).readvalue(str, org.openapitools.client.model.order.class); assertnull(o.getquantity()); } }","comment":"\/\/ todo: the null value is not allowed per oas document. \/\/ the deserialization should fail.","repo":"IonBazan\/openapi-generator","code_context_2":"String str = \"{ \\\"id\\\": 123, \\\"petId\\\": 345, \\\"quantity\\\": null }\";\norg.openapitools.client.model.Order o = json.getContext(null).readValue(str, org.openapitools.client.model.Order.class);\n\/\/ TODO: the null value is not allowed per OAS document.\n\/\/ The deserialization should fail.\nassertNull(o.getQuantity());\n}","code_context_10":"public void testNullValueDisallowed() throws Exception {\n{\nString str = \"{ \\\"id\\\": 123, \\\"petId\\\": 345, \\\"quantity\\\": 100, \\\"status\\\": \\\"placed\\\" }\";\norg.openapitools.client.model.Order o = json.getContext(null).readValue(str, org.openapitools.client.model.Order.class);\nassertEquals(100L, (long)o.getQuantity());\nassertEquals(org.openapitools.client.model.Order.StatusEnum.PLACED, o.getStatus());\n}\n{\nString str = \"{ \\\"id\\\": 123, \\\"petId\\\": 345, \\\"quantity\\\": null }\";\norg.openapitools.client.model.Order o = json.getContext(null).readValue(str, org.openapitools.client.model.Order.class);\n\/\/ TODO: the null value is not allowed per OAS document.\n\/\/ The deserialization should fail.\nassertNull(o.getQuantity());\n}\n}","code_context_20":"@Test\npublic void testNullValueDisallowed() throws Exception {\n{\nString str = \"{ \\\"id\\\": 123, \\\"petId\\\": 345, \\\"quantity\\\": 100, \\\"status\\\": \\\"placed\\\" }\";\norg.openapitools.client.model.Order o = json.getContext(null).readValue(str, org.openapitools.client.model.Order.class);\nassertEquals(100L, (long)o.getQuantity());\nassertEquals(org.openapitools.client.model.Order.StatusEnum.PLACED, o.getStatus());\n}\n{\nString str = \"{ \\\"id\\\": 123, \\\"petId\\\": 345, \\\"quantity\\\": null }\";\norg.openapitools.client.model.Order o = json.getContext(null).readValue(str, org.openapitools.client.model.Order.class);\n\/\/ TODO: the null value is not allowed per OAS document.\n\/\/ The deserialization should fail.\nassertNull(o.getQuantity());\n}\n}","label":[0,0,1,0]}
{"id":9930,"original_code":"public static String getUserDocumentsPath() {\n        if (m_documents == null) {\n            \/\/TODO: Should I look at the OneDrive entry first?\n            \/\/      The OneDrive key from the web is different from mine.\n            m_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\", \"Personal\");\n            if (m_documents == null) {\n                m_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\User Shell Folders\", \"Personal\");\n                if (m_documents == null) {\n                    Server.logger().log(Level.SEVERE, \"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\n                    System.out.println(\"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\n                    \/\/if we cannot get this, we have to exit because we don't know where to store our data.\n                    System.exit(1);\n                }\n            }\n            if (m_documents.contains(\"%USERPROFILE%\")) {\n                m_documents = m_documents.replace(\"%USERPROFILE%\", System.getenv(\"USERPROFILE\"));\n            }\n        }\n        return m_documents;\n    }","code":"public static String getUserDocumentsPath() {\n        if (m_documents == null) {\n           \n           \n            m_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\", \"Personal\");\n            if (m_documents == null) {\n                m_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\User Shell Folders\", \"Personal\");\n                if (m_documents == null) {\n                    Server.logger().log(Level.SEVERE, \"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\n                    System.out.println(\"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\n                   \n                    System.exit(1);\n                }\n            }\n            if (m_documents.contains(\"%USERPROFILE%\")) {\n                m_documents = m_documents.replace(\"%USERPROFILE%\", System.getenv(\"USERPROFILE\"));\n            }\n        }\n        return m_documents;\n    }","cleancode":"public static string getuserdocumentspath() { if (m_documents == null) { m_documents = advapi32util.registrygetstringvalue(hkey_current_user, \"software\\\\microsoft\\\\windows\\\\currentversion\\\\explorer\\\\shell folders\", \"personal\"); if (m_documents == null) { m_documents = advapi32util.registrygetstringvalue(hkey_current_user, \"software\\\\microsoft\\\\windows\\\\currentversion\\\\explorer\\\\user shell folders\", \"personal\"); if (m_documents == null) { server.logger().log(level.severe, \"advapi32util.registrygetstringvalue(hkey_current_user, \\\"software\\\\\\\\microsoft\\\\\\\\windows\\\\\\\\currentversion\\\\\\\\explorer\\\\\\\\user shell folders\\\", \\\"personal\\\") returned null\"); system.out.println(\"advapi32util.registrygetstringvalue(hkey_current_user, \\\"software\\\\\\\\microsoft\\\\\\\\windows\\\\\\\\currentversion\\\\\\\\explorer\\\\\\\\user shell folders\\\", \\\"personal\\\") returned null\"); system.exit(1); } } if (m_documents.contains(\"%userprofile%\")) { m_documents = m_documents.replace(\"%userprofile%\", system.getenv(\"userprofile\")); } } return m_documents; }","comment":"\/** * returns the path to the users documents location. * @return the path to the user's documents location. *\/\n\/\/todo: should i look at the onedrive entry first? \/\/ the onedrive key from the web is different from mine.\n\/\/if we cannot get this, we have to exit because we don't know where to store our data.","repo":"SIMRacingApps\/SIMRacingAppsServer","code_context_2":"public static String getUserDocumentsPath() {\nif (m_documents == null) {\n\/\/TODO: Should I look at the OneDrive entry first?\n\/\/ The OneDrive key from the web is different from mine.\nm_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\", \"Personal\");\nif (m_documents == null) {\nm_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\User Shell Folders\", \"Personal\");\nif (m_documents == null) {\nServer.logger().log(Level.SEVERE, \"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\nSystem.out.println(\"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\n\/\/if we cannot get this, we have to exit because we don't know where to store our data.\nSystem.exit(1);\n}\n}\nif (m_documents.contains(\"%USERPROFILE%\")) {\nm_documents = m_documents.replace(\"%USERPROFILE%\", System.getenv(\"USERPROFILE\"));\n}\n}\nreturn m_documents;\n}\n\npublic static String getUserDocumentsPath() {\nif (m_documents == null) {\n\/\/TODO: Should I look at the OneDrive entry first?\n\/\/ The OneDrive key from the web is different from mine.\nm_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\", \"Personal\");\nif (m_documents == null) {\n\nServer.logger().log(Level.SEVERE, \"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\nSystem.out.println(\"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\n\/\/if we cannot get this, we have to exit because we don't know where to store our data.\nSystem.exit(1);\n}","code_context_10":"public static String getUserDocumentsPath() {\nif (m_documents == null) {\n\/\/TODO: Should I look at the OneDrive entry first?\n\/\/ The OneDrive key from the web is different from mine.\nm_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\", \"Personal\");\nif (m_documents == null) {\nm_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\User Shell Folders\", \"Personal\");\nif (m_documents == null) {\nServer.logger().log(Level.SEVERE, \"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\nSystem.out.println(\"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\n\/\/if we cannot get this, we have to exit because we don't know where to store our data.\nSystem.exit(1);\n}\n}\nif (m_documents.contains(\"%USERPROFILE%\")) {\nm_documents = m_documents.replace(\"%USERPROFILE%\", System.getenv(\"USERPROFILE\"));\n}\n}\nreturn m_documents;\n}\n\npublic static String getUserDocumentsPath() {\nif (m_documents == null) {\n\/\/TODO: Should I look at the OneDrive entry first?\n\/\/ The OneDrive key from the web is different from mine.\nm_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\", \"Personal\");\nif (m_documents == null) {\nm_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\User Shell Folders\", \"Personal\");\nif (m_documents == null) {\nServer.logger().log(Level.SEVERE, \"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\nSystem.out.println(\"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\n\/\/if we cannot get this, we have to exit because we don't know where to store our data.\nSystem.exit(1);\n}\n}\n\npublic static String getUserDocumentsPath() {\nif (m_documents == null) {\n\/\/TODO: Should I look at the OneDrive entry first?\n\/\/ The OneDrive key from the web is different from mine.\nm_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\", \"Personal\");\nif (m_documents == null) {\nm_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\User Shell Folders\", \"Personal\");\nif (m_documents == null) {\nServer.logger().log(Level.SEVERE, \"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\nSystem.out.println(\"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\n\/\/if we cannot get this, we have to exit because we don't know where to store our data.\nSystem.exit(1);\n}\n}\nif (m_documents.contains(\"%USERPROFILE%\")) {\nm_documents = m_documents.replace(\"%USERPROFILE%\", System.getenv(\"USERPROFILE\"));\n}\n}\nreturn m_documents;\n}","code_context_20":"public static String getUserDocumentsPath() {\nif (m_documents == null) {\n\/\/TODO: Should I look at the OneDrive entry first?\n\/\/ The OneDrive key from the web is different from mine.\nm_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\", \"Personal\");\nif (m_documents == null) {\nm_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\User Shell Folders\", \"Personal\");\nif (m_documents == null) {\nServer.logger().log(Level.SEVERE, \"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\nSystem.out.println(\"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\n\/\/if we cannot get this, we have to exit because we don't know where to store our data.\nSystem.exit(1);\n}\n}\nif (m_documents.contains(\"%USERPROFILE%\")) {\nm_documents = m_documents.replace(\"%USERPROFILE%\", System.getenv(\"USERPROFILE\"));\n}\n}\nreturn m_documents;\n}\n\npublic static String getUserDocumentsPath() {\nif (m_documents == null) {\n\/\/TODO: Should I look at the OneDrive entry first?\n\/\/ The OneDrive key from the web is different from mine.\nm_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\", \"Personal\");\nif (m_documents == null) {\nm_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\User Shell Folders\", \"Personal\");\nif (m_documents == null) {\nServer.logger().log(Level.SEVERE, \"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\nSystem.out.println(\"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\n\/\/if we cannot get this, we have to exit because we don't know where to store our data.\nSystem.exit(1);\n}\n}\nif (m_documents.contains(\"%USERPROFILE%\")) {\nm_documents = m_documents.replace(\"%USERPROFILE%\", System.getenv(\"USERPROFILE\"));\n}\n}\nreturn m_documents;\n}\n\npublic static String getUserDocumentsPath() {\nif (m_documents == null) {\n\/\/TODO: Should I look at the OneDrive entry first?\n\/\/ The OneDrive key from the web is different from mine.\nm_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\", \"Personal\");\nif (m_documents == null) {\nm_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\User Shell Folders\", \"Personal\");\nif (m_documents == null) {\nServer.logger().log(Level.SEVERE, \"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\nSystem.out.println(\"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\n\/\/if we cannot get this, we have to exit because we don't know where to store our data.\nSystem.exit(1);\n}\n}\nif (m_documents.contains(\"%USERPROFILE%\")) {\nm_documents = m_documents.replace(\"%USERPROFILE%\", System.getenv(\"USERPROFILE\"));\n}\n}\nreturn m_documents;\n}","label":[1,0,0,0]}
{"id":34529,"original_code":"public void testWrongName() {\n        try {\n            construct(\"--- !!org.yaml.snakeyaml.constructor.TestBean\\nwrongName: No one\\nage: 24\\nborn: 1982-05-03\\n\");\n            fail(\"IntrospectionException expected.\");\n        } catch (Exception e) {\n            \/\/ TODO improve the error message - the pointer should be at the\n            \/\/ property name, not value\n            assertEquals(\n                    \"Cannot create property=wrongName for JavaBean=#<org.jvyaml.TestBean name=\\\"null\\\" age=0 born=\\\"null\\\">\\n\" +\n                            \" in 'string', line 1, column 5:\\n\" +\n                            \"    --- !!org.yaml.snakeyaml.constructor ... \\n\" +\n                            \"        ^\\n\" +\n                            \"Unable to find property 'wrongName' on class: org.yaml.snakeyaml.constructor.TestBean\\n\" +\n                            \" in 'string', line 2, column 12:\\n\" +\n                            \"    wrongName: No one\\n\" +\n                            \"               ^\\n\",\n                    e.getMessage());\n        }\n    }","code":"public void testWrongName() {\n        try {\n            construct(\"--- !!org.yaml.snakeyaml.constructor.TestBean\\nwrongName: No one\\nage: 24\\nborn: 1982-05-03\\n\");\n            fail(\"IntrospectionException expected.\");\n        } catch (Exception e) {\n           \n           \n            assertEquals(\n                    \"Cannot create property=wrongName for JavaBean=#<org.jvyaml.TestBean name=\\\"null\\\" age=0 born=\\\"null\\\">\\n\" +\n                            \" in 'string', line 1, column 5:\\n\" +\n                            \"    --- !!org.yaml.snakeyaml.constructor ... \\n\" +\n                            \"        ^\\n\" +\n                            \"Unable to find property 'wrongName' on class: org.yaml.snakeyaml.constructor.TestBean\\n\" +\n                            \" in 'string', line 2, column 12:\\n\" +\n                            \"    wrongName: No one\\n\" +\n                            \"               ^\\n\",\n                    e.getMessage());\n        }\n    }","cleancode":"public void testwrongname() { try { construct(\"--- !!org.yaml.snakeyaml.constructor.testbean\\nwrongname: no one\\nage: 24\\nborn: 1982-05-03\\n\"); fail(\"introspectionexception expected.\"); } catch (exception e) { assertequals( \"cannot create property=wrongname for javabean=#<org.jvyaml.testbean name=\\\"null\\\" age=0 born=\\\"null\\\">\\n\" + \" in 'string', line 1, column 5:\\n\" + \" --- !!org.yaml.snakeyaml.constructor ... \\n\" + \" ^\\n\" + \"unable to find property 'wrongname' on class: org.yaml.snakeyaml.constructor.testbean\\n\" + \" in 'string', line 2, column 12:\\n\" + \" wrongname: no one\\n\" + \" ^\\n\", e.getmessage()); } }","comment":"\/\/ todo improve the error message - the pointer should be at the \/\/ property name, not value","repo":"PRECISE\/ROSLab","code_context_2":"fail(\"IntrospectionException expected.\");\n} catch (Exception e) {\n\/\/ TODO improve the error message - the pointer should be at the\n\/\/ property name, not value\nassertEquals(\n\"Cannot create property=wrongName for JavaBean=#<org.jvyaml.TestBean name=\\\"null\\\" age=0 born=\\\"null\\\">\\n\" +","code_context_10":"public void testWrongName() {\ntry {\nconstruct(\"--- !!org.yaml.snakeyaml.constructor.TestBean\\nwrongName: No one\\nage: 24\\nborn: 1982-05-03\\n\");\nfail(\"IntrospectionException expected.\");\n} catch (Exception e) {\n\/\/ TODO improve the error message - the pointer should be at the\n\/\/ property name, not value\nassertEquals(\n\"Cannot create property=wrongName for JavaBean=#<org.jvyaml.TestBean name=\\\"null\\\" age=0 born=\\\"null\\\">\\n\" +\n\" in 'string', line 1, column 5:\\n\" +\n\" --- !!org.yaml.snakeyaml.constructor ... \\n\" +\n\" ^\\n\" +\n\"Unable to find property 'wrongName' on class: org.yaml.snakeyaml.constructor.TestBean\\n\" +\n\" in 'string', line 2, column 12:\\n\" +\n\" wrongName: No one\\n\" +\n\" ^\\n\",\ne.getMessage());","code_context_20":"public void testWrongName() {\ntry {\nconstruct(\"--- !!org.yaml.snakeyaml.constructor.TestBean\\nwrongName: No one\\nage: 24\\nborn: 1982-05-03\\n\");\nfail(\"IntrospectionException expected.\");\n} catch (Exception e) {\n\/\/ TODO improve the error message - the pointer should be at the\n\/\/ property name, not value\nassertEquals(\n\"Cannot create property=wrongName for JavaBean=#<org.jvyaml.TestBean name=\\\"null\\\" age=0 born=\\\"null\\\">\\n\" +\n\" in 'string', line 1, column 5:\\n\" +\n\" --- !!org.yaml.snakeyaml.constructor ... \\n\" +\n\" ^\\n\" +\n\"Unable to find property 'wrongName' on class: org.yaml.snakeyaml.constructor.TestBean\\n\" +\n\" in 'string', line 2, column 12:\\n\" +\n\" wrongName: No one\\n\" +\n\" ^\\n\",\ne.getMessage());\n}\n}","label":[1,0,0,0]}
{"id":1770,"original_code":"@Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Request request = (Request) o;\n            if (objectID != request.objectID) return false;\n            if (methodIdentifier != null ? !methodIdentifier.equals(request.methodIdentifier) : request.methodIdentifier != null)\n                return false;\n            \/\/ Probably incorrect - comparing Object[] arrays with Arrays.equals\n            return Arrays.equals(args, request.args);\n        }","code":"@Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Request request = (Request) o;\n            if (objectID != request.objectID) return false;\n            if (methodIdentifier != null ? !methodIdentifier.equals(request.methodIdentifier) : request.methodIdentifier != null)\n                return false;\n           \n            return Arrays.equals(args, request.args);\n        }","cleancode":"@override public boolean equals(object o) { if (this == o) return true; if (o == null || getclass() != o.getclass()) return false; request request = (request) o; if (objectid != request.objectid) return false; if (methodidentifier != null ? !methodidentifier.equals(request.methodidentifier) : request.methodidentifier != null) return false; return arrays.equals(args, request.args); }","comment":"\/\/ probably incorrect - comparing object[] arrays with arrays.equals","repo":"MatzeS\/blackbird_java","code_context_2":"if (methodIdentifier != null ? !methodIdentifier.equals(request.methodIdentifier) : request.methodIdentifier != null)\nreturn false;\n\/\/ Probably incorrect - comparing Object[] arrays with Arrays.equals\nreturn Arrays.equals(args, request.args);\n}","code_context_10":"@Override\npublic boolean equals(Object o) {\nif (this == o) return true;\nif (o == null || getClass() != o.getClass()) return false;\nRequest request = (Request) o;\nif (objectID != request.objectID) return false;\nif (methodIdentifier != null ? !methodIdentifier.equals(request.methodIdentifier) : request.methodIdentifier != null)\nreturn false;\n\/\/ Probably incorrect - comparing Object[] arrays with Arrays.equals\nreturn Arrays.equals(args, request.args);\n}","code_context_20":"@Override\npublic boolean equals(Object o) {\nif (this == o) return true;\nif (o == null || getClass() != o.getClass()) return false;\nRequest request = (Request) o;\nif (objectID != request.objectID) return false;\nif (methodIdentifier != null ? !methodIdentifier.equals(request.methodIdentifier) : request.methodIdentifier != null)\nreturn false;\n\/\/ Probably incorrect - comparing Object[] arrays with Arrays.equals\nreturn Arrays.equals(args, request.args);\n}","label":[0,0,1,0]}
{"id":34690,"original_code":"@Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,\n                                        Authentication authentication) throws ServletException, IOException {\n        log.debug(\"Authentication success\");\n        \/\/ TODO: Optimize\n        Map<String, Object> result = new HashMap<>(1);\n        result.put(\"redirect\", sitProperties.redirect());\n        JSONWriter.write(response, HttpStatus.OK, Result.ok(result));\n    }","code":"@Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,\n                                        Authentication authentication) throws ServletException, IOException {\n        log.debug(\"Authentication success\");\n       \n        Map<String, Object> result = new HashMap<>(1);\n        result.put(\"redirect\", sitProperties.redirect());\n        JSONWriter.write(response, HttpStatus.OK, Result.ok(result));\n    }","cleancode":"@override public void onauthenticationsuccess(httpservletrequest request, httpservletresponse response, authentication authentication) throws servletexception, ioexception { log.debug(\"authentication success\"); map<string, object> result = new hashmap<>(1); result.put(\"redirect\", sitproperties.redirect()); jsonwriter.write(response, httpstatus.ok, result.ok(result)); }","comment":"\/\/ todo: optimize","repo":"O70\/spring-laboratory","code_context_2":"Authentication authentication) throws ServletException, IOException {\nlog.debug(\"Authentication success\");\n\/\/ TODO: Optimize\nMap<String, Object> result = new HashMap<>(1);\nresult.put(\"redirect\", sitProperties.redirect());","code_context_10":"@Override\npublic void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,\nAuthentication authentication) throws ServletException, IOException {\nlog.debug(\"Authentication success\");\n\/\/ TODO: Optimize\nMap<String, Object> result = new HashMap<>(1);\nresult.put(\"redirect\", sitProperties.redirect());\nJSONWriter.write(response, HttpStatus.OK, Result.ok(result));\n}","code_context_20":"@Override\npublic void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,\nAuthentication authentication) throws ServletException, IOException {\nlog.debug(\"Authentication success\");\n\/\/ TODO: Optimize\nMap<String, Object> result = new HashMap<>(1);\nresult.put(\"redirect\", sitProperties.redirect());\nJSONWriter.write(response, HttpStatus.OK, Result.ok(result));\n}","label":[1,0,0,0]}
{"id":18316,"original_code":"private Set<String> findUris(Graph graph) {\n        Set<String> result = new HashSet<>();\n        for (Triple t : graph.iterate()) {\n            try {\n                String object = t.getObject().toString().replace(\"<\", \"\").replace(\">\", \"\");\n                \/\/ check for valid uri\n                new URL(object).toURI();\n                result.add(object);\n            } catch (MalformedURLException e) {\n                e.printStackTrace();\n            } catch (URISyntaxException e) {\n                e.printStackTrace();\n            }\n        }\n        return result;\n    }","code":"private Set<String> findUris(Graph graph) {\n        Set<String> result = new HashSet<>();\n        for (Triple t : graph.iterate()) {\n            try {\n                String object = t.getObject().toString().replace(\"<\", \"\").replace(\">\", \"\");\n               \n                new URL(object).toURI();\n                result.add(object);\n            } catch (MalformedURLException e) {\n                e.printStackTrace();\n            } catch (URISyntaxException e) {\n                e.printStackTrace();\n            }\n        }\n        return result;\n    }","cleancode":"private set<string> finduris(graph graph) { set<string> result = new hashset<>(); for (triple t : graph.iterate()) { try { string object = t.getobject().tostring().replace(\"<\", \"\").replace(\">\", \"\"); new url(object).touri(); result.add(object); } catch (malformedurlexception e) { e.printstacktrace(); } catch (urisyntaxexception e) { e.printstacktrace(); } } return result; }","comment":"\/\/ todo idea: recognise links that return promising representations\n\/\/ check for valid uri","repo":"Interactions-HSG\/wot-search","code_context_2":"private Set<String> findUris(Graph graph) {\nSet<String> result = new HashSet<>();\nfor (Triple t : graph.iterate()) {\ntry {\nString object = t.getObject().toString().replace(\"<\", \"\").replace(\">\", \"\");\n\/\/ check for valid uri\nnew URL(object).toURI();\nresult.add(object);\n} catch (MalformedURLException e) {\ne.printStackTrace();\n} catch (URISyntaxException e) {\ne.printStackTrace();\n}\n}\nreturn result;\n}\n\ntry {\nString object = t.getObject().toString().replace(\"<\", \"\").replace(\">\", \"\");\n\/\/ check for valid uri\nnew URL(object).toURI();\nresult.add(object);","code_context_10":"private Set<String> findUris(Graph graph) {\nSet<String> result = new HashSet<>();\nfor (Triple t : graph.iterate()) {\ntry {\nString object = t.getObject().toString().replace(\"<\", \"\").replace(\">\", \"\");\n\/\/ check for valid uri\nnew URL(object).toURI();\nresult.add(object);\n} catch (MalformedURLException e) {\ne.printStackTrace();\n} catch (URISyntaxException e) {\ne.printStackTrace();\n}\n}\nreturn result;\n}\n\nprivate Set<String> findUris(Graph graph) {\nSet<String> result = new HashSet<>();\nfor (Triple t : graph.iterate()) {\ntry {\nString object = t.getObject().toString().replace(\"<\", \"\").replace(\">\", \"\");\n\/\/ check for valid uri\nnew URL(object).toURI();\nresult.add(object);\n} catch (MalformedURLException e) {\ne.printStackTrace();\n} catch (URISyntaxException e) {\ne.printStackTrace();\n}\n}\nreturn result;\n}","code_context_20":"private Set<String> findUris(Graph graph) {\nSet<String> result = new HashSet<>();\nfor (Triple t : graph.iterate()) {\ntry {\nString object = t.getObject().toString().replace(\"<\", \"\").replace(\">\", \"\");\n\/\/ check for valid uri\nnew URL(object).toURI();\nresult.add(object);\n} catch (MalformedURLException e) {\ne.printStackTrace();\n} catch (URISyntaxException e) {\ne.printStackTrace();\n}\n}\nreturn result;\n}\n\nprivate Set<String> findUris(Graph graph) {\nSet<String> result = new HashSet<>();\nfor (Triple t : graph.iterate()) {\ntry {\nString object = t.getObject().toString().replace(\"<\", \"\").replace(\">\", \"\");\n\/\/ check for valid uri\nnew URL(object).toURI();\nresult.add(object);\n} catch (MalformedURLException e) {\ne.printStackTrace();\n} catch (URISyntaxException e) {\ne.printStackTrace();\n}\n}\nreturn result;\n}","label":[1,0,0,0]}
{"id":10287,"original_code":"@Override\n    public PipelineData execute(ActionExpressionType expression, PipelineData input, ExecutionContext context, OperationResult globalResult) throws ScriptExecutionException {\n        boolean rebind = expressionHelper.getArgumentAsBoolean(expression.getParameter(), PARAM_REBIND_RESOURCES, input, context, false, PARAM_REBIND_RESOURCES, globalResult);\n        PipelineData output = PipelineData.createEmpty();\n        for (PipelineItem item: input.getData()) {\n            PrismValue value = item.getValue();\n            OperationResult result = operationsHelper.createActionResult(item, this, context, globalResult);\n            context.checkTaskStop();\n            if (value instanceof PrismObjectValue && ((PrismObjectValue) value).asObjectable() instanceof ConnectorHostType) {\n                PrismObject<ConnectorHostType> connectorHostTypePrismObject = ((PrismObjectValue) value).asPrismObject();\n                Set<ConnectorType> newConnectors;\n                long started = operationsHelper.recordStart(context, connectorHostTypePrismObject.asObjectable());\n                Throwable exception = null;\n                try {\n\t\t\t\t\tnewConnectors = modelService.discoverConnectors(connectorHostTypePrismObject.asObjectable(), context.getTask(), result);\n                    operationsHelper.recordEnd(context, connectorHostTypePrismObject.asObjectable(), started, null);\n                } catch (CommunicationException | SecurityViolationException | SchemaException | ConfigurationException | ObjectNotFoundException | RuntimeException e) {\n                    operationsHelper.recordEnd(context, connectorHostTypePrismObject.asObjectable(), started, e);\n\t\t\t\t\texception = processActionException(e, NAME, value, context);\n\t\t\t\t\tnewConnectors = Collections.emptySet();\n\t\t\t\t}\n                context.println((exception != null ? \"Attempted to discover \" : \"Discovered \" + newConnectors.size())\n\t\t\t\t\t\t+ \" new connector(s) from \" + connectorHostTypePrismObject + exceptionSuffix(exception));\n                for (ConnectorType connectorType : newConnectors) {\n                    output.addValue(connectorType.asPrismObject().getValue(), item.getResult());\n                }\n                try {\n\t\t\t\t\tif (rebind) {\n\t\t\t\t\t\trebindConnectors(newConnectors, context, result);\n\t\t\t\t\t}\n\t\t\t\t} catch (ScriptExecutionException e) {\n\t\t\t\t\t\/\/noinspection ThrowableNotThrown\n\t\t\t\t\tprocessActionException(e, NAME, value, context);\t\t\/\/ TODO better message\n\t\t\t\t}\n            } else {\n\t\t\t\t\/\/noinspection ThrowableNotThrown\n\t\t\t\tprocessActionException(new ScriptExecutionException(\"Input item is not a PrismObject<ConnectorHost>\"), NAME, value, context);\n            }\n            operationsHelper.trimAndCloneResult(result, globalResult, context);\n        }\n        return output;      \/\/ TODO configurable output (either connector hosts or discovered connectors)\n    }","code":"@Override\n    public PipelineData execute(ActionExpressionType expression, PipelineData input, ExecutionContext context, OperationResult globalResult) throws ScriptExecutionException {\n        boolean rebind = expressionHelper.getArgumentAsBoolean(expression.getParameter(), PARAM_REBIND_RESOURCES, input, context, false, PARAM_REBIND_RESOURCES, globalResult);\n        PipelineData output = PipelineData.createEmpty();\n        for (PipelineItem item: input.getData()) {\n            PrismValue value = item.getValue();\n            OperationResult result = operationsHelper.createActionResult(item, this, context, globalResult);\n            context.checkTaskStop();\n            if (value instanceof PrismObjectValue && ((PrismObjectValue) value).asObjectable() instanceof ConnectorHostType) {\n                PrismObject<ConnectorHostType> connectorHostTypePrismObject = ((PrismObjectValue) value).asPrismObject();\n                Set<ConnectorType> newConnectors;\n                long started = operationsHelper.recordStart(context, connectorHostTypePrismObject.asObjectable());\n                Throwable exception = null;\n                try {\n\t\t\t\t\tnewConnectors = modelService.discoverConnectors(connectorHostTypePrismObject.asObjectable(), context.getTask(), result);\n                    operationsHelper.recordEnd(context, connectorHostTypePrismObject.asObjectable(), started, null);\n                } catch (CommunicationException | SecurityViolationException | SchemaException | ConfigurationException | ObjectNotFoundException | RuntimeException e) {\n                    operationsHelper.recordEnd(context, connectorHostTypePrismObject.asObjectable(), started, e);\n\t\t\t\t\texception = processActionException(e, NAME, value, context);\n\t\t\t\t\tnewConnectors = Collections.emptySet();\n\t\t\t\t}\n                context.println((exception != null ? \"Attempted to discover \" : \"Discovered \" + newConnectors.size())\n\t\t\t\t\t\t+ \" new connector(s) from \" + connectorHostTypePrismObject + exceptionSuffix(exception));\n                for (ConnectorType connectorType : newConnectors) {\n                    output.addValue(connectorType.asPrismObject().getValue(), item.getResult());\n                }\n                try {\n\t\t\t\t\tif (rebind) {\n\t\t\t\t\t\trebindConnectors(newConnectors, context, result);\n\t\t\t\t\t}\n\t\t\t\t} catch (ScriptExecutionException e) {\n\t\t\t\t\n\t\t\t\t\tprocessActionException(e, NAME, value, context);\t\n\t\t\t\t}\n            } else {\n\t\t\t\n\t\t\t\tprocessActionException(new ScriptExecutionException(\"Input item is not a PrismObject<ConnectorHost>\"), NAME, value, context);\n            }\n            operationsHelper.trimAndCloneResult(result, globalResult, context);\n        }\n        return output;     \n    }","cleancode":"@override public pipelinedata execute(actionexpressiontype expression, pipelinedata input, executioncontext context, operationresult globalresult) throws scriptexecutionexception { boolean rebind = expressionhelper.getargumentasboolean(expression.getparameter(), param_rebind_resources, input, context, false, param_rebind_resources, globalresult); pipelinedata output = pipelinedata.createempty(); for (pipelineitem item: input.getdata()) { prismvalue value = item.getvalue(); operationresult result = operationshelper.createactionresult(item, this, context, globalresult); context.checktaskstop(); if (value instanceof prismobjectvalue && ((prismobjectvalue) value).asobjectable() instanceof connectorhosttype) { prismobject<connectorhosttype> connectorhosttypeprismobject = ((prismobjectvalue) value).asprismobject(); set<connectortype> newconnectors; long started = operationshelper.recordstart(context, connectorhosttypeprismobject.asobjectable()); throwable exception = null; try { newconnectors = modelservice.discoverconnectors(connectorhosttypeprismobject.asobjectable(), context.gettask(), result); operationshelper.recordend(context, connectorhosttypeprismobject.asobjectable(), started, null); } catch (communicationexception | securityviolationexception | schemaexception | configurationexception | objectnotfoundexception | runtimeexception e) { operationshelper.recordend(context, connectorhosttypeprismobject.asobjectable(), started, e); exception = processactionexception(e, name, value, context); newconnectors = collections.emptyset(); } context.println((exception != null ? \"attempted to discover \" : \"discovered \" + newconnectors.size()) + \" new connector(s) from \" + connectorhosttypeprismobject + exceptionsuffix(exception)); for (connectortype connectortype : newconnectors) { output.addvalue(connectortype.asprismobject().getvalue(), item.getresult()); } try { if (rebind) { rebindconnectors(newconnectors, context, result); } } catch (scriptexecutionexception e) { processactionexception(e, name, value, context); } } else { processactionexception(new scriptexecutionexception(\"input item is not a prismobject<connectorhost>\"), name, value, context); } operationshelper.trimandcloneresult(result, globalresult, context); } return output; }","comment":"\/\/noinspection throwablenotthrown\n\/\/ todo better message\n\/\/noinspection throwablenotthrown\n\/\/ todo configurable output (either connector hosts or discovered connectors)","repo":"Neovision-xin\/dev","code_context_2":"}\n} catch (ScriptExecutionException e) {\n\/\/noinspection ThrowableNotThrown\nprocessActionException(e, NAME, value, context); \/\/ TODO better message\n}\n\n} catch (ScriptExecutionException e) {\n\/\/noinspection ThrowableNotThrown\nprocessActionException(e, NAME, value, context); \/\/ TODO better message\n}\n} else {\n\n}\n} catch (ScriptExecutionException e) {\n\/\/noinspection ThrowableNotThrown\nprocessActionException(e, NAME, value, context); \/\/ TODO better message\n}\n\noperationsHelper.trimAndCloneResult(result, globalResult, context);\n}\nreturn output; \/\/ TODO configurable output (either connector hosts or discovered connectors)\n}","code_context_10":"context.println((exception != null ? \"Attempted to discover \" : \"Discovered \" + newConnectors.size())\n+ \" new connector(s) from \" + connectorHostTypePrismObject + exceptionSuffix(exception));\nfor (ConnectorType connectorType : newConnectors) {\noutput.addValue(connectorType.asPrismObject().getValue(), item.getResult());\n}\ntry {\nif (rebind) {\nrebindConnectors(newConnectors, context, result);\n}\n} catch (ScriptExecutionException e) {\n\/\/noinspection ThrowableNotThrown\nprocessActionException(e, NAME, value, context); \/\/ TODO better message\n}\n} else {\n\/\/noinspection ThrowableNotThrown\nprocessActionException(new ScriptExecutionException(\"Input item is not a PrismObject<ConnectorHost>\"), NAME, value, context);\n}\noperationsHelper.trimAndCloneResult(result, globalResult, context);\n}\nreturn output; \/\/ TODO configurable output (either connector hosts or discovered connectors)\n}\n\n+ \" new connector(s) from \" + connectorHostTypePrismObject + exceptionSuffix(exception));\nfor (ConnectorType connectorType : newConnectors) {\noutput.addValue(connectorType.asPrismObject().getValue(), item.getResult());\n}\ntry {\nif (rebind) {\nrebindConnectors(newConnectors, context, result);\n}\n} catch (ScriptExecutionException e) {\n\/\/noinspection ThrowableNotThrown\nprocessActionException(e, NAME, value, context); \/\/ TODO better message\n}\n} else {\n\/\/noinspection ThrowableNotThrown\nprocessActionException(new ScriptExecutionException(\"Input item is not a PrismObject<ConnectorHost>\"), NAME, value, context);\n}\noperationsHelper.trimAndCloneResult(result, globalResult, context);\n}\nreturn output; \/\/ TODO configurable output (either connector hosts or discovered connectors)\n}\n\ncontext.println((exception != null ? \"Attempted to discover \" : \"Discovered \" + newConnectors.size())\n+ \" new connector(s) from \" + connectorHostTypePrismObject + exceptionSuffix(exception));\nfor (ConnectorType connectorType : newConnectors) {\noutput.addValue(connectorType.asPrismObject().getValue(), item.getResult());\n}\ntry {\nif (rebind) {\nrebindConnectors(newConnectors, context, result);\n}\n} catch (ScriptExecutionException e) {\n\/\/noinspection ThrowableNotThrown\nprocessActionException(e, NAME, value, context); \/\/ TODO better message\n}\n} else {\n\/\/noinspection ThrowableNotThrown\nprocessActionException(new ScriptExecutionException(\"Input item is not a PrismObject<ConnectorHost>\"), NAME, value, context);\n}\noperationsHelper.trimAndCloneResult(result, globalResult, context);\n}\nreturn output; \/\/ TODO configurable output (either connector hosts or discovered connectors)\n}\n\n} catch (ScriptExecutionException e) {\n\/\/noinspection ThrowableNotThrown\nprocessActionException(e, NAME, value, context); \/\/ TODO better message\n}\n} else {\n\/\/noinspection ThrowableNotThrown\nprocessActionException(new ScriptExecutionException(\"Input item is not a PrismObject<ConnectorHost>\"), NAME, value, context);\n}\noperationsHelper.trimAndCloneResult(result, globalResult, context);\n}\nreturn output; \/\/ TODO configurable output (either connector hosts or discovered connectors)\n}","code_context_20":"long started = operationsHelper.recordStart(context, connectorHostTypePrismObject.asObjectable());\nThrowable exception = null;\ntry {\nnewConnectors = modelService.discoverConnectors(connectorHostTypePrismObject.asObjectable(), context.getTask(), result);\noperationsHelper.recordEnd(context, connectorHostTypePrismObject.asObjectable(), started, null);\n} catch (CommunicationException | SecurityViolationException | SchemaException | ConfigurationException | ObjectNotFoundException | RuntimeException e) {\noperationsHelper.recordEnd(context, connectorHostTypePrismObject.asObjectable(), started, e);\nexception = processActionException(e, NAME, value, context);\nnewConnectors = Collections.emptySet();\n}\ncontext.println((exception != null ? \"Attempted to discover \" : \"Discovered \" + newConnectors.size())\n+ \" new connector(s) from \" + connectorHostTypePrismObject + exceptionSuffix(exception));\nfor (ConnectorType connectorType : newConnectors) {\noutput.addValue(connectorType.asPrismObject().getValue(), item.getResult());\n}\ntry {\nif (rebind) {\nrebindConnectors(newConnectors, context, result);\n}\n} catch (ScriptExecutionException e) {\n\/\/noinspection ThrowableNotThrown\nprocessActionException(e, NAME, value, context); \/\/ TODO better message\n}\n} else {\n\/\/noinspection ThrowableNotThrown\nprocessActionException(new ScriptExecutionException(\"Input item is not a PrismObject<ConnectorHost>\"), NAME, value, context);\n}\noperationsHelper.trimAndCloneResult(result, globalResult, context);\n}\nreturn output; \/\/ TODO configurable output (either connector hosts or discovered connectors)\n}\n\nThrowable exception = null;\ntry {\nnewConnectors = modelService.discoverConnectors(connectorHostTypePrismObject.asObjectable(), context.getTask(), result);\noperationsHelper.recordEnd(context, connectorHostTypePrismObject.asObjectable(), started, null);\n} catch (CommunicationException | SecurityViolationException | SchemaException | ConfigurationException | ObjectNotFoundException | RuntimeException e) {\noperationsHelper.recordEnd(context, connectorHostTypePrismObject.asObjectable(), started, e);\nexception = processActionException(e, NAME, value, context);\nnewConnectors = Collections.emptySet();\n}\ncontext.println((exception != null ? \"Attempted to discover \" : \"Discovered \" + newConnectors.size())\n+ \" new connector(s) from \" + connectorHostTypePrismObject + exceptionSuffix(exception));\nfor (ConnectorType connectorType : newConnectors) {\noutput.addValue(connectorType.asPrismObject().getValue(), item.getResult());\n}\ntry {\nif (rebind) {\nrebindConnectors(newConnectors, context, result);\n}\n} catch (ScriptExecutionException e) {\n\/\/noinspection ThrowableNotThrown\nprocessActionException(e, NAME, value, context); \/\/ TODO better message\n}\n} else {\n\/\/noinspection ThrowableNotThrown\nprocessActionException(new ScriptExecutionException(\"Input item is not a PrismObject<ConnectorHost>\"), NAME, value, context);\n}\noperationsHelper.trimAndCloneResult(result, globalResult, context);\n}\nreturn output; \/\/ TODO configurable output (either connector hosts or discovered connectors)\n}\n\nlong started = operationsHelper.recordStart(context, connectorHostTypePrismObject.asObjectable());\nThrowable exception = null;\ntry {\nnewConnectors = modelService.discoverConnectors(connectorHostTypePrismObject.asObjectable(), context.getTask(), result);\noperationsHelper.recordEnd(context, connectorHostTypePrismObject.asObjectable(), started, null);\n} catch (CommunicationException | SecurityViolationException | SchemaException | ConfigurationException | ObjectNotFoundException | RuntimeException e) {\noperationsHelper.recordEnd(context, connectorHostTypePrismObject.asObjectable(), started, e);\nexception = processActionException(e, NAME, value, context);\nnewConnectors = Collections.emptySet();\n}\ncontext.println((exception != null ? \"Attempted to discover \" : \"Discovered \" + newConnectors.size())\n+ \" new connector(s) from \" + connectorHostTypePrismObject + exceptionSuffix(exception));\nfor (ConnectorType connectorType : newConnectors) {\noutput.addValue(connectorType.asPrismObject().getValue(), item.getResult());\n}\ntry {\nif (rebind) {\nrebindConnectors(newConnectors, context, result);\n}\n} catch (ScriptExecutionException e) {\n\/\/noinspection ThrowableNotThrown\nprocessActionException(e, NAME, value, context); \/\/ TODO better message\n}\n} else {\n\/\/noinspection ThrowableNotThrown\nprocessActionException(new ScriptExecutionException(\"Input item is not a PrismObject<ConnectorHost>\"), NAME, value, context);\n}\noperationsHelper.trimAndCloneResult(result, globalResult, context);\n}\nreturn output; \/\/ TODO configurable output (either connector hosts or discovered connectors)\n}\n\n}\ncontext.println((exception != null ? \"Attempted to discover \" : \"Discovered \" + newConnectors.size())\n+ \" new connector(s) from \" + connectorHostTypePrismObject + exceptionSuffix(exception));\nfor (ConnectorType connectorType : newConnectors) {\noutput.addValue(connectorType.asPrismObject().getValue(), item.getResult());\n}\ntry {\nif (rebind) {\nrebindConnectors(newConnectors, context, result);\n}\n} catch (ScriptExecutionException e) {\n\/\/noinspection ThrowableNotThrown\nprocessActionException(e, NAME, value, context); \/\/ TODO better message\n}\n} else {\n\/\/noinspection ThrowableNotThrown\nprocessActionException(new ScriptExecutionException(\"Input item is not a PrismObject<ConnectorHost>\"), NAME, value, context);\n}\noperationsHelper.trimAndCloneResult(result, globalResult, context);\n}\nreturn output; \/\/ TODO configurable output (either connector hosts or discovered connectors)\n}","label":[1,0,0,0]}
{"id":34916,"original_code":"private boolean analyzeLastLine(\n      PageAnalysis analysis, PageElementTag tag,\n      Collection<CheckErrorResult> errors) {\n    \/\/ TODO: Refactor\n    \/\/ Check type of tag\n    if (!HtmlTagType.CENTER.equals(tag.getType()) &&\n        !HtmlTagType.SMALL.equals(tag.getType())) {\n      return false;\n    }\n    \/\/ Check namespace\n    Integer namespace = analysis.getPage().getNamespace();\n    if ((namespace == null) || (namespace.intValue() == Namespace.TEMPLATE)) {\n      return false;\n    }\n    \/\/ Go to the end of the last line\n    String contents = analysis.getContents();\n    int index = contents.length();\n    while ((index > 0) && (contents.charAt(index - 1) == '\\n')) {\n      index--;\n    }\n    while ((index > 0) && (contents.charAt(index - 1) == ' ')) {\n      index--;\n    }\n    if (index == 0) {\n      return false;\n    }\n    \/\/ Check if there's a tag at the end of the last line\n    int lastIndex = index;\n    PageElementTag lastTag = null;\n    if (contents.charAt(index - 1) == '>') {\n      lastTag = analysis.isInTag(index - 1);\n      if (lastTag != null) {\n        index = lastTag.getBeginIndex();\n      }\n    }\n    \/\/ Check if the tag is in the last line\n    int tagEndIndex = tag.getEndIndex();\n    while ((index > tagEndIndex) && (contents.charAt(index - 1) != '\\n')) {\n      index--;\n      if (contents.charAt(index) == '>') {\n        if (analysis.isInTag(index - 1, tag.getType()) != null) {\n          return false;\n        }\n      }\n    }\n    if (index > tagEndIndex) {\n      return false;\n    }\n    \/\/ Check if there's an other opening tag before in the page\n    List<PageElementTag> tags = analysis.getTags(tag.getType());\n    boolean after = false;\n    boolean hasOtherTagBefore = false;\n    for (PageElementTag otherTag : tags) {\n      if (!after) {\n        if (otherTag == tag) {\n          after = true;\n        } else if (!otherTag.isComplete()) {\n          hasOtherTagBefore = true;\n        }\n      }\n    }\n    \/\/ Decide what to do\n    if (lastTag == tag) {\n      CheckErrorResult errorResult = createCheckErrorResult(analysis, tag.getBeginIndex(), tag.getEndIndex());\n      errorResult.addReplacement(\"\");\n      if (hasOtherTagBefore && (tag.getParametersCount() == 0)) {\n        errorResult.addReplacement(\n            TagBuilder.from(tag.getName(), TagFormat.CLOSE).toString());\n      }\n      errors.add(errorResult);\n      return true;\n    }\n    if (lastTag != null) {\n      CheckErrorResult errorResult = analyzeArea(\n          analysis, tag, lastTag.getBeginIndex(), tag.getEndIndex(),\n          !hasOtherTagBefore, ActionAlone.ALONE_NOTHING); \n      if (errorResult != null) {\n        errors.add(errorResult);\n        return true;\n      }\n    } else {\n      CheckErrorResult errorResult = analyzeArea(\n          analysis, tag, tag.getBeginIndex(), lastIndex,\n          !hasOtherTagBefore, ActionAlone.ALONE_NOTHING); \n      if (errorResult != null) {\n        errors.add(errorResult);\n        return true;\n      }\n    }\n    return false;\n  }","code":"private boolean analyzeLastLine(\n      PageAnalysis analysis, PageElementTag tag,\n      Collection<CheckErrorResult> errors) {\n   \n   \n    if (!HtmlTagType.CENTER.equals(tag.getType()) &&\n        !HtmlTagType.SMALL.equals(tag.getType())) {\n      return false;\n    }\n   \n    Integer namespace = analysis.getPage().getNamespace();\n    if ((namespace == null) || (namespace.intValue() == Namespace.TEMPLATE)) {\n      return false;\n    }\n   \n    String contents = analysis.getContents();\n    int index = contents.length();\n    while ((index > 0) && (contents.charAt(index - 1) == '\\n')) {\n      index--;\n    }\n    while ((index > 0) && (contents.charAt(index - 1) == ' ')) {\n      index--;\n    }\n    if (index == 0) {\n      return false;\n    }\n   \n    int lastIndex = index;\n    PageElementTag lastTag = null;\n    if (contents.charAt(index - 1) == '>') {\n      lastTag = analysis.isInTag(index - 1);\n      if (lastTag != null) {\n        index = lastTag.getBeginIndex();\n      }\n    }\n   \n    int tagEndIndex = tag.getEndIndex();\n    while ((index > tagEndIndex) && (contents.charAt(index - 1) != '\\n')) {\n      index--;\n      if (contents.charAt(index) == '>') {\n        if (analysis.isInTag(index - 1, tag.getType()) != null) {\n          return false;\n        }\n      }\n    }\n    if (index > tagEndIndex) {\n      return false;\n    }\n   \n    List<PageElementTag> tags = analysis.getTags(tag.getType());\n    boolean after = false;\n    boolean hasOtherTagBefore = false;\n    for (PageElementTag otherTag : tags) {\n      if (!after) {\n        if (otherTag == tag) {\n          after = true;\n        } else if (!otherTag.isComplete()) {\n          hasOtherTagBefore = true;\n        }\n      }\n    }\n   \n    if (lastTag == tag) {\n      CheckErrorResult errorResult = createCheckErrorResult(analysis, tag.getBeginIndex(), tag.getEndIndex());\n      errorResult.addReplacement(\"\");\n      if (hasOtherTagBefore && (tag.getParametersCount() == 0)) {\n        errorResult.addReplacement(\n            TagBuilder.from(tag.getName(), TagFormat.CLOSE).toString());\n      }\n      errors.add(errorResult);\n      return true;\n    }\n    if (lastTag != null) {\n      CheckErrorResult errorResult = analyzeArea(\n          analysis, tag, lastTag.getBeginIndex(), tag.getEndIndex(),\n          !hasOtherTagBefore, ActionAlone.ALONE_NOTHING); \n      if (errorResult != null) {\n        errors.add(errorResult);\n        return true;\n      }\n    } else {\n      CheckErrorResult errorResult = analyzeArea(\n          analysis, tag, tag.getBeginIndex(), lastIndex,\n          !hasOtherTagBefore, ActionAlone.ALONE_NOTHING); \n      if (errorResult != null) {\n        errors.add(errorResult);\n        return true;\n      }\n    }\n    return false;\n  }","cleancode":"private boolean analyzelastline( pageanalysis analysis, pageelementtag tag, collection<checkerrorresult> errors) { if (!htmltagtype.center.equals(tag.gettype()) && !htmltagtype.small.equals(tag.gettype())) { return false; } integer namespace = analysis.getpage().getnamespace(); if ((namespace == null) || (namespace.intvalue() == namespace.template)) { return false; } string contents = analysis.getcontents(); int index = contents.length(); while ((index > 0) && (contents.charat(index - 1) == '\\n')) { index--; } while ((index > 0) && (contents.charat(index - 1) == ' ')) { index--; } if (index == 0) { return false; } int lastindex = index; pageelementtag lasttag = null; if (contents.charat(index - 1) == '>') { lasttag = analysis.isintag(index - 1); if (lasttag != null) { index = lasttag.getbeginindex(); } } int tagendindex = tag.getendindex(); while ((index > tagendindex) && (contents.charat(index - 1) != '\\n')) { index--; if (contents.charat(index) == '>') { if (analysis.isintag(index - 1, tag.gettype()) != null) { return false; } } } if (index > tagendindex) { return false; } list<pageelementtag> tags = analysis.gettags(tag.gettype()); boolean after = false; boolean hasothertagbefore = false; for (pageelementtag othertag : tags) { if (!after) { if (othertag == tag) { after = true; } else if (!othertag.iscomplete()) { hasothertagbefore = true; } } } if (lasttag == tag) { checkerrorresult errorresult = createcheckerrorresult(analysis, tag.getbeginindex(), tag.getendindex()); errorresult.addreplacement(\"\"); if (hasothertagbefore && (tag.getparameterscount() == 0)) { errorresult.addreplacement( tagbuilder.from(tag.getname(), tagformat.close).tostring()); } errors.add(errorresult); return true; } if (lasttag != null) { checkerrorresult errorresult = analyzearea( analysis, tag, lasttag.getbeginindex(), tag.getendindex(), !hasothertagbefore, actionalone.alone_nothing); if (errorresult != null) { errors.add(errorresult); return true; } } else { checkerrorresult errorresult = analyzearea( analysis, tag, tag.getbeginindex(), lastindex, !hasothertagbefore, actionalone.alone_nothing); if (errorresult != null) { errors.add(errorresult); return true; } } return false; }","comment":"\/** * @param analysis page analysis. * @param tag tag. * @param errors errors found in the page. * @return true if the error has been reported. *\/\n\/\/ todo: refactor \/\/ check type of tag\n\/\/ check namespace\n\/\/ go to the end of the last line\n\/\/ check if there's a tag at the end of the last line\n\/\/ check if the tag is in the last line\n\/\/ check if there's an other opening tag before in the page\n\/\/ decide what to do","repo":"RogueScholar\/wpcleaner","code_context_2":"private boolean analyzeLastLine(\nPageAnalysis analysis, PageElementTag tag,\nCollection<CheckErrorResult> errors) {\n\/\/ TODO: Refactor\n\/\/ Check type of tag\nif (!HtmlTagType.CENTER.equals(tag.getType()) &&\n!HtmlTagType.SMALL.equals(tag.getType())) {\nreturn false;\n}\n\/\/ Check namespace\nInteger namespace = analysis.getPage().getNamespace();\nif ((namespace == null) || (namespace.intValue() == Namespace.TEMPLATE)) {\nreturn false;\n}\n\/\/ Go to the end of the last line\nString contents = analysis.getContents();\nint index = contents.length();\nwhile ((index > 0) && (contents.charAt(index - 1) == '\\n')) {\nindex--;\n}\nwhile ((index > 0) && (contents.charAt(index - 1) == ' ')) {\nindex--;\n}\nif (index == 0) {\nreturn false;\n}\n\/\/ Check if there's a tag at the end of the last line\nint lastIndex = index;\nPageElementTag lastTag = null;\nif (contents.charAt(index - 1) == '>') {\nlastTag = analysis.isInTag(index - 1);\nif (lastTag != null) {\nindex = lastTag.getBeginIndex();\n}\n}\n\/\/ Check if the tag is in the last line\nint tagEndIndex = tag.getEndIndex();\nwhile ((index > tagEndIndex) && (contents.charAt(index - 1) != '\\n')) {\nindex--;\nif (contents.charAt(index) == '>') {\nif (analysis.isInTag(index - 1, tag.getType()) != null) {\nreturn false;\n}\n}\n}\nif (index > tagEndIndex) {\nreturn false;\n}\n\/\/ Check if there's an other opening tag before in the page\nList<PageElementTag> tags = analysis.getTags(tag.getType());\nboolean after = false;\nboolean hasOtherTagBefore = false;\nfor (PageElementTag otherTag : tags) {\nif (!after) {\nif (otherTag == tag) {\nafter = true;\n} else if (!otherTag.isComplete()) {\nhasOtherTagBefore = true;\n}\n}\n}\n\/\/ Decide what to do\nif (lastTag == tag) {\nCheckErrorResult errorResult = createCheckErrorResult(analysis, tag.getBeginIndex(), tag.getEndIndex());\nerrorResult.addReplacement(\"\");\nif (hasOtherTagBefore && (tag.getParametersCount() == 0)) {\nerrorResult.addReplacement(\nTagBuilder.from(tag.getName(), TagFormat.CLOSE).toString());\n}\nerrors.add(errorResult);\nreturn true;\n}\nif (lastTag != null) {\nCheckErrorResult errorResult = analyzeArea(\nanalysis, tag, lastTag.getBeginIndex(), tag.getEndIndex(),\n!hasOtherTagBefore, ActionAlone.ALONE_NOTHING);\nif (errorResult != null) {\nerrors.add(errorResult);\nreturn true;\n}\n} else {\nCheckErrorResult errorResult = analyzeArea(\nanalysis, tag, tag.getBeginIndex(), lastIndex,\n!hasOtherTagBefore, ActionAlone.ALONE_NOTHING);\nif (errorResult != null) {\nerrors.add(errorResult);\nreturn true;\n}\n}\nreturn false;\n}\n\nPageAnalysis analysis, PageElementTag tag,\nCollection<CheckErrorResult> errors) {\n\/\/ TODO: Refactor\n\/\/ Check type of tag\nif (!HtmlTagType.CENTER.equals(tag.getType()) &&\n!HtmlTagType.SMALL.equals(tag.getType())) {\n\nreturn false;\n}\n\/\/ Check namespace\nInteger namespace = analysis.getPage().getNamespace();\nif ((namespace == null) || (namespace.intValue() == Namespace.TEMPLATE)) {\n\nreturn false;\n}\n\/\/ Go to the end of the last line\nString contents = analysis.getContents();\nint index = contents.length();\n\nreturn false;\n}\n\/\/ Check if there's a tag at the end of the last line\nint lastIndex = index;\nPageElementTag lastTag = null;\n\n}\n}\n\/\/ Check if the tag is in the last line\nint tagEndIndex = tag.getEndIndex();\nwhile ((index > tagEndIndex) && (contents.charAt(index - 1) != '\\n')) {\n\nreturn false;\n}\n\/\/ Check if there's an other opening tag before in the page\nList<PageElementTag> tags = analysis.getTags(tag.getType());\nboolean after = false;\n\n}\n}\n\/\/ Decide what to do\nif (lastTag == tag) {\nCheckErrorResult errorResult = createCheckErrorResult(analysis, tag.getBeginIndex(), tag.getEndIndex());","code_context_10":"private boolean analyzeLastLine(\nPageAnalysis analysis, PageElementTag tag,\nCollection<CheckErrorResult> errors) {\n\/\/ TODO: Refactor\n\/\/ Check type of tag\nif (!HtmlTagType.CENTER.equals(tag.getType()) &&\n!HtmlTagType.SMALL.equals(tag.getType())) {\nreturn false;\n}\n\/\/ Check namespace\nInteger namespace = analysis.getPage().getNamespace();\nif ((namespace == null) || (namespace.intValue() == Namespace.TEMPLATE)) {\nreturn false;\n}\n\/\/ Go to the end of the last line\nString contents = analysis.getContents();\nint index = contents.length();\nwhile ((index > 0) && (contents.charAt(index - 1) == '\\n')) {\nindex--;\n}\nwhile ((index > 0) && (contents.charAt(index - 1) == ' ')) {\nindex--;\n}\nif (index == 0) {\nreturn false;\n}\n\/\/ Check if there's a tag at the end of the last line\nint lastIndex = index;\nPageElementTag lastTag = null;\nif (contents.charAt(index - 1) == '>') {\nlastTag = analysis.isInTag(index - 1);\nif (lastTag != null) {\nindex = lastTag.getBeginIndex();\n}\n}\n\/\/ Check if the tag is in the last line\nint tagEndIndex = tag.getEndIndex();\nwhile ((index > tagEndIndex) && (contents.charAt(index - 1) != '\\n')) {\nindex--;\nif (contents.charAt(index) == '>') {\nif (analysis.isInTag(index - 1, tag.getType()) != null) {\nreturn false;\n}\n}\n}\nif (index > tagEndIndex) {\nreturn false;\n}\n\/\/ Check if there's an other opening tag before in the page\nList<PageElementTag> tags = analysis.getTags(tag.getType());\nboolean after = false;\nboolean hasOtherTagBefore = false;\nfor (PageElementTag otherTag : tags) {\nif (!after) {\nif (otherTag == tag) {\nafter = true;\n} else if (!otherTag.isComplete()) {\nhasOtherTagBefore = true;\n}\n}\n}\n\/\/ Decide what to do\nif (lastTag == tag) {\nCheckErrorResult errorResult = createCheckErrorResult(analysis, tag.getBeginIndex(), tag.getEndIndex());\nerrorResult.addReplacement(\"\");\nif (hasOtherTagBefore && (tag.getParametersCount() == 0)) {\nerrorResult.addReplacement(\nTagBuilder.from(tag.getName(), TagFormat.CLOSE).toString());\n}\nerrors.add(errorResult);\nreturn true;\n}\nif (lastTag != null) {\nCheckErrorResult errorResult = analyzeArea(\nanalysis, tag, lastTag.getBeginIndex(), tag.getEndIndex(),\n!hasOtherTagBefore, ActionAlone.ALONE_NOTHING);\nif (errorResult != null) {\nerrors.add(errorResult);\nreturn true;\n}\n} else {\nCheckErrorResult errorResult = analyzeArea(\nanalysis, tag, tag.getBeginIndex(), lastIndex,\n!hasOtherTagBefore, ActionAlone.ALONE_NOTHING);\nif (errorResult != null) {\nerrors.add(errorResult);\nreturn true;\n}\n}\nreturn false;\n}\n\nprivate boolean analyzeLastLine(\nPageAnalysis analysis, PageElementTag tag,\nCollection<CheckErrorResult> errors) {\n\/\/ TODO: Refactor\n\/\/ Check type of tag\nif (!HtmlTagType.CENTER.equals(tag.getType()) &&\n!HtmlTagType.SMALL.equals(tag.getType())) {\nreturn false;\n}\n\/\/ Check namespace\nInteger namespace = analysis.getPage().getNamespace();\nif ((namespace == null) || (namespace.intValue() == Namespace.TEMPLATE)) {\nreturn false;\n}\n\/\/ Go to the end of the last line\n\nprivate boolean analyzeLastLine(\nPageAnalysis analysis, PageElementTag tag,\nCollection<CheckErrorResult> errors) {\n\/\/ TODO: Refactor\n\/\/ Check type of tag\nif (!HtmlTagType.CENTER.equals(tag.getType()) &&\n!HtmlTagType.SMALL.equals(tag.getType())) {\nreturn false;\n}\n\/\/ Check namespace\nInteger namespace = analysis.getPage().getNamespace();\nif ((namespace == null) || (namespace.intValue() == Namespace.TEMPLATE)) {\nreturn false;\n}\n\/\/ Go to the end of the last line\nString contents = analysis.getContents();\nint index = contents.length();\nwhile ((index > 0) && (contents.charAt(index - 1) == '\\n')) {\nindex--;\n}\n\n\/\/ Check type of tag\nif (!HtmlTagType.CENTER.equals(tag.getType()) &&\n!HtmlTagType.SMALL.equals(tag.getType())) {\nreturn false;\n}\n\/\/ Check namespace\nInteger namespace = analysis.getPage().getNamespace();\nif ((namespace == null) || (namespace.intValue() == Namespace.TEMPLATE)) {\nreturn false;\n}\n\/\/ Go to the end of the last line\nString contents = analysis.getContents();\nint index = contents.length();\nwhile ((index > 0) && (contents.charAt(index - 1) == '\\n')) {\nindex--;\n}\nwhile ((index > 0) && (contents.charAt(index - 1) == ' ')) {\nindex--;\n}\nif (index == 0) {\nreturn false;\n\nint index = contents.length();\nwhile ((index > 0) && (contents.charAt(index - 1) == '\\n')) {\nindex--;\n}\nwhile ((index > 0) && (contents.charAt(index - 1) == ' ')) {\nindex--;\n}\nif (index == 0) {\nreturn false;\n}\n\/\/ Check if there's a tag at the end of the last line\nint lastIndex = index;\nPageElementTag lastTag = null;\nif (contents.charAt(index - 1) == '>') {\nlastTag = analysis.isInTag(index - 1);\nif (lastTag != null) {\nindex = lastTag.getBeginIndex();\n}\n}\n\/\/ Check if the tag is in the last line\nint tagEndIndex = tag.getEndIndex();\n\n}\n\/\/ Check if there's a tag at the end of the last line\nint lastIndex = index;\nPageElementTag lastTag = null;\nif (contents.charAt(index - 1) == '>') {\nlastTag = analysis.isInTag(index - 1);\nif (lastTag != null) {\nindex = lastTag.getBeginIndex();\n}\n}\n\/\/ Check if the tag is in the last line\nint tagEndIndex = tag.getEndIndex();\nwhile ((index > tagEndIndex) && (contents.charAt(index - 1) != '\\n')) {\nindex--;\nif (contents.charAt(index) == '>') {\nif (analysis.isInTag(index - 1, tag.getType()) != null) {\nreturn false;\n}\n}\n}\nif (index > tagEndIndex) {\n\nindex--;\nif (contents.charAt(index) == '>') {\nif (analysis.isInTag(index - 1, tag.getType()) != null) {\nreturn false;\n}\n}\n}\nif (index > tagEndIndex) {\nreturn false;\n}\n\/\/ Check if there's an other opening tag before in the page\nList<PageElementTag> tags = analysis.getTags(tag.getType());\nboolean after = false;\nboolean hasOtherTagBefore = false;\nfor (PageElementTag otherTag : tags) {\nif (!after) {\nif (otherTag == tag) {\nafter = true;\n} else if (!otherTag.isComplete()) {\nhasOtherTagBefore = true;\n}\n\nboolean hasOtherTagBefore = false;\nfor (PageElementTag otherTag : tags) {\nif (!after) {\nif (otherTag == tag) {\nafter = true;\n} else if (!otherTag.isComplete()) {\nhasOtherTagBefore = true;\n}\n}\n}\n\/\/ Decide what to do\nif (lastTag == tag) {\nCheckErrorResult errorResult = createCheckErrorResult(analysis, tag.getBeginIndex(), tag.getEndIndex());\nerrorResult.addReplacement(\"\");\nif (hasOtherTagBefore && (tag.getParametersCount() == 0)) {\nerrorResult.addReplacement(\nTagBuilder.from(tag.getName(), TagFormat.CLOSE).toString());\n}\nerrors.add(errorResult);\nreturn true;\n}","code_context_20":"private boolean analyzeLastLine(\nPageAnalysis analysis, PageElementTag tag,\nCollection<CheckErrorResult> errors) {\n\/\/ TODO: Refactor\n\/\/ Check type of tag\nif (!HtmlTagType.CENTER.equals(tag.getType()) &&\n!HtmlTagType.SMALL.equals(tag.getType())) {\nreturn false;\n}\n\/\/ Check namespace\nInteger namespace = analysis.getPage().getNamespace();\nif ((namespace == null) || (namespace.intValue() == Namespace.TEMPLATE)) {\nreturn false;\n}\n\/\/ Go to the end of the last line\nString contents = analysis.getContents();\nint index = contents.length();\nwhile ((index > 0) && (contents.charAt(index - 1) == '\\n')) {\nindex--;\n}\nwhile ((index > 0) && (contents.charAt(index - 1) == ' ')) {\nindex--;\n}\nif (index == 0) {\nreturn false;\n}\n\/\/ Check if there's a tag at the end of the last line\nint lastIndex = index;\nPageElementTag lastTag = null;\nif (contents.charAt(index - 1) == '>') {\nlastTag = analysis.isInTag(index - 1);\nif (lastTag != null) {\nindex = lastTag.getBeginIndex();\n}\n}\n\/\/ Check if the tag is in the last line\nint tagEndIndex = tag.getEndIndex();\nwhile ((index > tagEndIndex) && (contents.charAt(index - 1) != '\\n')) {\nindex--;\nif (contents.charAt(index) == '>') {\nif (analysis.isInTag(index - 1, tag.getType()) != null) {\nreturn false;\n}\n}\n}\nif (index > tagEndIndex) {\nreturn false;\n}\n\/\/ Check if there's an other opening tag before in the page\nList<PageElementTag> tags = analysis.getTags(tag.getType());\nboolean after = false;\nboolean hasOtherTagBefore = false;\nfor (PageElementTag otherTag : tags) {\nif (!after) {\nif (otherTag == tag) {\nafter = true;\n} else if (!otherTag.isComplete()) {\nhasOtherTagBefore = true;\n}\n}\n}\n\/\/ Decide what to do\nif (lastTag == tag) {\nCheckErrorResult errorResult = createCheckErrorResult(analysis, tag.getBeginIndex(), tag.getEndIndex());\nerrorResult.addReplacement(\"\");\nif (hasOtherTagBefore && (tag.getParametersCount() == 0)) {\nerrorResult.addReplacement(\nTagBuilder.from(tag.getName(), TagFormat.CLOSE).toString());\n}\nerrors.add(errorResult);\nreturn true;\n}\nif (lastTag != null) {\nCheckErrorResult errorResult = analyzeArea(\nanalysis, tag, lastTag.getBeginIndex(), tag.getEndIndex(),\n!hasOtherTagBefore, ActionAlone.ALONE_NOTHING);\nif (errorResult != null) {\nerrors.add(errorResult);\nreturn true;\n}\n} else {\nCheckErrorResult errorResult = analyzeArea(\nanalysis, tag, tag.getBeginIndex(), lastIndex,\n!hasOtherTagBefore, ActionAlone.ALONE_NOTHING);\nif (errorResult != null) {\nerrors.add(errorResult);\nreturn true;\n}\n}\nreturn false;\n}\n\nprivate boolean analyzeLastLine(\nPageAnalysis analysis, PageElementTag tag,\nCollection<CheckErrorResult> errors) {\n\/\/ TODO: Refactor\n\/\/ Check type of tag\nif (!HtmlTagType.CENTER.equals(tag.getType()) &&\n!HtmlTagType.SMALL.equals(tag.getType())) {\nreturn false;\n}\n\/\/ Check namespace\nInteger namespace = analysis.getPage().getNamespace();\nif ((namespace == null) || (namespace.intValue() == Namespace.TEMPLATE)) {\nreturn false;\n}\n\/\/ Go to the end of the last line\nString contents = analysis.getContents();\nint index = contents.length();\nwhile ((index > 0) && (contents.charAt(index - 1) == '\\n')) {\nindex--;\n}\nwhile ((index > 0) && (contents.charAt(index - 1) == ' ')) {\nindex--;\n}\nif (index == 0) {\nreturn false;\n\nprivate boolean analyzeLastLine(\nPageAnalysis analysis, PageElementTag tag,\nCollection<CheckErrorResult> errors) {\n\/\/ TODO: Refactor\n\/\/ Check type of tag\nif (!HtmlTagType.CENTER.equals(tag.getType()) &&\n!HtmlTagType.SMALL.equals(tag.getType())) {\nreturn false;\n}\n\/\/ Check namespace\nInteger namespace = analysis.getPage().getNamespace();\nif ((namespace == null) || (namespace.intValue() == Namespace.TEMPLATE)) {\nreturn false;\n}\n\/\/ Go to the end of the last line\nString contents = analysis.getContents();\nint index = contents.length();\nwhile ((index > 0) && (contents.charAt(index - 1) == '\\n')) {\nindex--;\n}\nwhile ((index > 0) && (contents.charAt(index - 1) == ' ')) {\nindex--;\n}\nif (index == 0) {\nreturn false;\n}\n\/\/ Check if there's a tag at the end of the last line\nint lastIndex = index;\nPageElementTag lastTag = null;\nif (contents.charAt(index - 1) == '>') {\n\nprivate boolean analyzeLastLine(\nPageAnalysis analysis, PageElementTag tag,\nCollection<CheckErrorResult> errors) {\n\/\/ TODO: Refactor\n\/\/ Check type of tag\nif (!HtmlTagType.CENTER.equals(tag.getType()) &&\n!HtmlTagType.SMALL.equals(tag.getType())) {\nreturn false;\n}\n\/\/ Check namespace\nInteger namespace = analysis.getPage().getNamespace();\nif ((namespace == null) || (namespace.intValue() == Namespace.TEMPLATE)) {\nreturn false;\n}\n\/\/ Go to the end of the last line\nString contents = analysis.getContents();\nint index = contents.length();\nwhile ((index > 0) && (contents.charAt(index - 1) == '\\n')) {\nindex--;\n}\nwhile ((index > 0) && (contents.charAt(index - 1) == ' ')) {\nindex--;\n}\nif (index == 0) {\nreturn false;\n}\n\/\/ Check if there's a tag at the end of the last line\nint lastIndex = index;\nPageElementTag lastTag = null;\nif (contents.charAt(index - 1) == '>') {\nlastTag = analysis.isInTag(index - 1);\nif (lastTag != null) {\nindex = lastTag.getBeginIndex();\n}\n}\n\n!HtmlTagType.SMALL.equals(tag.getType())) {\nreturn false;\n}\n\/\/ Check namespace\nInteger namespace = analysis.getPage().getNamespace();\nif ((namespace == null) || (namespace.intValue() == Namespace.TEMPLATE)) {\nreturn false;\n}\n\/\/ Go to the end of the last line\nString contents = analysis.getContents();\nint index = contents.length();\nwhile ((index > 0) && (contents.charAt(index - 1) == '\\n')) {\nindex--;\n}\nwhile ((index > 0) && (contents.charAt(index - 1) == ' ')) {\nindex--;\n}\nif (index == 0) {\nreturn false;\n}\n\/\/ Check if there's a tag at the end of the last line\nint lastIndex = index;\nPageElementTag lastTag = null;\nif (contents.charAt(index - 1) == '>') {\nlastTag = analysis.isInTag(index - 1);\nif (lastTag != null) {\nindex = lastTag.getBeginIndex();\n}\n}\n\/\/ Check if the tag is in the last line\nint tagEndIndex = tag.getEndIndex();\nwhile ((index > tagEndIndex) && (contents.charAt(index - 1) != '\\n')) {\nindex--;\nif (contents.charAt(index) == '>') {\nif (analysis.isInTag(index - 1, tag.getType()) != null) {\nreturn false;\n}\n}\n}\nif (index > tagEndIndex) {\nreturn false;\n\nString contents = analysis.getContents();\nint index = contents.length();\nwhile ((index > 0) && (contents.charAt(index - 1) == '\\n')) {\nindex--;\n}\nwhile ((index > 0) && (contents.charAt(index - 1) == ' ')) {\nindex--;\n}\nif (index == 0) {\nreturn false;\n}\n\/\/ Check if there's a tag at the end of the last line\nint lastIndex = index;\nPageElementTag lastTag = null;\nif (contents.charAt(index - 1) == '>') {\nlastTag = analysis.isInTag(index - 1);\nif (lastTag != null) {\nindex = lastTag.getBeginIndex();\n}\n}\n\/\/ Check if the tag is in the last line\nint tagEndIndex = tag.getEndIndex();\nwhile ((index > tagEndIndex) && (contents.charAt(index - 1) != '\\n')) {\nindex--;\nif (contents.charAt(index) == '>') {\nif (analysis.isInTag(index - 1, tag.getType()) != null) {\nreturn false;\n}\n}\n}\nif (index > tagEndIndex) {\nreturn false;\n}\n\/\/ Check if there's an other opening tag before in the page\nList<PageElementTag> tags = analysis.getTags(tag.getType());\nboolean after = false;\nboolean hasOtherTagBefore = false;\nfor (PageElementTag otherTag : tags) {\nif (!after) {\nif (otherTag == tag) {\nafter = true;\n\nPageElementTag lastTag = null;\nif (contents.charAt(index - 1) == '>') {\nlastTag = analysis.isInTag(index - 1);\nif (lastTag != null) {\nindex = lastTag.getBeginIndex();\n}\n}\n\/\/ Check if the tag is in the last line\nint tagEndIndex = tag.getEndIndex();\nwhile ((index > tagEndIndex) && (contents.charAt(index - 1) != '\\n')) {\nindex--;\nif (contents.charAt(index) == '>') {\nif (analysis.isInTag(index - 1, tag.getType()) != null) {\nreturn false;\n}\n}\n}\nif (index > tagEndIndex) {\nreturn false;\n}\n\/\/ Check if there's an other opening tag before in the page\nList<PageElementTag> tags = analysis.getTags(tag.getType());\nboolean after = false;\nboolean hasOtherTagBefore = false;\nfor (PageElementTag otherTag : tags) {\nif (!after) {\nif (otherTag == tag) {\nafter = true;\n} else if (!otherTag.isComplete()) {\nhasOtherTagBefore = true;\n}\n}\n}\n\/\/ Decide what to do\nif (lastTag == tag) {\nCheckErrorResult errorResult = createCheckErrorResult(analysis, tag.getBeginIndex(), tag.getEndIndex());\nerrorResult.addReplacement(\"\");\nif (hasOtherTagBefore && (tag.getParametersCount() == 0)) {\nerrorResult.addReplacement(\nTagBuilder.from(tag.getName(), TagFormat.CLOSE).toString());\n}\n\nreturn false;\n}\n}\n}\nif (index > tagEndIndex) {\nreturn false;\n}\n\/\/ Check if there's an other opening tag before in the page\nList<PageElementTag> tags = analysis.getTags(tag.getType());\nboolean after = false;\nboolean hasOtherTagBefore = false;\nfor (PageElementTag otherTag : tags) {\nif (!after) {\nif (otherTag == tag) {\nafter = true;\n} else if (!otherTag.isComplete()) {\nhasOtherTagBefore = true;\n}\n}\n}\n\/\/ Decide what to do\nif (lastTag == tag) {\nCheckErrorResult errorResult = createCheckErrorResult(analysis, tag.getBeginIndex(), tag.getEndIndex());\nerrorResult.addReplacement(\"\");\nif (hasOtherTagBefore && (tag.getParametersCount() == 0)) {\nerrorResult.addReplacement(\nTagBuilder.from(tag.getName(), TagFormat.CLOSE).toString());\n}\nerrors.add(errorResult);\nreturn true;\n}\nif (lastTag != null) {\nCheckErrorResult errorResult = analyzeArea(\nanalysis, tag, lastTag.getBeginIndex(), tag.getEndIndex(),\n!hasOtherTagBefore, ActionAlone.ALONE_NOTHING);\nif (errorResult != null) {\nerrors.add(errorResult);\nreturn true;\n}\n} else {\nCheckErrorResult errorResult = analyzeArea(","label":[1,0,0,0]}
{"id":10562,"original_code":"@Override\n    public CFG createCFG() {\n        CFG cfg = new CFG(null);\n        BasicBlock start = new BasicBlock(\"PROGRAM-START\", BasicBlock.NOT_REDUCIBLE);\n        BasicBlock end = new BasicBlock(\"PROGRAM-END\", BasicBlock.REDUCIBLE_SINGLETON);\n        cfg.start = start;\n        cfg.end = end;\n        cfg.addVertex(start);\n        cfg.addVertex(end);\n        CFG firstCFG = body.get(0).createCFG();\n        cfg.addVertex(firstCFG.start);\n        cfg.addVertex(firstCFG.end);\n        cfg.addEdge(start, firstCFG.start);\n        BasicBlock prev = firstCFG.end;\n        \/\/ If there is only one node, then we would fall through the for loop, so\n        \/\/ we just copy over all nodes in the CFG here. TODO: Don't Copy Paste\n        if (body.size() == 1) {\n            firstCFG.vertexSet()\n                    .stream()\n                        .forEachOrdered(block ->\n                            firstCFG\n                                    .edgesOf(block)\n                                    .stream()\n                                    .forEachOrdered(edge -> {\n                                        BasicBlock src = firstCFG.getEdgeSource(edge);\n                                        BasicBlock tgt = firstCFG.getEdgeTarget(edge);\n                                        cfg.addVertex(src);\n                                        cfg.addVertex(tgt);\n                                        cfg.addEdge(src, tgt);\n                                    })\n                        );\n        }\n        for (ASTNode node : body.subList(1, body.size())) {\n            if (node instanceof IfConditionalASTNode) {\n                Logger.getAnonymousLogger().info(node.getClass().getName());\n            }\n            CFG stmtCFG = node.createCFG();\n            if (stmtCFG == null) { \n                continue;\n            }\n            cfg.addVertex(stmtCFG.start);\n            cfg.addVertex(stmtCFG.end);\n            cfg.addEdge(prev, stmtCFG.start);\n            Logger.getAnonymousLogger().info(stmtCFG.toString());\n            stmtCFG.vertexSet()\n                    .stream()\n                        .forEachOrdered(block ->\n                            stmtCFG\n                                    .edgesOf(block)\n                                    .stream()\n                                    .forEachOrdered(edge -> {\n                                        BasicBlock src = stmtCFG.getEdgeSource(edge);\n                                        BasicBlock tgt = stmtCFG.getEdgeTarget(edge);\n                                        if (node instanceof IfConditionalASTNode) {\n                                            Logger.getAnonymousLogger().info(\"Bridging Gap for: \" + src + \" and \" + tgt);\n                                        }\n                                        cfg.addVertex(src);\n                                        cfg.addVertex(tgt);\n                                        cfg.addEdge(src, tgt);\n                                    })\n                        );\n            prev = stmtCFG.end;\n        }\n        cfg.addEdge(prev, end);\n        removeTrivialNodes(cfg);\n        Logger.getAnonymousLogger().info(\"Reducing...\");\n        Set<BasicBlock> processed = new TreeSet<>();\n        reduceCFG(cfg, processed);\n\/\/        processed.clear();\n\/\/        reduceCFG(cfg, processed);\n        return cfg;                \n    }","code":"@Override\n    public CFG createCFG() {\n        CFG cfg = new CFG(null);\n        BasicBlock start = new BasicBlock(\"PROGRAM-START\", BasicBlock.NOT_REDUCIBLE);\n        BasicBlock end = new BasicBlock(\"PROGRAM-END\", BasicBlock.REDUCIBLE_SINGLETON);\n        cfg.start = start;\n        cfg.end = end;\n        cfg.addVertex(start);\n        cfg.addVertex(end);\n        CFG firstCFG = body.get(0).createCFG();\n        cfg.addVertex(firstCFG.start);\n        cfg.addVertex(firstCFG.end);\n        cfg.addEdge(start, firstCFG.start);\n        BasicBlock prev = firstCFG.end;\n       \n       \n        if (body.size() == 1) {\n            firstCFG.vertexSet()\n                    .stream()\n                        .forEachOrdered(block ->\n                            firstCFG\n                                    .edgesOf(block)\n                                    .stream()\n                                    .forEachOrdered(edge -> {\n                                        BasicBlock src = firstCFG.getEdgeSource(edge);\n                                        BasicBlock tgt = firstCFG.getEdgeTarget(edge);\n                                        cfg.addVertex(src);\n                                        cfg.addVertex(tgt);\n                                        cfg.addEdge(src, tgt);\n                                    })\n                        );\n        }\n        for (ASTNode node : body.subList(1, body.size())) {\n            if (node instanceof IfConditionalASTNode) {\n                Logger.getAnonymousLogger().info(node.getClass().getName());\n            }\n            CFG stmtCFG = node.createCFG();\n            if (stmtCFG == null) { \n                continue;\n            }\n            cfg.addVertex(stmtCFG.start);\n            cfg.addVertex(stmtCFG.end);\n            cfg.addEdge(prev, stmtCFG.start);\n            Logger.getAnonymousLogger().info(stmtCFG.toString());\n            stmtCFG.vertexSet()\n                    .stream()\n                        .forEachOrdered(block ->\n                            stmtCFG\n                                    .edgesOf(block)\n                                    .stream()\n                                    .forEachOrdered(edge -> {\n                                        BasicBlock src = stmtCFG.getEdgeSource(edge);\n                                        BasicBlock tgt = stmtCFG.getEdgeTarget(edge);\n                                        if (node instanceof IfConditionalASTNode) {\n                                            Logger.getAnonymousLogger().info(\"Bridging Gap for: \" + src + \" and \" + tgt);\n                                        }\n                                        cfg.addVertex(src);\n                                        cfg.addVertex(tgt);\n                                        cfg.addEdge(src, tgt);\n                                    })\n                        );\n            prev = stmtCFG.end;\n        }\n        cfg.addEdge(prev, end);\n        removeTrivialNodes(cfg);\n        Logger.getAnonymousLogger().info(\"Reducing...\");\n        Set<BasicBlock> processed = new TreeSet<>();\n        reduceCFG(cfg, processed);\n        return cfg;                \n    }","cleancode":"@override public cfg createcfg() { cfg cfg = new cfg(null); basicblock start = new basicblock(\"program-start\", basicblock.not_reducible); basicblock end = new basicblock(\"program-end\", basicblock.reducible_singleton); cfg.start = start; cfg.end = end; cfg.addvertex(start); cfg.addvertex(end); cfg firstcfg = body.get(0).createcfg(); cfg.addvertex(firstcfg.start); cfg.addvertex(firstcfg.end); cfg.addedge(start, firstcfg.start); basicblock prev = firstcfg.end; if (body.size() == 1) { firstcfg.vertexset() .stream() .foreachordered(block -> firstcfg .edgesof(block) .stream() .foreachordered(edge -> { basicblock src = firstcfg.getedgesource(edge); basicblock tgt = firstcfg.getedgetarget(edge); cfg.addvertex(src); cfg.addvertex(tgt); cfg.addedge(src, tgt); }) ); } for (astnode node : body.sublist(1, body.size())) { if (node instanceof ifconditionalastnode) { logger.getanonymouslogger().info(node.getclass().getname()); } cfg stmtcfg = node.createcfg(); if (stmtcfg == null) { continue; } cfg.addvertex(stmtcfg.start); cfg.addvertex(stmtcfg.end); cfg.addedge(prev, stmtcfg.start); logger.getanonymouslogger().info(stmtcfg.tostring()); stmtcfg.vertexset() .stream() .foreachordered(block -> stmtcfg .edgesof(block) .stream() .foreachordered(edge -> { basicblock src = stmtcfg.getedgesource(edge); basicblock tgt = stmtcfg.getedgetarget(edge); if (node instanceof ifconditionalastnode) { logger.getanonymouslogger().info(\"bridging gap for: \" + src + \" and \" + tgt); } cfg.addvertex(src); cfg.addvertex(tgt); cfg.addedge(src, tgt); }) ); prev = stmtcfg.end; } cfg.addedge(prev, end); removetrivialnodes(cfg); logger.getanonymouslogger().info(\"reducing...\"); set<basicblock> processed = new treeset<>(); reducecfg(cfg, processed); return cfg; }","comment":"\/\/ if there is only one node, then we would fall through the for loop, so \/\/ we just copy over all nodes in the cfg here. todo: don't copy paste\n\/\/ processed.clear(); \/\/ reducecfg(cfg, processed);","repo":"LouisJenkinsCS\/DSL","code_context_2":"cfg.addEdge(start, firstCFG.start);\nBasicBlock prev = firstCFG.end;\n\/\/ If there is only one node, then we would fall through the for loop, so\n\/\/ we just copy over all nodes in the CFG here. TODO: Don't Copy Paste\nif (body.size() == 1) {\nfirstCFG.vertexSet()\n\nSet<BasicBlock> processed = new TreeSet<>();\nreduceCFG(cfg, processed);\n\/\/ processed.clear();\n\/\/ reduceCFG(cfg, processed);\nreturn cfg;\n}","code_context_10":"BasicBlock end = new BasicBlock(\"PROGRAM-END\", BasicBlock.REDUCIBLE_SINGLETON);\ncfg.start = start;\ncfg.end = end;\ncfg.addVertex(start);\ncfg.addVertex(end);\nCFG firstCFG = body.get(0).createCFG();\ncfg.addVertex(firstCFG.start);\ncfg.addVertex(firstCFG.end);\ncfg.addEdge(start, firstCFG.start);\nBasicBlock prev = firstCFG.end;\n\/\/ If there is only one node, then we would fall through the for loop, so\n\/\/ we just copy over all nodes in the CFG here. TODO: Don't Copy Paste\nif (body.size() == 1) {\nfirstCFG.vertexSet()\n.stream()\n.forEachOrdered(block ->\nfirstCFG\n.edgesOf(block)\n.stream()\n.forEachOrdered(edge -> {\nBasicBlock src = firstCFG.getEdgeSource(edge);\nBasicBlock tgt = firstCFG.getEdgeTarget(edge);\n\ncfg.addEdge(src, tgt);\n})\n);\nprev = stmtCFG.end;\n}\ncfg.addEdge(prev, end);\nremoveTrivialNodes(cfg);\nLogger.getAnonymousLogger().info(\"Reducing...\");\nSet<BasicBlock> processed = new TreeSet<>();\nreduceCFG(cfg, processed);\n\/\/ processed.clear();\n\/\/ reduceCFG(cfg, processed);\nreturn cfg;\n}","code_context_20":"@Override\npublic CFG createCFG() {\nCFG cfg = new CFG(null);\nBasicBlock start = new BasicBlock(\"PROGRAM-START\", BasicBlock.NOT_REDUCIBLE);\nBasicBlock end = new BasicBlock(\"PROGRAM-END\", BasicBlock.REDUCIBLE_SINGLETON);\ncfg.start = start;\ncfg.end = end;\ncfg.addVertex(start);\ncfg.addVertex(end);\nCFG firstCFG = body.get(0).createCFG();\ncfg.addVertex(firstCFG.start);\ncfg.addVertex(firstCFG.end);\ncfg.addEdge(start, firstCFG.start);\nBasicBlock prev = firstCFG.end;\n\/\/ If there is only one node, then we would fall through the for loop, so\n\/\/ we just copy over all nodes in the CFG here. TODO: Don't Copy Paste\nif (body.size() == 1) {\nfirstCFG.vertexSet()\n.stream()\n.forEachOrdered(block ->\nfirstCFG\n.edgesOf(block)\n.stream()\n.forEachOrdered(edge -> {\nBasicBlock src = firstCFG.getEdgeSource(edge);\nBasicBlock tgt = firstCFG.getEdgeTarget(edge);\ncfg.addVertex(src);\ncfg.addVertex(tgt);\ncfg.addEdge(src, tgt);\n})\n);\n}\nfor (ASTNode node : body.subList(1, body.size())) {\nif (node instanceof IfConditionalASTNode) {\nLogger.getAnonymousLogger().info(node.getClass().getName());\n}\n\n.edgesOf(block)\n.stream()\n.forEachOrdered(edge -> {\nBasicBlock src = stmtCFG.getEdgeSource(edge);\nBasicBlock tgt = stmtCFG.getEdgeTarget(edge);\nif (node instanceof IfConditionalASTNode) {\nLogger.getAnonymousLogger().info(\"Bridging Gap for: \" + src + \" and \" + tgt);\n}\ncfg.addVertex(src);\ncfg.addVertex(tgt);\ncfg.addEdge(src, tgt);\n})\n);\nprev = stmtCFG.end;\n}\ncfg.addEdge(prev, end);\nremoveTrivialNodes(cfg);\nLogger.getAnonymousLogger().info(\"Reducing...\");\nSet<BasicBlock> processed = new TreeSet<>();\nreduceCFG(cfg, processed);\n\/\/ processed.clear();\n\/\/ reduceCFG(cfg, processed);\nreturn cfg;\n}","label":[1,0,0,0]}
{"id":2478,"original_code":"public boolean isHeld(IControllerEvent event) {\n  return activationMap.containsKey(event);\n }","code":"public boolean isHeld(IControllerEvent event) {\n  return activationMap.containsKey(event);\n }","cleancode":"public boolean isheld(icontrollerevent event) { return activationmap.containskey(event); }","comment":"\/**todo documentation * * @param event * @return *\/","repo":"Matthewacon\/mh4-hackathon","code_context_2":"public boolean isHeld(IControllerEvent event) {\nreturn activationMap.containsKey(event);\n}","code_context_10":"public boolean isHeld(IControllerEvent event) {\nreturn activationMap.containsKey(event);\n}","code_context_20":"public boolean isHeld(IControllerEvent event) {\nreturn activationMap.containsKey(event);\n}","label":[0,0,0,0]}
{"id":18874,"original_code":"public void setAir(final World world)\n    {\n        \/\/ TODO maybe see if there is a way to find the default \"air\" for this\n        \/\/ world\n        world.setBlockState(this.getPos(), Blocks.AIR.getDefaultState());\n    }","code":"public void setAir(final World world)\n    {\n       \n       \n        world.setBlockState(this.getPos(), Blocks.AIR.getDefaultState());\n    }","cleancode":"public void setair(final world world) { world.setblockstate(this.getpos(), blocks.air.getdefaultstate()); }","comment":"\/\/ todo maybe see if there is a way to find the default \"air\" for this \/\/ world","repo":"MetaltyrantMk2\/Pokecube-Issues-and-Wiki","code_context_2":"public void setAir(final World world)\n{\n\/\/ TODO maybe see if there is a way to find the default \"air\" for this\n\/\/ world\nworld.setBlockState(this.getPos(), Blocks.AIR.getDefaultState());\n}","code_context_10":"public void setAir(final World world)\n{\n\/\/ TODO maybe see if there is a way to find the default \"air\" for this\n\/\/ world\nworld.setBlockState(this.getPos(), Blocks.AIR.getDefaultState());\n}","code_context_20":"public void setAir(final World world)\n{\n\/\/ TODO maybe see if there is a way to find the default \"air\" for this\n\/\/ world\nworld.setBlockState(this.getPos(), Blocks.AIR.getDefaultState());\n}","label":[1,0,0,0]}
{"id":2498,"original_code":"@PluginMethod\n    public void writeFile(PluginCall call) {\n        String path = call.getString(\"path\");\n        String data = call.getString(\"data\");\n        Boolean recursive = call.getBoolean(\"recursive\", false);\n        if (path == null) {\n            Logger.error(getLogTag(), \"No path or filename retrieved from call\", null);\n            call.reject(\"NO_PATH\");\n            return;\n        }\n        if (data == null) {\n            Logger.error(getLogTag(), \"No data retrieved from call\", null);\n            call.reject(\"NO_DATA\");\n            return;\n        }\n        String directory = getDirectoryParameter(call);\n        if (directory != null) {\n            if (isPublicDirectory(directory) && !isStoragePermissionGranted()) {\n                requestAllPermissions(call, \"permissionCallback\");\n            } else {\n                \/\/ create directory because it might not exist\n                File androidDir = implementation.getDirectory(directory);\n                if (androidDir != null) {\n                    if (androidDir.exists() || androidDir.mkdirs()) {\n                        \/\/ path might include directories as well\n                        File fileObject = new File(androidDir, path);\n                        if (fileObject.getParentFile().exists() || (recursive && fileObject.getParentFile().mkdirs())) {\n                            saveFile(call, fileObject, data);\n                        } else {\n                            call.reject(\"Parent folder doesn't exist\");\n                        }\n                    } else {\n                        Logger.error(getLogTag(), \"Not able to create '\" + directory + \"'!\", null);\n                        call.reject(\"NOT_CREATED_DIR\");\n                    }\n                } else {\n                    Logger.error(getLogTag(), \"Directory ID '\" + directory + \"' is not supported by plugin\", null);\n                    call.reject(\"INVALID_DIR\");\n                }\n            }\n        } else {\n            \/\/ check file:\/\/ or no scheme uris\n            Uri u = Uri.parse(path);\n            if (u.getScheme() == null || u.getScheme().equals(\"file\")) {\n                File fileObject = new File(u.getPath());\n                \/\/ do not know where the file is being store so checking the permission to be secure\n                \/\/ TODO to prevent permission checking we need a property from the call\n                if (!isStoragePermissionGranted()) {\n                    requestAllPermissions(call, \"permissionCallback\");\n                } else {\n                    if (\n                        fileObject.getParentFile() == null ||\n                        fileObject.getParentFile().exists() ||\n                        (recursive && fileObject.getParentFile().mkdirs())\n                    ) {\n                        saveFile(call, fileObject, data);\n                    } else {\n                        call.reject(\"Parent folder doesn't exist\");\n                    }\n                }\n            } else {\n                call.reject(u.getScheme() + \" scheme not supported\");\n            }\n        }\n    }","code":"@PluginMethod\n    public void writeFile(PluginCall call) {\n        String path = call.getString(\"path\");\n        String data = call.getString(\"data\");\n        Boolean recursive = call.getBoolean(\"recursive\", false);\n        if (path == null) {\n            Logger.error(getLogTag(), \"No path or filename retrieved from call\", null);\n            call.reject(\"NO_PATH\");\n            return;\n        }\n        if (data == null) {\n            Logger.error(getLogTag(), \"No data retrieved from call\", null);\n            call.reject(\"NO_DATA\");\n            return;\n        }\n        String directory = getDirectoryParameter(call);\n        if (directory != null) {\n            if (isPublicDirectory(directory) && !isStoragePermissionGranted()) {\n                requestAllPermissions(call, \"permissionCallback\");\n            } else {\n               \n                File androidDir = implementation.getDirectory(directory);\n                if (androidDir != null) {\n                    if (androidDir.exists() || androidDir.mkdirs()) {\n                       \n                        File fileObject = new File(androidDir, path);\n                        if (fileObject.getParentFile().exists() || (recursive && fileObject.getParentFile().mkdirs())) {\n                            saveFile(call, fileObject, data);\n                        } else {\n                            call.reject(\"Parent folder doesn't exist\");\n                        }\n                    } else {\n                        Logger.error(getLogTag(), \"Not able to create '\" + directory + \"'!\", null);\n                        call.reject(\"NOT_CREATED_DIR\");\n                    }\n                } else {\n                    Logger.error(getLogTag(), \"Directory ID '\" + directory + \"' is not supported by plugin\", null);\n                    call.reject(\"INVALID_DIR\");\n                }\n            }\n        } else {\n           \n            Uri u = Uri.parse(path);\n            if (u.getScheme() == null || u.getScheme().equals(\"file\")) {\n                File fileObject = new File(u.getPath());\n               \n               \n                if (!isStoragePermissionGranted()) {\n                    requestAllPermissions(call, \"permissionCallback\");\n                } else {\n                    if (\n                        fileObject.getParentFile() == null ||\n                        fileObject.getParentFile().exists() ||\n                        (recursive && fileObject.getParentFile().mkdirs())\n                    ) {\n                        saveFile(call, fileObject, data);\n                    } else {\n                        call.reject(\"Parent folder doesn't exist\");\n                    }\n                }\n            } else {\n                call.reject(u.getScheme() + \" scheme not supported\");\n            }\n        }\n    }","cleancode":"@pluginmethod public void writefile(plugincall call) { string path = call.getstring(\"path\"); string data = call.getstring(\"data\"); boolean recursive = call.getboolean(\"recursive\", false); if (path == null) { logger.error(getlogtag(), \"no path or filename retrieved from call\", null); call.reject(\"no_path\"); return; } if (data == null) { logger.error(getlogtag(), \"no data retrieved from call\", null); call.reject(\"no_data\"); return; } string directory = getdirectoryparameter(call); if (directory != null) { if (ispublicdirectory(directory) && !isstoragepermissiongranted()) { requestallpermissions(call, \"permissioncallback\"); } else { file androiddir = implementation.getdirectory(directory); if (androiddir != null) { if (androiddir.exists() || androiddir.mkdirs()) { file fileobject = new file(androiddir, path); if (fileobject.getparentfile().exists() || (recursive && fileobject.getparentfile().mkdirs())) { savefile(call, fileobject, data); } else { call.reject(\"parent folder doesn't exist\"); } } else { logger.error(getlogtag(), \"not able to create '\" + directory + \"'!\", null); call.reject(\"not_created_dir\"); } } else { logger.error(getlogtag(), \"directory id '\" + directory + \"' is not supported by plugin\", null); call.reject(\"invalid_dir\"); } } } else { uri u = uri.parse(path); if (u.getscheme() == null || u.getscheme().equals(\"file\")) { file fileobject = new file(u.getpath()); if (!isstoragepermissiongranted()) { requestallpermissions(call, \"permissioncallback\"); } else { if ( fileobject.getparentfile() == null || fileobject.getparentfile().exists() || (recursive && fileobject.getparentfile().mkdirs()) ) { savefile(call, fileobject, data); } else { call.reject(\"parent folder doesn't exist\"); } } } else { call.reject(u.getscheme() + \" scheme not supported\"); } } }","comment":"\/\/ create directory because it might not exist\n\/\/ path might include directories as well\n\/\/ check file:\/\/ or no scheme uris\n\/\/ do not know where the file is being store so checking the permission to be secure \/\/ todo to prevent permission checking we need a property from the call","repo":"RetoeGo\/Stuby","code_context_2":"requestAllPermissions(call, \"permissionCallback\");\n} else {\n\/\/ create directory because it might not exist\nFile androidDir = implementation.getDirectory(directory);\nif (androidDir != null) {\n\nif (androidDir != null) {\nif (androidDir.exists() || androidDir.mkdirs()) {\n\/\/ path might include directories as well\nFile fileObject = new File(androidDir, path);\nif (fileObject.getParentFile().exists() || (recursive && fileObject.getParentFile().mkdirs())) {\n\n}\n} else {\n\/\/ check file:\/\/ or no scheme uris\nUri u = Uri.parse(path);\nif (u.getScheme() == null || u.getScheme().equals(\"file\")) {\n\nif (u.getScheme() == null || u.getScheme().equals(\"file\")) {\nFile fileObject = new File(u.getPath());\n\/\/ do not know where the file is being store so checking the permission to be secure\n\/\/ TODO to prevent permission checking we need a property from the call\nif (!isStoragePermissionGranted()) {\nrequestAllPermissions(call, \"permissionCallback\");","code_context_10":"if (data == null) {\nLogger.error(getLogTag(), \"No data retrieved from call\", null);\ncall.reject(\"NO_DATA\");\nreturn;\n}\nString directory = getDirectoryParameter(call);\nif (directory != null) {\nif (isPublicDirectory(directory) && !isStoragePermissionGranted()) {\nrequestAllPermissions(call, \"permissionCallback\");\n} else {\n\/\/ create directory because it might not exist\nFile androidDir = implementation.getDirectory(directory);\nif (androidDir != null) {\nif (androidDir.exists() || androidDir.mkdirs()) {\n\/\/ path might include directories as well\nFile fileObject = new File(androidDir, path);\nif (fileObject.getParentFile().exists() || (recursive && fileObject.getParentFile().mkdirs())) {\nsaveFile(call, fileObject, data);\n} else {\ncall.reject(\"Parent folder doesn't exist\");\n}\n\n}\nString directory = getDirectoryParameter(call);\nif (directory != null) {\nif (isPublicDirectory(directory) && !isStoragePermissionGranted()) {\nrequestAllPermissions(call, \"permissionCallback\");\n} else {\n\/\/ create directory because it might not exist\nFile androidDir = implementation.getDirectory(directory);\nif (androidDir != null) {\nif (androidDir.exists() || androidDir.mkdirs()) {\n\/\/ path might include directories as well\nFile fileObject = new File(androidDir, path);\nif (fileObject.getParentFile().exists() || (recursive && fileObject.getParentFile().mkdirs())) {\nsaveFile(call, fileObject, data);\n} else {\ncall.reject(\"Parent folder doesn't exist\");\n}\n} else {\nLogger.error(getLogTag(), \"Not able to create '\" + directory + \"'!\", null);\ncall.reject(\"NOT_CREATED_DIR\");\n}\n\n} else {\nLogger.error(getLogTag(), \"Not able to create '\" + directory + \"'!\", null);\ncall.reject(\"NOT_CREATED_DIR\");\n}\n} else {\nLogger.error(getLogTag(), \"Directory ID '\" + directory + \"' is not supported by plugin\", null);\ncall.reject(\"INVALID_DIR\");\n}\n}\n} else {\n\/\/ check file:\/\/ or no scheme uris\nUri u = Uri.parse(path);\nif (u.getScheme() == null || u.getScheme().equals(\"file\")) {\nFile fileObject = new File(u.getPath());\n\/\/ do not know where the file is being store so checking the permission to be secure\n\/\/ TODO to prevent permission checking we need a property from the call\nif (!isStoragePermissionGranted()) {\nrequestAllPermissions(call, \"permissionCallback\");\n} else {\nif (\nfileObject.getParentFile() == null ||\n\n} else {\nLogger.error(getLogTag(), \"Directory ID '\" + directory + \"' is not supported by plugin\", null);\ncall.reject(\"INVALID_DIR\");\n}\n}\n} else {\n\/\/ check file:\/\/ or no scheme uris\nUri u = Uri.parse(path);\nif (u.getScheme() == null || u.getScheme().equals(\"file\")) {\nFile fileObject = new File(u.getPath());\n\/\/ do not know where the file is being store so checking the permission to be secure\n\/\/ TODO to prevent permission checking we need a property from the call\nif (!isStoragePermissionGranted()) {\nrequestAllPermissions(call, \"permissionCallback\");\n} else {\nif (\nfileObject.getParentFile() == null ||\nfileObject.getParentFile().exists() ||\n(recursive && fileObject.getParentFile().mkdirs())\n) {\nsaveFile(call, fileObject, data);\n} else {","code_context_20":"@PluginMethod\npublic void writeFile(PluginCall call) {\nString path = call.getString(\"path\");\nString data = call.getString(\"data\");\nBoolean recursive = call.getBoolean(\"recursive\", false);\nif (path == null) {\nLogger.error(getLogTag(), \"No path or filename retrieved from call\", null);\ncall.reject(\"NO_PATH\");\nreturn;\n}\nif (data == null) {\nLogger.error(getLogTag(), \"No data retrieved from call\", null);\ncall.reject(\"NO_DATA\");\nreturn;\n}\nString directory = getDirectoryParameter(call);\nif (directory != null) {\nif (isPublicDirectory(directory) && !isStoragePermissionGranted()) {\nrequestAllPermissions(call, \"permissionCallback\");\n} else {\n\/\/ create directory because it might not exist\nFile androidDir = implementation.getDirectory(directory);\nif (androidDir != null) {\nif (androidDir.exists() || androidDir.mkdirs()) {\n\/\/ path might include directories as well\nFile fileObject = new File(androidDir, path);\nif (fileObject.getParentFile().exists() || (recursive && fileObject.getParentFile().mkdirs())) {\nsaveFile(call, fileObject, data);\n} else {\ncall.reject(\"Parent folder doesn't exist\");\n}\n} else {\nLogger.error(getLogTag(), \"Not able to create '\" + directory + \"'!\", null);\ncall.reject(\"NOT_CREATED_DIR\");\n}\n} else {\nLogger.error(getLogTag(), \"Directory ID '\" + directory + \"' is not supported by plugin\", null);\ncall.reject(\"INVALID_DIR\");\n}\n}\n} else {\n\nBoolean recursive = call.getBoolean(\"recursive\", false);\nif (path == null) {\nLogger.error(getLogTag(), \"No path or filename retrieved from call\", null);\ncall.reject(\"NO_PATH\");\nreturn;\n}\nif (data == null) {\nLogger.error(getLogTag(), \"No data retrieved from call\", null);\ncall.reject(\"NO_DATA\");\nreturn;\n}\nString directory = getDirectoryParameter(call);\nif (directory != null) {\nif (isPublicDirectory(directory) && !isStoragePermissionGranted()) {\nrequestAllPermissions(call, \"permissionCallback\");\n} else {\n\/\/ create directory because it might not exist\nFile androidDir = implementation.getDirectory(directory);\nif (androidDir != null) {\nif (androidDir.exists() || androidDir.mkdirs()) {\n\/\/ path might include directories as well\nFile fileObject = new File(androidDir, path);\nif (fileObject.getParentFile().exists() || (recursive && fileObject.getParentFile().mkdirs())) {\nsaveFile(call, fileObject, data);\n} else {\ncall.reject(\"Parent folder doesn't exist\");\n}\n} else {\nLogger.error(getLogTag(), \"Not able to create '\" + directory + \"'!\", null);\ncall.reject(\"NOT_CREATED_DIR\");\n}\n} else {\nLogger.error(getLogTag(), \"Directory ID '\" + directory + \"' is not supported by plugin\", null);\ncall.reject(\"INVALID_DIR\");\n}\n}\n} else {\n\/\/ check file:\/\/ or no scheme uris\nUri u = Uri.parse(path);\nif (u.getScheme() == null || u.getScheme().equals(\"file\")) {\nFile fileObject = new File(u.getPath());\n\nFile androidDir = implementation.getDirectory(directory);\nif (androidDir != null) {\nif (androidDir.exists() || androidDir.mkdirs()) {\n\/\/ path might include directories as well\nFile fileObject = new File(androidDir, path);\nif (fileObject.getParentFile().exists() || (recursive && fileObject.getParentFile().mkdirs())) {\nsaveFile(call, fileObject, data);\n} else {\ncall.reject(\"Parent folder doesn't exist\");\n}\n} else {\nLogger.error(getLogTag(), \"Not able to create '\" + directory + \"'!\", null);\ncall.reject(\"NOT_CREATED_DIR\");\n}\n} else {\nLogger.error(getLogTag(), \"Directory ID '\" + directory + \"' is not supported by plugin\", null);\ncall.reject(\"INVALID_DIR\");\n}\n}\n} else {\n\/\/ check file:\/\/ or no scheme uris\nUri u = Uri.parse(path);\nif (u.getScheme() == null || u.getScheme().equals(\"file\")) {\nFile fileObject = new File(u.getPath());\n\/\/ do not know where the file is being store so checking the permission to be secure\n\/\/ TODO to prevent permission checking we need a property from the call\nif (!isStoragePermissionGranted()) {\nrequestAllPermissions(call, \"permissionCallback\");\n} else {\nif (\nfileObject.getParentFile() == null ||\nfileObject.getParentFile().exists() ||\n(recursive && fileObject.getParentFile().mkdirs())\n) {\nsaveFile(call, fileObject, data);\n} else {\ncall.reject(\"Parent folder doesn't exist\");\n}\n}\n} else {\ncall.reject(u.getScheme() + \" scheme not supported\");\n\nFile fileObject = new File(androidDir, path);\nif (fileObject.getParentFile().exists() || (recursive && fileObject.getParentFile().mkdirs())) {\nsaveFile(call, fileObject, data);\n} else {\ncall.reject(\"Parent folder doesn't exist\");\n}\n} else {\nLogger.error(getLogTag(), \"Not able to create '\" + directory + \"'!\", null);\ncall.reject(\"NOT_CREATED_DIR\");\n}\n} else {\nLogger.error(getLogTag(), \"Directory ID '\" + directory + \"' is not supported by plugin\", null);\ncall.reject(\"INVALID_DIR\");\n}\n}\n} else {\n\/\/ check file:\/\/ or no scheme uris\nUri u = Uri.parse(path);\nif (u.getScheme() == null || u.getScheme().equals(\"file\")) {\nFile fileObject = new File(u.getPath());\n\/\/ do not know where the file is being store so checking the permission to be secure\n\/\/ TODO to prevent permission checking we need a property from the call\nif (!isStoragePermissionGranted()) {\nrequestAllPermissions(call, \"permissionCallback\");\n} else {\nif (\nfileObject.getParentFile() == null ||\nfileObject.getParentFile().exists() ||\n(recursive && fileObject.getParentFile().mkdirs())\n) {\nsaveFile(call, fileObject, data);\n} else {\ncall.reject(\"Parent folder doesn't exist\");\n}\n}\n} else {\ncall.reject(u.getScheme() + \" scheme not supported\");\n}\n}\n}","label":[1,0,0,0]}
{"id":2512,"original_code":"public MyPair<List<List<FpgaInternalMove>>,List<MyPair<FpgaInternalState,List<FpgaInternalMove>>>> getNextStates(FpgaInternalState state){\n\t\tif(this.theMachine.isTerminal(state.getCompactMachineState())) {\n\t\t\treturn null;\n\t\t}\n\t\t\/\/ Retrieve all legal moves\n\t\tList<List<CompactMove>> movesForAllRoles;\n\t\ttry {\n\t\t\tmovesForAllRoles = this.theMachine.getAllLegalMoves(state.getCompactMachineState());\n\t\t} catch (MoveDefinitionException e) {\n\t\t\tGamerLogger.logError(\"StateMachine\", \"[FakeFPGALibrary] Error when getting all legal moves!\");\n\t\t\tthrow new RuntimeException(\"StateMachine - [FakeFPGALibrary] Error when getting all legal moves!\");\n\t\t}\n\t\tList<List<FpgaInternalMove>> internalMovesForAllRoles = new ArrayList<List<FpgaInternalMove>>();\n\t\tfor(List<CompactMove> movesForOneRole : movesForAllRoles) {\n\t\t\tList<FpgaInternalMove> internalMovesForOneRole = new ArrayList<FpgaInternalMove>();\n\t\t\tfor(CompactMove move : movesForOneRole) {\n\t\t\t\tinternalMovesForOneRole.add(new FpgaInternalMove(move));\n\t\t\t}\n\t\t\tinternalMovesForAllRoles.add(internalMovesForOneRole);\n\t\t}\n\t\t\/\/ Retrieve all joint moves and next states\n\t\tList<List<CompactMove>> allJointMoves;\n\t\ttry {\n\t\t\tallJointMoves = this.theMachine.getLegalJointMoves(state.getCompactMachineState());\n\t\t} catch (MoveDefinitionException | StateMachineException e) {\n\t\t\tGamerLogger.logError(\"StateMachine\", \"[FakeFPGALibrary] Error when getting all legal joint moves!\");\n\t\t\tthrow new RuntimeException(\"StateMachine - [FakeFPGALibrary] Error when getting all legal joint moves!\");\n\t\t}\n\t\tList<MyPair<FpgaInternalState,List<FpgaInternalMove>>> internalJointMovesAndNextStates = new ArrayList<MyPair<FpgaInternalState,List<FpgaInternalMove>>>();\n\t\tCompactMachineState nextState;\n\t\tif(allJointMoves == null) {\n\t\t\tSystem.out.println(\"Null joint moves\");\n\t\t}\n\t\tfor(List<CompactMove> jointMove : allJointMoves) {\n\t\t\tnextState = this.theMachine.getCompactNextState(state.getCompactMachineState(), jointMove);\n\t\t\tList<FpgaInternalMove> internalJointMove = new ArrayList<FpgaInternalMove>();\n\t\t\tfor(CompactMove move : jointMove) {\n\t\t\t\tinternalJointMove.add(new FpgaInternalMove(move));\n\t\t\t}\n\t\t\tinternalJointMovesAndNextStates.add(new MyPair<FpgaInternalState,List<FpgaInternalMove>>(new FpgaInternalState(nextState), internalJointMove));\n\t\t}\n\t\treturn new MyPair<List<List<FpgaInternalMove>>,List<MyPair<FpgaInternalState,List<FpgaInternalMove>>>>(internalMovesForAllRoles, internalJointMovesAndNextStates);\n\t}","code":"public MyPair<List<List<FpgaInternalMove>>,List<MyPair<FpgaInternalState,List<FpgaInternalMove>>>> getNextStates(FpgaInternalState state){\n\t\tif(this.theMachine.isTerminal(state.getCompactMachineState())) {\n\t\t\treturn null;\n\t\t}\n\t\n\t\tList<List<CompactMove>> movesForAllRoles;\n\t\ttry {\n\t\t\tmovesForAllRoles = this.theMachine.getAllLegalMoves(state.getCompactMachineState());\n\t\t} catch (MoveDefinitionException e) {\n\t\t\tGamerLogger.logError(\"StateMachine\", \"[FakeFPGALibrary] Error when getting all legal moves!\");\n\t\t\tthrow new RuntimeException(\"StateMachine - [FakeFPGALibrary] Error when getting all legal moves!\");\n\t\t}\n\t\tList<List<FpgaInternalMove>> internalMovesForAllRoles = new ArrayList<List<FpgaInternalMove>>();\n\t\tfor(List<CompactMove> movesForOneRole : movesForAllRoles) {\n\t\t\tList<FpgaInternalMove> internalMovesForOneRole = new ArrayList<FpgaInternalMove>();\n\t\t\tfor(CompactMove move : movesForOneRole) {\n\t\t\t\tinternalMovesForOneRole.add(new FpgaInternalMove(move));\n\t\t\t}\n\t\t\tinternalMovesForAllRoles.add(internalMovesForOneRole);\n\t\t}\n\t\n\t\tList<List<CompactMove>> allJointMoves;\n\t\ttry {\n\t\t\tallJointMoves = this.theMachine.getLegalJointMoves(state.getCompactMachineState());\n\t\t} catch (MoveDefinitionException | StateMachineException e) {\n\t\t\tGamerLogger.logError(\"StateMachine\", \"[FakeFPGALibrary] Error when getting all legal joint moves!\");\n\t\t\tthrow new RuntimeException(\"StateMachine - [FakeFPGALibrary] Error when getting all legal joint moves!\");\n\t\t}\n\t\tList<MyPair<FpgaInternalState,List<FpgaInternalMove>>> internalJointMovesAndNextStates = new ArrayList<MyPair<FpgaInternalState,List<FpgaInternalMove>>>();\n\t\tCompactMachineState nextState;\n\t\tif(allJointMoves == null) {\n\t\t\tSystem.out.println(\"Null joint moves\");\n\t\t}\n\t\tfor(List<CompactMove> jointMove : allJointMoves) {\n\t\t\tnextState = this.theMachine.getCompactNextState(state.getCompactMachineState(), jointMove);\n\t\t\tList<FpgaInternalMove> internalJointMove = new ArrayList<FpgaInternalMove>();\n\t\t\tfor(CompactMove move : jointMove) {\n\t\t\t\tinternalJointMove.add(new FpgaInternalMove(move));\n\t\t\t}\n\t\t\tinternalJointMovesAndNextStates.add(new MyPair<FpgaInternalState,List<FpgaInternalMove>>(new FpgaInternalState(nextState), internalJointMove));\n\t\t}\n\t\treturn new MyPair<List<List<FpgaInternalMove>>,List<MyPair<FpgaInternalState,List<FpgaInternalMove>>>>(internalMovesForAllRoles, internalJointMovesAndNextStates);\n\t}","cleancode":"public mypair<list<list<fpgainternalmove>>,list<mypair<fpgainternalstate,list<fpgainternalmove>>>> getnextstates(fpgainternalstate state){ if(this.themachine.isterminal(state.getcompactmachinestate())) { return null; } list<list<compactmove>> movesforallroles; try { movesforallroles = this.themachine.getalllegalmoves(state.getcompactmachinestate()); } catch (movedefinitionexception e) { gamerlogger.logerror(\"statemachine\", \"[fakefpgalibrary] error when getting all legal moves!\"); throw new runtimeexception(\"statemachine - [fakefpgalibrary] error when getting all legal moves!\"); } list<list<fpgainternalmove>> internalmovesforallroles = new arraylist<list<fpgainternalmove>>(); for(list<compactmove> movesforonerole : movesforallroles) { list<fpgainternalmove> internalmovesforonerole = new arraylist<fpgainternalmove>(); for(compactmove move : movesforonerole) { internalmovesforonerole.add(new fpgainternalmove(move)); } internalmovesforallroles.add(internalmovesforonerole); } list<list<compactmove>> alljointmoves; try { alljointmoves = this.themachine.getlegaljointmoves(state.getcompactmachinestate()); } catch (movedefinitionexception | statemachineexception e) { gamerlogger.logerror(\"statemachine\", \"[fakefpgalibrary] error when getting all legal joint moves!\"); throw new runtimeexception(\"statemachine - [fakefpgalibrary] error when getting all legal joint moves!\"); } list<mypair<fpgainternalstate,list<fpgainternalmove>>> internaljointmovesandnextstates = new arraylist<mypair<fpgainternalstate,list<fpgainternalmove>>>(); compactmachinestate nextstate; if(alljointmoves == null) { system.out.println(\"null joint moves\"); } for(list<compactmove> jointmove : alljointmoves) { nextstate = this.themachine.getcompactnextstate(state.getcompactmachinestate(), jointmove); list<fpgainternalmove> internaljointmove = new arraylist<fpgainternalmove>(); for(compactmove move : jointmove) { internaljointmove.add(new fpgainternalmove(move)); } internaljointmovesandnextstates.add(new mypair<fpgainternalstate,list<fpgainternalmove>>(new fpgainternalstate(nextstate), internaljointmove)); } return new mypair<list<list<fpgainternalmove>>,list<mypair<fpgainternalstate,list<fpgainternalmove>>>>(internalmovesforallroles, internaljointmovesandnextstates); }","comment":"\/** * given a state, this function returns all states reachable from this state. each next state is * paired with the list of moves (one for each role in the game) that lead to the next state. * * whenever i call this method i assume that the moves for the roles are returned always with the * same role order. * * @param state * @return a list of lists of legal moves, one for each role, and all states reachable from the * given state, each of which is paired with the list of moves (one for each role in the game) * that lead to the next state. * * ? what does this method return if the state is terminal? * for now assuming it returns null. *\/\n\/\/ retrieve all legal moves\n\/\/ retrieve all joint moves and next states","repo":"Lucsparidans\/GGP-Project","code_context_2":"public MyPair<List<List<FpgaInternalMove>>,List<MyPair<FpgaInternalState,List<FpgaInternalMove>>>> getNextStates(FpgaInternalState state){\nif(this.theMachine.isTerminal(state.getCompactMachineState())) {\nreturn null;\n}\n\/\/ Retrieve all legal moves\nList<List<CompactMove>> movesForAllRoles;\ntry {\nmovesForAllRoles = this.theMachine.getAllLegalMoves(state.getCompactMachineState());\n} catch (MoveDefinitionException e) {\nGamerLogger.logError(\"StateMachine\", \"[FakeFPGALibrary] Error when getting all legal moves!\");\nthrow new RuntimeException(\"StateMachine - [FakeFPGALibrary] Error when getting all legal moves!\");\n}\nList<List<FpgaInternalMove>> internalMovesForAllRoles = new ArrayList<List<FpgaInternalMove>>();\nfor(List<CompactMove> movesForOneRole : movesForAllRoles) {\nList<FpgaInternalMove> internalMovesForOneRole = new ArrayList<FpgaInternalMove>();\nfor(CompactMove move : movesForOneRole) {\ninternalMovesForOneRole.add(new FpgaInternalMove(move));\n}\ninternalMovesForAllRoles.add(internalMovesForOneRole);\n}\n\/\/ Retrieve all joint moves and next states\nList<List<CompactMove>> allJointMoves;\ntry {\nallJointMoves = this.theMachine.getLegalJointMoves(state.getCompactMachineState());\n} catch (MoveDefinitionException | StateMachineException e) {\nGamerLogger.logError(\"StateMachine\", \"[FakeFPGALibrary] Error when getting all legal joint moves!\");\nthrow new RuntimeException(\"StateMachine - [FakeFPGALibrary] Error when getting all legal joint moves!\");\n}\nList<MyPair<FpgaInternalState,List<FpgaInternalMove>>> internalJointMovesAndNextStates = new ArrayList<MyPair<FpgaInternalState,List<FpgaInternalMove>>>();\nCompactMachineState nextState;\nif(allJointMoves == null) {\nSystem.out.println(\"Null joint moves\");\n}\nfor(List<CompactMove> jointMove : allJointMoves) {\nnextState = this.theMachine.getCompactNextState(state.getCompactMachineState(), jointMove);\nList<FpgaInternalMove> internalJointMove = new ArrayList<FpgaInternalMove>();\nfor(CompactMove move : jointMove) {\ninternalJointMove.add(new FpgaInternalMove(move));\n}\ninternalJointMovesAndNextStates.add(new MyPair<FpgaInternalState,List<FpgaInternalMove>>(new FpgaInternalState(nextState), internalJointMove));\n}\nreturn new MyPair<List<List<FpgaInternalMove>>,List<MyPair<FpgaInternalState,List<FpgaInternalMove>>>>(internalMovesForAllRoles, internalJointMovesAndNextStates);\n}\n\nreturn null;\n}\n\/\/ Retrieve all legal moves\nList<List<CompactMove>> movesForAllRoles;\ntry {\n\ninternalMovesForAllRoles.add(internalMovesForOneRole);\n}\n\/\/ Retrieve all joint moves and next states\nList<List<CompactMove>> allJointMoves;\ntry {","code_context_10":"public MyPair<List<List<FpgaInternalMove>>,List<MyPair<FpgaInternalState,List<FpgaInternalMove>>>> getNextStates(FpgaInternalState state){\nif(this.theMachine.isTerminal(state.getCompactMachineState())) {\nreturn null;\n}\n\/\/ Retrieve all legal moves\nList<List<CompactMove>> movesForAllRoles;\ntry {\nmovesForAllRoles = this.theMachine.getAllLegalMoves(state.getCompactMachineState());\n} catch (MoveDefinitionException e) {\nGamerLogger.logError(\"StateMachine\", \"[FakeFPGALibrary] Error when getting all legal moves!\");\nthrow new RuntimeException(\"StateMachine - [FakeFPGALibrary] Error when getting all legal moves!\");\n}\nList<List<FpgaInternalMove>> internalMovesForAllRoles = new ArrayList<List<FpgaInternalMove>>();\nfor(List<CompactMove> movesForOneRole : movesForAllRoles) {\nList<FpgaInternalMove> internalMovesForOneRole = new ArrayList<FpgaInternalMove>();\nfor(CompactMove move : movesForOneRole) {\ninternalMovesForOneRole.add(new FpgaInternalMove(move));\n}\ninternalMovesForAllRoles.add(internalMovesForOneRole);\n}\n\/\/ Retrieve all joint moves and next states\nList<List<CompactMove>> allJointMoves;\ntry {\nallJointMoves = this.theMachine.getLegalJointMoves(state.getCompactMachineState());\n} catch (MoveDefinitionException | StateMachineException e) {\nGamerLogger.logError(\"StateMachine\", \"[FakeFPGALibrary] Error when getting all legal joint moves!\");\nthrow new RuntimeException(\"StateMachine - [FakeFPGALibrary] Error when getting all legal joint moves!\");\n}\nList<MyPair<FpgaInternalState,List<FpgaInternalMove>>> internalJointMovesAndNextStates = new ArrayList<MyPair<FpgaInternalState,List<FpgaInternalMove>>>();\nCompactMachineState nextState;\nif(allJointMoves == null) {\nSystem.out.println(\"Null joint moves\");\n}\nfor(List<CompactMove> jointMove : allJointMoves) {\nnextState = this.theMachine.getCompactNextState(state.getCompactMachineState(), jointMove);\nList<FpgaInternalMove> internalJointMove = new ArrayList<FpgaInternalMove>();\nfor(CompactMove move : jointMove) {\ninternalJointMove.add(new FpgaInternalMove(move));\n}\ninternalJointMovesAndNextStates.add(new MyPair<FpgaInternalState,List<FpgaInternalMove>>(new FpgaInternalState(nextState), internalJointMove));\n}\nreturn new MyPair<List<List<FpgaInternalMove>>,List<MyPair<FpgaInternalState,List<FpgaInternalMove>>>>(internalMovesForAllRoles, internalJointMovesAndNextStates);\n}\n\npublic MyPair<List<List<FpgaInternalMove>>,List<MyPair<FpgaInternalState,List<FpgaInternalMove>>>> getNextStates(FpgaInternalState state){\nif(this.theMachine.isTerminal(state.getCompactMachineState())) {\nreturn null;\n}\n\/\/ Retrieve all legal moves\nList<List<CompactMove>> movesForAllRoles;\ntry {\nmovesForAllRoles = this.theMachine.getAllLegalMoves(state.getCompactMachineState());\n} catch (MoveDefinitionException e) {\nGamerLogger.logError(\"StateMachine\", \"[FakeFPGALibrary] Error when getting all legal moves!\");\nthrow new RuntimeException(\"StateMachine - [FakeFPGALibrary] Error when getting all legal moves!\");\n}\nList<List<FpgaInternalMove>> internalMovesForAllRoles = new ArrayList<List<FpgaInternalMove>>();\nfor(List<CompactMove> movesForOneRole : movesForAllRoles) {\nList<FpgaInternalMove> internalMovesForOneRole = new ArrayList<FpgaInternalMove>();\n\nthrow new RuntimeException(\"StateMachine - [FakeFPGALibrary] Error when getting all legal moves!\");\n}\nList<List<FpgaInternalMove>> internalMovesForAllRoles = new ArrayList<List<FpgaInternalMove>>();\nfor(List<CompactMove> movesForOneRole : movesForAllRoles) {\nList<FpgaInternalMove> internalMovesForOneRole = new ArrayList<FpgaInternalMove>();\nfor(CompactMove move : movesForOneRole) {\ninternalMovesForOneRole.add(new FpgaInternalMove(move));\n}\ninternalMovesForAllRoles.add(internalMovesForOneRole);\n}\n\/\/ Retrieve all joint moves and next states\nList<List<CompactMove>> allJointMoves;\ntry {\nallJointMoves = this.theMachine.getLegalJointMoves(state.getCompactMachineState());\n} catch (MoveDefinitionException | StateMachineException e) {\nGamerLogger.logError(\"StateMachine\", \"[FakeFPGALibrary] Error when getting all legal joint moves!\");\nthrow new RuntimeException(\"StateMachine - [FakeFPGALibrary] Error when getting all legal joint moves!\");\n}\nList<MyPair<FpgaInternalState,List<FpgaInternalMove>>> internalJointMovesAndNextStates = new ArrayList<MyPair<FpgaInternalState,List<FpgaInternalMove>>>();\nCompactMachineState nextState;\nif(allJointMoves == null) {","code_context_20":"public MyPair<List<List<FpgaInternalMove>>,List<MyPair<FpgaInternalState,List<FpgaInternalMove>>>> getNextStates(FpgaInternalState state){\nif(this.theMachine.isTerminal(state.getCompactMachineState())) {\nreturn null;\n}\n\/\/ Retrieve all legal moves\nList<List<CompactMove>> movesForAllRoles;\ntry {\nmovesForAllRoles = this.theMachine.getAllLegalMoves(state.getCompactMachineState());\n} catch (MoveDefinitionException e) {\nGamerLogger.logError(\"StateMachine\", \"[FakeFPGALibrary] Error when getting all legal moves!\");\nthrow new RuntimeException(\"StateMachine - [FakeFPGALibrary] Error when getting all legal moves!\");\n}\nList<List<FpgaInternalMove>> internalMovesForAllRoles = new ArrayList<List<FpgaInternalMove>>();\nfor(List<CompactMove> movesForOneRole : movesForAllRoles) {\nList<FpgaInternalMove> internalMovesForOneRole = new ArrayList<FpgaInternalMove>();\nfor(CompactMove move : movesForOneRole) {\ninternalMovesForOneRole.add(new FpgaInternalMove(move));\n}\ninternalMovesForAllRoles.add(internalMovesForOneRole);\n}\n\/\/ Retrieve all joint moves and next states\nList<List<CompactMove>> allJointMoves;\ntry {\nallJointMoves = this.theMachine.getLegalJointMoves(state.getCompactMachineState());\n} catch (MoveDefinitionException | StateMachineException e) {\nGamerLogger.logError(\"StateMachine\", \"[FakeFPGALibrary] Error when getting all legal joint moves!\");\nthrow new RuntimeException(\"StateMachine - [FakeFPGALibrary] Error when getting all legal joint moves!\");\n}\nList<MyPair<FpgaInternalState,List<FpgaInternalMove>>> internalJointMovesAndNextStates = new ArrayList<MyPair<FpgaInternalState,List<FpgaInternalMove>>>();\nCompactMachineState nextState;\nif(allJointMoves == null) {\nSystem.out.println(\"Null joint moves\");\n}\nfor(List<CompactMove> jointMove : allJointMoves) {\nnextState = this.theMachine.getCompactNextState(state.getCompactMachineState(), jointMove);\nList<FpgaInternalMove> internalJointMove = new ArrayList<FpgaInternalMove>();\nfor(CompactMove move : jointMove) {\ninternalJointMove.add(new FpgaInternalMove(move));\n}\ninternalJointMovesAndNextStates.add(new MyPair<FpgaInternalState,List<FpgaInternalMove>>(new FpgaInternalState(nextState), internalJointMove));\n}\nreturn new MyPair<List<List<FpgaInternalMove>>,List<MyPair<FpgaInternalState,List<FpgaInternalMove>>>>(internalMovesForAllRoles, internalJointMovesAndNextStates);\n}\n\npublic MyPair<List<List<FpgaInternalMove>>,List<MyPair<FpgaInternalState,List<FpgaInternalMove>>>> getNextStates(FpgaInternalState state){\nif(this.theMachine.isTerminal(state.getCompactMachineState())) {\nreturn null;\n}\n\/\/ Retrieve all legal moves\nList<List<CompactMove>> movesForAllRoles;\ntry {\nmovesForAllRoles = this.theMachine.getAllLegalMoves(state.getCompactMachineState());\n} catch (MoveDefinitionException e) {\nGamerLogger.logError(\"StateMachine\", \"[FakeFPGALibrary] Error when getting all legal moves!\");\nthrow new RuntimeException(\"StateMachine - [FakeFPGALibrary] Error when getting all legal moves!\");\n}\nList<List<FpgaInternalMove>> internalMovesForAllRoles = new ArrayList<List<FpgaInternalMove>>();\nfor(List<CompactMove> movesForOneRole : movesForAllRoles) {\nList<FpgaInternalMove> internalMovesForOneRole = new ArrayList<FpgaInternalMove>();\nfor(CompactMove move : movesForOneRole) {\ninternalMovesForOneRole.add(new FpgaInternalMove(move));\n}\ninternalMovesForAllRoles.add(internalMovesForOneRole);\n}\n\/\/ Retrieve all joint moves and next states\nList<List<CompactMove>> allJointMoves;\ntry {\nallJointMoves = this.theMachine.getLegalJointMoves(state.getCompactMachineState());\n} catch (MoveDefinitionException | StateMachineException e) {\n\npublic MyPair<List<List<FpgaInternalMove>>,List<MyPair<FpgaInternalState,List<FpgaInternalMove>>>> getNextStates(FpgaInternalState state){\nif(this.theMachine.isTerminal(state.getCompactMachineState())) {\nreturn null;\n}\n\/\/ Retrieve all legal moves\nList<List<CompactMove>> movesForAllRoles;\ntry {\nmovesForAllRoles = this.theMachine.getAllLegalMoves(state.getCompactMachineState());\n} catch (MoveDefinitionException e) {\nGamerLogger.logError(\"StateMachine\", \"[FakeFPGALibrary] Error when getting all legal moves!\");\nthrow new RuntimeException(\"StateMachine - [FakeFPGALibrary] Error when getting all legal moves!\");\n}\nList<List<FpgaInternalMove>> internalMovesForAllRoles = new ArrayList<List<FpgaInternalMove>>();\nfor(List<CompactMove> movesForOneRole : movesForAllRoles) {\nList<FpgaInternalMove> internalMovesForOneRole = new ArrayList<FpgaInternalMove>();\nfor(CompactMove move : movesForOneRole) {\ninternalMovesForOneRole.add(new FpgaInternalMove(move));\n}\ninternalMovesForAllRoles.add(internalMovesForOneRole);\n}\n\/\/ Retrieve all joint moves and next states\nList<List<CompactMove>> allJointMoves;\ntry {\nallJointMoves = this.theMachine.getLegalJointMoves(state.getCompactMachineState());\n} catch (MoveDefinitionException | StateMachineException e) {\nGamerLogger.logError(\"StateMachine\", \"[FakeFPGALibrary] Error when getting all legal joint moves!\");\nthrow new RuntimeException(\"StateMachine - [FakeFPGALibrary] Error when getting all legal joint moves!\");\n}\nList<MyPair<FpgaInternalState,List<FpgaInternalMove>>> internalJointMovesAndNextStates = new ArrayList<MyPair<FpgaInternalState,List<FpgaInternalMove>>>();\nCompactMachineState nextState;\nif(allJointMoves == null) {\nSystem.out.println(\"Null joint moves\");\n}\nfor(List<CompactMove> jointMove : allJointMoves) {\nnextState = this.theMachine.getCompactNextState(state.getCompactMachineState(), jointMove);\nList<FpgaInternalMove> internalJointMove = new ArrayList<FpgaInternalMove>();\nfor(CompactMove move : jointMove) {\ninternalJointMove.add(new FpgaInternalMove(move));\n}\ninternalJointMovesAndNextStates.add(new MyPair<FpgaInternalState,List<FpgaInternalMove>>(new FpgaInternalState(nextState), internalJointMove));\n}","label":[1,0,0,0]}
{"id":10940,"original_code":"public void setWindow(SpectralWindow window) {\n        \/\/ Use the same window everywhere.\n        for (int i = 0; i < ffts.length; i++) {\n            ffts[i].setWindow(window); \/\/ TODO review, both sides or just one\n            iffts[i].setWindow(window);\n        }\n    }","code":"public void setWindow(SpectralWindow window) {\n       \n        for (int i = 0; i < ffts.length; i++) {\n            ffts[i].setWindow(window);\n            iffts[i].setWindow(window);\n        }\n    }","cleancode":"public void setwindow(spectralwindow window) { for (int i = 0; i < ffts.length; i++) { ffts[i].setwindow(window); iffts[i].setwindow(window); } }","comment":"\/** * specify one window to be used for all ffts and iffts. the window should be the same size as * the ffts. * * @param window default is hammingwindow * @see spectralwindowfactory *\/\n\/\/ use the same window everywhere.\n\/\/ todo review, both sides or just one","repo":"RubbaBoy\/jsyn","code_context_2":"public void setWindow(SpectralWindow window) {\n\/\/ Use the same window everywhere.\nfor (int i = 0; i < ffts.length; i++) {\nffts[i].setWindow(window); \/\/ TODO review, both sides or just one\niffts[i].setWindow(window);\n}\n}\n\npublic void setWindow(SpectralWindow window) {\n\/\/ Use the same window everywhere.\nfor (int i = 0; i < ffts.length; i++) {\nffts[i].setWindow(window); \/\/ TODO review, both sides or just one\n\n\/\/ Use the same window everywhere.\nfor (int i = 0; i < ffts.length; i++) {\nffts[i].setWindow(window); \/\/ TODO review, both sides or just one\niffts[i].setWindow(window);\n}","code_context_10":"public void setWindow(SpectralWindow window) {\n\/\/ Use the same window everywhere.\nfor (int i = 0; i < ffts.length; i++) {\nffts[i].setWindow(window); \/\/ TODO review, both sides or just one\niffts[i].setWindow(window);\n}\n}\n\npublic void setWindow(SpectralWindow window) {\n\/\/ Use the same window everywhere.\nfor (int i = 0; i < ffts.length; i++) {\nffts[i].setWindow(window); \/\/ TODO review, both sides or just one\niffts[i].setWindow(window);\n}\n}\n\npublic void setWindow(SpectralWindow window) {\n\/\/ Use the same window everywhere.\nfor (int i = 0; i < ffts.length; i++) {\nffts[i].setWindow(window); \/\/ TODO review, both sides or just one\niffts[i].setWindow(window);\n}\n}","code_context_20":"public void setWindow(SpectralWindow window) {\n\/\/ Use the same window everywhere.\nfor (int i = 0; i < ffts.length; i++) {\nffts[i].setWindow(window); \/\/ TODO review, both sides or just one\niffts[i].setWindow(window);\n}\n}\n\npublic void setWindow(SpectralWindow window) {\n\/\/ Use the same window everywhere.\nfor (int i = 0; i < ffts.length; i++) {\nffts[i].setWindow(window); \/\/ TODO review, both sides or just one\niffts[i].setWindow(window);\n}\n}\n\npublic void setWindow(SpectralWindow window) {\n\/\/ Use the same window everywhere.\nfor (int i = 0; i < ffts.length; i++) {\nffts[i].setWindow(window); \/\/ TODO review, both sides or just one\niffts[i].setWindow(window);\n}\n}","label":[1,0,0,0]}
{"id":19154,"original_code":"public void registBroadcastReceiver(){\n        mRegistrationBroadcastReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                String action = intent.getAction();\n                if(action.equals(QuickstartPreferences.REGISTRATION_READY)){\n                }else if(action.equals(QuickstartPreferences.REGISTRATION_GENERATING)){\n                }else if(action.equals(QuickstartPreferences.REGISTRATION_COMPLETE)){\n                    Log.d(TAG, \"token is set in gcm_token\");\n                    gcm_token = intent.getStringExtra(\"token\");\n                    Log.d(TAG, \"gcm_token: \" + gcm_token);\n                    ConnectServer.getInstance().setAsncTask(new AsyncTask<String, Void, Boolean>() {\n                        @Override\n                        protected Boolean doInBackground(String... params) {\n                            URL obj = null;\n                            try {\n                                obj = new URL(\"http:\/\/165.194.104.22:5000\/gcm\");\n                                HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n                                \/\/implement below code if token is send to server\n                                con = ConnectServer.getInstance().setHeader(con);\n                                con.setDoOutput(true);\n                                String parameter = URLEncoder.encode(\"register_id\", \"UTF-8\") + \"=\" + URLEncoder.encode(gcm_token, \"UTF-8\");\n                                OutputStreamWriter wr = new OutputStreamWriter(con.getOutputStream());\n                                wr.write(parameter);\n                                wr.flush();\n                                BufferedReader rd = null;\n                                if (con.getResponseCode() == 200) {\n                                    Log.d(TAG,\"gcm_token is sent\");\n                                } else {\n                                    rd = new BufferedReader(new InputStreamReader(con.getErrorStream(), \"UTF-8\"));\n                                    Log.e(TAG,rd.readLine());\n                                }\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                            }\n                            return null;\n                        }\n                        @Override\n                        protected void onPostExecute(Boolean aBoolean) {\n                        }\n                    });\n                    ConnectServer.getInstance().execute();\n                }\n            }\n        };\n    }","code":"public void registBroadcastReceiver(){\n        mRegistrationBroadcastReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                String action = intent.getAction();\n                if(action.equals(QuickstartPreferences.REGISTRATION_READY)){\n                }else if(action.equals(QuickstartPreferences.REGISTRATION_GENERATING)){\n                }else if(action.equals(QuickstartPreferences.REGISTRATION_COMPLETE)){\n                    Log.d(TAG, \"token is set in gcm_token\");\n                    gcm_token = intent.getStringExtra(\"token\");\n                    Log.d(TAG, \"gcm_token: \" + gcm_token);\n                    ConnectServer.getInstance().setAsncTask(new AsyncTask<String, Void, Boolean>() {\n                        @Override\n                        protected Boolean doInBackground(String... params) {\n                            URL obj = null;\n                            try {\n                                obj = new URL(\"http:\/\/165.194.104.22:5000\/gcm\");\n                                HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n                               \n                                con = ConnectServer.getInstance().setHeader(con);\n                                con.setDoOutput(true);\n                                String parameter = URLEncoder.encode(\"register_id\", \"UTF-8\") + \"=\" + URLEncoder.encode(gcm_token, \"UTF-8\");\n                                OutputStreamWriter wr = new OutputStreamWriter(con.getOutputStream());\n                                wr.write(parameter);\n                                wr.flush();\n                                BufferedReader rd = null;\n                                if (con.getResponseCode() == 200) {\n                                    Log.d(TAG,\"gcm_token is sent\");\n                                } else {\n                                    rd = new BufferedReader(new InputStreamReader(con.getErrorStream(), \"UTF-8\"));\n                                    Log.e(TAG,rd.readLine());\n                                }\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                            }\n                            return null;\n                        }\n                        @Override\n                        protected void onPostExecute(Boolean aBoolean) {\n                        }\n                    });\n                    ConnectServer.getInstance().execute();\n                }\n            }\n        };\n    }","cleancode":"public void registbroadcastreceiver(){ mregistrationbroadcastreceiver = new broadcastreceiver() { @override public void onreceive(context context, intent intent) { string action = intent.getaction(); if(action.equals(quickstartpreferences.registration_ready)){ }else if(action.equals(quickstartpreferences.registration_generating)){ }else if(action.equals(quickstartpreferences.registration_complete)){ log.d(tag, \"token is set in gcm_token\"); gcm_token = intent.getstringextra(\"token\"); log.d(tag, \"gcm_token: \" + gcm_token); connectserver.getinstance().setasnctask(new asynctask<string, void, boolean>() { @override protected boolean doinbackground(string... params) { url obj = null; try { obj = new url(\"http:\/\/165.194.104.22:5000\/gcm\"); httpurlconnection con = (httpurlconnection) obj.openconnection(); con = connectserver.getinstance().setheader(con); con.setdooutput(true); string parameter = urlencoder.encode(\"register_id\", \"utf-8\") + \"=\" + urlencoder.encode(gcm_token, \"utf-8\"); outputstreamwriter wr = new outputstreamwriter(con.getoutputstream()); wr.write(parameter); wr.flush(); bufferedreader rd = null; if (con.getresponsecode() == 200) { log.d(tag,\"gcm_token is sent\"); } else { rd = new bufferedreader(new inputstreamreader(con.geterrorstream(), \"utf-8\")); log.e(tag,rd.readline()); } } catch (ioexception e) { e.printstacktrace(); } return null; } @override protected void onpostexecute(boolean aboolean) { } }); connectserver.getinstance().execute(); } } }; }","comment":"\/\/implement below code if token is send to server","repo":"KyoungjunPark\/SmartClass","code_context_2":"obj = new URL(\"http:\/\/165.194.104.22:5000\/gcm\");\nHttpURLConnection con = (HttpURLConnection) obj.openConnection();\n\/\/implement below code if token is send to server\ncon = ConnectServer.getInstance().setHeader(con);\ncon.setDoOutput(true);","code_context_10":"Log.d(TAG, \"token is set in gcm_token\");\ngcm_token = intent.getStringExtra(\"token\");\nLog.d(TAG, \"gcm_token: \" + gcm_token);\nConnectServer.getInstance().setAsncTask(new AsyncTask<String, Void, Boolean>() {\n@Override\nprotected Boolean doInBackground(String... params) {\nURL obj = null;\ntry {\nobj = new URL(\"http:\/\/165.194.104.22:5000\/gcm\");\nHttpURLConnection con = (HttpURLConnection) obj.openConnection();\n\/\/implement below code if token is send to server\ncon = ConnectServer.getInstance().setHeader(con);\ncon.setDoOutput(true);\nString parameter = URLEncoder.encode(\"register_id\", \"UTF-8\") + \"=\" + URLEncoder.encode(gcm_token, \"UTF-8\");\nOutputStreamWriter wr = new OutputStreamWriter(con.getOutputStream());\nwr.write(parameter);\nwr.flush();\nBufferedReader rd = null;\nif (con.getResponseCode() == 200) {\nLog.d(TAG,\"gcm_token is sent\");\n} else {","code_context_20":"public void registBroadcastReceiver(){\nmRegistrationBroadcastReceiver = new BroadcastReceiver() {\n@Override\npublic void onReceive(Context context, Intent intent) {\nString action = intent.getAction();\nif(action.equals(QuickstartPreferences.REGISTRATION_READY)){\n}else if(action.equals(QuickstartPreferences.REGISTRATION_GENERATING)){\n}else if(action.equals(QuickstartPreferences.REGISTRATION_COMPLETE)){\nLog.d(TAG, \"token is set in gcm_token\");\ngcm_token = intent.getStringExtra(\"token\");\nLog.d(TAG, \"gcm_token: \" + gcm_token);\nConnectServer.getInstance().setAsncTask(new AsyncTask<String, Void, Boolean>() {\n@Override\nprotected Boolean doInBackground(String... params) {\nURL obj = null;\ntry {\nobj = new URL(\"http:\/\/165.194.104.22:5000\/gcm\");\nHttpURLConnection con = (HttpURLConnection) obj.openConnection();\n\/\/implement below code if token is send to server\ncon = ConnectServer.getInstance().setHeader(con);\ncon.setDoOutput(true);\nString parameter = URLEncoder.encode(\"register_id\", \"UTF-8\") + \"=\" + URLEncoder.encode(gcm_token, \"UTF-8\");\nOutputStreamWriter wr = new OutputStreamWriter(con.getOutputStream());\nwr.write(parameter);\nwr.flush();\nBufferedReader rd = null;\nif (con.getResponseCode() == 200) {\nLog.d(TAG,\"gcm_token is sent\");\n} else {\nrd = new BufferedReader(new InputStreamReader(con.getErrorStream(), \"UTF-8\"));\nLog.e(TAG,rd.readLine());\n}\n} catch (IOException e) {\ne.printStackTrace();\n}\nreturn null;\n}\n@Override\nprotected void onPostExecute(Boolean aBoolean) {","label":[0,1,0,0]}
{"id":10985,"original_code":"static void addChildElement(\n            BasePropertyWriter p,\n            Map<String, BasePropertyWriter> childElements,\n            FlowElementsContainer process,\n            Collection<ElementParameters> simulationParameters,\n            List<ItemDefinition> itemDefinitions,\n            List<RootElement> rootElements) {\n        childElements.put(p.getElement().getId(), p);\n        if (p.getElement() instanceof FlowElement) {\n            \/\/ compatibility fix: boundary events should always occur at the bottom\n            \/\/ otherwise they will be drawn at an incorrect position on load\n            if (p instanceof BoundaryEventPropertyWriter) {\n                process.getFlowElements().add((FlowElement) p.getElement());\n            } else {\n                process.getFlowElements().add(0, (FlowElement) p.getElement());\n                p.getElement();\n            }\n        } else if (p.getElement() instanceof Artifact) {\n            if (process instanceof Process) {\n                ((Process) process).getArtifacts().add((Artifact) p.getElement());\n            } else if (process instanceof SubProcess) {\n                ((SubProcess) process).getArtifacts().add((Artifact) p.getElement());\n            }\n        }\n        if (p instanceof PropertyWriter) {\n            ElementParameters sp = ((PropertyWriter) p).getSimulationParameters();\n            if (sp != null) {\n                simulationParameters.add(sp);\n            }\n        }\n        itemDefinitions.addAll(p.getItemDefinitions());\n        rootElements.addAll(p.getRootElements());\n        rootElements.addAll(p.getInterfaces());\n    }","code":"static void addChildElement(\n            BasePropertyWriter p,\n            Map<String, BasePropertyWriter> childElements,\n            FlowElementsContainer process,\n            Collection<ElementParameters> simulationParameters,\n            List<ItemDefinition> itemDefinitions,\n            List<RootElement> rootElements) {\n        childElements.put(p.getElement().getId(), p);\n        if (p.getElement() instanceof FlowElement) {\n           \n           \n            if (p instanceof BoundaryEventPropertyWriter) {\n                process.getFlowElements().add((FlowElement) p.getElement());\n            } else {\n                process.getFlowElements().add(0, (FlowElement) p.getElement());\n                p.getElement();\n            }\n        } else if (p.getElement() instanceof Artifact) {\n            if (process instanceof Process) {\n                ((Process) process).getArtifacts().add((Artifact) p.getElement());\n            } else if (process instanceof SubProcess) {\n                ((SubProcess) process).getArtifacts().add((Artifact) p.getElement());\n            }\n        }\n        if (p instanceof PropertyWriter) {\n            ElementParameters sp = ((PropertyWriter) p).getSimulationParameters();\n            if (sp != null) {\n                simulationParameters.add(sp);\n            }\n        }\n        itemDefinitions.addAll(p.getItemDefinitions());\n        rootElements.addAll(p.getRootElements());\n        rootElements.addAll(p.getInterfaces());\n    }","cleancode":"static void addchildelement( basepropertywriter p, map<string, basepropertywriter> childelements, flowelementscontainer process, collection<elementparameters> simulationparameters, list<itemdefinition> itemdefinitions, list<rootelement> rootelements) { childelements.put(p.getelement().getid(), p); if (p.getelement() instanceof flowelement) { if (p instanceof boundaryeventpropertywriter) { process.getflowelements().add((flowelement) p.getelement()); } else { process.getflowelements().add(0, (flowelement) p.getelement()); p.getelement(); } } else if (p.getelement() instanceof artifact) { if (process instanceof process) { ((process) process).getartifacts().add((artifact) p.getelement()); } else if (process instanceof subprocess) { ((subprocess) process).getartifacts().add((artifact) p.getelement()); } } if (p instanceof propertywriter) { elementparameters sp = ((propertywriter) p).getsimulationparameters(); if (sp != null) { simulationparameters.add(sp); } } itemdefinitions.addall(p.getitemdefinitions()); rootelements.addall(p.getrootelements()); rootelements.addall(p.getinterfaces()); }","comment":"\/\/ compatibility fix: boundary events should always occur at the bottom \/\/ otherwise they will be drawn at an incorrect position on load","repo":"Prodaxis\/kie-wb-common","code_context_2":"childElements.put(p.getElement().getId(), p);\nif (p.getElement() instanceof FlowElement) {\n\/\/ compatibility fix: boundary events should always occur at the bottom\n\/\/ otherwise they will be drawn at an incorrect position on load\nif (p instanceof BoundaryEventPropertyWriter) {\nprocess.getFlowElements().add((FlowElement) p.getElement());","code_context_10":"static void addChildElement(\nBasePropertyWriter p,\nMap<String, BasePropertyWriter> childElements,\nFlowElementsContainer process,\nCollection<ElementParameters> simulationParameters,\nList<ItemDefinition> itemDefinitions,\nList<RootElement> rootElements) {\nchildElements.put(p.getElement().getId(), p);\nif (p.getElement() instanceof FlowElement) {\n\/\/ compatibility fix: boundary events should always occur at the bottom\n\/\/ otherwise they will be drawn at an incorrect position on load\nif (p instanceof BoundaryEventPropertyWriter) {\nprocess.getFlowElements().add((FlowElement) p.getElement());\n} else {\nprocess.getFlowElements().add(0, (FlowElement) p.getElement());\np.getElement();\n}\n} else if (p.getElement() instanceof Artifact) {\nif (process instanceof Process) {\n((Process) process).getArtifacts().add((Artifact) p.getElement());\n} else if (process instanceof SubProcess) {","code_context_20":"static void addChildElement(\nBasePropertyWriter p,\nMap<String, BasePropertyWriter> childElements,\nFlowElementsContainer process,\nCollection<ElementParameters> simulationParameters,\nList<ItemDefinition> itemDefinitions,\nList<RootElement> rootElements) {\nchildElements.put(p.getElement().getId(), p);\nif (p.getElement() instanceof FlowElement) {\n\/\/ compatibility fix: boundary events should always occur at the bottom\n\/\/ otherwise they will be drawn at an incorrect position on load\nif (p instanceof BoundaryEventPropertyWriter) {\nprocess.getFlowElements().add((FlowElement) p.getElement());\n} else {\nprocess.getFlowElements().add(0, (FlowElement) p.getElement());\np.getElement();\n}\n} else if (p.getElement() instanceof Artifact) {\nif (process instanceof Process) {\n((Process) process).getArtifacts().add((Artifact) p.getElement());\n} else if (process instanceof SubProcess) {\n((SubProcess) process).getArtifacts().add((Artifact) p.getElement());\n}\n}\nif (p instanceof PropertyWriter) {\nElementParameters sp = ((PropertyWriter) p).getSimulationParameters();\nif (sp != null) {\nsimulationParameters.add(sp);\n}\n}\nitemDefinitions.addAll(p.getItemDefinitions());","label":[0,0,1,0]}
{"id":19324,"original_code":"@Test\n    public void testGetWithTwoTags() {\n        int limit = THREAD_COUNT;        \/\/ TODO How to set this?\n        queryParameters.put(\"limit\", Arrays.asList(String.valueOf(limit)));\n        \/\/ TODO pick iteration and pod at random\n        queryParameters.put(\"tag\", Arrays.asList(\"iteration:1\", \"podname:\" + workerPodNames.get(0)));\n        logger.info(\"Query parameters: \" + queryParameters.size());\n        List<Datum> traces = simpleRestClient.getTraces(queryParameters, limit);\n        Instant testEndTime = Instant.now();\n        long duration = Duration.between(testStartTime, testEndTime).toMillis();\n        logger.info(\"Retrieval of \" + limit + \" spans in testGetWithTwoTags took \" + numberFormat.format(duration) + \" milliseconds\");\n        assertNotNull(traces);\n        assertEquals(limit, traces.size());\n        \/\/ TODO add more validation\n    }","code":"@Test\n    public void testGetWithTwoTags() {\n        int limit = THREAD_COUNT;       \n        queryParameters.put(\"limit\", Arrays.asList(String.valueOf(limit)));\n       \n        queryParameters.put(\"tag\", Arrays.asList(\"iteration:1\", \"podname:\" + workerPodNames.get(0)));\n        logger.info(\"Query parameters: \" + queryParameters.size());\n        List<Datum> traces = simpleRestClient.getTraces(queryParameters, limit);\n        Instant testEndTime = Instant.now();\n        long duration = Duration.between(testStartTime, testEndTime).toMillis();\n        logger.info(\"Retrieval of \" + limit + \" spans in testGetWithTwoTags took \" + numberFormat.format(duration) + \" milliseconds\");\n        assertNotNull(traces);\n        assertEquals(limit, traces.size());\n       \n    }","cleancode":"@test public void testgetwithtwotags() { int limit = thread_count; queryparameters.put(\"limit\", arrays.aslist(string.valueof(limit))); queryparameters.put(\"tag\", arrays.aslist(\"iteration:1\", \"podname:\" + workerpodnames.get(0))); logger.info(\"query parameters: \" + queryparameters.size()); list<datum> traces = simplerestclient.gettraces(queryparameters, limit); instant testendtime = instant.now(); long duration = duration.between(teststarttime, testendtime).tomillis(); logger.info(\"retrieval of \" + limit + \" spans in testgetwithtwotags took \" + numberformat.format(duration) + \" milliseconds\"); assertnotnull(traces); assertequals(limit, traces.size()); }","comment":"\/\/ todo how to set this?\n\/\/ todo pick iteration and pod at random\n\/\/ todo add more validation","repo":"PikBot\/jaeger-performance","code_context_2":"@Test\npublic void testGetWithTwoTags() {\nint limit = THREAD_COUNT; \/\/ TODO How to set this?\nqueryParameters.put(\"limit\", Arrays.asList(String.valueOf(limit)));\n\/\/ TODO pick iteration and pod at random\n\nint limit = THREAD_COUNT; \/\/ TODO How to set this?\nqueryParameters.put(\"limit\", Arrays.asList(String.valueOf(limit)));\n\/\/ TODO pick iteration and pod at random\nqueryParameters.put(\"tag\", Arrays.asList(\"iteration:1\", \"podname:\" + workerPodNames.get(0)));\nlogger.info(\"Query parameters: \" + queryParameters.size());\n\nassertNotNull(traces);\nassertEquals(limit, traces.size());\n\/\/ TODO add more validation\n}","code_context_10":"@Test\npublic void testGetWithTwoTags() {\nint limit = THREAD_COUNT; \/\/ TODO How to set this?\nqueryParameters.put(\"limit\", Arrays.asList(String.valueOf(limit)));\n\/\/ TODO pick iteration and pod at random\nqueryParameters.put(\"tag\", Arrays.asList(\"iteration:1\", \"podname:\" + workerPodNames.get(0)));\nlogger.info(\"Query parameters: \" + queryParameters.size());\nList<Datum> traces = simpleRestClient.getTraces(queryParameters, limit);\nInstant testEndTime = Instant.now();\nlong duration = Duration.between(testStartTime, testEndTime).toMillis();\nlogger.info(\"Retrieval of \" + limit + \" spans in testGetWithTwoTags took \" + numberFormat.format(duration) + \" milliseconds\");\nassertNotNull(traces);\nassertEquals(limit, traces.size());\n\n@Test\npublic void testGetWithTwoTags() {\nint limit = THREAD_COUNT; \/\/ TODO How to set this?\nqueryParameters.put(\"limit\", Arrays.asList(String.valueOf(limit)));\n\/\/ TODO pick iteration and pod at random\nqueryParameters.put(\"tag\", Arrays.asList(\"iteration:1\", \"podname:\" + workerPodNames.get(0)));\nlogger.info(\"Query parameters: \" + queryParameters.size());\nList<Datum> traces = simpleRestClient.getTraces(queryParameters, limit);\nInstant testEndTime = Instant.now();\nlong duration = Duration.between(testStartTime, testEndTime).toMillis();\nlogger.info(\"Retrieval of \" + limit + \" spans in testGetWithTwoTags took \" + numberFormat.format(duration) + \" milliseconds\");\nassertNotNull(traces);\nassertEquals(limit, traces.size());\n\/\/ TODO add more validation\n}\n\nqueryParameters.put(\"limit\", Arrays.asList(String.valueOf(limit)));\n\/\/ TODO pick iteration and pod at random\nqueryParameters.put(\"tag\", Arrays.asList(\"iteration:1\", \"podname:\" + workerPodNames.get(0)));\nlogger.info(\"Query parameters: \" + queryParameters.size());\nList<Datum> traces = simpleRestClient.getTraces(queryParameters, limit);\nInstant testEndTime = Instant.now();\nlong duration = Duration.between(testStartTime, testEndTime).toMillis();\nlogger.info(\"Retrieval of \" + limit + \" spans in testGetWithTwoTags took \" + numberFormat.format(duration) + \" milliseconds\");\nassertNotNull(traces);\nassertEquals(limit, traces.size());\n\/\/ TODO add more validation\n}","code_context_20":"@Test\npublic void testGetWithTwoTags() {\nint limit = THREAD_COUNT; \/\/ TODO How to set this?\nqueryParameters.put(\"limit\", Arrays.asList(String.valueOf(limit)));\n\/\/ TODO pick iteration and pod at random\nqueryParameters.put(\"tag\", Arrays.asList(\"iteration:1\", \"podname:\" + workerPodNames.get(0)));\nlogger.info(\"Query parameters: \" + queryParameters.size());\nList<Datum> traces = simpleRestClient.getTraces(queryParameters, limit);\nInstant testEndTime = Instant.now();\nlong duration = Duration.between(testStartTime, testEndTime).toMillis();\nlogger.info(\"Retrieval of \" + limit + \" spans in testGetWithTwoTags took \" + numberFormat.format(duration) + \" milliseconds\");\nassertNotNull(traces);\nassertEquals(limit, traces.size());\n\/\/ TODO add more validation\n}\n\n@Test\npublic void testGetWithTwoTags() {\nint limit = THREAD_COUNT; \/\/ TODO How to set this?\nqueryParameters.put(\"limit\", Arrays.asList(String.valueOf(limit)));\n\/\/ TODO pick iteration and pod at random\nqueryParameters.put(\"tag\", Arrays.asList(\"iteration:1\", \"podname:\" + workerPodNames.get(0)));\nlogger.info(\"Query parameters: \" + queryParameters.size());\nList<Datum> traces = simpleRestClient.getTraces(queryParameters, limit);\nInstant testEndTime = Instant.now();\nlong duration = Duration.between(testStartTime, testEndTime).toMillis();\nlogger.info(\"Retrieval of \" + limit + \" spans in testGetWithTwoTags took \" + numberFormat.format(duration) + \" milliseconds\");\nassertNotNull(traces);\nassertEquals(limit, traces.size());\n\/\/ TODO add more validation\n}\n\n@Test\npublic void testGetWithTwoTags() {\nint limit = THREAD_COUNT; \/\/ TODO How to set this?\nqueryParameters.put(\"limit\", Arrays.asList(String.valueOf(limit)));\n\/\/ TODO pick iteration and pod at random\nqueryParameters.put(\"tag\", Arrays.asList(\"iteration:1\", \"podname:\" + workerPodNames.get(0)));\nlogger.info(\"Query parameters: \" + queryParameters.size());\nList<Datum> traces = simpleRestClient.getTraces(queryParameters, limit);\nInstant testEndTime = Instant.now();\nlong duration = Duration.between(testStartTime, testEndTime).toMillis();\nlogger.info(\"Retrieval of \" + limit + \" spans in testGetWithTwoTags took \" + numberFormat.format(duration) + \" milliseconds\");\nassertNotNull(traces);\nassertEquals(limit, traces.size());\n\/\/ TODO add more validation\n}","label":[1,1,0,0]}
{"id":19350,"original_code":"@Override\n  public List<InputSplit> getSplits(JobContext context) throws IOException {\n    final Configuration conf = context.getConfiguration();\n    final KijiURI inputTableURI = getInputTableURI(conf);\n    final Kiji kiji = Kiji.Factory.open(inputTableURI, conf);\n    final KijiTable table = kiji.openTable(inputTableURI.getTable());\n    final HTableInterface htable = HBaseKijiTable.downcast(table).openHTableConnection();\n    try {\n      final List<InputSplit> splits = Lists.newArrayList();\n      for (KijiRegion region : table.getRegions()) {\n        final byte[] startKey = region.getStartKey();\n        \/\/ TODO: a smart way to get which location is most relevant.\n        final String location =\n            region.getLocations().isEmpty() ? null : region.getLocations().iterator().next();\n        final TableSplit tableSplit = new TableSplit(\n            htable.getTableName(), startKey, region.getEndKey(), location);\n        splits.add(new KijiTableSplit(tableSplit, startKey));\n      }\n      return splits;\n    } finally {\n      htable.close();\n    }\n  }","code":"@Override\n  public List<InputSplit> getSplits(JobContext context) throws IOException {\n    final Configuration conf = context.getConfiguration();\n    final KijiURI inputTableURI = getInputTableURI(conf);\n    final Kiji kiji = Kiji.Factory.open(inputTableURI, conf);\n    final KijiTable table = kiji.openTable(inputTableURI.getTable());\n    final HTableInterface htable = HBaseKijiTable.downcast(table).openHTableConnection();\n    try {\n      final List<InputSplit> splits = Lists.newArrayList();\n      for (KijiRegion region : table.getRegions()) {\n        final byte[] startKey = region.getStartKey();\n       \n        final String location =\n            region.getLocations().isEmpty() ? null : region.getLocations().iterator().next();\n        final TableSplit tableSplit = new TableSplit(\n            htable.getTableName(), startKey, region.getEndKey(), location);\n        splits.add(new KijiTableSplit(tableSplit, startKey));\n      }\n      return splits;\n    } finally {\n      htable.close();\n    }\n  }","cleancode":"@override public list<inputsplit> getsplits(jobcontext context) throws ioexception { final configuration conf = context.getconfiguration(); final kijiuri inputtableuri = getinputtableuri(conf); final kiji kiji = kiji.factory.open(inputtableuri, conf); final kijitable table = kiji.opentable(inputtableuri.gettable()); final htableinterface htable = hbasekijitable.downcast(table).openhtableconnection(); try { final list<inputsplit> splits = lists.newarraylist(); for (kijiregion region : table.getregions()) { final byte[] startkey = region.getstartkey(); final string location = region.getlocations().isempty() ? null : region.getlocations().iterator().next(); final tablesplit tablesplit = new tablesplit( htable.gettablename(), startkey, region.getendkey(), location); splits.add(new kijitablesplit(tablesplit, startkey)); } return splits; } finally { htable.close(); } }","comment":"\/** {@inheritdoc} *\/\n\/\/ todo: a smart way to get which location is most relevant.","repo":"NeoGridBR\/kiji-schema","code_context_2":"@Override\npublic List<InputSplit> getSplits(JobContext context) throws IOException {\nfinal Configuration conf = context.getConfiguration();\nfinal KijiURI inputTableURI = getInputTableURI(conf);\nfinal Kiji kiji = Kiji.Factory.open(inputTableURI, conf);\nfinal KijiTable table = kiji.openTable(inputTableURI.getTable());\nfinal HTableInterface htable = HBaseKijiTable.downcast(table).openHTableConnection();\ntry {\nfinal List<InputSplit> splits = Lists.newArrayList();\nfor (KijiRegion region : table.getRegions()) {\nfinal byte[] startKey = region.getStartKey();\n\/\/ TODO: a smart way to get which location is most relevant.\nfinal String location =\nregion.getLocations().isEmpty() ? null : region.getLocations().iterator().next();\nfinal TableSplit tableSplit = new TableSplit(\nhtable.getTableName(), startKey, region.getEndKey(), location);\nsplits.add(new KijiTableSplit(tableSplit, startKey));\n}\nreturn splits;\n} finally {\nhtable.close();\n}\n}\n\nfor (KijiRegion region : table.getRegions()) {\nfinal byte[] startKey = region.getStartKey();\n\/\/ TODO: a smart way to get which location is most relevant.\nfinal String location =\nregion.getLocations().isEmpty() ? null : region.getLocations().iterator().next();","code_context_10":"@Override\npublic List<InputSplit> getSplits(JobContext context) throws IOException {\nfinal Configuration conf = context.getConfiguration();\nfinal KijiURI inputTableURI = getInputTableURI(conf);\nfinal Kiji kiji = Kiji.Factory.open(inputTableURI, conf);\nfinal KijiTable table = kiji.openTable(inputTableURI.getTable());\nfinal HTableInterface htable = HBaseKijiTable.downcast(table).openHTableConnection();\ntry {\nfinal List<InputSplit> splits = Lists.newArrayList();\nfor (KijiRegion region : table.getRegions()) {\nfinal byte[] startKey = region.getStartKey();\n\/\/ TODO: a smart way to get which location is most relevant.\nfinal String location =\nregion.getLocations().isEmpty() ? null : region.getLocations().iterator().next();\nfinal TableSplit tableSplit = new TableSplit(\nhtable.getTableName(), startKey, region.getEndKey(), location);\nsplits.add(new KijiTableSplit(tableSplit, startKey));\n}\nreturn splits;\n} finally {\nhtable.close();\n}\n}\n\npublic List<InputSplit> getSplits(JobContext context) throws IOException {\nfinal Configuration conf = context.getConfiguration();\nfinal KijiURI inputTableURI = getInputTableURI(conf);\nfinal Kiji kiji = Kiji.Factory.open(inputTableURI, conf);\nfinal KijiTable table = kiji.openTable(inputTableURI.getTable());\nfinal HTableInterface htable = HBaseKijiTable.downcast(table).openHTableConnection();\ntry {\nfinal List<InputSplit> splits = Lists.newArrayList();\nfor (KijiRegion region : table.getRegions()) {\nfinal byte[] startKey = region.getStartKey();\n\/\/ TODO: a smart way to get which location is most relevant.\nfinal String location =\nregion.getLocations().isEmpty() ? null : region.getLocations().iterator().next();\nfinal TableSplit tableSplit = new TableSplit(\nhtable.getTableName(), startKey, region.getEndKey(), location);\nsplits.add(new KijiTableSplit(tableSplit, startKey));\n}\nreturn splits;\n} finally {\nhtable.close();\n}","code_context_20":"@Override\npublic List<InputSplit> getSplits(JobContext context) throws IOException {\nfinal Configuration conf = context.getConfiguration();\nfinal KijiURI inputTableURI = getInputTableURI(conf);\nfinal Kiji kiji = Kiji.Factory.open(inputTableURI, conf);\nfinal KijiTable table = kiji.openTable(inputTableURI.getTable());\nfinal HTableInterface htable = HBaseKijiTable.downcast(table).openHTableConnection();\ntry {\nfinal List<InputSplit> splits = Lists.newArrayList();\nfor (KijiRegion region : table.getRegions()) {\nfinal byte[] startKey = region.getStartKey();\n\/\/ TODO: a smart way to get which location is most relevant.\nfinal String location =\nregion.getLocations().isEmpty() ? null : region.getLocations().iterator().next();\nfinal TableSplit tableSplit = new TableSplit(\nhtable.getTableName(), startKey, region.getEndKey(), location);\nsplits.add(new KijiTableSplit(tableSplit, startKey));\n}\nreturn splits;\n} finally {\nhtable.close();\n}\n}\n\n@Override\npublic List<InputSplit> getSplits(JobContext context) throws IOException {\nfinal Configuration conf = context.getConfiguration();\nfinal KijiURI inputTableURI = getInputTableURI(conf);\nfinal Kiji kiji = Kiji.Factory.open(inputTableURI, conf);\nfinal KijiTable table = kiji.openTable(inputTableURI.getTable());\nfinal HTableInterface htable = HBaseKijiTable.downcast(table).openHTableConnection();\ntry {\nfinal List<InputSplit> splits = Lists.newArrayList();\nfor (KijiRegion region : table.getRegions()) {\nfinal byte[] startKey = region.getStartKey();\n\/\/ TODO: a smart way to get which location is most relevant.\nfinal String location =\nregion.getLocations().isEmpty() ? null : region.getLocations().iterator().next();\nfinal TableSplit tableSplit = new TableSplit(\nhtable.getTableName(), startKey, region.getEndKey(), location);\nsplits.add(new KijiTableSplit(tableSplit, startKey));\n}\nreturn splits;\n} finally {\nhtable.close();\n}\n}","label":[1,0,0,0]}
{"id":11228,"original_code":"private void onHeartClicked(MenuItem item) {\n        ArrayList favoritesList = null;\n        String filename = \"favorites.json\";\n        FileInputStream inputStream = null;\n        try {\n            inputStream = openFileInput(filename);\n            String json = IOUtils.toString(inputStream, \"UTF-8\");\n            Gson gson = new Gson();\n            favoritesList = gson.fromJson(json, ArrayList.class);\n            inputStream.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        if(favoritesList == null) return;\n        SharedPreferences sharedPreferences = getSharedPreferences(\"pref\", Context.MODE_PRIVATE);\n        Boolean isFavorited = sharedPreferences.getBoolean(stopName + \"Favorited\", false);\n        if (!isFavorited) { \/\/favoriting\n            item.setIcon(R.drawable.ic_favorite_white_24dp);\n            item.getIcon().setColorFilter(ContextCompat.getColor(getApplicationContext(), R.color.colorAccent), PorterDuff.Mode.SRC_IN);\n            favoritesList.add(stopName); \/\/TODO make sure this doesn't break anything\n            isFavorited = true;\n        } else { \/\/unfavoriting\n            item.setIcon(R.drawable.ic_favorite_border_white_24dp);\n            item.getIcon().setColorFilter(Color.parseColor(\"#ffffff\"), PorterDuff.Mode.SRC_IN);\n            favoritesList.remove(stopName);\n            isFavorited = false;\n        }\n        SharedPreferences.Editor editor = sharedPreferences.edit();\n        editor.putBoolean(stopName + \"Favorited\", isFavorited);\n        editor.putString(stopName, stopId); \/\/Stores stop id value with stopName key\n        editor.apply();\n        gsonFileUtils.writeListToFile(favoritesList, this);\n    }","code":"private void onHeartClicked(MenuItem item) {\n        ArrayList favoritesList = null;\n        String filename = \"favorites.json\";\n        FileInputStream inputStream = null;\n        try {\n            inputStream = openFileInput(filename);\n            String json = IOUtils.toString(inputStream, \"UTF-8\");\n            Gson gson = new Gson();\n            favoritesList = gson.fromJson(json, ArrayList.class);\n            inputStream.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        if(favoritesList == null) return;\n        SharedPreferences sharedPreferences = getSharedPreferences(\"pref\", Context.MODE_PRIVATE);\n        Boolean isFavorited = sharedPreferences.getBoolean(stopName + \"Favorited\", false);\n        if (!isFavorited) {\n            item.setIcon(R.drawable.ic_favorite_white_24dp);\n            item.getIcon().setColorFilter(ContextCompat.getColor(getApplicationContext(), R.color.colorAccent), PorterDuff.Mode.SRC_IN);\n            favoritesList.add(stopName);\n            isFavorited = true;\n        } else {\n            item.setIcon(R.drawable.ic_favorite_border_white_24dp);\n            item.getIcon().setColorFilter(Color.parseColor(\"#ffffff\"), PorterDuff.Mode.SRC_IN);\n            favoritesList.remove(stopName);\n            isFavorited = false;\n        }\n        SharedPreferences.Editor editor = sharedPreferences.edit();\n        editor.putBoolean(stopName + \"Favorited\", isFavorited);\n        editor.putString(stopName, stopId);\n        editor.apply();\n        gsonFileUtils.writeListToFile(favoritesList, this);\n    }","cleancode":"private void onheartclicked(menuitem item) { arraylist favoriteslist = null; string filename = \"favorites.json\"; fileinputstream inputstream = null; try { inputstream = openfileinput(filename); string json = ioutils.tostring(inputstream, \"utf-8\"); gson gson = new gson(); favoriteslist = gson.fromjson(json, arraylist.class); inputstream.close(); } catch (ioexception e) { e.printstacktrace(); } if(favoriteslist == null) return; sharedpreferences sharedpreferences = getsharedpreferences(\"pref\", context.mode_private); boolean isfavorited = sharedpreferences.getboolean(stopname + \"favorited\", false); if (!isfavorited) { item.seticon(r.drawable.ic_favorite_white_24dp); item.geticon().setcolorfilter(contextcompat.getcolor(getapplicationcontext(), r.color.coloraccent), porterduff.mode.src_in); favoriteslist.add(stopname); isfavorited = true; } else { item.seticon(r.drawable.ic_favorite_border_white_24dp); item.geticon().setcolorfilter(color.parsecolor(\"#ffffff\"), porterduff.mode.src_in); favoriteslist.remove(stopname); isfavorited = false; } sharedpreferences.editor editor = sharedpreferences.edit(); editor.putboolean(stopname + \"favorited\", isfavorited); editor.putstring(stopname, stopid); editor.apply(); gsonfileutils.writelisttofile(favoriteslist, this); }","comment":"\/\/favoriting\n\/\/todo make sure this doesn't break anything\n\/\/unfavoriting\n\/\/stores stop id value with stopname key","repo":"Newbhope\/cu-bus","code_context_2":"SharedPreferences sharedPreferences = getSharedPreferences(\"pref\", Context.MODE_PRIVATE);\nBoolean isFavorited = sharedPreferences.getBoolean(stopName + \"Favorited\", false);\nif (!isFavorited) { \/\/favoriting\nitem.setIcon(R.drawable.ic_favorite_white_24dp);\nitem.getIcon().setColorFilter(ContextCompat.getColor(getApplicationContext(), R.color.colorAccent), PorterDuff.Mode.SRC_IN);\n\nitem.setIcon(R.drawable.ic_favorite_white_24dp);\nitem.getIcon().setColorFilter(ContextCompat.getColor(getApplicationContext(), R.color.colorAccent), PorterDuff.Mode.SRC_IN);\nfavoritesList.add(stopName); \/\/TODO make sure this doesn't break anything\nisFavorited = true;\n} else { \/\/unfavoriting\n\nfavoritesList.add(stopName); \/\/TODO make sure this doesn't break anything\nisFavorited = true;\n} else { \/\/unfavoriting\nitem.setIcon(R.drawable.ic_favorite_border_white_24dp);\nitem.getIcon().setColorFilter(Color.parseColor(\"#ffffff\"), PorterDuff.Mode.SRC_IN);\n\nSharedPreferences.Editor editor = sharedPreferences.edit();\neditor.putBoolean(stopName + \"Favorited\", isFavorited);\neditor.putString(stopName, stopId); \/\/Stores stop id value with stopName key\neditor.apply();\ngsonFileUtils.writeListToFile(favoritesList, this);","code_context_10":"String json = IOUtils.toString(inputStream, \"UTF-8\");\nGson gson = new Gson();\nfavoritesList = gson.fromJson(json, ArrayList.class);\ninputStream.close();\n} catch (IOException e) {\ne.printStackTrace();\n}\nif(favoritesList == null) return;\nSharedPreferences sharedPreferences = getSharedPreferences(\"pref\", Context.MODE_PRIVATE);\nBoolean isFavorited = sharedPreferences.getBoolean(stopName + \"Favorited\", false);\nif (!isFavorited) { \/\/favoriting\nitem.setIcon(R.drawable.ic_favorite_white_24dp);\nitem.getIcon().setColorFilter(ContextCompat.getColor(getApplicationContext(), R.color.colorAccent), PorterDuff.Mode.SRC_IN);\nfavoritesList.add(stopName); \/\/TODO make sure this doesn't break anything\nisFavorited = true;\n} else { \/\/unfavoriting\nitem.setIcon(R.drawable.ic_favorite_border_white_24dp);\nitem.getIcon().setColorFilter(Color.parseColor(\"#ffffff\"), PorterDuff.Mode.SRC_IN);\nfavoritesList.remove(stopName);\nisFavorited = false;\n}\n\ninputStream.close();\n} catch (IOException e) {\ne.printStackTrace();\n}\nif(favoritesList == null) return;\nSharedPreferences sharedPreferences = getSharedPreferences(\"pref\", Context.MODE_PRIVATE);\nBoolean isFavorited = sharedPreferences.getBoolean(stopName + \"Favorited\", false);\nif (!isFavorited) { \/\/favoriting\nitem.setIcon(R.drawable.ic_favorite_white_24dp);\nitem.getIcon().setColorFilter(ContextCompat.getColor(getApplicationContext(), R.color.colorAccent), PorterDuff.Mode.SRC_IN);\nfavoritesList.add(stopName); \/\/TODO make sure this doesn't break anything\nisFavorited = true;\n} else { \/\/unfavoriting\nitem.setIcon(R.drawable.ic_favorite_border_white_24dp);\nitem.getIcon().setColorFilter(Color.parseColor(\"#ffffff\"), PorterDuff.Mode.SRC_IN);\nfavoritesList.remove(stopName);\nisFavorited = false;\n}\nSharedPreferences.Editor editor = sharedPreferences.edit();\neditor.putBoolean(stopName + \"Favorited\", isFavorited);\neditor.putString(stopName, stopId); \/\/Stores stop id value with stopName key\n\ne.printStackTrace();\n}\nif(favoritesList == null) return;\nSharedPreferences sharedPreferences = getSharedPreferences(\"pref\", Context.MODE_PRIVATE);\nBoolean isFavorited = sharedPreferences.getBoolean(stopName + \"Favorited\", false);\nif (!isFavorited) { \/\/favoriting\nitem.setIcon(R.drawable.ic_favorite_white_24dp);\nitem.getIcon().setColorFilter(ContextCompat.getColor(getApplicationContext(), R.color.colorAccent), PorterDuff.Mode.SRC_IN);\nfavoritesList.add(stopName); \/\/TODO make sure this doesn't break anything\nisFavorited = true;\n} else { \/\/unfavoriting\nitem.setIcon(R.drawable.ic_favorite_border_white_24dp);\nitem.getIcon().setColorFilter(Color.parseColor(\"#ffffff\"), PorterDuff.Mode.SRC_IN);\nfavoritesList.remove(stopName);\nisFavorited = false;\n}\nSharedPreferences.Editor editor = sharedPreferences.edit();\neditor.putBoolean(stopName + \"Favorited\", isFavorited);\neditor.putString(stopName, stopId); \/\/Stores stop id value with stopName key\neditor.apply();\ngsonFileUtils.writeListToFile(favoritesList, this);\n\nfavoritesList.add(stopName); \/\/TODO make sure this doesn't break anything\nisFavorited = true;\n} else { \/\/unfavoriting\nitem.setIcon(R.drawable.ic_favorite_border_white_24dp);\nitem.getIcon().setColorFilter(Color.parseColor(\"#ffffff\"), PorterDuff.Mode.SRC_IN);\nfavoritesList.remove(stopName);\nisFavorited = false;\n}\nSharedPreferences.Editor editor = sharedPreferences.edit();\neditor.putBoolean(stopName + \"Favorited\", isFavorited);\neditor.putString(stopName, stopId); \/\/Stores stop id value with stopName key\neditor.apply();\ngsonFileUtils.writeListToFile(favoritesList, this);\n}","code_context_20":"private void onHeartClicked(MenuItem item) {\nArrayList favoritesList = null;\nString filename = \"favorites.json\";\nFileInputStream inputStream = null;\ntry {\ninputStream = openFileInput(filename);\nString json = IOUtils.toString(inputStream, \"UTF-8\");\nGson gson = new Gson();\nfavoritesList = gson.fromJson(json, ArrayList.class);\ninputStream.close();\n} catch (IOException e) {\ne.printStackTrace();\n}\nif(favoritesList == null) return;\nSharedPreferences sharedPreferences = getSharedPreferences(\"pref\", Context.MODE_PRIVATE);\nBoolean isFavorited = sharedPreferences.getBoolean(stopName + \"Favorited\", false);\nif (!isFavorited) { \/\/favoriting\nitem.setIcon(R.drawable.ic_favorite_white_24dp);\nitem.getIcon().setColorFilter(ContextCompat.getColor(getApplicationContext(), R.color.colorAccent), PorterDuff.Mode.SRC_IN);\nfavoritesList.add(stopName); \/\/TODO make sure this doesn't break anything\nisFavorited = true;\n} else { \/\/unfavoriting\nitem.setIcon(R.drawable.ic_favorite_border_white_24dp);\nitem.getIcon().setColorFilter(Color.parseColor(\"#ffffff\"), PorterDuff.Mode.SRC_IN);\nfavoritesList.remove(stopName);\nisFavorited = false;\n}\nSharedPreferences.Editor editor = sharedPreferences.edit();\neditor.putBoolean(stopName + \"Favorited\", isFavorited);\neditor.putString(stopName, stopId); \/\/Stores stop id value with stopName key\neditor.apply();\ngsonFileUtils.writeListToFile(favoritesList, this);\n}\n\nprivate void onHeartClicked(MenuItem item) {\nArrayList favoritesList = null;\nString filename = \"favorites.json\";\nFileInputStream inputStream = null;\ntry {\ninputStream = openFileInput(filename);\nString json = IOUtils.toString(inputStream, \"UTF-8\");\nGson gson = new Gson();\nfavoritesList = gson.fromJson(json, ArrayList.class);\ninputStream.close();\n} catch (IOException e) {\ne.printStackTrace();\n}\nif(favoritesList == null) return;\nSharedPreferences sharedPreferences = getSharedPreferences(\"pref\", Context.MODE_PRIVATE);\nBoolean isFavorited = sharedPreferences.getBoolean(stopName + \"Favorited\", false);\nif (!isFavorited) { \/\/favoriting\nitem.setIcon(R.drawable.ic_favorite_white_24dp);\nitem.getIcon().setColorFilter(ContextCompat.getColor(getApplicationContext(), R.color.colorAccent), PorterDuff.Mode.SRC_IN);\nfavoritesList.add(stopName); \/\/TODO make sure this doesn't break anything\nisFavorited = true;\n} else { \/\/unfavoriting\nitem.setIcon(R.drawable.ic_favorite_border_white_24dp);\nitem.getIcon().setColorFilter(Color.parseColor(\"#ffffff\"), PorterDuff.Mode.SRC_IN);\nfavoritesList.remove(stopName);\nisFavorited = false;\n}\nSharedPreferences.Editor editor = sharedPreferences.edit();\neditor.putBoolean(stopName + \"Favorited\", isFavorited);\neditor.putString(stopName, stopId); \/\/Stores stop id value with stopName key\neditor.apply();\ngsonFileUtils.writeListToFile(favoritesList, this);\n}\n\nArrayList favoritesList = null;\nString filename = \"favorites.json\";\nFileInputStream inputStream = null;\ntry {\ninputStream = openFileInput(filename);\nString json = IOUtils.toString(inputStream, \"UTF-8\");\nGson gson = new Gson();\nfavoritesList = gson.fromJson(json, ArrayList.class);\ninputStream.close();\n} catch (IOException e) {\ne.printStackTrace();\n}\nif(favoritesList == null) return;\nSharedPreferences sharedPreferences = getSharedPreferences(\"pref\", Context.MODE_PRIVATE);\nBoolean isFavorited = sharedPreferences.getBoolean(stopName + \"Favorited\", false);\nif (!isFavorited) { \/\/favoriting\nitem.setIcon(R.drawable.ic_favorite_white_24dp);\nitem.getIcon().setColorFilter(ContextCompat.getColor(getApplicationContext(), R.color.colorAccent), PorterDuff.Mode.SRC_IN);\nfavoritesList.add(stopName); \/\/TODO make sure this doesn't break anything\nisFavorited = true;\n} else { \/\/unfavoriting\nitem.setIcon(R.drawable.ic_favorite_border_white_24dp);\nitem.getIcon().setColorFilter(Color.parseColor(\"#ffffff\"), PorterDuff.Mode.SRC_IN);\nfavoritesList.remove(stopName);\nisFavorited = false;\n}\nSharedPreferences.Editor editor = sharedPreferences.edit();\neditor.putBoolean(stopName + \"Favorited\", isFavorited);\neditor.putString(stopName, stopId); \/\/Stores stop id value with stopName key\neditor.apply();\ngsonFileUtils.writeListToFile(favoritesList, this);\n}\n\ninputStream.close();\n} catch (IOException e) {\ne.printStackTrace();\n}\nif(favoritesList == null) return;\nSharedPreferences sharedPreferences = getSharedPreferences(\"pref\", Context.MODE_PRIVATE);\nBoolean isFavorited = sharedPreferences.getBoolean(stopName + \"Favorited\", false);\nif (!isFavorited) { \/\/favoriting\nitem.setIcon(R.drawable.ic_favorite_white_24dp);\nitem.getIcon().setColorFilter(ContextCompat.getColor(getApplicationContext(), R.color.colorAccent), PorterDuff.Mode.SRC_IN);\nfavoritesList.add(stopName); \/\/TODO make sure this doesn't break anything\nisFavorited = true;\n} else { \/\/unfavoriting\nitem.setIcon(R.drawable.ic_favorite_border_white_24dp);\nitem.getIcon().setColorFilter(Color.parseColor(\"#ffffff\"), PorterDuff.Mode.SRC_IN);\nfavoritesList.remove(stopName);\nisFavorited = false;\n}\nSharedPreferences.Editor editor = sharedPreferences.edit();\neditor.putBoolean(stopName + \"Favorited\", isFavorited);\neditor.putString(stopName, stopId); \/\/Stores stop id value with stopName key\neditor.apply();\ngsonFileUtils.writeListToFile(favoritesList, this);\n}","label":[0,0,1,0]}
{"id":11229,"original_code":"private void getStopLocation(String stopId) {\n        final RequestQueue queue = Volley.newRequestQueue(this);\n        Uri stopUrlUri = Uri.parse(getStopUrl)\n                .buildUpon()\n                .appendQueryParameter(key_param, getResources().getString(R.string.api_key))\n                .appendQueryParameter(stop_param, stopId)\n                .build();\n        String stopUrl = stopUrlUri.toString();\n        JsonObjectRequest locationRequest = new JsonObjectRequest(Request.Method.GET, stopUrl, null, new Response.Listener<JSONObject>() {\n            @Override\n            public void onResponse(JSONObject response) {\n                try {\n                    stopLatlon = new double[2];\n                    JSONArray stopsArray = response.getJSONArray(\"stops\");\n                    JSONObject stop = stopsArray.getJSONObject(0);\n                    JSONArray pointsArray = stop.getJSONArray(\"stop_points\");\n                    JSONObject point = pointsArray.getJSONObject(0); \/\/TODO: determine which corner I should use\n                    stopLatlon[0] = point.getDouble(\"stop_lat\");\n                    stopLatlon[1] = point.getDouble(\"stop_lon\");\n                } catch (JSONException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, new Response.ErrorListener() {\n            @Override\n            public void onErrorResponse(VolleyError error) {\n            }\n        });\n        queue.add(locationRequest);\n    }","code":"private void getStopLocation(String stopId) {\n        final RequestQueue queue = Volley.newRequestQueue(this);\n        Uri stopUrlUri = Uri.parse(getStopUrl)\n                .buildUpon()\n                .appendQueryParameter(key_param, getResources().getString(R.string.api_key))\n                .appendQueryParameter(stop_param, stopId)\n                .build();\n        String stopUrl = stopUrlUri.toString();\n        JsonObjectRequest locationRequest = new JsonObjectRequest(Request.Method.GET, stopUrl, null, new Response.Listener<JSONObject>() {\n            @Override\n            public void onResponse(JSONObject response) {\n                try {\n                    stopLatlon = new double[2];\n                    JSONArray stopsArray = response.getJSONArray(\"stops\");\n                    JSONObject stop = stopsArray.getJSONObject(0);\n                    JSONArray pointsArray = stop.getJSONArray(\"stop_points\");\n                    JSONObject point = pointsArray.getJSONObject(0);\n                    stopLatlon[0] = point.getDouble(\"stop_lat\");\n                    stopLatlon[1] = point.getDouble(\"stop_lon\");\n                } catch (JSONException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, new Response.ErrorListener() {\n            @Override\n            public void onErrorResponse(VolleyError error) {\n            }\n        });\n        queue.add(locationRequest);\n    }","cleancode":"private void getstoplocation(string stopid) { final requestqueue queue = volley.newrequestqueue(this); uri stopurluri = uri.parse(getstopurl) .buildupon() .appendqueryparameter(key_param, getresources().getstring(r.string.api_key)) .appendqueryparameter(stop_param, stopid) .build(); string stopurl = stopurluri.tostring(); jsonobjectrequest locationrequest = new jsonobjectrequest(request.method.get, stopurl, null, new response.listener<jsonobject>() { @override public void onresponse(jsonobject response) { try { stoplatlon = new double[2]; jsonarray stopsarray = response.getjsonarray(\"stops\"); jsonobject stop = stopsarray.getjsonobject(0); jsonarray pointsarray = stop.getjsonarray(\"stop_points\"); jsonobject point = pointsarray.getjsonobject(0); stoplatlon[0] = point.getdouble(\"stop_lat\"); stoplatlon[1] = point.getdouble(\"stop_lon\"); } catch (jsonexception e) { e.printstacktrace(); } } }, new response.errorlistener() { @override public void onerrorresponse(volleyerror error) { } }); queue.add(locationrequest); }","comment":"\/** * inserts values into stoplatlon with stop_id * @param stopid *\/\n\/\/todo: determine which corner i should use","repo":"Newbhope\/cu-bus","code_context_2":"private void getStopLocation(String stopId) {\nfinal RequestQueue queue = Volley.newRequestQueue(this);\nUri stopUrlUri = Uri.parse(getStopUrl)\n.buildUpon()\n.appendQueryParameter(key_param, getResources().getString(R.string.api_key))\n.appendQueryParameter(stop_param, stopId)\n.build();\nString stopUrl = stopUrlUri.toString();\nJsonObjectRequest locationRequest = new JsonObjectRequest(Request.Method.GET, stopUrl, null, new Response.Listener<JSONObject>() {\n@Override\npublic void onResponse(JSONObject response) {\ntry {\nstopLatlon = new double[2];\nJSONArray stopsArray = response.getJSONArray(\"stops\");\nJSONObject stop = stopsArray.getJSONObject(0);\nJSONArray pointsArray = stop.getJSONArray(\"stop_points\");\nJSONObject point = pointsArray.getJSONObject(0); \/\/TODO: determine which corner I should use\nstopLatlon[0] = point.getDouble(\"stop_lat\");\nstopLatlon[1] = point.getDouble(\"stop_lon\");\n} catch (JSONException e) {\ne.printStackTrace();\n}\n}\n}, new Response.ErrorListener() {\n@Override\npublic void onErrorResponse(VolleyError error) {\n}\n});\nqueue.add(locationRequest);\n}\n\nJSONObject stop = stopsArray.getJSONObject(0);\nJSONArray pointsArray = stop.getJSONArray(\"stop_points\");\nJSONObject point = pointsArray.getJSONObject(0); \/\/TODO: determine which corner I should use\nstopLatlon[0] = point.getDouble(\"stop_lat\");\nstopLatlon[1] = point.getDouble(\"stop_lon\");","code_context_10":"private void getStopLocation(String stopId) {\nfinal RequestQueue queue = Volley.newRequestQueue(this);\nUri stopUrlUri = Uri.parse(getStopUrl)\n.buildUpon()\n.appendQueryParameter(key_param, getResources().getString(R.string.api_key))\n.appendQueryParameter(stop_param, stopId)\n.build();\nString stopUrl = stopUrlUri.toString();\nJsonObjectRequest locationRequest = new JsonObjectRequest(Request.Method.GET, stopUrl, null, new Response.Listener<JSONObject>() {\n@Override\npublic void onResponse(JSONObject response) {\ntry {\nstopLatlon = new double[2];\nJSONArray stopsArray = response.getJSONArray(\"stops\");\nJSONObject stop = stopsArray.getJSONObject(0);\nJSONArray pointsArray = stop.getJSONArray(\"stop_points\");\nJSONObject point = pointsArray.getJSONObject(0); \/\/TODO: determine which corner I should use\nstopLatlon[0] = point.getDouble(\"stop_lat\");\nstopLatlon[1] = point.getDouble(\"stop_lon\");\n} catch (JSONException e) {\ne.printStackTrace();\n}\n}\n}, new Response.ErrorListener() {\n@Override\npublic void onErrorResponse(VolleyError error) {\n}\n});\nqueue.add(locationRequest);\n}\n\n.build();\nString stopUrl = stopUrlUri.toString();\nJsonObjectRequest locationRequest = new JsonObjectRequest(Request.Method.GET, stopUrl, null, new Response.Listener<JSONObject>() {\n@Override\npublic void onResponse(JSONObject response) {\ntry {\nstopLatlon = new double[2];\nJSONArray stopsArray = response.getJSONArray(\"stops\");\nJSONObject stop = stopsArray.getJSONObject(0);\nJSONArray pointsArray = stop.getJSONArray(\"stop_points\");\nJSONObject point = pointsArray.getJSONObject(0); \/\/TODO: determine which corner I should use\nstopLatlon[0] = point.getDouble(\"stop_lat\");\nstopLatlon[1] = point.getDouble(\"stop_lon\");\n} catch (JSONException e) {\ne.printStackTrace();\n}\n}\n}, new Response.ErrorListener() {\n@Override\npublic void onErrorResponse(VolleyError error) {\n}","code_context_20":"private void getStopLocation(String stopId) {\nfinal RequestQueue queue = Volley.newRequestQueue(this);\nUri stopUrlUri = Uri.parse(getStopUrl)\n.buildUpon()\n.appendQueryParameter(key_param, getResources().getString(R.string.api_key))\n.appendQueryParameter(stop_param, stopId)\n.build();\nString stopUrl = stopUrlUri.toString();\nJsonObjectRequest locationRequest = new JsonObjectRequest(Request.Method.GET, stopUrl, null, new Response.Listener<JSONObject>() {\n@Override\npublic void onResponse(JSONObject response) {\ntry {\nstopLatlon = new double[2];\nJSONArray stopsArray = response.getJSONArray(\"stops\");\nJSONObject stop = stopsArray.getJSONObject(0);\nJSONArray pointsArray = stop.getJSONArray(\"stop_points\");\nJSONObject point = pointsArray.getJSONObject(0); \/\/TODO: determine which corner I should use\nstopLatlon[0] = point.getDouble(\"stop_lat\");\nstopLatlon[1] = point.getDouble(\"stop_lon\");\n} catch (JSONException e) {\ne.printStackTrace();\n}\n}\n}, new Response.ErrorListener() {\n@Override\npublic void onErrorResponse(VolleyError error) {\n}\n});\nqueue.add(locationRequest);\n}\n\nprivate void getStopLocation(String stopId) {\nfinal RequestQueue queue = Volley.newRequestQueue(this);\nUri stopUrlUri = Uri.parse(getStopUrl)\n.buildUpon()\n.appendQueryParameter(key_param, getResources().getString(R.string.api_key))\n.appendQueryParameter(stop_param, stopId)\n.build();\nString stopUrl = stopUrlUri.toString();\nJsonObjectRequest locationRequest = new JsonObjectRequest(Request.Method.GET, stopUrl, null, new Response.Listener<JSONObject>() {\n@Override\npublic void onResponse(JSONObject response) {\ntry {\nstopLatlon = new double[2];\nJSONArray stopsArray = response.getJSONArray(\"stops\");\nJSONObject stop = stopsArray.getJSONObject(0);\nJSONArray pointsArray = stop.getJSONArray(\"stop_points\");\nJSONObject point = pointsArray.getJSONObject(0); \/\/TODO: determine which corner I should use\nstopLatlon[0] = point.getDouble(\"stop_lat\");\nstopLatlon[1] = point.getDouble(\"stop_lon\");\n} catch (JSONException e) {\ne.printStackTrace();\n}\n}\n}, new Response.ErrorListener() {\n@Override\npublic void onErrorResponse(VolleyError error) {\n}\n});\nqueue.add(locationRequest);\n}","label":[1,0,0,0]}
{"id":11234,"original_code":"private void buildWeightList(\n      List<TDataNodeInfo> onlineDataNodes, List<TRegionReplicaSet> allocatedRegions) {\n    \/\/ TODO: The remaining disk capacity of DataNode can also be calculated into the weightList\n    int maximumRegionNum = 0;\n    Map<TDataNodeLocation, Integer> countMap = new HashMap<>();\n    for (TDataNodeInfo dataNodeInfo : onlineDataNodes) {\n      maxId = Math.max(maxId, dataNodeInfo.getLocation().getDataNodeId());\n      countMap.put(dataNodeInfo.getLocation(), 0);\n    }\n    for (TRegionReplicaSet regionReplicaSet : allocatedRegions) {\n      for (TDataNodeLocation dataNodeLocation : regionReplicaSet.getDataNodeLocations()) {\n        countMap.computeIfPresent(dataNodeLocation, (dataNode, count) -> (count + 1));\n        maximumRegionNum = Math.max(maximumRegionNum, countMap.get(dataNodeLocation));\n      }\n    }\n    weightList = new ArrayList<>();\n    for (Map.Entry<TDataNodeLocation, Integer> countEntry : countMap.entrySet()) {\n      int weight = maximumRegionNum - countEntry.getValue() + 1;\n      \/\/ Repeatedly add DataNode copies equal to the number of their weights\n      for (int repeat = 0; repeat < weight; repeat++) {\n        weightList.add(countEntry.getKey().deepCopy());\n      }\n    }\n  }","code":"private void buildWeightList(\n      List<TDataNodeInfo> onlineDataNodes, List<TRegionReplicaSet> allocatedRegions) {\n   \n    int maximumRegionNum = 0;\n    Map<TDataNodeLocation, Integer> countMap = new HashMap<>();\n    for (TDataNodeInfo dataNodeInfo : onlineDataNodes) {\n      maxId = Math.max(maxId, dataNodeInfo.getLocation().getDataNodeId());\n      countMap.put(dataNodeInfo.getLocation(), 0);\n    }\n    for (TRegionReplicaSet regionReplicaSet : allocatedRegions) {\n      for (TDataNodeLocation dataNodeLocation : regionReplicaSet.getDataNodeLocations()) {\n        countMap.computeIfPresent(dataNodeLocation, (dataNode, count) -> (count + 1));\n        maximumRegionNum = Math.max(maximumRegionNum, countMap.get(dataNodeLocation));\n      }\n    }\n    weightList = new ArrayList<>();\n    for (Map.Entry<TDataNodeLocation, Integer> countEntry : countMap.entrySet()) {\n      int weight = maximumRegionNum - countEntry.getValue() + 1;\n     \n      for (int repeat = 0; repeat < weight; repeat++) {\n        weightList.add(countEntry.getKey().deepCopy());\n      }\n    }\n  }","cleancode":"private void buildweightlist( list<tdatanodeinfo> onlinedatanodes, list<tregionreplicaset> allocatedregions) { int maximumregionnum = 0; map<tdatanodelocation, integer> countmap = new hashmap<>(); for (tdatanodeinfo datanodeinfo : onlinedatanodes) { maxid = math.max(maxid, datanodeinfo.getlocation().getdatanodeid()); countmap.put(datanodeinfo.getlocation(), 0); } for (tregionreplicaset regionreplicaset : allocatedregions) { for (tdatanodelocation datanodelocation : regionreplicaset.getdatanodelocations()) { countmap.computeifpresent(datanodelocation, (datanode, count) -> (count + 1)); maximumregionnum = math.max(maximumregionnum, countmap.get(datanodelocation)); } } weightlist = new arraylist<>(); for (map.entry<tdatanodelocation, integer> countentry : countmap.entryset()) { int weight = maximumregionnum - countentry.getvalue() + 1; for (int repeat = 0; repeat < weight; repeat++) { weightlist.add(countentry.getkey().deepcopy()); } } }","comment":"\/\/ todo: the remaining disk capacity of datanode can also be calculated into the weightlist\n\/\/ repeatedly add datanode copies equal to the number of their weights","repo":"RYH61\/iotdb","code_context_2":"private void buildWeightList(\nList<TDataNodeInfo> onlineDataNodes, List<TRegionReplicaSet> allocatedRegions) {\n\/\/ TODO: The remaining disk capacity of DataNode can also be calculated into the weightList\nint maximumRegionNum = 0;\nMap<TDataNodeLocation, Integer> countMap = new HashMap<>();\n\nfor (Map.Entry<TDataNodeLocation, Integer> countEntry : countMap.entrySet()) {\nint weight = maximumRegionNum - countEntry.getValue() + 1;\n\/\/ Repeatedly add DataNode copies equal to the number of their weights\nfor (int repeat = 0; repeat < weight; repeat++) {\nweightList.add(countEntry.getKey().deepCopy());","code_context_10":"private void buildWeightList(\nList<TDataNodeInfo> onlineDataNodes, List<TRegionReplicaSet> allocatedRegions) {\n\/\/ TODO: The remaining disk capacity of DataNode can also be calculated into the weightList\nint maximumRegionNum = 0;\nMap<TDataNodeLocation, Integer> countMap = new HashMap<>();\nfor (TDataNodeInfo dataNodeInfo : onlineDataNodes) {\nmaxId = Math.max(maxId, dataNodeInfo.getLocation().getDataNodeId());\ncountMap.put(dataNodeInfo.getLocation(), 0);\n}\nfor (TRegionReplicaSet regionReplicaSet : allocatedRegions) {\nfor (TDataNodeLocation dataNodeLocation : regionReplicaSet.getDataNodeLocations()) {\ncountMap.computeIfPresent(dataNodeLocation, (dataNode, count) -> (count + 1));\nmaximumRegionNum = Math.max(maximumRegionNum, countMap.get(dataNodeLocation));\n\n}\nfor (TRegionReplicaSet regionReplicaSet : allocatedRegions) {\nfor (TDataNodeLocation dataNodeLocation : regionReplicaSet.getDataNodeLocations()) {\ncountMap.computeIfPresent(dataNodeLocation, (dataNode, count) -> (count + 1));\nmaximumRegionNum = Math.max(maximumRegionNum, countMap.get(dataNodeLocation));\n}\n}\nweightList = new ArrayList<>();\nfor (Map.Entry<TDataNodeLocation, Integer> countEntry : countMap.entrySet()) {\nint weight = maximumRegionNum - countEntry.getValue() + 1;\n\/\/ Repeatedly add DataNode copies equal to the number of their weights\nfor (int repeat = 0; repeat < weight; repeat++) {\nweightList.add(countEntry.getKey().deepCopy());\n}\n}\n}","code_context_20":"private void buildWeightList(\nList<TDataNodeInfo> onlineDataNodes, List<TRegionReplicaSet> allocatedRegions) {\n\/\/ TODO: The remaining disk capacity of DataNode can also be calculated into the weightList\nint maximumRegionNum = 0;\nMap<TDataNodeLocation, Integer> countMap = new HashMap<>();\nfor (TDataNodeInfo dataNodeInfo : onlineDataNodes) {\nmaxId = Math.max(maxId, dataNodeInfo.getLocation().getDataNodeId());\ncountMap.put(dataNodeInfo.getLocation(), 0);\n}\nfor (TRegionReplicaSet regionReplicaSet : allocatedRegions) {\nfor (TDataNodeLocation dataNodeLocation : regionReplicaSet.getDataNodeLocations()) {\ncountMap.computeIfPresent(dataNodeLocation, (dataNode, count) -> (count + 1));\nmaximumRegionNum = Math.max(maximumRegionNum, countMap.get(dataNodeLocation));\n}\n}\nweightList = new ArrayList<>();\nfor (Map.Entry<TDataNodeLocation, Integer> countEntry : countMap.entrySet()) {\nint weight = maximumRegionNum - countEntry.getValue() + 1;\n\/\/ Repeatedly add DataNode copies equal to the number of their weights\nfor (int repeat = 0; repeat < weight; repeat++) {\nweightList.add(countEntry.getKey().deepCopy());\n}\n}\n\nprivate void buildWeightList(\nList<TDataNodeInfo> onlineDataNodes, List<TRegionReplicaSet> allocatedRegions) {\n\/\/ TODO: The remaining disk capacity of DataNode can also be calculated into the weightList\nint maximumRegionNum = 0;\nMap<TDataNodeLocation, Integer> countMap = new HashMap<>();\nfor (TDataNodeInfo dataNodeInfo : onlineDataNodes) {\nmaxId = Math.max(maxId, dataNodeInfo.getLocation().getDataNodeId());\ncountMap.put(dataNodeInfo.getLocation(), 0);\n}\nfor (TRegionReplicaSet regionReplicaSet : allocatedRegions) {\nfor (TDataNodeLocation dataNodeLocation : regionReplicaSet.getDataNodeLocations()) {\ncountMap.computeIfPresent(dataNodeLocation, (dataNode, count) -> (count + 1));\nmaximumRegionNum = Math.max(maximumRegionNum, countMap.get(dataNodeLocation));\n}\n}\nweightList = new ArrayList<>();\nfor (Map.Entry<TDataNodeLocation, Integer> countEntry : countMap.entrySet()) {\nint weight = maximumRegionNum - countEntry.getValue() + 1;\n\/\/ Repeatedly add DataNode copies equal to the number of their weights\nfor (int repeat = 0; repeat < weight; repeat++) {\nweightList.add(countEntry.getKey().deepCopy());\n}\n}\n}","label":[1,0,0,0]}
{"id":11434,"original_code":"public static Connection getConnectionDB() {\n\t\tFile dbDir = new File(CoreContext.DB_DATA_PATH);\n\t\tif (!dbDir.exists()) dbDir.mkdir();\n\t\tConnection connection = null;\n\t\ttry {\n\t\t\t\/\/ \u0435\u0441\u043b\u0438 \u0431\u0430\u0437\u044b \u043d\u0435\u0442, \u0442\u043e \u043e\u043d\u0430 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u0430 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438,\n\t\t\t\/\/ \u0438\u043d\u0430\u0447\u0435 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0439 \u0431\u0430\u0437\u0435\n\t\t\tconnection = DriverManager.getConnection(\n\t\t\t\t\t\"jdbc:hsqldb:file:\" + dbDir.getPath() + File.separator\n\t\t\t\t\t\t\t+ CoreContext.DB_LIBRARY_FILE_NAME, \"SA\", \"\");\n\t\t} catch (SQLException e) {\n\t\t\t\/\/ TODO change to log\n\t\t\tSystem.err.println(\"ERROR: failed to create connection with db\");\n\t\t\te.printStackTrace();\n\t\t\t\/\/ TODO change System.exit(1)\n\t\t\tSystem.exit(1);\n\t\t}\n\t\t\/\/ TODO version db\n\/\/\t\tSQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(\n\/\/\t\t\t\tnew File(dbDir, CoreContext.DB_LIBRARY_FILE_NAME), null);\n\/\/\n\/\/\t\tif (db.getVersion() != version) {\n\/\/\t\t\tdb.beginTransaction();\n\/\/\t\t\ttry {\n\/\/\t\t\t\tint currVersion = db.getVersion();\n\/\/\t\t\t\tif (currVersion == 0) {\n\/\/\t\t\t\t\tonCreate(db);\n\/\/\t\t\t\t};\n\/\/\t\t\t\tonUpgrade(db, currVersion);\n\/\/\t\t\t\tdb.setVersion(version);\n\/\/\t\t\t\tdb.setTransactionSuccessful();\n\/\/\t\t\t} finally {\n\/\/\t\t\t\tdb.endTransaction();\n\/\/\t\t\t}\n\/\/\t\t}\n\t\treturn connection;\n\t}","code":"public static Connection getConnectionDB() {\n\t\tFile dbDir = new File(CoreContext.DB_DATA_PATH);\n\t\tif (!dbDir.exists()) dbDir.mkdir();\n\t\tConnection connection = null;\n\t\ttry {\n\t\t\n\t\t\t\t\t\"jdbc:hsqldb:file:\" + dbDir.getPath() + File.separator\n\t\t\t\t\t\t\t+ CoreContext.DB_LIBRARY_FILE_NAME, \"SA\", \"\");\n\t\t} catch (SQLException e) {\n\t\t\n\t\t\tSystem.err.println(\"ERROR: failed to create connection with db\");\n\t\t\te.printStackTrace();\n\t\t\n\t\t\tSystem.exit(1);\n\t\t}\n\t\n\t\treturn connection;\n\t}","cleancode":"public static connection getconnectiondb() { file dbdir = new file(corecontext.db_data_path); if (!dbdir.exists()) dbdir.mkdir(); connection connection = null; try { \"jdbc:hsqldb:file:\" + dbdir.getpath() + file.separator + corecontext.db_library_file_name, \"sa\", \"\"); } catch (sqlexception e) { system.err.println(\"error: failed to create connection with db\"); e.printstacktrace(); system.exit(1); } return connection; }","comment":"\/\/ public static sqlitedatabase getconnectiondb() {\n\/\/ \u0435\u0441\u043b\u0438 \u0431\u0430\u0437\u044b \u043d\u0435\u0442, \u0442\u043e \u043e\u043d\u0430 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u0430 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438, \/\/ \u0438\u043d\u0430\u0447\u0435 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0439 \u0431\u0430\u0437\u0435\n\/\/ todo change to log\n\/\/ todo change system.exit(1)\n\/\/ todo version db \/\/ sqlitedatabase db = sqlitedatabase.openorcreatedatabase( \/\/ new file(dbdir, corecontext.db_library_file_name), null); \/\/ \/\/ if (db.getversion() != version) { \/\/ db.begintransaction(); \/\/ try { \/\/ int currversion = db.getversion(); \/\/ if (currversion == 0) { \/\/ oncreate(db); \/\/ }; \/\/ onupgrade(db, currversion); \/\/ db.setversion(version); \/\/ db.settransactionsuccessful(); \/\/ } finally { \/\/ db.endtransaction(); \/\/ } \/\/ }","repo":"NikitaFeodonit\/bqtj","code_context_2":"public static Connection getConnectionDB() {\nFile dbDir = new File(CoreContext.DB_DATA_PATH);\nif (!dbDir.exists()) dbDir.mkdir();\nConnection connection = null;\ntry {\n\/\/ \u0435\u0441\u043b\u0438 \u0431\u0430\u0437\u044b \u043d\u0435\u0442, \u0442\u043e \u043e\u043d\u0430 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u0430 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438,\n\/\/ \u0438\u043d\u0430\u0447\u0435 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0439 \u0431\u0430\u0437\u0435\nconnection = DriverManager.getConnection(\n\"jdbc:hsqldb:file:\" + dbDir.getPath() + File.separator\n+ CoreContext.DB_LIBRARY_FILE_NAME, \"SA\", \"\");\n} catch (SQLException e) {\n\/\/ TODO change to log\nSystem.err.println(\"ERROR: failed to create connection with db\");\ne.printStackTrace();\n\/\/ TODO change System.exit(1)\nSystem.exit(1);\n}\n\/\/ TODO version db\n\/\/ SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(\n\/\/ new File(dbDir, CoreContext.DB_LIBRARY_FILE_NAME), null);\n\/\/\n\/\/ if (db.getVersion() != version) {\n\/\/ db.beginTransaction();\n\/\/ try {\n\/\/ int currVersion = db.getVersion();\n\/\/ if (currVersion == 0) {\n\/\/ onCreate(db);\n\/\/ };\n\/\/ onUpgrade(db, currVersion);\n\/\/ db.setVersion(version);\n\/\/ db.setTransactionSuccessful();\n\/\/ } finally {\n\/\/ db.endTransaction();\n\/\/ }\n\/\/ }\nreturn connection;\n}\n\nConnection connection = null;\ntry {\n\/\/ \u0435\u0441\u043b\u0438 \u0431\u0430\u0437\u044b \u043d\u0435\u0442, \u0442\u043e \u043e\u043d\u0430 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u0430 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438,\n\/\/ \u0438\u043d\u0430\u0447\u0435 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0439 \u0431\u0430\u0437\u0435\nconnection = DriverManager.getConnection(\n\"jdbc:hsqldb:file:\" + dbDir.getPath() + File.separator\n\n+ CoreContext.DB_LIBRARY_FILE_NAME, \"SA\", \"\");\n} catch (SQLException e) {\n\/\/ TODO change to log\nSystem.err.println(\"ERROR: failed to create connection with db\");\ne.printStackTrace();\n\nSystem.err.println(\"ERROR: failed to create connection with db\");\ne.printStackTrace();\n\/\/ TODO change System.exit(1)\nSystem.exit(1);\n}\n\nSystem.exit(1);\n}\n\/\/ TODO version db\n\/\/ SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(\n\/\/ new File(dbDir, CoreContext.DB_LIBRARY_FILE_NAME), null);\n\/\/\n\/\/ if (db.getVersion() != version) {\n\/\/ db.beginTransaction();\n\/\/ try {\n\/\/ int currVersion = db.getVersion();\n\/\/ if (currVersion == 0) {\n\/\/ onCreate(db);\n\/\/ };\n\/\/ onUpgrade(db, currVersion);\n\/\/ db.setVersion(version);\n\/\/ db.setTransactionSuccessful();\n\/\/ } finally {\n\/\/ db.endTransaction();\n\/\/ }\n\/\/ }\nreturn connection;\n}","code_context_10":"public static Connection getConnectionDB() {\nFile dbDir = new File(CoreContext.DB_DATA_PATH);\nif (!dbDir.exists()) dbDir.mkdir();\nConnection connection = null;\ntry {\n\/\/ \u0435\u0441\u043b\u0438 \u0431\u0430\u0437\u044b \u043d\u0435\u0442, \u0442\u043e \u043e\u043d\u0430 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u0430 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438,\n\/\/ \u0438\u043d\u0430\u0447\u0435 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0439 \u0431\u0430\u0437\u0435\nconnection = DriverManager.getConnection(\n\"jdbc:hsqldb:file:\" + dbDir.getPath() + File.separator\n+ CoreContext.DB_LIBRARY_FILE_NAME, \"SA\", \"\");\n} catch (SQLException e) {\n\/\/ TODO change to log\nSystem.err.println(\"ERROR: failed to create connection with db\");\ne.printStackTrace();\n\/\/ TODO change System.exit(1)\nSystem.exit(1);\n}\n\/\/ TODO version db\n\/\/ SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(\n\/\/ new File(dbDir, CoreContext.DB_LIBRARY_FILE_NAME), null);\n\/\/\n\/\/ if (db.getVersion() != version) {\n\/\/ db.beginTransaction();\n\/\/ try {\n\/\/ int currVersion = db.getVersion();\n\/\/ if (currVersion == 0) {\n\/\/ onCreate(db);\n\/\/ };\n\/\/ onUpgrade(db, currVersion);\n\/\/ db.setVersion(version);\n\/\/ db.setTransactionSuccessful();\n\/\/ } finally {\n\/\/ db.endTransaction();\n\/\/ }\n\/\/ }\nreturn connection;\n}\n\npublic static Connection getConnectionDB() {\nFile dbDir = new File(CoreContext.DB_DATA_PATH);\nif (!dbDir.exists()) dbDir.mkdir();\nConnection connection = null;\ntry {\n\/\/ \u0435\u0441\u043b\u0438 \u0431\u0430\u0437\u044b \u043d\u0435\u0442, \u0442\u043e \u043e\u043d\u0430 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u0430 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438,\n\/\/ \u0438\u043d\u0430\u0447\u0435 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0439 \u0431\u0430\u0437\u0435\nconnection = DriverManager.getConnection(\n\"jdbc:hsqldb:file:\" + dbDir.getPath() + File.separator\n+ CoreContext.DB_LIBRARY_FILE_NAME, \"SA\", \"\");\n} catch (SQLException e) {\n\/\/ TODO change to log\nSystem.err.println(\"ERROR: failed to create connection with db\");\ne.printStackTrace();\n\/\/ TODO change System.exit(1)\nSystem.exit(1);\n}\n\nFile dbDir = new File(CoreContext.DB_DATA_PATH);\nif (!dbDir.exists()) dbDir.mkdir();\nConnection connection = null;\ntry {\n\/\/ \u0435\u0441\u043b\u0438 \u0431\u0430\u0437\u044b \u043d\u0435\u0442, \u0442\u043e \u043e\u043d\u0430 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u0430 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438,\n\/\/ \u0438\u043d\u0430\u0447\u0435 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0439 \u0431\u0430\u0437\u0435\nconnection = DriverManager.getConnection(\n\"jdbc:hsqldb:file:\" + dbDir.getPath() + File.separator\n+ CoreContext.DB_LIBRARY_FILE_NAME, \"SA\", \"\");\n} catch (SQLException e) {\n\/\/ TODO change to log\nSystem.err.println(\"ERROR: failed to create connection with db\");\ne.printStackTrace();\n\/\/ TODO change System.exit(1)\nSystem.exit(1);\n}\n\/\/ TODO version db\n\/\/ SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(\n\/\/ new File(dbDir, CoreContext.DB_LIBRARY_FILE_NAME), null);\n\/\/\n\/\/ if (db.getVersion() != version) {\n\ntry {\n\/\/ \u0435\u0441\u043b\u0438 \u0431\u0430\u0437\u044b \u043d\u0435\u0442, \u0442\u043e \u043e\u043d\u0430 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u0430 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438,\n\/\/ \u0438\u043d\u0430\u0447\u0435 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0439 \u0431\u0430\u0437\u0435\nconnection = DriverManager.getConnection(\n\"jdbc:hsqldb:file:\" + dbDir.getPath() + File.separator\n+ CoreContext.DB_LIBRARY_FILE_NAME, \"SA\", \"\");\n} catch (SQLException e) {\n\/\/ TODO change to log\nSystem.err.println(\"ERROR: failed to create connection with db\");\ne.printStackTrace();\n\/\/ TODO change System.exit(1)\nSystem.exit(1);\n}\n\/\/ TODO version db\n\/\/ SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(\n\/\/ new File(dbDir, CoreContext.DB_LIBRARY_FILE_NAME), null);\n\/\/\n\/\/ if (db.getVersion() != version) {\n\/\/ db.beginTransaction();\n\/\/ try {\n\/\/ int currVersion = db.getVersion();\n\nconnection = DriverManager.getConnection(\n\"jdbc:hsqldb:file:\" + dbDir.getPath() + File.separator\n+ CoreContext.DB_LIBRARY_FILE_NAME, \"SA\", \"\");\n} catch (SQLException e) {\n\/\/ TODO change to log\nSystem.err.println(\"ERROR: failed to create connection with db\");\ne.printStackTrace();\n\/\/ TODO change System.exit(1)\nSystem.exit(1);\n}\n\/\/ TODO version db\n\/\/ SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(\n\/\/ new File(dbDir, CoreContext.DB_LIBRARY_FILE_NAME), null);\n\/\/\n\/\/ if (db.getVersion() != version) {\n\/\/ db.beginTransaction();\n\/\/ try {\n\/\/ int currVersion = db.getVersion();\n\/\/ if (currVersion == 0) {\n\/\/ onCreate(db);\n\/\/ };\n\/\/ onUpgrade(db, currVersion);\n\/\/ db.setVersion(version);\n\/\/ db.setTransactionSuccessful();\n\/\/ } finally {\n\/\/ db.endTransaction();\n\/\/ }\n\/\/ }\nreturn connection;\n}","code_context_20":"public static Connection getConnectionDB() {\nFile dbDir = new File(CoreContext.DB_DATA_PATH);\nif (!dbDir.exists()) dbDir.mkdir();\nConnection connection = null;\ntry {\n\/\/ \u0435\u0441\u043b\u0438 \u0431\u0430\u0437\u044b \u043d\u0435\u0442, \u0442\u043e \u043e\u043d\u0430 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u0430 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438,\n\/\/ \u0438\u043d\u0430\u0447\u0435 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0439 \u0431\u0430\u0437\u0435\nconnection = DriverManager.getConnection(\n\"jdbc:hsqldb:file:\" + dbDir.getPath() + File.separator\n+ CoreContext.DB_LIBRARY_FILE_NAME, \"SA\", \"\");\n} catch (SQLException e) {\n\/\/ TODO change to log\nSystem.err.println(\"ERROR: failed to create connection with db\");\ne.printStackTrace();\n\/\/ TODO change System.exit(1)\nSystem.exit(1);\n}\n\/\/ TODO version db\n\/\/ SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(\n\/\/ new File(dbDir, CoreContext.DB_LIBRARY_FILE_NAME), null);\n\/\/\n\/\/ if (db.getVersion() != version) {\n\/\/ db.beginTransaction();\n\/\/ try {\n\/\/ int currVersion = db.getVersion();\n\/\/ if (currVersion == 0) {\n\/\/ onCreate(db);\n\/\/ };\n\/\/ onUpgrade(db, currVersion);\n\/\/ db.setVersion(version);\n\/\/ db.setTransactionSuccessful();\n\/\/ } finally {\n\/\/ db.endTransaction();\n\/\/ }\n\/\/ }\nreturn connection;\n}\n\npublic static Connection getConnectionDB() {\nFile dbDir = new File(CoreContext.DB_DATA_PATH);\nif (!dbDir.exists()) dbDir.mkdir();\nConnection connection = null;\ntry {\n\/\/ \u0435\u0441\u043b\u0438 \u0431\u0430\u0437\u044b \u043d\u0435\u0442, \u0442\u043e \u043e\u043d\u0430 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u0430 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438,\n\/\/ \u0438\u043d\u0430\u0447\u0435 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0439 \u0431\u0430\u0437\u0435\nconnection = DriverManager.getConnection(\n\"jdbc:hsqldb:file:\" + dbDir.getPath() + File.separator\n+ CoreContext.DB_LIBRARY_FILE_NAME, \"SA\", \"\");\n} catch (SQLException e) {\n\/\/ TODO change to log\nSystem.err.println(\"ERROR: failed to create connection with db\");\ne.printStackTrace();\n\/\/ TODO change System.exit(1)\nSystem.exit(1);\n}\n\/\/ TODO version db\n\/\/ SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(\n\/\/ new File(dbDir, CoreContext.DB_LIBRARY_FILE_NAME), null);\n\/\/\n\/\/ if (db.getVersion() != version) {\n\/\/ db.beginTransaction();\n\/\/ try {\n\/\/ int currVersion = db.getVersion();\n\/\/ if (currVersion == 0) {\n\/\/ onCreate(db);\n\npublic static Connection getConnectionDB() {\nFile dbDir = new File(CoreContext.DB_DATA_PATH);\nif (!dbDir.exists()) dbDir.mkdir();\nConnection connection = null;\ntry {\n\/\/ \u0435\u0441\u043b\u0438 \u0431\u0430\u0437\u044b \u043d\u0435\u0442, \u0442\u043e \u043e\u043d\u0430 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u0430 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438,\n\/\/ \u0438\u043d\u0430\u0447\u0435 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0439 \u0431\u0430\u0437\u0435\nconnection = DriverManager.getConnection(\n\"jdbc:hsqldb:file:\" + dbDir.getPath() + File.separator\n+ CoreContext.DB_LIBRARY_FILE_NAME, \"SA\", \"\");\n} catch (SQLException e) {\n\/\/ TODO change to log\nSystem.err.println(\"ERROR: failed to create connection with db\");\ne.printStackTrace();\n\/\/ TODO change System.exit(1)\nSystem.exit(1);\n}\n\/\/ TODO version db\n\/\/ SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(\n\/\/ new File(dbDir, CoreContext.DB_LIBRARY_FILE_NAME), null);\n\/\/\n\/\/ if (db.getVersion() != version) {\n\/\/ db.beginTransaction();\n\/\/ try {\n\/\/ int currVersion = db.getVersion();\n\/\/ if (currVersion == 0) {\n\/\/ onCreate(db);\n\/\/ };\n\/\/ onUpgrade(db, currVersion);\n\/\/ db.setVersion(version);\n\/\/ db.setTransactionSuccessful();\n\/\/ } finally {\n\npublic static Connection getConnectionDB() {\nFile dbDir = new File(CoreContext.DB_DATA_PATH);\nif (!dbDir.exists()) dbDir.mkdir();\nConnection connection = null;\ntry {\n\/\/ \u0435\u0441\u043b\u0438 \u0431\u0430\u0437\u044b \u043d\u0435\u0442, \u0442\u043e \u043e\u043d\u0430 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u0430 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438,\n\/\/ \u0438\u043d\u0430\u0447\u0435 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0439 \u0431\u0430\u0437\u0435\nconnection = DriverManager.getConnection(\n\"jdbc:hsqldb:file:\" + dbDir.getPath() + File.separator\n+ CoreContext.DB_LIBRARY_FILE_NAME, \"SA\", \"\");\n} catch (SQLException e) {\n\/\/ TODO change to log\nSystem.err.println(\"ERROR: failed to create connection with db\");\ne.printStackTrace();\n\/\/ TODO change System.exit(1)\nSystem.exit(1);\n}\n\/\/ TODO version db\n\/\/ SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(\n\/\/ new File(dbDir, CoreContext.DB_LIBRARY_FILE_NAME), null);\n\/\/\n\/\/ if (db.getVersion() != version) {\n\/\/ db.beginTransaction();\n\/\/ try {\n\/\/ int currVersion = db.getVersion();\n\/\/ if (currVersion == 0) {\n\/\/ onCreate(db);\n\/\/ };\n\/\/ onUpgrade(db, currVersion);\n\/\/ db.setVersion(version);\n\/\/ db.setTransactionSuccessful();\n\/\/ } finally {\n\/\/ db.endTransaction();\n\/\/ }\n\/\/ }\n\npublic static Connection getConnectionDB() {\nFile dbDir = new File(CoreContext.DB_DATA_PATH);\nif (!dbDir.exists()) dbDir.mkdir();\nConnection connection = null;\ntry {\n\/\/ \u0435\u0441\u043b\u0438 \u0431\u0430\u0437\u044b \u043d\u0435\u0442, \u0442\u043e \u043e\u043d\u0430 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u0430 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438,\n\/\/ \u0438\u043d\u0430\u0447\u0435 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0439 \u0431\u0430\u0437\u0435\nconnection = DriverManager.getConnection(\n\"jdbc:hsqldb:file:\" + dbDir.getPath() + File.separator\n+ CoreContext.DB_LIBRARY_FILE_NAME, \"SA\", \"\");\n} catch (SQLException e) {\n\/\/ TODO change to log\nSystem.err.println(\"ERROR: failed to create connection with db\");\ne.printStackTrace();\n\/\/ TODO change System.exit(1)\nSystem.exit(1);\n}\n\/\/ TODO version db\n\/\/ SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(\n\/\/ new File(dbDir, CoreContext.DB_LIBRARY_FILE_NAME), null);\n\/\/\n\/\/ if (db.getVersion() != version) {\n\/\/ db.beginTransaction();\n\/\/ try {\n\/\/ int currVersion = db.getVersion();\n\/\/ if (currVersion == 0) {\n\/\/ onCreate(db);\n\/\/ };\n\/\/ onUpgrade(db, currVersion);\n\/\/ db.setVersion(version);\n\/\/ db.setTransactionSuccessful();\n\/\/ } finally {\n\/\/ db.endTransaction();\n\/\/ }\n\/\/ }\nreturn connection;\n}","label":[1,1,0,0]}
{"id":3313,"original_code":"public void setOverrides(final LegacyOverridesMixin overrides) {\n        this.overrides = overrides;\n    }","code":"public void setOverrides(final LegacyOverridesMixin overrides) {\n        this.overrides = overrides;\n    }","cleancode":"public void setoverrides(final legacyoverridesmixin overrides) { this.overrides = overrides; }","comment":"\/\/ todo: remove. here for testing","repo":"KellyShao\/tessera","code_context_2":"public void setOverrides(final LegacyOverridesMixin overrides) {\nthis.overrides = overrides;\n}","code_context_10":"public void setOverrides(final LegacyOverridesMixin overrides) {\nthis.overrides = overrides;\n}","code_context_20":"public void setOverrides(final LegacyOverridesMixin overrides) {\nthis.overrides = overrides;\n}","label":[0,0,0,1]}
{"id":19819,"original_code":"private float getFuelAbsorptionCoefficient() {\n\t\t\/\/ TODO: Lookup type of fuel and get data from there\n\t\treturn 0.5f;\n\t}","code":"private float getFuelAbsorptionCoefficient() {\n\t\n\t\treturn 0.5f;\n\t}","cleancode":"private float getfuelabsorptioncoefficient() { return 0.5f; }","comment":"\/\/ 0..1. how well does this fuel absorb radiation?\n\/\/ todo: lookup type of fuel and get data from there","repo":"RAFIWE\/BigReactors-1.7.10-Fixed","code_context_2":"private float getFuelAbsorptionCoefficient() {\n\/\/ TODO: Lookup type of fuel and get data from there\nreturn 0.5f;\n}\n\nprivate float getFuelAbsorptionCoefficient() {\n\/\/ TODO: Lookup type of fuel and get data from there\nreturn 0.5f;\n}","code_context_10":"private float getFuelAbsorptionCoefficient() {\n\/\/ TODO: Lookup type of fuel and get data from there\nreturn 0.5f;\n}\n\nprivate float getFuelAbsorptionCoefficient() {\n\/\/ TODO: Lookup type of fuel and get data from there\nreturn 0.5f;\n}","code_context_20":"private float getFuelAbsorptionCoefficient() {\n\/\/ TODO: Lookup type of fuel and get data from there\nreturn 0.5f;\n}\n\nprivate float getFuelAbsorptionCoefficient() {\n\/\/ TODO: Lookup type of fuel and get data from there\nreturn 0.5f;\n}","label":[0,1,0,0]}
{"id":3445,"original_code":"@Override\n    public void teleopPeriodic()\n    {\n        SmartDashboard.putString(\"Robot\/GamePhase\", \"TELEOP\");\n        double timestamp = Timer.getFPGATimestamp();\n        double throttle = mControlBoard.getThrottle();\n        double turn = mControlBoard.getTurn();\n        try\n        {\n            if (mSuperstructure.isDriverControlled())\n            {\n                DriveSignal command = ArcadeDriveHelper.arcadeDrive(mControlBoard.getThrottle(), mControlBoard.getTurn(),\n                    true \/* TODO: Decide squared inputs or not *\/).scale(mSuperstructure.isDrivingReversed() ? -1 : 1)\/*.scale(6)*\/;\n                mDrive.setOpenLoop(command);\n                \/\/ mDrive.setVelocity(command, new DriveSignal(\n                \/\/     command.scale(Constants.kDriveLeftKv).getLeft() + Math.copySign(Constants.kDriveLeftVIntercept, command.getLeft()),\n                \/\/     command.scale(Constants.kDriveLeftKv).getRight() + Math.copySign(Constants.kDriveLeftVIntercept, command.getRight())\n                \/\/ ));\n                if(mControlBoard.getEjectPanel())\n                    mPanelHandler.setWantedState(PanelHandler.WantedState.EJECT);\n                if(mControlBoard.getIntake())\n                    mCargoIntake.setWantedState(CargoIntake.WantedState.INTAKE);\n                if(mControlBoard.getTestButtonOne())\n                    mCargoIntake.setWantedState(CargoIntake.WantedState.HOLD);\n                if(mControlBoard.getEjectCargo())\n                    mCargoIntake.setWantedState(CargoIntake.WantedState.EJECT);\n                if(mControlBoard.getTestButtonTwo())\n                    mPanelHandler.checkSystem(\"variant\");\n                if (mControlBoard.getReverseDirection())\n                {\n                    mSuperstructure.reverseDrivingDirection();\n                }\n                else if (mControlBoard.getDriveToSelectedTarget())\n                {\n                    mSuperstructure.setWantedState(Superstructure.WantedState.ALIGN_AND_INTAKE_CARGO);\n                }\n                else if (mControlBoard.getClimb()) \n                {\n                    mSuperstructure.setWantedState(Superstructure.WantedState.CLIMB);\n                }\n                \/\/ TODO (for button person): add buttons for all superstructure wanted states\n            }\n            else if (mControlBoard.getReturnToDriverControl())\n            {\n                mSuperstructure.setWantedState(Superstructure.WantedState.DRIVER_CONTROL);\n            }\n        }\n        catch (Throwable t)\n        {\n            Logger.logThrowableCrash(t);\n            throw t;\n        }\n        outputToSmartDashboard();\n    }","code":"@Override\n    public void teleopPeriodic()\n    {\n        SmartDashboard.putString(\"Robot\/GamePhase\", \"TELEOP\");\n        double timestamp = Timer.getFPGATimestamp();\n        double throttle = mControlBoard.getThrottle();\n        double turn = mControlBoard.getTurn();\n        try\n        {\n            if (mSuperstructure.isDriverControlled())\n            {\n                DriveSignal command = ArcadeDriveHelper.arcadeDrive(mControlBoard.getThrottle(), mControlBoard.getTurn(),\n                    true).scale(mSuperstructure.isDrivingReversed() ? -1 : 1;\n                mDrive.setOpenLoop(command);\n               \n               \n               \n               \n                if(mControlBoard.getEjectPanel())\n                    mPanelHandler.setWantedState(PanelHandler.WantedState.EJECT);\n                if(mControlBoard.getIntake())\n                    mCargoIntake.setWantedState(CargoIntake.WantedState.INTAKE);\n                if(mControlBoard.getTestButtonOne())\n                    mCargoIntake.setWantedState(CargoIntake.WantedState.HOLD);\n                if(mControlBoard.getEjectCargo())\n                    mCargoIntake.setWantedState(CargoIntake.WantedState.EJECT);\n                if(mControlBoard.getTestButtonTwo())\n                    mPanelHandler.checkSystem(\"variant\");\n                if (mControlBoard.getReverseDirection())\n                {\n                    mSuperstructure.reverseDrivingDirection();\n                }\n                else if (mControlBoard.getDriveToSelectedTarget())\n                {\n                    mSuperstructure.setWantedState(Superstructure.WantedState.ALIGN_AND_INTAKE_CARGO);\n                }\n                else if (mControlBoard.getClimb()) \n                {\n                    mSuperstructure.setWantedState(Superstructure.WantedState.CLIMB);\n                }\n               \n            }\n            else if (mControlBoard.getReturnToDriverControl())\n            {\n                mSuperstructure.setWantedState(Superstructure.WantedState.DRIVER_CONTROL);\n            }\n        }\n        catch (Throwable t)\n        {\n            Logger.logThrowableCrash(t);\n            throw t;\n        }\n        outputToSmartDashboard();\n    }","cleancode":"@override public void teleopperiodic() { smartdashboard.putstring(\"robot\/gamephase\", \"teleop\"); double timestamp = timer.getfpgatimestamp(); double throttle = mcontrolboard.getthrottle(); double turn = mcontrolboard.getturn(); try { if (msuperstructure.isdrivercontrolled()) { drivesignal command = arcadedrivehelper.arcadedrive(mcontrolboard.getthrottle(), mcontrolboard.getturn(), true).scale(msuperstructure.isdrivingreversed() ? -1 : 1; mdrive.setopenloop(command); if(mcontrolboard.getejectpanel()) mpanelhandler.setwantedstate(panelhandler.wantedstate.eject); if(mcontrolboard.getintake()) mcargointake.setwantedstate(cargointake.wantedstate.intake); if(mcontrolboard.gettestbuttonone()) mcargointake.setwantedstate(cargointake.wantedstate.hold); if(mcontrolboard.getejectcargo()) mcargointake.setwantedstate(cargointake.wantedstate.eject); if(mcontrolboard.gettestbuttontwo()) mpanelhandler.checksystem(\"variant\"); if (mcontrolboard.getreversedirection()) { msuperstructure.reversedrivingdirection(); } else if (mcontrolboard.getdrivetoselectedtarget()) { msuperstructure.setwantedstate(superstructure.wantedstate.align_and_intake_cargo); } else if (mcontrolboard.getclimb()) { msuperstructure.setwantedstate(superstructure.wantedstate.climb); } } else if (mcontrolboard.getreturntodrivercontrol()) { msuperstructure.setwantedstate(superstructure.wantedstate.driver_control); } } catch (throwable t) { logger.logthrowablecrash(t); throw t; } outputtosmartdashboard(); }","comment":"\/* todo: decide squared inputs or not *\/\n\/*.scale(6)*\/\n\/\/ mdrive.setvelocity(command, new drivesignal( \/\/ command.scale(constants.kdriveleftkv).getleft() + math.copysign(constants.kdriveleftvintercept, command.getleft()), \/\/ command.scale(constants.kdriveleftkv).getright() + math.copysign(constants.kdriveleftvintercept, command.getright()) \/\/ ));\n\/\/ todo (for button person): add buttons for all superstructure wanted states","repo":"MaximillianHays\/2019-DeepSpace","code_context_2":"{\nDriveSignal command = ArcadeDriveHelper.arcadeDrive(mControlBoard.getThrottle(), mControlBoard.getTurn(),\ntrue \/* TODO: Decide squared inputs or not *\/).scale(mSuperstructure.isDrivingReversed() ? -1 : 1)\/*.scale(6)*\/;\nmDrive.setOpenLoop(command);\n\/\/ mDrive.setVelocity(command, new DriveSignal(\n\n{\nDriveSignal command = ArcadeDriveHelper.arcadeDrive(mControlBoard.getThrottle(), mControlBoard.getTurn(),\ntrue \/* TODO: Decide squared inputs or not *\/).scale(mSuperstructure.isDrivingReversed() ? -1 : 1)\/*.scale(6)*\/;\nmDrive.setOpenLoop(command);\n\/\/ mDrive.setVelocity(command, new DriveSignal(\n\ntrue \/* TODO: Decide squared inputs or not *\/).scale(mSuperstructure.isDrivingReversed() ? -1 : 1)\/*.scale(6)*\/;\nmDrive.setOpenLoop(command);\n\/\/ mDrive.setVelocity(command, new DriveSignal(\n\/\/ command.scale(Constants.kDriveLeftKv).getLeft() + Math.copySign(Constants.kDriveLeftVIntercept, command.getLeft()),\n\/\/ command.scale(Constants.kDriveLeftKv).getRight() + Math.copySign(Constants.kDriveLeftVIntercept, command.getRight())\n\/\/ ));\nif(mControlBoard.getEjectPanel())\nmPanelHandler.setWantedState(PanelHandler.WantedState.EJECT);\n\nmSuperstructure.setWantedState(Superstructure.WantedState.CLIMB);\n}\n\/\/ TODO (for button person): add buttons for all superstructure wanted states\n}\nelse if (mControlBoard.getReturnToDriverControl())","code_context_10":"{\nSmartDashboard.putString(\"Robot\/GamePhase\", \"TELEOP\");\ndouble timestamp = Timer.getFPGATimestamp();\ndouble throttle = mControlBoard.getThrottle();\ndouble turn = mControlBoard.getTurn();\ntry\n{\nif (mSuperstructure.isDriverControlled())\n{\nDriveSignal command = ArcadeDriveHelper.arcadeDrive(mControlBoard.getThrottle(), mControlBoard.getTurn(),\ntrue \/* TODO: Decide squared inputs or not *\/).scale(mSuperstructure.isDrivingReversed() ? -1 : 1)\/*.scale(6)*\/;\nmDrive.setOpenLoop(command);\n\/\/ mDrive.setVelocity(command, new DriveSignal(\n\/\/ command.scale(Constants.kDriveLeftKv).getLeft() + Math.copySign(Constants.kDriveLeftVIntercept, command.getLeft()),\n\/\/ command.scale(Constants.kDriveLeftKv).getRight() + Math.copySign(Constants.kDriveLeftVIntercept, command.getRight())\n\/\/ ));\nif(mControlBoard.getEjectPanel())\nmPanelHandler.setWantedState(PanelHandler.WantedState.EJECT);\nif(mControlBoard.getIntake())\nmCargoIntake.setWantedState(CargoIntake.WantedState.INTAKE);\nif(mControlBoard.getTestButtonOne())\n\n{\nSmartDashboard.putString(\"Robot\/GamePhase\", \"TELEOP\");\ndouble timestamp = Timer.getFPGATimestamp();\ndouble throttle = mControlBoard.getThrottle();\ndouble turn = mControlBoard.getTurn();\ntry\n{\nif (mSuperstructure.isDriverControlled())\n{\nDriveSignal command = ArcadeDriveHelper.arcadeDrive(mControlBoard.getThrottle(), mControlBoard.getTurn(),\ntrue \/* TODO: Decide squared inputs or not *\/).scale(mSuperstructure.isDrivingReversed() ? -1 : 1)\/*.scale(6)*\/;\nmDrive.setOpenLoop(command);\n\/\/ mDrive.setVelocity(command, new DriveSignal(\n\/\/ command.scale(Constants.kDriveLeftKv).getLeft() + Math.copySign(Constants.kDriveLeftVIntercept, command.getLeft()),\n\/\/ command.scale(Constants.kDriveLeftKv).getRight() + Math.copySign(Constants.kDriveLeftVIntercept, command.getRight())\n\/\/ ));\nif(mControlBoard.getEjectPanel())\nmPanelHandler.setWantedState(PanelHandler.WantedState.EJECT);\nif(mControlBoard.getIntake())\nmCargoIntake.setWantedState(CargoIntake.WantedState.INTAKE);\nif(mControlBoard.getTestButtonOne())\n\ndouble timestamp = Timer.getFPGATimestamp();\ndouble throttle = mControlBoard.getThrottle();\ndouble turn = mControlBoard.getTurn();\ntry\n{\nif (mSuperstructure.isDriverControlled())\n{\nDriveSignal command = ArcadeDriveHelper.arcadeDrive(mControlBoard.getThrottle(), mControlBoard.getTurn(),\ntrue \/* TODO: Decide squared inputs or not *\/).scale(mSuperstructure.isDrivingReversed() ? -1 : 1)\/*.scale(6)*\/;\nmDrive.setOpenLoop(command);\n\/\/ mDrive.setVelocity(command, new DriveSignal(\n\/\/ command.scale(Constants.kDriveLeftKv).getLeft() + Math.copySign(Constants.kDriveLeftVIntercept, command.getLeft()),\n\/\/ command.scale(Constants.kDriveLeftKv).getRight() + Math.copySign(Constants.kDriveLeftVIntercept, command.getRight())\n\/\/ ));\nif(mControlBoard.getEjectPanel())\nmPanelHandler.setWantedState(PanelHandler.WantedState.EJECT);\nif(mControlBoard.getIntake())\nmCargoIntake.setWantedState(CargoIntake.WantedState.INTAKE);\nif(mControlBoard.getTestButtonOne())\nmCargoIntake.setWantedState(CargoIntake.WantedState.HOLD);\nif(mControlBoard.getEjectCargo())\nmCargoIntake.setWantedState(CargoIntake.WantedState.EJECT);\nif(mControlBoard.getTestButtonTwo())\nmPanelHandler.checkSystem(\"variant\");\n\nmSuperstructure.reverseDrivingDirection();\n}\nelse if (mControlBoard.getDriveToSelectedTarget())\n{\nmSuperstructure.setWantedState(Superstructure.WantedState.ALIGN_AND_INTAKE_CARGO);\n}\nelse if (mControlBoard.getClimb())\n{\nmSuperstructure.setWantedState(Superstructure.WantedState.CLIMB);\n}\n\/\/ TODO (for button person): add buttons for all superstructure wanted states\n}\nelse if (mControlBoard.getReturnToDriverControl())\n{\nmSuperstructure.setWantedState(Superstructure.WantedState.DRIVER_CONTROL);\n}\n}\ncatch (Throwable t)\n{\nLogger.logThrowableCrash(t);\nthrow t;","code_context_20":"@Override\npublic void teleopPeriodic()\n{\nSmartDashboard.putString(\"Robot\/GamePhase\", \"TELEOP\");\ndouble timestamp = Timer.getFPGATimestamp();\ndouble throttle = mControlBoard.getThrottle();\ndouble turn = mControlBoard.getTurn();\ntry\n{\nif (mSuperstructure.isDriverControlled())\n{\nDriveSignal command = ArcadeDriveHelper.arcadeDrive(mControlBoard.getThrottle(), mControlBoard.getTurn(),\ntrue \/* TODO: Decide squared inputs or not *\/).scale(mSuperstructure.isDrivingReversed() ? -1 : 1)\/*.scale(6)*\/;\nmDrive.setOpenLoop(command);\n\/\/ mDrive.setVelocity(command, new DriveSignal(\n\/\/ command.scale(Constants.kDriveLeftKv).getLeft() + Math.copySign(Constants.kDriveLeftVIntercept, command.getLeft()),\n\/\/ command.scale(Constants.kDriveLeftKv).getRight() + Math.copySign(Constants.kDriveLeftVIntercept, command.getRight())\n\/\/ ));\nif(mControlBoard.getEjectPanel())\nmPanelHandler.setWantedState(PanelHandler.WantedState.EJECT);\nif(mControlBoard.getIntake())\nmCargoIntake.setWantedState(CargoIntake.WantedState.INTAKE);\nif(mControlBoard.getTestButtonOne())\nmCargoIntake.setWantedState(CargoIntake.WantedState.HOLD);\nif(mControlBoard.getEjectCargo())\nmCargoIntake.setWantedState(CargoIntake.WantedState.EJECT);\nif(mControlBoard.getTestButtonTwo())\nmPanelHandler.checkSystem(\"variant\");\nif (mControlBoard.getReverseDirection())\n{\nmSuperstructure.reverseDrivingDirection();\n}\nelse if (mControlBoard.getDriveToSelectedTarget())\n\n@Override\npublic void teleopPeriodic()\n{\nSmartDashboard.putString(\"Robot\/GamePhase\", \"TELEOP\");\ndouble timestamp = Timer.getFPGATimestamp();\ndouble throttle = mControlBoard.getThrottle();\ndouble turn = mControlBoard.getTurn();\ntry\n{\nif (mSuperstructure.isDriverControlled())\n{\nDriveSignal command = ArcadeDriveHelper.arcadeDrive(mControlBoard.getThrottle(), mControlBoard.getTurn(),\ntrue \/* TODO: Decide squared inputs or not *\/).scale(mSuperstructure.isDrivingReversed() ? -1 : 1)\/*.scale(6)*\/;\nmDrive.setOpenLoop(command);\n\/\/ mDrive.setVelocity(command, new DriveSignal(\n\/\/ command.scale(Constants.kDriveLeftKv).getLeft() + Math.copySign(Constants.kDriveLeftVIntercept, command.getLeft()),\n\/\/ command.scale(Constants.kDriveLeftKv).getRight() + Math.copySign(Constants.kDriveLeftVIntercept, command.getRight())\n\/\/ ));\nif(mControlBoard.getEjectPanel())\nmPanelHandler.setWantedState(PanelHandler.WantedState.EJECT);\nif(mControlBoard.getIntake())\nmCargoIntake.setWantedState(CargoIntake.WantedState.INTAKE);\nif(mControlBoard.getTestButtonOne())\nmCargoIntake.setWantedState(CargoIntake.WantedState.HOLD);\nif(mControlBoard.getEjectCargo())\nmCargoIntake.setWantedState(CargoIntake.WantedState.EJECT);\nif(mControlBoard.getTestButtonTwo())\nmPanelHandler.checkSystem(\"variant\");\nif (mControlBoard.getReverseDirection())\n{\nmSuperstructure.reverseDrivingDirection();\n}\nelse if (mControlBoard.getDriveToSelectedTarget())\n\n@Override\npublic void teleopPeriodic()\n{\nSmartDashboard.putString(\"Robot\/GamePhase\", \"TELEOP\");\ndouble timestamp = Timer.getFPGATimestamp();\ndouble throttle = mControlBoard.getThrottle();\ndouble turn = mControlBoard.getTurn();\ntry\n{\nif (mSuperstructure.isDriverControlled())\n{\nDriveSignal command = ArcadeDriveHelper.arcadeDrive(mControlBoard.getThrottle(), mControlBoard.getTurn(),\ntrue \/* TODO: Decide squared inputs or not *\/).scale(mSuperstructure.isDrivingReversed() ? -1 : 1)\/*.scale(6)*\/;\nmDrive.setOpenLoop(command);\n\/\/ mDrive.setVelocity(command, new DriveSignal(\n\/\/ command.scale(Constants.kDriveLeftKv).getLeft() + Math.copySign(Constants.kDriveLeftVIntercept, command.getLeft()),\n\/\/ command.scale(Constants.kDriveLeftKv).getRight() + Math.copySign(Constants.kDriveLeftVIntercept, command.getRight())\n\/\/ ));\nif(mControlBoard.getEjectPanel())\nmPanelHandler.setWantedState(PanelHandler.WantedState.EJECT);\nif(mControlBoard.getIntake())\nmCargoIntake.setWantedState(CargoIntake.WantedState.INTAKE);\nif(mControlBoard.getTestButtonOne())\nmCargoIntake.setWantedState(CargoIntake.WantedState.HOLD);\nif(mControlBoard.getEjectCargo())\nmCargoIntake.setWantedState(CargoIntake.WantedState.EJECT);\nif(mControlBoard.getTestButtonTwo())\nmPanelHandler.checkSystem(\"variant\");\nif (mControlBoard.getReverseDirection())\n{\nmSuperstructure.reverseDrivingDirection();\n}\nelse if (mControlBoard.getDriveToSelectedTarget())\n{\nmSuperstructure.setWantedState(Superstructure.WantedState.ALIGN_AND_INTAKE_CARGO);\n}\nelse if (mControlBoard.getClimb())\n{\n\nif(mControlBoard.getIntake())\nmCargoIntake.setWantedState(CargoIntake.WantedState.INTAKE);\nif(mControlBoard.getTestButtonOne())\nmCargoIntake.setWantedState(CargoIntake.WantedState.HOLD);\nif(mControlBoard.getEjectCargo())\nmCargoIntake.setWantedState(CargoIntake.WantedState.EJECT);\nif(mControlBoard.getTestButtonTwo())\nmPanelHandler.checkSystem(\"variant\");\nif (mControlBoard.getReverseDirection())\n{\nmSuperstructure.reverseDrivingDirection();\n}\nelse if (mControlBoard.getDriveToSelectedTarget())\n{\nmSuperstructure.setWantedState(Superstructure.WantedState.ALIGN_AND_INTAKE_CARGO);\n}\nelse if (mControlBoard.getClimb())\n{\nmSuperstructure.setWantedState(Superstructure.WantedState.CLIMB);\n}\n\/\/ TODO (for button person): add buttons for all superstructure wanted states\n}\nelse if (mControlBoard.getReturnToDriverControl())\n{\nmSuperstructure.setWantedState(Superstructure.WantedState.DRIVER_CONTROL);\n}\n}\ncatch (Throwable t)\n{\nLogger.logThrowableCrash(t);\nthrow t;\n}\noutputToSmartDashboard();\n}","label":[0,1,0,0]}
{"id":3595,"original_code":"public ByteBuffer encode() throws IOException { \/\/ TODO: an implementation that can use more than one chunk\n\t\tByteArrayOutputStream bout = new ByteArrayOutputStream();\n\t\ttry (DataOutputStream os = new DataOutputStream(bout)) {\n\t\t\t\/* add the data for each entry *\/\n\t\t\tfor (ByteBuffer entry : entries) {\n\t\t\t\t\/* copy to temp buffer *\/\n\t\t\t\tbyte[] temp = new byte[entry.limit()];\n\t\t\t\tentry.position(0);\n\t\t\t\tentry.get(temp);\n\t\t\t\tentry.position(0);\n\t\t\t\t\/* copy to output stream *\/\n\t\t\t\tos.write(temp);\n\t\t\t}\n\t\t\t\/* write the chunk lengths *\/\n\t\t\tint prev = 0;\n\t\t\tfor (ByteBuffer entry : entries) {\n\t\t\t\t\/* \n\t\t\t\t * since each file is stored in the only chunk, just write the\n\t\t\t\t * delta-encoded file size\n\t\t\t\t *\/\n\t\t\t\tint chunkSize = entry.limit();\n\t\t\t\tos.writeInt(chunkSize - prev);\n\t\t\t\tprev = chunkSize;\n\t\t\t}\n\t\t\t\/* we only used one chunk due to a limitation of the implementation *\/\n\t\t\tbout.write(1);\n\t\t\t\/* wrap the bytes from the stream in a buffer *\/\n\t\t\tbyte[] bytes = bout.toByteArray();\n\t\t\treturn ByteBuffer.wrap(bytes);\n\t\t}\n\t}","code":"public ByteBuffer encode() throws IOException { \t\tByteArrayOutputStream bout = new ByteArrayOutputStream();\n\t\ttry (DataOutputStream os = new DataOutputStream(bout)) {\n\t\t\n\t\t\tfor (ByteBuffer entry : entries) {\n\t\t\t\n\t\t\t\tbyte[] temp = new byte[entry.limit()];\n\t\t\t\tentry.position(0);\n\t\t\t\tentry.get(temp);\n\t\t\t\tentry.position(0);\n\t\t\t\n\t\t\t\tos.write(temp);\n\t\t\t}\n\t\t\n\t\t\tint prev = 0;\n\t\t\tfor (ByteBuffer entry : entries) {\n\t\t\t\n\t\t\t\tint chunkSize = entry.limit();\n\t\t\t\tos.writeInt(chunkSize - prev);\n\t\t\t\tprev = chunkSize;\n\t\t\t}\n\t\t\n\t\t\tbout.write(1);\n\t\t\n\t\t\tbyte[] bytes = bout.toByteArray();\n\t\t\treturn ByteBuffer.wrap(bytes);\n\t\t}\n\t}","cleancode":"public bytebuffer encode() throws ioexception { bytearrayoutputstream bout = new bytearrayoutputstream(); try (dataoutputstream os = new dataoutputstream(bout)) { for (bytebuffer entry : entries) { byte[] temp = new byte[entry.limit()]; entry.position(0); entry.get(temp); entry.position(0); os.write(temp); } int prev = 0; for (bytebuffer entry : entries) { int chunksize = entry.limit(); os.writeint(chunksize - prev); prev = chunksize; } bout.write(1); byte[] bytes = bout.tobytearray(); return bytebuffer.wrap(bytes); } }","comment":"\/** * encodes this {@link archive} into a {@link bytebuffer}. * <p \/> * please note that this is a fairly simple implementation that does not * attempt to use more than one chunk. * @return an encoded {@link bytebuffer}. * @throws ioexception if an i\/o error occurs. *\/\n\/\/ todo: an implementation that can use more than one chunk\n\/* add the data for each entry *\/\n\/* copy to temp buffer *\/\n\/* copy to output stream *\/\n\/* write the chunk lengths *\/\n\/* * since each file is stored in the only chunk, just write the * delta-encoded file size *\/\n\/* we only used one chunk due to a limitation of the implementation *\/\n\/* wrap the bytes from the stream in a buffer *\/","repo":"Lmctruck30\/mopar","code_context_2":"public ByteBuffer encode() throws IOException { \/\/ TODO: an implementation that can use more than one chunk\nByteArrayOutputStream bout = new ByteArrayOutputStream();\ntry (DataOutputStream os = new DataOutputStream(bout)) {\n\/* add the data for each entry *\/\nfor (ByteBuffer entry : entries) {\n\/* copy to temp buffer *\/\nbyte[] temp = new byte[entry.limit()];\nentry.position(0);\nentry.get(temp);\nentry.position(0);\n\/* copy to output stream *\/\nos.write(temp);\n}\n\/* write the chunk lengths *\/\nint prev = 0;\nfor (ByteBuffer entry : entries) {\n\/*\n* since each file is stored in the only chunk, just write the\n* delta-encoded file size\n*\/\nint chunkSize = entry.limit();\nos.writeInt(chunkSize - prev);\nprev = chunkSize;\n}\n\/* we only used one chunk due to a limitation of the implementation *\/\nbout.write(1);\n\/* wrap the bytes from the stream in a buffer *\/\nbyte[] bytes = bout.toByteArray();\nreturn ByteBuffer.wrap(bytes);\n}\n}\n\npublic ByteBuffer encode() throws IOException { \/\/ TODO: an implementation that can use more than one chunk\nByteArrayOutputStream bout = new ByteArrayOutputStream();\ntry (DataOutputStream os = new DataOutputStream(bout)) {\n\nByteArrayOutputStream bout = new ByteArrayOutputStream();\ntry (DataOutputStream os = new DataOutputStream(bout)) {\n\/* add the data for each entry *\/\nfor (ByteBuffer entry : entries) {\n\/* copy to temp buffer *\/\n\n\/* add the data for each entry *\/\nfor (ByteBuffer entry : entries) {\n\/* copy to temp buffer *\/\nbyte[] temp = new byte[entry.limit()];\nentry.position(0);\n\nentry.get(temp);\nentry.position(0);\n\/* copy to output stream *\/\nos.write(temp);\n}\n\nos.write(temp);\n}\n\/* write the chunk lengths *\/\nint prev = 0;\nfor (ByteBuffer entry : entries) {\n\nByteArrayOutputStream bout = new ByteArrayOutputStream();\ntry (DataOutputStream os = new DataOutputStream(bout)) {\n\/* add the data for each entry *\/\nfor (ByteBuffer entry : entries) {\n\/* copy to temp buffer *\/\nbyte[] temp = new byte[entry.limit()];\nentry.position(0);\nentry.get(temp);\n\nprev = chunkSize;\n}\n\/* we only used one chunk due to a limitation of the implementation *\/\nbout.write(1);\n\/* wrap the bytes from the stream in a buffer *\/\n\n\/* we only used one chunk due to a limitation of the implementation *\/\nbout.write(1);\n\/* wrap the bytes from the stream in a buffer *\/\nbyte[] bytes = bout.toByteArray();\nreturn ByteBuffer.wrap(bytes);","code_context_10":"public ByteBuffer encode() throws IOException { \/\/ TODO: an implementation that can use more than one chunk\nByteArrayOutputStream bout = new ByteArrayOutputStream();\ntry (DataOutputStream os = new DataOutputStream(bout)) {\n\/* add the data for each entry *\/\nfor (ByteBuffer entry : entries) {\n\/* copy to temp buffer *\/\nbyte[] temp = new byte[entry.limit()];\nentry.position(0);\nentry.get(temp);\nentry.position(0);\n\/* copy to output stream *\/\nos.write(temp);\n}\n\/* write the chunk lengths *\/\nint prev = 0;\nfor (ByteBuffer entry : entries) {\n\/*\n* since each file is stored in the only chunk, just write the\n* delta-encoded file size\n*\/\nint chunkSize = entry.limit();\nos.writeInt(chunkSize - prev);\nprev = chunkSize;\n}\n\/* we only used one chunk due to a limitation of the implementation *\/\nbout.write(1);\n\/* wrap the bytes from the stream in a buffer *\/\nbyte[] bytes = bout.toByteArray();\nreturn ByteBuffer.wrap(bytes);\n}\n}\n\npublic ByteBuffer encode() throws IOException { \/\/ TODO: an implementation that can use more than one chunk\nByteArrayOutputStream bout = new ByteArrayOutputStream();\ntry (DataOutputStream os = new DataOutputStream(bout)) {\n\/* add the data for each entry *\/\nfor (ByteBuffer entry : entries) {\n\/* copy to temp buffer *\/\nbyte[] temp = new byte[entry.limit()];\nentry.position(0);\nentry.get(temp);\nentry.position(0);\n\/* copy to output stream *\/\n\npublic ByteBuffer encode() throws IOException { \/\/ TODO: an implementation that can use more than one chunk\nByteArrayOutputStream bout = new ByteArrayOutputStream();\ntry (DataOutputStream os = new DataOutputStream(bout)) {\n\/* add the data for each entry *\/\nfor (ByteBuffer entry : entries) {\n\/* copy to temp buffer *\/\nbyte[] temp = new byte[entry.limit()];\nentry.position(0);\nentry.get(temp);\nentry.position(0);\n\/* copy to output stream *\/\nos.write(temp);\n}\n\/* write the chunk lengths *\/\n\npublic ByteBuffer encode() throws IOException { \/\/ TODO: an implementation that can use more than one chunk\nByteArrayOutputStream bout = new ByteArrayOutputStream();\ntry (DataOutputStream os = new DataOutputStream(bout)) {\n\/* add the data for each entry *\/\nfor (ByteBuffer entry : entries) {\n\/* copy to temp buffer *\/\nbyte[] temp = new byte[entry.limit()];\nentry.position(0);\nentry.get(temp);\nentry.position(0);\n\/* copy to output stream *\/\nos.write(temp);\n}\n\/* write the chunk lengths *\/\nint prev = 0;\nfor (ByteBuffer entry : entries) {\n\npublic ByteBuffer encode() throws IOException { \/\/ TODO: an implementation that can use more than one chunk\nByteArrayOutputStream bout = new ByteArrayOutputStream();\ntry (DataOutputStream os = new DataOutputStream(bout)) {\n\/* add the data for each entry *\/\nfor (ByteBuffer entry : entries) {\n\/* copy to temp buffer *\/\nbyte[] temp = new byte[entry.limit()];\nentry.position(0);\nentry.get(temp);\nentry.position(0);\n\/* copy to output stream *\/\nos.write(temp);\n}\n\/* write the chunk lengths *\/\nint prev = 0;\nfor (ByteBuffer entry : entries) {\n\/*\n* since each file is stored in the only chunk, just write the\n* delta-encoded file size\n*\/\nint chunkSize = entry.limit();\n\n\/* add the data for each entry *\/\nfor (ByteBuffer entry : entries) {\n\/* copy to temp buffer *\/\nbyte[] temp = new byte[entry.limit()];\nentry.position(0);\nentry.get(temp);\nentry.position(0);\n\/* copy to output stream *\/\nos.write(temp);\n}\n\/* write the chunk lengths *\/\nint prev = 0;\nfor (ByteBuffer entry : entries) {\n\/*\n* since each file is stored in the only chunk, just write the\n* delta-encoded file size\n*\/\nint chunkSize = entry.limit();\nos.writeInt(chunkSize - prev);\nprev = chunkSize;\n}\n\npublic ByteBuffer encode() throws IOException { \/\/ TODO: an implementation that can use more than one chunk\nByteArrayOutputStream bout = new ByteArrayOutputStream();\ntry (DataOutputStream os = new DataOutputStream(bout)) {\n\/* add the data for each entry *\/\nfor (ByteBuffer entry : entries) {\n\/* copy to temp buffer *\/\nbyte[] temp = new byte[entry.limit()];\nentry.position(0);\nentry.get(temp);\nentry.position(0);\n\/* copy to output stream *\/\nos.write(temp);\n}\n\/* write the chunk lengths *\/\nint prev = 0;\nfor (ByteBuffer entry : entries) {\n\/*\n\nint prev = 0;\nfor (ByteBuffer entry : entries) {\n\/*\n* since each file is stored in the only chunk, just write the\n* delta-encoded file size\n*\/\nint chunkSize = entry.limit();\nos.writeInt(chunkSize - prev);\nprev = chunkSize;\n}\n\/* we only used one chunk due to a limitation of the implementation *\/\nbout.write(1);\n\/* wrap the bytes from the stream in a buffer *\/\nbyte[] bytes = bout.toByteArray();\nreturn ByteBuffer.wrap(bytes);\n}\n}\n\n\/*\n* since each file is stored in the only chunk, just write the\n* delta-encoded file size\n*\/\nint chunkSize = entry.limit();\nos.writeInt(chunkSize - prev);\nprev = chunkSize;\n}\n\/* we only used one chunk due to a limitation of the implementation *\/\nbout.write(1);\n\/* wrap the bytes from the stream in a buffer *\/\nbyte[] bytes = bout.toByteArray();\nreturn ByteBuffer.wrap(bytes);\n}\n}","code_context_20":"public ByteBuffer encode() throws IOException { \/\/ TODO: an implementation that can use more than one chunk\nByteArrayOutputStream bout = new ByteArrayOutputStream();\ntry (DataOutputStream os = new DataOutputStream(bout)) {\n\/* add the data for each entry *\/\nfor (ByteBuffer entry : entries) {\n\/* copy to temp buffer *\/\nbyte[] temp = new byte[entry.limit()];\nentry.position(0);\nentry.get(temp);\nentry.position(0);\n\/* copy to output stream *\/\nos.write(temp);\n}\n\/* write the chunk lengths *\/\nint prev = 0;\nfor (ByteBuffer entry : entries) {\n\/*\n* since each file is stored in the only chunk, just write the\n* delta-encoded file size\n*\/\nint chunkSize = entry.limit();\nos.writeInt(chunkSize - prev);\nprev = chunkSize;\n}\n\/* we only used one chunk due to a limitation of the implementation *\/\nbout.write(1);\n\/* wrap the bytes from the stream in a buffer *\/\nbyte[] bytes = bout.toByteArray();\nreturn ByteBuffer.wrap(bytes);\n}\n}\n\npublic ByteBuffer encode() throws IOException { \/\/ TODO: an implementation that can use more than one chunk\nByteArrayOutputStream bout = new ByteArrayOutputStream();\ntry (DataOutputStream os = new DataOutputStream(bout)) {\n\/* add the data for each entry *\/\nfor (ByteBuffer entry : entries) {\n\/* copy to temp buffer *\/\nbyte[] temp = new byte[entry.limit()];\nentry.position(0);\nentry.get(temp);\nentry.position(0);\n\/* copy to output stream *\/\nos.write(temp);\n}\n\/* write the chunk lengths *\/\nint prev = 0;\nfor (ByteBuffer entry : entries) {\n\/*\n* since each file is stored in the only chunk, just write the\n* delta-encoded file size\n*\/\nint chunkSize = entry.limit();\n\npublic ByteBuffer encode() throws IOException { \/\/ TODO: an implementation that can use more than one chunk\nByteArrayOutputStream bout = new ByteArrayOutputStream();\ntry (DataOutputStream os = new DataOutputStream(bout)) {\n\/* add the data for each entry *\/\nfor (ByteBuffer entry : entries) {\n\/* copy to temp buffer *\/\nbyte[] temp = new byte[entry.limit()];\nentry.position(0);\nentry.get(temp);\nentry.position(0);\n\/* copy to output stream *\/\nos.write(temp);\n}\n\/* write the chunk lengths *\/\nint prev = 0;\nfor (ByteBuffer entry : entries) {\n\/*\n* since each file is stored in the only chunk, just write the\n* delta-encoded file size\n*\/\nint chunkSize = entry.limit();\nos.writeInt(chunkSize - prev);\nprev = chunkSize;\n}\n\npublic ByteBuffer encode() throws IOException { \/\/ TODO: an implementation that can use more than one chunk\nByteArrayOutputStream bout = new ByteArrayOutputStream();\ntry (DataOutputStream os = new DataOutputStream(bout)) {\n\/* add the data for each entry *\/\nfor (ByteBuffer entry : entries) {\n\/* copy to temp buffer *\/\nbyte[] temp = new byte[entry.limit()];\nentry.position(0);\nentry.get(temp);\nentry.position(0);\n\/* copy to output stream *\/\nos.write(temp);\n}\n\/* write the chunk lengths *\/\nint prev = 0;\nfor (ByteBuffer entry : entries) {\n\/*\n* since each file is stored in the only chunk, just write the\n* delta-encoded file size\n*\/\nint chunkSize = entry.limit();\nos.writeInt(chunkSize - prev);\nprev = chunkSize;\n}\n\/* we only used one chunk due to a limitation of the implementation *\/\nbout.write(1);\n\npublic ByteBuffer encode() throws IOException { \/\/ TODO: an implementation that can use more than one chunk\nByteArrayOutputStream bout = new ByteArrayOutputStream();\ntry (DataOutputStream os = new DataOutputStream(bout)) {\n\/* add the data for each entry *\/\nfor (ByteBuffer entry : entries) {\n\/* copy to temp buffer *\/\nbyte[] temp = new byte[entry.limit()];\nentry.position(0);\nentry.get(temp);\nentry.position(0);\n\/* copy to output stream *\/\nos.write(temp);\n}\n\/* write the chunk lengths *\/\nint prev = 0;\nfor (ByteBuffer entry : entries) {\n\/*\n* since each file is stored in the only chunk, just write the\n* delta-encoded file size\n*\/\nint chunkSize = entry.limit();\nos.writeInt(chunkSize - prev);\nprev = chunkSize;\n}\n\/* we only used one chunk due to a limitation of the implementation *\/\nbout.write(1);\n\/* wrap the bytes from the stream in a buffer *\/\nbyte[] bytes = bout.toByteArray();\nreturn ByteBuffer.wrap(bytes);\n}\n}\n\npublic ByteBuffer encode() throws IOException { \/\/ TODO: an implementation that can use more than one chunk\nByteArrayOutputStream bout = new ByteArrayOutputStream();\ntry (DataOutputStream os = new DataOutputStream(bout)) {\n\/* add the data for each entry *\/\nfor (ByteBuffer entry : entries) {\n\/* copy to temp buffer *\/\nbyte[] temp = new byte[entry.limit()];\nentry.position(0);\nentry.get(temp);\nentry.position(0);\n\/* copy to output stream *\/\nos.write(temp);\n}\n\/* write the chunk lengths *\/\nint prev = 0;\nfor (ByteBuffer entry : entries) {\n\/*\n* since each file is stored in the only chunk, just write the\n* delta-encoded file size\n*\/\nint chunkSize = entry.limit();\nos.writeInt(chunkSize - prev);\nprev = chunkSize;\n}\n\/* we only used one chunk due to a limitation of the implementation *\/\nbout.write(1);\n\/* wrap the bytes from the stream in a buffer *\/\nbyte[] bytes = bout.toByteArray();\nreturn ByteBuffer.wrap(bytes);\n}\n}\n\npublic ByteBuffer encode() throws IOException { \/\/ TODO: an implementation that can use more than one chunk\nByteArrayOutputStream bout = new ByteArrayOutputStream();\ntry (DataOutputStream os = new DataOutputStream(bout)) {\n\/* add the data for each entry *\/\nfor (ByteBuffer entry : entries) {\n\/* copy to temp buffer *\/\nbyte[] temp = new byte[entry.limit()];\nentry.position(0);\nentry.get(temp);\nentry.position(0);\n\/* copy to output stream *\/\nos.write(temp);\n}\n\/* write the chunk lengths *\/\nint prev = 0;\nfor (ByteBuffer entry : entries) {\n\/*\n* since each file is stored in the only chunk, just write the\n* delta-encoded file size\n*\/\nint chunkSize = entry.limit();\nos.writeInt(chunkSize - prev);\nprev = chunkSize;\n}\n\/* we only used one chunk due to a limitation of the implementation *\/\nbout.write(1);\n\/* wrap the bytes from the stream in a buffer *\/\n\nfor (ByteBuffer entry : entries) {\n\/* copy to temp buffer *\/\nbyte[] temp = new byte[entry.limit()];\nentry.position(0);\nentry.get(temp);\nentry.position(0);\n\/* copy to output stream *\/\nos.write(temp);\n}\n\/* write the chunk lengths *\/\nint prev = 0;\nfor (ByteBuffer entry : entries) {\n\/*\n* since each file is stored in the only chunk, just write the\n* delta-encoded file size\n*\/\nint chunkSize = entry.limit();\nos.writeInt(chunkSize - prev);\nprev = chunkSize;\n}\n\/* we only used one chunk due to a limitation of the implementation *\/\nbout.write(1);\n\/* wrap the bytes from the stream in a buffer *\/\nbyte[] bytes = bout.toByteArray();\nreturn ByteBuffer.wrap(bytes);\n}\n}\n\nbyte[] temp = new byte[entry.limit()];\nentry.position(0);\nentry.get(temp);\nentry.position(0);\n\/* copy to output stream *\/\nos.write(temp);\n}\n\/* write the chunk lengths *\/\nint prev = 0;\nfor (ByteBuffer entry : entries) {\n\/*\n* since each file is stored in the only chunk, just write the\n* delta-encoded file size\n*\/\nint chunkSize = entry.limit();\nos.writeInt(chunkSize - prev);\nprev = chunkSize;\n}\n\/* we only used one chunk due to a limitation of the implementation *\/\nbout.write(1);\n\/* wrap the bytes from the stream in a buffer *\/\nbyte[] bytes = bout.toByteArray();\nreturn ByteBuffer.wrap(bytes);\n}\n}","label":[0,1,0,0]}
{"id":11794,"original_code":"public ClassInfo extendedFindClass(String className) {\n    \/\/ ClassDoc.findClass has this bug that we're working around here:\n    \/\/ If you have a class PackageManager with an inner class PackageInfo\n    \/\/ and you call it with \"PackageInfo\" it doesn't find it.\n    return searchInnerClasses(className.split(\"\\\\.\"), 0);\n  }","code":"public ClassInfo extendedFindClass(String className) {\n   \n   \n   \n    return searchInnerClasses(className.split(\"\\\\.\"), 0);\n  }","cleancode":"public classinfo extendedfindclass(string classname) { return searchinnerclasses(classname.split(\"\\\\.\"), 0); }","comment":"\/\/ classdoc.findclass has this bug that we're working around here: \/\/ if you have a class packagemanager with an inner class packageinfo \/\/ and you call it with \"packageinfo\" it doesn't find it.","repo":"Keneral\/ae1","code_context_2":"public ClassInfo extendedFindClass(String className) {\n\/\/ ClassDoc.findClass has this bug that we're working around here:\n\/\/ If you have a class PackageManager with an inner class PackageInfo\n\/\/ and you call it with \"PackageInfo\" it doesn't find it.\nreturn searchInnerClasses(className.split(\"\\\\.\"), 0);\n}","code_context_10":"public ClassInfo extendedFindClass(String className) {\n\/\/ ClassDoc.findClass has this bug that we're working around here:\n\/\/ If you have a class PackageManager with an inner class PackageInfo\n\/\/ and you call it with \"PackageInfo\" it doesn't find it.\nreturn searchInnerClasses(className.split(\"\\\\.\"), 0);\n}","code_context_20":"public ClassInfo extendedFindClass(String className) {\n\/\/ ClassDoc.findClass has this bug that we're working around here:\n\/\/ If you have a class PackageManager with an inner class PackageInfo\n\/\/ and you call it with \"PackageInfo\" it doesn't find it.\nreturn searchInnerClasses(className.split(\"\\\\.\"), 0);\n}","label":[0,0,1,0]}
{"id":12226,"original_code":"@Override\n    public void buildFunctionIfNecessary(FunctionConf functionConf) {\n        \/\/ Snapshot the directory before installing dependencies\n        List<Path> beforeSnapshot = getDirectorySnapshot(functionConf);\n        loggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Copying Greengrass SDK\");\n        copySdk(log, functionConf, resourceHelper, ioHelper);\n        if (hasDependencies(functionConf.getBuildDirectory())) {\n            loggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Installing Python dependencies\");\n            installDependencies(functionConf);\n        }\n        \/\/ Snapshot the directory after installing dependencies\n        List<Path> afterSnapshot = getDirectorySnapshot(functionConf);\n        List<Path> addedFiles = new ArrayList<>(afterSnapshot);\n        addedFiles.removeAll(beforeSnapshot);\n        loggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Packaging function for AWS Lambda\");\n        File tempFile = Try.of(() -> ioHelper.getTempFile(\"python-lambda-build\", \"zip\")).get();\n        \/\/ Get the directories, longest named directories first\n        List<Path> addedDirectories = addedFiles\n                .stream()\n                .filter(path -> path.toFile().isDirectory())\n                .sorted(Comparator.comparingInt(path -> path.toString().length()).reversed())\n                .collect(Collectors.toList());\n        \/\/ Get the possible Python directories (don't include *dist-info and bin)\n        \/\/ NOTE: This is an esoteric fix for Zope being broken which breaks Twisted - https:\/\/github.com\/kpdyer\/fteproxy\/issues\/66\n        List<Path> possibleBrokenPythonDirectories = addedDirectories\n                .stream()\n                .filter(path -> !path.toString().endsWith(DIST_INFO))\n                .filter(path -> !path.toString().endsWith(BIN))\n                .filter(path -> !path.resolve(INIT_PY).toFile().exists())\n                .collect(Collectors.toList());\n        \/\/ \"Touch\" the file to fix this issue\n        possibleBrokenPythonDirectories.stream()\n                .map(path -> path.resolve(INIT_PY).toFile())\n                .forEach(this::touchAndIgnoreExceptions);\n        ZipUtil.pack(functionConf.getBuildDirectory().toFile(), tempFile);\n        moveDeploymentPackage(functionConf, tempFile);\n    }","code":"@Override\n    public void buildFunctionIfNecessary(FunctionConf functionConf) {\n       \n        List<Path> beforeSnapshot = getDirectorySnapshot(functionConf);\n        loggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Copying Greengrass SDK\");\n        copySdk(log, functionConf, resourceHelper, ioHelper);\n        if (hasDependencies(functionConf.getBuildDirectory())) {\n            loggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Installing Python dependencies\");\n            installDependencies(functionConf);\n        }\n       \n        List<Path> afterSnapshot = getDirectorySnapshot(functionConf);\n        List<Path> addedFiles = new ArrayList<>(afterSnapshot);\n        addedFiles.removeAll(beforeSnapshot);\n        loggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Packaging function for AWS Lambda\");\n        File tempFile = Try.of(() -> ioHelper.getTempFile(\"python-lambda-build\", \"zip\")).get();\n       \n        List<Path> addedDirectories = addedFiles\n                .stream()\n                .filter(path -> path.toFile().isDirectory())\n                .sorted(Comparator.comparingInt(path -> path.toString().length()).reversed())\n                .collect(Collectors.toList());\n       \n       \n        List<Path> possibleBrokenPythonDirectories = addedDirectories\n                .stream()\n                .filter(path -> !path.toString().endsWith(DIST_INFO))\n                .filter(path -> !path.toString().endsWith(BIN))\n                .filter(path -> !path.resolve(INIT_PY).toFile().exists())\n                .collect(Collectors.toList());\n       \n        possibleBrokenPythonDirectories.stream()\n                .map(path -> path.resolve(INIT_PY).toFile())\n                .forEach(this::touchAndIgnoreExceptions);\n        ZipUtil.pack(functionConf.getBuildDirectory().toFile(), tempFile);\n        moveDeploymentPackage(functionConf, tempFile);\n    }","cleancode":"@override public void buildfunctionifnecessary(functionconf functionconf) { list<path> beforesnapshot = getdirectorysnapshot(functionconf); logginghelper.loginfowithname(log, functionconf.getfunctionname(), \"copying greengrass sdk\"); copysdk(log, functionconf, resourcehelper, iohelper); if (hasdependencies(functionconf.getbuilddirectory())) { logginghelper.loginfowithname(log, functionconf.getfunctionname(), \"installing python dependencies\"); installdependencies(functionconf); } list<path> aftersnapshot = getdirectorysnapshot(functionconf); list<path> addedfiles = new arraylist<>(aftersnapshot); addedfiles.removeall(beforesnapshot); logginghelper.loginfowithname(log, functionconf.getfunctionname(), \"packaging function for aws lambda\"); file tempfile = try.of(() -> iohelper.gettempfile(\"python-lambda-build\", \"zip\")).get(); list<path> addeddirectories = addedfiles .stream() .filter(path -> path.tofile().isdirectory()) .sorted(comparator.comparingint(path -> path.tostring().length()).reversed()) .collect(collectors.tolist()); list<path> possiblebrokenpythondirectories = addeddirectories .stream() .filter(path -> !path.tostring().endswith(dist_info)) .filter(path -> !path.tostring().endswith(bin)) .filter(path -> !path.resolve(init_py).tofile().exists()) .collect(collectors.tolist()); possiblebrokenpythondirectories.stream() .map(path -> path.resolve(init_py).tofile()) .foreach(this::touchandignoreexceptions); ziputil.pack(functionconf.getbuilddirectory().tofile(), tempfile); movedeploymentpackage(functionconf, tempfile); }","comment":"\/\/ snapshot the directory before installing dependencies\n\/\/ snapshot the directory after installing dependencies\n\/\/ get the directories, longest named directories first\n\/\/ get the possible python directories (don't include *dist-info and bin) \/\/ note: this is an esoteric fix for zope being broken which breaks twisted - https:\/\/github.com\/kpdyer\/fteproxy\/issues\/66\n\/\/ \"touch\" the file to fix this issue","repo":"QuinnCiccoretti\/aws-greengrass-provisioner","code_context_2":"@Override\npublic void buildFunctionIfNecessary(FunctionConf functionConf) {\n\/\/ Snapshot the directory before installing dependencies\nList<Path> beforeSnapshot = getDirectorySnapshot(functionConf);\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Copying Greengrass SDK\");\n\ninstallDependencies(functionConf);\n}\n\/\/ Snapshot the directory after installing dependencies\nList<Path> afterSnapshot = getDirectorySnapshot(functionConf);\nList<Path> addedFiles = new ArrayList<>(afterSnapshot);\n\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Packaging function for AWS Lambda\");\nFile tempFile = Try.of(() -> ioHelper.getTempFile(\"python-lambda-build\", \"zip\")).get();\n\/\/ Get the directories, longest named directories first\nList<Path> addedDirectories = addedFiles\n.stream()\n\n.sorted(Comparator.comparingInt(path -> path.toString().length()).reversed())\n.collect(Collectors.toList());\n\/\/ Get the possible Python directories (don't include *dist-info and bin)\n\/\/ NOTE: This is an esoteric fix for Zope being broken which breaks Twisted - https:\/\/github.com\/kpdyer\/fteproxy\/issues\/66\nList<Path> possibleBrokenPythonDirectories = addedDirectories\n.stream()\n\n.filter(path -> !path.resolve(INIT_PY).toFile().exists())\n.collect(Collectors.toList());\n\/\/ \"Touch\" the file to fix this issue\npossibleBrokenPythonDirectories.stream()\n.map(path -> path.resolve(INIT_PY).toFile())","code_context_10":"@Override\npublic void buildFunctionIfNecessary(FunctionConf functionConf) {\n\/\/ Snapshot the directory before installing dependencies\nList<Path> beforeSnapshot = getDirectorySnapshot(functionConf);\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Copying Greengrass SDK\");\ncopySdk(log, functionConf, resourceHelper, ioHelper);\nif (hasDependencies(functionConf.getBuildDirectory())) {\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Installing Python dependencies\");\ninstallDependencies(functionConf);\n}\n\/\/ Snapshot the directory after installing dependencies\nList<Path> afterSnapshot = getDirectorySnapshot(functionConf);\nList<Path> addedFiles = new ArrayList<>(afterSnapshot);\n\n@Override\npublic void buildFunctionIfNecessary(FunctionConf functionConf) {\n\/\/ Snapshot the directory before installing dependencies\nList<Path> beforeSnapshot = getDirectorySnapshot(functionConf);\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Copying Greengrass SDK\");\ncopySdk(log, functionConf, resourceHelper, ioHelper);\nif (hasDependencies(functionConf.getBuildDirectory())) {\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Installing Python dependencies\");\ninstallDependencies(functionConf);\n}\n\/\/ Snapshot the directory after installing dependencies\nList<Path> afterSnapshot = getDirectorySnapshot(functionConf);\nList<Path> addedFiles = new ArrayList<>(afterSnapshot);\naddedFiles.removeAll(beforeSnapshot);\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Packaging function for AWS Lambda\");\nFile tempFile = Try.of(() -> ioHelper.getTempFile(\"python-lambda-build\", \"zip\")).get();\n\/\/ Get the directories, longest named directories first\nList<Path> addedDirectories = addedFiles\n.stream()\n.filter(path -> path.toFile().isDirectory())\n.sorted(Comparator.comparingInt(path -> path.toString().length()).reversed())\n\nif (hasDependencies(functionConf.getBuildDirectory())) {\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Installing Python dependencies\");\ninstallDependencies(functionConf);\n}\n\/\/ Snapshot the directory after installing dependencies\nList<Path> afterSnapshot = getDirectorySnapshot(functionConf);\nList<Path> addedFiles = new ArrayList<>(afterSnapshot);\naddedFiles.removeAll(beforeSnapshot);\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Packaging function for AWS Lambda\");\nFile tempFile = Try.of(() -> ioHelper.getTempFile(\"python-lambda-build\", \"zip\")).get();\n\/\/ Get the directories, longest named directories first\nList<Path> addedDirectories = addedFiles\n.stream()\n.filter(path -> path.toFile().isDirectory())\n.sorted(Comparator.comparingInt(path -> path.toString().length()).reversed())\n.collect(Collectors.toList());\n\/\/ Get the possible Python directories (don't include *dist-info and bin)\n\/\/ NOTE: This is an esoteric fix for Zope being broken which breaks Twisted - https:\/\/github.com\/kpdyer\/fteproxy\/issues\/66\nList<Path> possibleBrokenPythonDirectories = addedDirectories\n.stream()\n.filter(path -> !path.toString().endsWith(DIST_INFO))\n\nList<Path> addedFiles = new ArrayList<>(afterSnapshot);\naddedFiles.removeAll(beforeSnapshot);\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Packaging function for AWS Lambda\");\nFile tempFile = Try.of(() -> ioHelper.getTempFile(\"python-lambda-build\", \"zip\")).get();\n\/\/ Get the directories, longest named directories first\nList<Path> addedDirectories = addedFiles\n.stream()\n.filter(path -> path.toFile().isDirectory())\n.sorted(Comparator.comparingInt(path -> path.toString().length()).reversed())\n.collect(Collectors.toList());\n\/\/ Get the possible Python directories (don't include *dist-info and bin)\n\/\/ NOTE: This is an esoteric fix for Zope being broken which breaks Twisted - https:\/\/github.com\/kpdyer\/fteproxy\/issues\/66\nList<Path> possibleBrokenPythonDirectories = addedDirectories\n.stream()\n.filter(path -> !path.toString().endsWith(DIST_INFO))\n.filter(path -> !path.toString().endsWith(BIN))\n.filter(path -> !path.resolve(INIT_PY).toFile().exists())\n.collect(Collectors.toList());\n\/\/ \"Touch\" the file to fix this issue\npossibleBrokenPythonDirectories.stream()\n.map(path -> path.resolve(INIT_PY).toFile())\n.forEach(this::touchAndIgnoreExceptions);\n\n.sorted(Comparator.comparingInt(path -> path.toString().length()).reversed())\n.collect(Collectors.toList());\n\/\/ Get the possible Python directories (don't include *dist-info and bin)\n\/\/ NOTE: This is an esoteric fix for Zope being broken which breaks Twisted - https:\/\/github.com\/kpdyer\/fteproxy\/issues\/66\nList<Path> possibleBrokenPythonDirectories = addedDirectories\n.stream()\n.filter(path -> !path.toString().endsWith(DIST_INFO))\n.filter(path -> !path.toString().endsWith(BIN))\n.filter(path -> !path.resolve(INIT_PY).toFile().exists())\n.collect(Collectors.toList());\n\/\/ \"Touch\" the file to fix this issue\npossibleBrokenPythonDirectories.stream()\n.map(path -> path.resolve(INIT_PY).toFile())\n.forEach(this::touchAndIgnoreExceptions);\nZipUtil.pack(functionConf.getBuildDirectory().toFile(), tempFile);\nmoveDeploymentPackage(functionConf, tempFile);\n}","code_context_20":"@Override\npublic void buildFunctionIfNecessary(FunctionConf functionConf) {\n\/\/ Snapshot the directory before installing dependencies\nList<Path> beforeSnapshot = getDirectorySnapshot(functionConf);\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Copying Greengrass SDK\");\ncopySdk(log, functionConf, resourceHelper, ioHelper);\nif (hasDependencies(functionConf.getBuildDirectory())) {\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Installing Python dependencies\");\ninstallDependencies(functionConf);\n}\n\/\/ Snapshot the directory after installing dependencies\nList<Path> afterSnapshot = getDirectorySnapshot(functionConf);\nList<Path> addedFiles = new ArrayList<>(afterSnapshot);\naddedFiles.removeAll(beforeSnapshot);\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Packaging function for AWS Lambda\");\nFile tempFile = Try.of(() -> ioHelper.getTempFile(\"python-lambda-build\", \"zip\")).get();\n\/\/ Get the directories, longest named directories first\nList<Path> addedDirectories = addedFiles\n.stream()\n.filter(path -> path.toFile().isDirectory())\n.sorted(Comparator.comparingInt(path -> path.toString().length()).reversed())\n.collect(Collectors.toList());\n\/\/ Get the possible Python directories (don't include *dist-info and bin)\n\n@Override\npublic void buildFunctionIfNecessary(FunctionConf functionConf) {\n\/\/ Snapshot the directory before installing dependencies\nList<Path> beforeSnapshot = getDirectorySnapshot(functionConf);\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Copying Greengrass SDK\");\ncopySdk(log, functionConf, resourceHelper, ioHelper);\nif (hasDependencies(functionConf.getBuildDirectory())) {\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Installing Python dependencies\");\ninstallDependencies(functionConf);\n}\n\/\/ Snapshot the directory after installing dependencies\nList<Path> afterSnapshot = getDirectorySnapshot(functionConf);\nList<Path> addedFiles = new ArrayList<>(afterSnapshot);\naddedFiles.removeAll(beforeSnapshot);\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Packaging function for AWS Lambda\");\nFile tempFile = Try.of(() -> ioHelper.getTempFile(\"python-lambda-build\", \"zip\")).get();\n\/\/ Get the directories, longest named directories first\nList<Path> addedDirectories = addedFiles\n.stream()\n.filter(path -> path.toFile().isDirectory())\n.sorted(Comparator.comparingInt(path -> path.toString().length()).reversed())\n.collect(Collectors.toList());\n\/\/ Get the possible Python directories (don't include *dist-info and bin)\n\/\/ NOTE: This is an esoteric fix for Zope being broken which breaks Twisted - https:\/\/github.com\/kpdyer\/fteproxy\/issues\/66\nList<Path> possibleBrokenPythonDirectories = addedDirectories\n.stream()\n.filter(path -> !path.toString().endsWith(DIST_INFO))\n.filter(path -> !path.toString().endsWith(BIN))\n.filter(path -> !path.resolve(INIT_PY).toFile().exists())\n.collect(Collectors.toList());\n\/\/ \"Touch\" the file to fix this issue\n\n@Override\npublic void buildFunctionIfNecessary(FunctionConf functionConf) {\n\/\/ Snapshot the directory before installing dependencies\nList<Path> beforeSnapshot = getDirectorySnapshot(functionConf);\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Copying Greengrass SDK\");\ncopySdk(log, functionConf, resourceHelper, ioHelper);\nif (hasDependencies(functionConf.getBuildDirectory())) {\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Installing Python dependencies\");\ninstallDependencies(functionConf);\n}\n\/\/ Snapshot the directory after installing dependencies\nList<Path> afterSnapshot = getDirectorySnapshot(functionConf);\nList<Path> addedFiles = new ArrayList<>(afterSnapshot);\naddedFiles.removeAll(beforeSnapshot);\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Packaging function for AWS Lambda\");\nFile tempFile = Try.of(() -> ioHelper.getTempFile(\"python-lambda-build\", \"zip\")).get();\n\/\/ Get the directories, longest named directories first\nList<Path> addedDirectories = addedFiles\n.stream()\n.filter(path -> path.toFile().isDirectory())\n.sorted(Comparator.comparingInt(path -> path.toString().length()).reversed())\n.collect(Collectors.toList());\n\/\/ Get the possible Python directories (don't include *dist-info and bin)\n\/\/ NOTE: This is an esoteric fix for Zope being broken which breaks Twisted - https:\/\/github.com\/kpdyer\/fteproxy\/issues\/66\nList<Path> possibleBrokenPythonDirectories = addedDirectories\n.stream()\n.filter(path -> !path.toString().endsWith(DIST_INFO))\n.filter(path -> !path.toString().endsWith(BIN))\n.filter(path -> !path.resolve(INIT_PY).toFile().exists())\n.collect(Collectors.toList());\n\/\/ \"Touch\" the file to fix this issue\npossibleBrokenPythonDirectories.stream()\n.map(path -> path.resolve(INIT_PY).toFile())\n.forEach(this::touchAndIgnoreExceptions);\nZipUtil.pack(functionConf.getBuildDirectory().toFile(), tempFile);\nmoveDeploymentPackage(functionConf, tempFile);\n}\n\n\/\/ Snapshot the directory before installing dependencies\nList<Path> beforeSnapshot = getDirectorySnapshot(functionConf);\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Copying Greengrass SDK\");\ncopySdk(log, functionConf, resourceHelper, ioHelper);\nif (hasDependencies(functionConf.getBuildDirectory())) {\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Installing Python dependencies\");\ninstallDependencies(functionConf);\n}\n\/\/ Snapshot the directory after installing dependencies\nList<Path> afterSnapshot = getDirectorySnapshot(functionConf);\nList<Path> addedFiles = new ArrayList<>(afterSnapshot);\naddedFiles.removeAll(beforeSnapshot);\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Packaging function for AWS Lambda\");\nFile tempFile = Try.of(() -> ioHelper.getTempFile(\"python-lambda-build\", \"zip\")).get();\n\/\/ Get the directories, longest named directories first\nList<Path> addedDirectories = addedFiles\n.stream()\n.filter(path -> path.toFile().isDirectory())\n.sorted(Comparator.comparingInt(path -> path.toString().length()).reversed())\n.collect(Collectors.toList());\n\/\/ Get the possible Python directories (don't include *dist-info and bin)\n\/\/ NOTE: This is an esoteric fix for Zope being broken which breaks Twisted - https:\/\/github.com\/kpdyer\/fteproxy\/issues\/66\nList<Path> possibleBrokenPythonDirectories = addedDirectories\n.stream()\n.filter(path -> !path.toString().endsWith(DIST_INFO))\n.filter(path -> !path.toString().endsWith(BIN))\n.filter(path -> !path.resolve(INIT_PY).toFile().exists())\n.collect(Collectors.toList());\n\/\/ \"Touch\" the file to fix this issue\npossibleBrokenPythonDirectories.stream()\n.map(path -> path.resolve(INIT_PY).toFile())\n.forEach(this::touchAndIgnoreExceptions);\nZipUtil.pack(functionConf.getBuildDirectory().toFile(), tempFile);\nmoveDeploymentPackage(functionConf, tempFile);\n}\n\n\/\/ Snapshot the directory after installing dependencies\nList<Path> afterSnapshot = getDirectorySnapshot(functionConf);\nList<Path> addedFiles = new ArrayList<>(afterSnapshot);\naddedFiles.removeAll(beforeSnapshot);\nloggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Packaging function for AWS Lambda\");\nFile tempFile = Try.of(() -> ioHelper.getTempFile(\"python-lambda-build\", \"zip\")).get();\n\/\/ Get the directories, longest named directories first\nList<Path> addedDirectories = addedFiles\n.stream()\n.filter(path -> path.toFile().isDirectory())\n.sorted(Comparator.comparingInt(path -> path.toString().length()).reversed())\n.collect(Collectors.toList());\n\/\/ Get the possible Python directories (don't include *dist-info and bin)\n\/\/ NOTE: This is an esoteric fix for Zope being broken which breaks Twisted - https:\/\/github.com\/kpdyer\/fteproxy\/issues\/66\nList<Path> possibleBrokenPythonDirectories = addedDirectories\n.stream()\n.filter(path -> !path.toString().endsWith(DIST_INFO))\n.filter(path -> !path.toString().endsWith(BIN))\n.filter(path -> !path.resolve(INIT_PY).toFile().exists())\n.collect(Collectors.toList());\n\/\/ \"Touch\" the file to fix this issue\npossibleBrokenPythonDirectories.stream()\n.map(path -> path.resolve(INIT_PY).toFile())\n.forEach(this::touchAndIgnoreExceptions);\nZipUtil.pack(functionConf.getBuildDirectory().toFile(), tempFile);\nmoveDeploymentPackage(functionConf, tempFile);\n}","label":[0,0,0,0]}
{"id":20549,"original_code":"private static Reporter trade(String starting_date, final String ending_date, Portfolio portfolio, Reporter reporter, String order_file_name,boolean include_trading_fees,boolean pay_dividends) {\n        int final_time = 0; \/\/last day must also be included\n        Strategy strategy = new Strategy(portfolio, portfolio.getDatabase(),include_trading_fees);\n        Long starting_time = System.currentTimeMillis();\n        System.out.println(\"Trading simulation starts: \");\n        System.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n        \/\/0. Write dividend dates to dividend array\n        \/\/todo: implement array\n        List<String> dividend_dates = new ArrayList<>();\n        if (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);}\n        while (final_time == 0) {\n            \/\/TECHNICAL\n            if (starting_date.equals(ending_date)) {\n                final_time++;\n            }\n            \/\/Check if we have data about this day in the database? Maybe it's Christmas or maybe it's the weekend.\n            if (portfolio.getDatabase().contains_day(starting_date)) {\n                \/\/1. Dividend payments to other parties\n                portfolio.exercise_dividends(starting_date);\n                \/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\n                portfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n                \/\/3. Strategy((1.)unemployment rate, (2.) P\/E  (3) moving average (4) RSI)\n                strategy.setPortfolio(strategy.trade_all(starting_date));\n                \/\/4. Pay dividends to the owners\n                if (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n            }\n            \/\/TODO: remove the else part later\n            else{\n                portfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n                portfolio.exercise_dividends(starting_date);\n            }\n            \/\/ todo: remove\n           if(portfolio.get_cash_available(starting_date) < 0){System.out.println(portfolio.get_cash_available(starting_date));}\n            reporter.report(portfolio,starting_date);\n            starting_date = LocalDate.parse(starting_date).plusDays(1).toString();\n        }\n        portfolio.order_results_to_file(order_file_name,ending_date);\n        Long ending_time = System.currentTimeMillis();\n        System.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n        System.out.println(\"Trading simulation ended: \");\n        System.out.println(\"Simulation took \" + Math.round((ending_time - starting_time) * 0.001 * 1 \/ 60) + \" minutes to complete\");\n        return reporter;\n    }","code":"private static Reporter trade(String starting_date, final String ending_date, Portfolio portfolio, Reporter reporter, String order_file_name,boolean include_trading_fees,boolean pay_dividends) {\n        int final_time = 0;\n        Strategy strategy = new Strategy(portfolio, portfolio.getDatabase(),include_trading_fees);\n        Long starting_time = System.currentTimeMillis();\n        System.out.println(\"Trading simulation starts: \");\n        System.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n       \n       \n        List<String> dividend_dates = new ArrayList<>();\n        if (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);}\n        while (final_time == 0) {\n           \n            if (starting_date.equals(ending_date)) {\n                final_time++;\n            }\n           \n            if (portfolio.getDatabase().contains_day(starting_date)) {\n               \n                portfolio.exercise_dividends(starting_date);\n               \n                portfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n               \n                strategy.setPortfolio(strategy.trade_all(starting_date));\n               \n                if (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n            }\n           \n            else{\n                portfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n                portfolio.exercise_dividends(starting_date);\n            }\n           \n           if(portfolio.get_cash_available(starting_date) < 0){System.out.println(portfolio.get_cash_available(starting_date));}\n            reporter.report(portfolio,starting_date);\n            starting_date = LocalDate.parse(starting_date).plusDays(1).toString();\n        }\n        portfolio.order_results_to_file(order_file_name,ending_date);\n        Long ending_time = System.currentTimeMillis();\n        System.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n        System.out.println(\"Trading simulation ended: \");\n        System.out.println(\"Simulation took \" + Math.round((ending_time - starting_time) * 0.001 * 1 \/ 60) + \" minutes to complete\");\n        return reporter;\n    }","cleancode":"private static reporter trade(string starting_date, final string ending_date, portfolio portfolio, reporter reporter, string order_file_name,boolean include_trading_fees,boolean pay_dividends) { int final_time = 0; strategy strategy = new strategy(portfolio, portfolio.getdatabase(),include_trading_fees); long starting_time = system.currenttimemillis(); system.out.println(\"trading simulation starts: \"); system.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\"); list<string> dividend_dates = new arraylist<>(); if (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);} while (final_time == 0) { if (starting_date.equals(ending_date)) { final_time++; } if (portfolio.getdatabase().contains_day(starting_date)) { portfolio.exercise_dividends(starting_date); portfolio.exercise_obligations(starting_date,strategy.isuse_trading_fees()); strategy.setportfolio(strategy.trade_all(starting_date)); if (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);} } else{ portfolio.exercise_obligations(starting_date,strategy.isuse_trading_fees()); portfolio.exercise_dividends(starting_date); } if(portfolio.get_cash_available(starting_date) < 0){system.out.println(portfolio.get_cash_available(starting_date));} reporter.report(portfolio,starting_date); starting_date = localdate.parse(starting_date).plusdays(1).tostring(); } portfolio.order_results_to_file(order_file_name,ending_date); long ending_time = system.currenttimemillis(); system.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\"); system.out.println(\"trading simulation ended: \"); system.out.println(\"simulation took \" + math.round((ending_time - starting_time) * 0.001 * 1 \/ 60) + \" minutes to complete\"); return reporter; }","comment":"\/\/last day must also be included\n\/\/0. write dividend dates to dividend array \/\/todo: implement array\n\/\/technical\n\/\/check if we have data about this day in the database? maybe it's christmas or maybe it's the weekend.\n\/\/1. dividend payments to other parties\n\/\/2. do i have any rights or obligations (options) \/ obligations(stocks)?\n\/\/3. strategy((1.)unemployment rate, (2.) p\/e (3) moving average (4) rsi)\n\/\/4. pay dividends to the owners\n\/\/todo: remove the else part later\n\/\/ todo: remove","repo":"KGKallasmaa\/S_P500_trading_options","code_context_2":"private static Reporter trade(String starting_date, final String ending_date, Portfolio portfolio, Reporter reporter, String order_file_name,boolean include_trading_fees,boolean pay_dividends) {\nint final_time = 0; \/\/last day must also be included\nStrategy strategy = new Strategy(portfolio, portfolio.getDatabase(),include_trading_fees);\nLong starting_time = System.currentTimeMillis();\n\nSystem.out.println(\"Trading simulation starts: \");\nSystem.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n\/\/0. Write dividend dates to dividend array\n\/\/todo: implement array\nList<String> dividend_dates = new ArrayList<>();\nif (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);}\n\nif (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);}\nwhile (final_time == 0) {\n\/\/TECHNICAL\nif (starting_date.equals(ending_date)) {\nfinal_time++;\n\nfinal_time++;\n}\n\/\/Check if we have data about this day in the database? Maybe it's Christmas or maybe it's the weekend.\nif (portfolio.getDatabase().contains_day(starting_date)) {\n\/\/1. Dividend payments to other parties\n\n\/\/Check if we have data about this day in the database? Maybe it's Christmas or maybe it's the weekend.\nif (portfolio.getDatabase().contains_day(starting_date)) {\n\/\/1. Dividend payments to other parties\nportfolio.exercise_dividends(starting_date);\n\/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\n\n\/\/1. Dividend payments to other parties\nportfolio.exercise_dividends(starting_date);\n\/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n\/\/3. Strategy((1.)unemployment rate, (2.) P\/E (3) moving average (4) RSI)\n\n\/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n\/\/3. Strategy((1.)unemployment rate, (2.) P\/E (3) moving average (4) RSI)\nstrategy.setPortfolio(strategy.trade_all(starting_date));\n\/\/4. Pay dividends to the owners\n\n\/\/3. Strategy((1.)unemployment rate, (2.) P\/E (3) moving average (4) RSI)\nstrategy.setPortfolio(strategy.trade_all(starting_date));\n\/\/4. Pay dividends to the owners\nif (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n}\n\nif (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n}\n\/\/TODO: remove the else part later\nelse{\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n\nportfolio.exercise_dividends(starting_date);\n}\n\/\/ todo: remove\nif(portfolio.get_cash_available(starting_date) < 0){System.out.println(portfolio.get_cash_available(starting_date));}\nreporter.report(portfolio,starting_date);","code_context_10":"private static Reporter trade(String starting_date, final String ending_date, Portfolio portfolio, Reporter reporter, String order_file_name,boolean include_trading_fees,boolean pay_dividends) {\nint final_time = 0; \/\/last day must also be included\nStrategy strategy = new Strategy(portfolio, portfolio.getDatabase(),include_trading_fees);\nLong starting_time = System.currentTimeMillis();\nSystem.out.println(\"Trading simulation starts: \");\nSystem.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n\/\/0. Write dividend dates to dividend array\n\/\/todo: implement array\nList<String> dividend_dates = new ArrayList<>();\nif (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);}\nwhile (final_time == 0) {\n\/\/TECHNICAL\n\nprivate static Reporter trade(String starting_date, final String ending_date, Portfolio portfolio, Reporter reporter, String order_file_name,boolean include_trading_fees,boolean pay_dividends) {\nint final_time = 0; \/\/last day must also be included\nStrategy strategy = new Strategy(portfolio, portfolio.getDatabase(),include_trading_fees);\nLong starting_time = System.currentTimeMillis();\nSystem.out.println(\"Trading simulation starts: \");\nSystem.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n\/\/0. Write dividend dates to dividend array\n\/\/todo: implement array\nList<String> dividend_dates = new ArrayList<>();\nif (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);}\nwhile (final_time == 0) {\n\/\/TECHNICAL\nif (starting_date.equals(ending_date)) {\nfinal_time++;\n}\n\/\/Check if we have data about this day in the database? Maybe it's Christmas or maybe it's the weekend.\nif (portfolio.getDatabase().contains_day(starting_date)) {\n\/\/1. Dividend payments to other parties\n\nint final_time = 0; \/\/last day must also be included\nStrategy strategy = new Strategy(portfolio, portfolio.getDatabase(),include_trading_fees);\nLong starting_time = System.currentTimeMillis();\nSystem.out.println(\"Trading simulation starts: \");\nSystem.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n\/\/0. Write dividend dates to dividend array\n\/\/todo: implement array\nList<String> dividend_dates = new ArrayList<>();\nif (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);}\nwhile (final_time == 0) {\n\/\/TECHNICAL\nif (starting_date.equals(ending_date)) {\nfinal_time++;\n}\n\/\/Check if we have data about this day in the database? Maybe it's Christmas or maybe it's the weekend.\nif (portfolio.getDatabase().contains_day(starting_date)) {\n\/\/1. Dividend payments to other parties\nportfolio.exercise_dividends(starting_date);\n\/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n\/\/3. Strategy((1.)unemployment rate, (2.) P\/E (3) moving average (4) RSI)\n\nSystem.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n\/\/0. Write dividend dates to dividend array\n\/\/todo: implement array\nList<String> dividend_dates = new ArrayList<>();\nif (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);}\nwhile (final_time == 0) {\n\/\/TECHNICAL\nif (starting_date.equals(ending_date)) {\nfinal_time++;\n}\n\/\/Check if we have data about this day in the database? Maybe it's Christmas or maybe it's the weekend.\nif (portfolio.getDatabase().contains_day(starting_date)) {\n\/\/1. Dividend payments to other parties\nportfolio.exercise_dividends(starting_date);\n\/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n\/\/3. Strategy((1.)unemployment rate, (2.) P\/E (3) moving average (4) RSI)\nstrategy.setPortfolio(strategy.trade_all(starting_date));\n\/\/4. Pay dividends to the owners\nif (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n}\n\n\/\/todo: implement array\nList<String> dividend_dates = new ArrayList<>();\nif (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);}\nwhile (final_time == 0) {\n\/\/TECHNICAL\nif (starting_date.equals(ending_date)) {\nfinal_time++;\n}\n\/\/Check if we have data about this day in the database? Maybe it's Christmas or maybe it's the weekend.\nif (portfolio.getDatabase().contains_day(starting_date)) {\n\/\/1. Dividend payments to other parties\nportfolio.exercise_dividends(starting_date);\n\/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n\/\/3. Strategy((1.)unemployment rate, (2.) P\/E (3) moving average (4) RSI)\nstrategy.setPortfolio(strategy.trade_all(starting_date));\n\/\/4. Pay dividends to the owners\nif (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n}\n\/\/TODO: remove the else part later\nelse{\n\nif (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);}\nwhile (final_time == 0) {\n\/\/TECHNICAL\nif (starting_date.equals(ending_date)) {\nfinal_time++;\n}\n\/\/Check if we have data about this day in the database? Maybe it's Christmas or maybe it's the weekend.\nif (portfolio.getDatabase().contains_day(starting_date)) {\n\/\/1. Dividend payments to other parties\nportfolio.exercise_dividends(starting_date);\n\/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n\/\/3. Strategy((1.)unemployment rate, (2.) P\/E (3) moving average (4) RSI)\nstrategy.setPortfolio(strategy.trade_all(starting_date));\n\/\/4. Pay dividends to the owners\nif (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n}\n\/\/TODO: remove the else part later\nelse{\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\nportfolio.exercise_dividends(starting_date);\n\n\/\/TECHNICAL\nif (starting_date.equals(ending_date)) {\nfinal_time++;\n}\n\/\/Check if we have data about this day in the database? Maybe it's Christmas or maybe it's the weekend.\nif (portfolio.getDatabase().contains_day(starting_date)) {\n\/\/1. Dividend payments to other parties\nportfolio.exercise_dividends(starting_date);\n\/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n\/\/3. Strategy((1.)unemployment rate, (2.) P\/E (3) moving average (4) RSI)\nstrategy.setPortfolio(strategy.trade_all(starting_date));\n\/\/4. Pay dividends to the owners\nif (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n}\n\/\/TODO: remove the else part later\nelse{\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\nportfolio.exercise_dividends(starting_date);\n}\n\/\/ todo: remove\n\nfinal_time++;\n}\n\/\/Check if we have data about this day in the database? Maybe it's Christmas or maybe it's the weekend.\nif (portfolio.getDatabase().contains_day(starting_date)) {\n\/\/1. Dividend payments to other parties\nportfolio.exercise_dividends(starting_date);\n\/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n\/\/3. Strategy((1.)unemployment rate, (2.) P\/E (3) moving average (4) RSI)\nstrategy.setPortfolio(strategy.trade_all(starting_date));\n\/\/4. Pay dividends to the owners\nif (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n}\n\/\/TODO: remove the else part later\nelse{\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\nportfolio.exercise_dividends(starting_date);\n}\n\/\/ todo: remove\nif(portfolio.get_cash_available(starting_date) < 0){System.out.println(portfolio.get_cash_available(starting_date));}\nreporter.report(portfolio,starting_date);\n\nif (portfolio.getDatabase().contains_day(starting_date)) {\n\/\/1. Dividend payments to other parties\nportfolio.exercise_dividends(starting_date);\n\/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n\/\/3. Strategy((1.)unemployment rate, (2.) P\/E (3) moving average (4) RSI)\nstrategy.setPortfolio(strategy.trade_all(starting_date));\n\/\/4. Pay dividends to the owners\nif (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n}\n\/\/TODO: remove the else part later\nelse{\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\nportfolio.exercise_dividends(starting_date);\n}\n\/\/ todo: remove\nif(portfolio.get_cash_available(starting_date) < 0){System.out.println(portfolio.get_cash_available(starting_date));}\nreporter.report(portfolio,starting_date);\nstarting_date = LocalDate.parse(starting_date).plusDays(1).toString();\n}\nportfolio.order_results_to_file(order_file_name,ending_date);\n\n\/\/3. Strategy((1.)unemployment rate, (2.) P\/E (3) moving average (4) RSI)\nstrategy.setPortfolio(strategy.trade_all(starting_date));\n\/\/4. Pay dividends to the owners\nif (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n}\n\/\/TODO: remove the else part later\nelse{\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\nportfolio.exercise_dividends(starting_date);\n}\n\/\/ todo: remove\nif(portfolio.get_cash_available(starting_date) < 0){System.out.println(portfolio.get_cash_available(starting_date));}\nreporter.report(portfolio,starting_date);\nstarting_date = LocalDate.parse(starting_date).plusDays(1).toString();\n}\nportfolio.order_results_to_file(order_file_name,ending_date);\nLong ending_time = System.currentTimeMillis();\nSystem.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\nSystem.out.println(\"Trading simulation ended: \");\nSystem.out.println(\"Simulation took \" + Math.round((ending_time - starting_time) * 0.001 * 1 \/ 60) + \" minutes to complete\");\nreturn reporter;","code_context_20":"private static Reporter trade(String starting_date, final String ending_date, Portfolio portfolio, Reporter reporter, String order_file_name,boolean include_trading_fees,boolean pay_dividends) {\nint final_time = 0; \/\/last day must also be included\nStrategy strategy = new Strategy(portfolio, portfolio.getDatabase(),include_trading_fees);\nLong starting_time = System.currentTimeMillis();\nSystem.out.println(\"Trading simulation starts: \");\nSystem.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n\/\/0. Write dividend dates to dividend array\n\/\/todo: implement array\nList<String> dividend_dates = new ArrayList<>();\nif (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);}\nwhile (final_time == 0) {\n\/\/TECHNICAL\nif (starting_date.equals(ending_date)) {\nfinal_time++;\n}\n\/\/Check if we have data about this day in the database? Maybe it's Christmas or maybe it's the weekend.\nif (portfolio.getDatabase().contains_day(starting_date)) {\n\/\/1. Dividend payments to other parties\nportfolio.exercise_dividends(starting_date);\n\/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n\/\/3. Strategy((1.)unemployment rate, (2.) P\/E (3) moving average (4) RSI)\n\nprivate static Reporter trade(String starting_date, final String ending_date, Portfolio portfolio, Reporter reporter, String order_file_name,boolean include_trading_fees,boolean pay_dividends) {\nint final_time = 0; \/\/last day must also be included\nStrategy strategy = new Strategy(portfolio, portfolio.getDatabase(),include_trading_fees);\nLong starting_time = System.currentTimeMillis();\nSystem.out.println(\"Trading simulation starts: \");\nSystem.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n\/\/0. Write dividend dates to dividend array\n\/\/todo: implement array\nList<String> dividend_dates = new ArrayList<>();\nif (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);}\nwhile (final_time == 0) {\n\/\/TECHNICAL\nif (starting_date.equals(ending_date)) {\nfinal_time++;\n}\n\/\/Check if we have data about this day in the database? Maybe it's Christmas or maybe it's the weekend.\nif (portfolio.getDatabase().contains_day(starting_date)) {\n\/\/1. Dividend payments to other parties\nportfolio.exercise_dividends(starting_date);\n\/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n\/\/3. Strategy((1.)unemployment rate, (2.) P\/E (3) moving average (4) RSI)\nstrategy.setPortfolio(strategy.trade_all(starting_date));\n\/\/4. Pay dividends to the owners\nif (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n}\n\/\/TODO: remove the else part later\nelse{\n\nprivate static Reporter trade(String starting_date, final String ending_date, Portfolio portfolio, Reporter reporter, String order_file_name,boolean include_trading_fees,boolean pay_dividends) {\nint final_time = 0; \/\/last day must also be included\nStrategy strategy = new Strategy(portfolio, portfolio.getDatabase(),include_trading_fees);\nLong starting_time = System.currentTimeMillis();\nSystem.out.println(\"Trading simulation starts: \");\nSystem.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n\/\/0. Write dividend dates to dividend array\n\/\/todo: implement array\nList<String> dividend_dates = new ArrayList<>();\nif (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);}\nwhile (final_time == 0) {\n\/\/TECHNICAL\nif (starting_date.equals(ending_date)) {\nfinal_time++;\n}\n\/\/Check if we have data about this day in the database? Maybe it's Christmas or maybe it's the weekend.\nif (portfolio.getDatabase().contains_day(starting_date)) {\n\/\/1. Dividend payments to other parties\nportfolio.exercise_dividends(starting_date);\n\/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n\/\/3. Strategy((1.)unemployment rate, (2.) P\/E (3) moving average (4) RSI)\nstrategy.setPortfolio(strategy.trade_all(starting_date));\n\/\/4. Pay dividends to the owners\nif (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n}\n\/\/TODO: remove the else part later\nelse{\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\nportfolio.exercise_dividends(starting_date);\n}\n\/\/ todo: remove\n\nprivate static Reporter trade(String starting_date, final String ending_date, Portfolio portfolio, Reporter reporter, String order_file_name,boolean include_trading_fees,boolean pay_dividends) {\nint final_time = 0; \/\/last day must also be included\nStrategy strategy = new Strategy(portfolio, portfolio.getDatabase(),include_trading_fees);\nLong starting_time = System.currentTimeMillis();\nSystem.out.println(\"Trading simulation starts: \");\nSystem.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n\/\/0. Write dividend dates to dividend array\n\/\/todo: implement array\nList<String> dividend_dates = new ArrayList<>();\nif (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);}\nwhile (final_time == 0) {\n\/\/TECHNICAL\nif (starting_date.equals(ending_date)) {\nfinal_time++;\n}\n\/\/Check if we have data about this day in the database? Maybe it's Christmas or maybe it's the weekend.\nif (portfolio.getDatabase().contains_day(starting_date)) {\n\/\/1. Dividend payments to other parties\nportfolio.exercise_dividends(starting_date);\n\/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n\/\/3. Strategy((1.)unemployment rate, (2.) P\/E (3) moving average (4) RSI)\nstrategy.setPortfolio(strategy.trade_all(starting_date));\n\/\/4. Pay dividends to the owners\nif (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n}\n\/\/TODO: remove the else part later\nelse{\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\nportfolio.exercise_dividends(starting_date);\n}\n\/\/ todo: remove\nif(portfolio.get_cash_available(starting_date) < 0){System.out.println(portfolio.get_cash_available(starting_date));}\nreporter.report(portfolio,starting_date);\nstarting_date = LocalDate.parse(starting_date).plusDays(1).toString();\n}\n\nprivate static Reporter trade(String starting_date, final String ending_date, Portfolio portfolio, Reporter reporter, String order_file_name,boolean include_trading_fees,boolean pay_dividends) {\nint final_time = 0; \/\/last day must also be included\nStrategy strategy = new Strategy(portfolio, portfolio.getDatabase(),include_trading_fees);\nLong starting_time = System.currentTimeMillis();\nSystem.out.println(\"Trading simulation starts: \");\nSystem.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n\/\/0. Write dividend dates to dividend array\n\/\/todo: implement array\nList<String> dividend_dates = new ArrayList<>();\nif (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);}\nwhile (final_time == 0) {\n\/\/TECHNICAL\nif (starting_date.equals(ending_date)) {\nfinal_time++;\n}\n\/\/Check if we have data about this day in the database? Maybe it's Christmas or maybe it's the weekend.\nif (portfolio.getDatabase().contains_day(starting_date)) {\n\/\/1. Dividend payments to other parties\nportfolio.exercise_dividends(starting_date);\n\/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n\/\/3. Strategy((1.)unemployment rate, (2.) P\/E (3) moving average (4) RSI)\nstrategy.setPortfolio(strategy.trade_all(starting_date));\n\/\/4. Pay dividends to the owners\nif (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n}\n\/\/TODO: remove the else part later\nelse{\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\nportfolio.exercise_dividends(starting_date);\n}\n\/\/ todo: remove\nif(portfolio.get_cash_available(starting_date) < 0){System.out.println(portfolio.get_cash_available(starting_date));}\nreporter.report(portfolio,starting_date);\nstarting_date = LocalDate.parse(starting_date).plusDays(1).toString();\n}\nportfolio.order_results_to_file(order_file_name,ending_date);\nLong ending_time = System.currentTimeMillis();\n\nprivate static Reporter trade(String starting_date, final String ending_date, Portfolio portfolio, Reporter reporter, String order_file_name,boolean include_trading_fees,boolean pay_dividends) {\nint final_time = 0; \/\/last day must also be included\nStrategy strategy = new Strategy(portfolio, portfolio.getDatabase(),include_trading_fees);\nLong starting_time = System.currentTimeMillis();\nSystem.out.println(\"Trading simulation starts: \");\nSystem.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n\/\/0. Write dividend dates to dividend array\n\/\/todo: implement array\nList<String> dividend_dates = new ArrayList<>();\nif (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);}\nwhile (final_time == 0) {\n\/\/TECHNICAL\nif (starting_date.equals(ending_date)) {\nfinal_time++;\n}\n\/\/Check if we have data about this day in the database? Maybe it's Christmas or maybe it's the weekend.\nif (portfolio.getDatabase().contains_day(starting_date)) {\n\/\/1. Dividend payments to other parties\nportfolio.exercise_dividends(starting_date);\n\/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n\/\/3. Strategy((1.)unemployment rate, (2.) P\/E (3) moving average (4) RSI)\nstrategy.setPortfolio(strategy.trade_all(starting_date));\n\/\/4. Pay dividends to the owners\nif (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n}\n\/\/TODO: remove the else part later\nelse{\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\nportfolio.exercise_dividends(starting_date);\n}\n\/\/ todo: remove\nif(portfolio.get_cash_available(starting_date) < 0){System.out.println(portfolio.get_cash_available(starting_date));}\nreporter.report(portfolio,starting_date);\nstarting_date = LocalDate.parse(starting_date).plusDays(1).toString();\n}\nportfolio.order_results_to_file(order_file_name,ending_date);\nLong ending_time = System.currentTimeMillis();\nSystem.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\nSystem.out.println(\"Trading simulation ended: \");\n\nint final_time = 0; \/\/last day must also be included\nStrategy strategy = new Strategy(portfolio, portfolio.getDatabase(),include_trading_fees);\nLong starting_time = System.currentTimeMillis();\nSystem.out.println(\"Trading simulation starts: \");\nSystem.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n\/\/0. Write dividend dates to dividend array\n\/\/todo: implement array\nList<String> dividend_dates = new ArrayList<>();\nif (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);}\nwhile (final_time == 0) {\n\/\/TECHNICAL\nif (starting_date.equals(ending_date)) {\nfinal_time++;\n}\n\/\/Check if we have data about this day in the database? Maybe it's Christmas or maybe it's the weekend.\nif (portfolio.getDatabase().contains_day(starting_date)) {\n\/\/1. Dividend payments to other parties\nportfolio.exercise_dividends(starting_date);\n\/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n\/\/3. Strategy((1.)unemployment rate, (2.) P\/E (3) moving average (4) RSI)\nstrategy.setPortfolio(strategy.trade_all(starting_date));\n\/\/4. Pay dividends to the owners\nif (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n}\n\/\/TODO: remove the else part later\nelse{\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\nportfolio.exercise_dividends(starting_date);\n}\n\/\/ todo: remove\nif(portfolio.get_cash_available(starting_date) < 0){System.out.println(portfolio.get_cash_available(starting_date));}\nreporter.report(portfolio,starting_date);\nstarting_date = LocalDate.parse(starting_date).plusDays(1).toString();\n}\nportfolio.order_results_to_file(order_file_name,ending_date);\nLong ending_time = System.currentTimeMillis();\nSystem.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\nSystem.out.println(\"Trading simulation ended: \");\nSystem.out.println(\"Simulation took \" + Math.round((ending_time - starting_time) * 0.001 * 1 \/ 60) + \" minutes to complete\");\nreturn reporter;\n\nLong starting_time = System.currentTimeMillis();\nSystem.out.println(\"Trading simulation starts: \");\nSystem.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n\/\/0. Write dividend dates to dividend array\n\/\/todo: implement array\nList<String> dividend_dates = new ArrayList<>();\nif (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);}\nwhile (final_time == 0) {\n\/\/TECHNICAL\nif (starting_date.equals(ending_date)) {\nfinal_time++;\n}\n\/\/Check if we have data about this day in the database? Maybe it's Christmas or maybe it's the weekend.\nif (portfolio.getDatabase().contains_day(starting_date)) {\n\/\/1. Dividend payments to other parties\nportfolio.exercise_dividends(starting_date);\n\/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n\/\/3. Strategy((1.)unemployment rate, (2.) P\/E (3) moving average (4) RSI)\nstrategy.setPortfolio(strategy.trade_all(starting_date));\n\/\/4. Pay dividends to the owners\nif (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n}\n\/\/TODO: remove the else part later\nelse{\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\nportfolio.exercise_dividends(starting_date);\n}\n\/\/ todo: remove\nif(portfolio.get_cash_available(starting_date) < 0){System.out.println(portfolio.get_cash_available(starting_date));}\nreporter.report(portfolio,starting_date);\nstarting_date = LocalDate.parse(starting_date).plusDays(1).toString();\n}\nportfolio.order_results_to_file(order_file_name,ending_date);\nLong ending_time = System.currentTimeMillis();\nSystem.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\nSystem.out.println(\"Trading simulation ended: \");\nSystem.out.println(\"Simulation took \" + Math.round((ending_time - starting_time) * 0.001 * 1 \/ 60) + \" minutes to complete\");\nreturn reporter;\n}\n\n\/\/0. Write dividend dates to dividend array\n\/\/todo: implement array\nList<String> dividend_dates = new ArrayList<>();\nif (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);}\nwhile (final_time == 0) {\n\/\/TECHNICAL\nif (starting_date.equals(ending_date)) {\nfinal_time++;\n}\n\/\/Check if we have data about this day in the database? Maybe it's Christmas or maybe it's the weekend.\nif (portfolio.getDatabase().contains_day(starting_date)) {\n\/\/1. Dividend payments to other parties\nportfolio.exercise_dividends(starting_date);\n\/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n\/\/3. Strategy((1.)unemployment rate, (2.) P\/E (3) moving average (4) RSI)\nstrategy.setPortfolio(strategy.trade_all(starting_date));\n\/\/4. Pay dividends to the owners\nif (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n}\n\/\/TODO: remove the else part later\nelse{\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\nportfolio.exercise_dividends(starting_date);\n}\n\/\/ todo: remove\nif(portfolio.get_cash_available(starting_date) < 0){System.out.println(portfolio.get_cash_available(starting_date));}\nreporter.report(portfolio,starting_date);\nstarting_date = LocalDate.parse(starting_date).plusDays(1).toString();\n}\nportfolio.order_results_to_file(order_file_name,ending_date);\nLong ending_time = System.currentTimeMillis();\nSystem.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\nSystem.out.println(\"Trading simulation ended: \");\nSystem.out.println(\"Simulation took \" + Math.round((ending_time - starting_time) * 0.001 * 1 \/ 60) + \" minutes to complete\");\nreturn reporter;\n}\n\n\/\/TECHNICAL\nif (starting_date.equals(ending_date)) {\nfinal_time++;\n}\n\/\/Check if we have data about this day in the database? Maybe it's Christmas or maybe it's the weekend.\nif (portfolio.getDatabase().contains_day(starting_date)) {\n\/\/1. Dividend payments to other parties\nportfolio.exercise_dividends(starting_date);\n\/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n\/\/3. Strategy((1.)unemployment rate, (2.) P\/E (3) moving average (4) RSI)\nstrategy.setPortfolio(strategy.trade_all(starting_date));\n\/\/4. Pay dividends to the owners\nif (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n}\n\/\/TODO: remove the else part later\nelse{\nportfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\nportfolio.exercise_dividends(starting_date);\n}\n\/\/ todo: remove\nif(portfolio.get_cash_available(starting_date) < 0){System.out.println(portfolio.get_cash_available(starting_date));}\nreporter.report(portfolio,starting_date);\nstarting_date = LocalDate.parse(starting_date).plusDays(1).toString();\n}\nportfolio.order_results_to_file(order_file_name,ending_date);\nLong ending_time = System.currentTimeMillis();\nSystem.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\nSystem.out.println(\"Trading simulation ended: \");\nSystem.out.println(\"Simulation took \" + Math.round((ending_time - starting_time) * 0.001 * 1 \/ 60) + \" minutes to complete\");\nreturn reporter;\n}","label":[1,1,0,0]}
{"id":12644,"original_code":"public void sendMessage(long chatId, Response response) {\n        var request = responseToSendMessageConverter.convert(response, chatId);\n        telegramBot.execute(request, new Callback<>() {\n            @Override\n            public void onResponse(SendMessage sendMessage, SendResponse sendResponse) {\n                \/\/ Do nothing\n            }\n            @Override\n            public void onFailure(SendMessage sendMessage, IOException e) {\n                log.warn(\"Error occurred when sending message {}, exception: {}\", request, e);\n            }\n        });\n    }","code":"public void sendMessage(long chatId, Response response) {\n        var request = responseToSendMessageConverter.convert(response, chatId);\n        telegramBot.execute(request, new Callback<>() {\n            @Override\n            public void onResponse(SendMessage sendMessage, SendResponse sendResponse) {\n               \n            }\n            @Override\n            public void onFailure(SendMessage sendMessage, IOException e) {\n                log.warn(\"Error occurred when sending message {}, exception: {}\", request, e);\n            }\n        });\n    }","cleancode":"public void sendmessage(long chatid, response response) { var request = responsetosendmessageconverter.convert(response, chatid); telegrambot.execute(request, new callback<>() { @override public void onresponse(sendmessage sendmessage, sendresponse sendresponse) { } @override public void onfailure(sendmessage sendmessage, ioexception e) { log.warn(\"error occurred when sending message {}, exception: {}\", request, e); } }); }","comment":"\/\/ todo: 04\/10\/2020 should be uni\n\/\/ do nothing","repo":"MisterRnobe\/sodexo-tg-bot","code_context_2":"public void sendMessage(long chatId, Response response) {\nvar request = responseToSendMessageConverter.convert(response, chatId);\ntelegramBot.execute(request, new Callback<>() {\n@Override\npublic void onResponse(SendMessage sendMessage, SendResponse sendResponse) {\n\/\/ Do nothing\n}\n@Override\npublic void onFailure(SendMessage sendMessage, IOException e) {\nlog.warn(\"Error occurred when sending message {}, exception: {}\", request, e);\n}\n});\n}\n\n@Override\npublic void onResponse(SendMessage sendMessage, SendResponse sendResponse) {\n\/\/ Do nothing\n}\n@Override","code_context_10":"public void sendMessage(long chatId, Response response) {\nvar request = responseToSendMessageConverter.convert(response, chatId);\ntelegramBot.execute(request, new Callback<>() {\n@Override\npublic void onResponse(SendMessage sendMessage, SendResponse sendResponse) {\n\/\/ Do nothing\n}\n@Override\npublic void onFailure(SendMessage sendMessage, IOException e) {\nlog.warn(\"Error occurred when sending message {}, exception: {}\", request, e);\n}\n});\n}\n\npublic void sendMessage(long chatId, Response response) {\nvar request = responseToSendMessageConverter.convert(response, chatId);\ntelegramBot.execute(request, new Callback<>() {\n@Override\npublic void onResponse(SendMessage sendMessage, SendResponse sendResponse) {\n\/\/ Do nothing\n}\n@Override\npublic void onFailure(SendMessage sendMessage, IOException e) {\nlog.warn(\"Error occurred when sending message {}, exception: {}\", request, e);\n}\n});\n}","code_context_20":"public void sendMessage(long chatId, Response response) {\nvar request = responseToSendMessageConverter.convert(response, chatId);\ntelegramBot.execute(request, new Callback<>() {\n@Override\npublic void onResponse(SendMessage sendMessage, SendResponse sendResponse) {\n\/\/ Do nothing\n}\n@Override\npublic void onFailure(SendMessage sendMessage, IOException e) {\nlog.warn(\"Error occurred when sending message {}, exception: {}\", request, e);\n}\n});\n}\n\npublic void sendMessage(long chatId, Response response) {\nvar request = responseToSendMessageConverter.convert(response, chatId);\ntelegramBot.execute(request, new Callback<>() {\n@Override\npublic void onResponse(SendMessage sendMessage, SendResponse sendResponse) {\n\/\/ Do nothing\n}\n@Override\npublic void onFailure(SendMessage sendMessage, IOException e) {\nlog.warn(\"Error occurred when sending message {}, exception: {}\", request, e);\n}\n});\n}","label":[1,0,0,0]}
{"id":12762,"original_code":"public static DatabindException from(SerializerProvider ctxt, String msg, Throwable problem) {\n        \/\/ 17-Aug-2015, tatu: As per [databind#903] this is bit problematic as\n        \/\/   SerializerProvider instance does not currently hold on to generator...\n        return new DatabindException(ctxt.getGenerator(), msg, problem);\n    }","code":"public static DatabindException from(SerializerProvider ctxt, String msg, Throwable problem) {\n       \n       \n        return new DatabindException(ctxt.getGenerator(), msg, problem);\n    }","cleancode":"public static databindexception from(serializerprovider ctxt, string msg, throwable problem) { return new databindexception(ctxt.getgenerator(), msg, problem); }","comment":"\/\/ 17-aug-2015, tatu: as per [databind#903] this is bit problematic as \/\/ serializerprovider instance does not currently hold on to generator...","repo":"Migwel\/jackson-databind","code_context_2":"public static DatabindException from(SerializerProvider ctxt, String msg, Throwable problem) {\n\/\/ 17-Aug-2015, tatu: As per [databind#903] this is bit problematic as\n\/\/ SerializerProvider instance does not currently hold on to generator...\nreturn new DatabindException(ctxt.getGenerator(), msg, problem);\n}","code_context_10":"public static DatabindException from(SerializerProvider ctxt, String msg, Throwable problem) {\n\/\/ 17-Aug-2015, tatu: As per [databind#903] this is bit problematic as\n\/\/ SerializerProvider instance does not currently hold on to generator...\nreturn new DatabindException(ctxt.getGenerator(), msg, problem);\n}","code_context_20":"public static DatabindException from(SerializerProvider ctxt, String msg, Throwable problem) {\n\/\/ 17-Aug-2015, tatu: As per [databind#903] this is bit problematic as\n\/\/ SerializerProvider instance does not currently hold on to generator...\nreturn new DatabindException(ctxt.getGenerator(), msg, problem);\n}","label":[0,0,1,0]}
{"id":12861,"original_code":"private void parseMedia() {\n        assertTypeAndAdvance(PXStylesheetTokenType.MEDIA);\n        \/\/ TODO: support media types, NOT, and ONLY. Skipping for now\n        while (isType(PXStylesheetTokenType.IDENTIFIER)) {\n            advance();\n        }\n        \/\/ 'and' may appear here\n        advanceIfIsType(PXStylesheetTokenType.AND);\n        \/\/ parse optional expressions\n        if (isType(PXStylesheetTokenType.LPAREN)) {\n            parseMediaExpressions();\n        }\n        \/\/ parse body\n        if (isType(PXStylesheetTokenType.LCURLY)) {\n            try {\n                advance();\n                while (currentLexeme != null\n                        && currentLexeme.getType() != PXStylesheetTokenType.EOF\n                        && !isType(PXStylesheetTokenType.RCURLY)) {\n                    parseRuleSet();\n                }\n                advanceIfIsType(PXStylesheetTokenType.RCURLY,\n                        \"Expected @media body closing curly brace\");\n            } finally {\n                \/\/ reset active media query to none\n                currentStyleSheet.setActiveMediaQuery(null);\n            }\n        }\n    }","code":"private void parseMedia() {\n        assertTypeAndAdvance(PXStylesheetTokenType.MEDIA);\n       \n        while (isType(PXStylesheetTokenType.IDENTIFIER)) {\n            advance();\n        }\n       \n        advanceIfIsType(PXStylesheetTokenType.AND);\n       \n        if (isType(PXStylesheetTokenType.LPAREN)) {\n            parseMediaExpressions();\n        }\n       \n        if (isType(PXStylesheetTokenType.LCURLY)) {\n            try {\n                advance();\n                while (currentLexeme != null\n                        && currentLexeme.getType() != PXStylesheetTokenType.EOF\n                        && !isType(PXStylesheetTokenType.RCURLY)) {\n                    parseRuleSet();\n                }\n                advanceIfIsType(PXStylesheetTokenType.RCURLY,\n                        \"Expected @media body closing curly brace\");\n            } finally {\n               \n                currentStyleSheet.setActiveMediaQuery(null);\n            }\n        }\n    }","cleancode":"private void parsemedia() { asserttypeandadvance(pxstylesheettokentype.media); while (istype(pxstylesheettokentype.identifier)) { advance(); } advanceifistype(pxstylesheettokentype.and); if (istype(pxstylesheettokentype.lparen)) { parsemediaexpressions(); } if (istype(pxstylesheettokentype.lcurly)) { try { advance(); while (currentlexeme != null && currentlexeme.gettype() != pxstylesheettokentype.eof && !istype(pxstylesheettokentype.rcurly)) { parseruleset(); } advanceifistype(pxstylesheettokentype.rcurly, \"expected @media body closing curly brace\"); } finally { currentstylesheet.setactivemediaquery(null); } } }","comment":"\/\/ todo: support media types, not, and only. skipping for now\n\/\/ 'and' may appear here\n\/\/ parse optional expressions\n\/\/ parse body\n\/\/ reset active media query to none","repo":"Pixate\/pixate-freestyle-android","code_context_2":"private void parseMedia() {\nassertTypeAndAdvance(PXStylesheetTokenType.MEDIA);\n\/\/ TODO: support media types, NOT, and ONLY. Skipping for now\nwhile (isType(PXStylesheetTokenType.IDENTIFIER)) {\nadvance();\n\nadvance();\n}\n\/\/ 'and' may appear here\nadvanceIfIsType(PXStylesheetTokenType.AND);\n\/\/ parse optional expressions\n\n\/\/ 'and' may appear here\nadvanceIfIsType(PXStylesheetTokenType.AND);\n\/\/ parse optional expressions\nif (isType(PXStylesheetTokenType.LPAREN)) {\nparseMediaExpressions();\n\nparseMediaExpressions();\n}\n\/\/ parse body\nif (isType(PXStylesheetTokenType.LCURLY)) {\ntry {\n\n\"Expected @media body closing curly brace\");\n} finally {\n\/\/ reset active media query to none\ncurrentStyleSheet.setActiveMediaQuery(null);\n}","code_context_10":"private void parseMedia() {\nassertTypeAndAdvance(PXStylesheetTokenType.MEDIA);\n\/\/ TODO: support media types, NOT, and ONLY. Skipping for now\nwhile (isType(PXStylesheetTokenType.IDENTIFIER)) {\nadvance();\n}\n\/\/ 'and' may appear here\nadvanceIfIsType(PXStylesheetTokenType.AND);\n\/\/ parse optional expressions\nif (isType(PXStylesheetTokenType.LPAREN)) {\nparseMediaExpressions();\n}\n\/\/ parse body\n\nprivate void parseMedia() {\nassertTypeAndAdvance(PXStylesheetTokenType.MEDIA);\n\/\/ TODO: support media types, NOT, and ONLY. Skipping for now\nwhile (isType(PXStylesheetTokenType.IDENTIFIER)) {\nadvance();\n}\n\/\/ 'and' may appear here\nadvanceIfIsType(PXStylesheetTokenType.AND);\n\/\/ parse optional expressions\nif (isType(PXStylesheetTokenType.LPAREN)) {\nparseMediaExpressions();\n}\n\/\/ parse body\nif (isType(PXStylesheetTokenType.LCURLY)) {\ntry {\nadvance();\nwhile (currentLexeme != null\n\nprivate void parseMedia() {\nassertTypeAndAdvance(PXStylesheetTokenType.MEDIA);\n\/\/ TODO: support media types, NOT, and ONLY. Skipping for now\nwhile (isType(PXStylesheetTokenType.IDENTIFIER)) {\nadvance();\n}\n\/\/ 'and' may appear here\nadvanceIfIsType(PXStylesheetTokenType.AND);\n\/\/ parse optional expressions\nif (isType(PXStylesheetTokenType.LPAREN)) {\nparseMediaExpressions();\n}\n\/\/ parse body\nif (isType(PXStylesheetTokenType.LCURLY)) {\ntry {\nadvance();\nwhile (currentLexeme != null\n&& currentLexeme.getType() != PXStylesheetTokenType.EOF\n&& !isType(PXStylesheetTokenType.RCURLY)) {\n\n\/\/ TODO: support media types, NOT, and ONLY. Skipping for now\nwhile (isType(PXStylesheetTokenType.IDENTIFIER)) {\nadvance();\n}\n\/\/ 'and' may appear here\nadvanceIfIsType(PXStylesheetTokenType.AND);\n\/\/ parse optional expressions\nif (isType(PXStylesheetTokenType.LPAREN)) {\nparseMediaExpressions();\n}\n\/\/ parse body\nif (isType(PXStylesheetTokenType.LCURLY)) {\ntry {\nadvance();\nwhile (currentLexeme != null\n&& currentLexeme.getType() != PXStylesheetTokenType.EOF\n&& !isType(PXStylesheetTokenType.RCURLY)) {\nparseRuleSet();\n}\nadvanceIfIsType(PXStylesheetTokenType.RCURLY,\n\"Expected @media body closing curly brace\");\n\ntry {\nadvance();\nwhile (currentLexeme != null\n&& currentLexeme.getType() != PXStylesheetTokenType.EOF\n&& !isType(PXStylesheetTokenType.RCURLY)) {\nparseRuleSet();\n}\nadvanceIfIsType(PXStylesheetTokenType.RCURLY,\n\"Expected @media body closing curly brace\");\n} finally {\n\/\/ reset active media query to none\ncurrentStyleSheet.setActiveMediaQuery(null);\n}\n}\n}","code_context_20":"private void parseMedia() {\nassertTypeAndAdvance(PXStylesheetTokenType.MEDIA);\n\/\/ TODO: support media types, NOT, and ONLY. Skipping for now\nwhile (isType(PXStylesheetTokenType.IDENTIFIER)) {\nadvance();\n}\n\/\/ 'and' may appear here\nadvanceIfIsType(PXStylesheetTokenType.AND);\n\/\/ parse optional expressions\nif (isType(PXStylesheetTokenType.LPAREN)) {\nparseMediaExpressions();\n}\n\/\/ parse body\nif (isType(PXStylesheetTokenType.LCURLY)) {\ntry {\nadvance();\nwhile (currentLexeme != null\n&& currentLexeme.getType() != PXStylesheetTokenType.EOF\n&& !isType(PXStylesheetTokenType.RCURLY)) {\nparseRuleSet();\n}\nadvanceIfIsType(PXStylesheetTokenType.RCURLY,\n\"Expected @media body closing curly brace\");\n\nprivate void parseMedia() {\nassertTypeAndAdvance(PXStylesheetTokenType.MEDIA);\n\/\/ TODO: support media types, NOT, and ONLY. Skipping for now\nwhile (isType(PXStylesheetTokenType.IDENTIFIER)) {\nadvance();\n}\n\/\/ 'and' may appear here\nadvanceIfIsType(PXStylesheetTokenType.AND);\n\/\/ parse optional expressions\nif (isType(PXStylesheetTokenType.LPAREN)) {\nparseMediaExpressions();\n}\n\/\/ parse body\nif (isType(PXStylesheetTokenType.LCURLY)) {\ntry {\nadvance();\nwhile (currentLexeme != null\n&& currentLexeme.getType() != PXStylesheetTokenType.EOF\n&& !isType(PXStylesheetTokenType.RCURLY)) {\nparseRuleSet();\n}\nadvanceIfIsType(PXStylesheetTokenType.RCURLY,\n\"Expected @media body closing curly brace\");\n} finally {\n\/\/ reset active media query to none\ncurrentStyleSheet.setActiveMediaQuery(null);\n}\n\nprivate void parseMedia() {\nassertTypeAndAdvance(PXStylesheetTokenType.MEDIA);\n\/\/ TODO: support media types, NOT, and ONLY. Skipping for now\nwhile (isType(PXStylesheetTokenType.IDENTIFIER)) {\nadvance();\n}\n\/\/ 'and' may appear here\nadvanceIfIsType(PXStylesheetTokenType.AND);\n\/\/ parse optional expressions\nif (isType(PXStylesheetTokenType.LPAREN)) {\nparseMediaExpressions();\n}\n\/\/ parse body\nif (isType(PXStylesheetTokenType.LCURLY)) {\ntry {\nadvance();\nwhile (currentLexeme != null\n&& currentLexeme.getType() != PXStylesheetTokenType.EOF\n&& !isType(PXStylesheetTokenType.RCURLY)) {\nparseRuleSet();\n}\nadvanceIfIsType(PXStylesheetTokenType.RCURLY,\n\"Expected @media body closing curly brace\");\n} finally {\n\/\/ reset active media query to none\ncurrentStyleSheet.setActiveMediaQuery(null);\n}\n}\n}\n\nprivate void parseMedia() {\nassertTypeAndAdvance(PXStylesheetTokenType.MEDIA);\n\/\/ TODO: support media types, NOT, and ONLY. Skipping for now\nwhile (isType(PXStylesheetTokenType.IDENTIFIER)) {\nadvance();\n}\n\/\/ 'and' may appear here\nadvanceIfIsType(PXStylesheetTokenType.AND);\n\/\/ parse optional expressions\nif (isType(PXStylesheetTokenType.LPAREN)) {\nparseMediaExpressions();\n}\n\/\/ parse body\nif (isType(PXStylesheetTokenType.LCURLY)) {\ntry {\nadvance();\nwhile (currentLexeme != null\n&& currentLexeme.getType() != PXStylesheetTokenType.EOF\n&& !isType(PXStylesheetTokenType.RCURLY)) {\nparseRuleSet();\n}\nadvanceIfIsType(PXStylesheetTokenType.RCURLY,\n\"Expected @media body closing curly brace\");\n} finally {\n\/\/ reset active media query to none\ncurrentStyleSheet.setActiveMediaQuery(null);\n}\n}\n}\n\nadvance();\n}\n\/\/ 'and' may appear here\nadvanceIfIsType(PXStylesheetTokenType.AND);\n\/\/ parse optional expressions\nif (isType(PXStylesheetTokenType.LPAREN)) {\nparseMediaExpressions();\n}\n\/\/ parse body\nif (isType(PXStylesheetTokenType.LCURLY)) {\ntry {\nadvance();\nwhile (currentLexeme != null\n&& currentLexeme.getType() != PXStylesheetTokenType.EOF\n&& !isType(PXStylesheetTokenType.RCURLY)) {\nparseRuleSet();\n}\nadvanceIfIsType(PXStylesheetTokenType.RCURLY,\n\"Expected @media body closing curly brace\");\n} finally {\n\/\/ reset active media query to none\ncurrentStyleSheet.setActiveMediaQuery(null);\n}\n}\n}","label":[1,0,0,0]}
{"id":21298,"original_code":"private void init() {\n    try { \n      \/\/ TODO: detect if already have a gradle setup\n      \/\/ TODO: later, use always same and symlink if possible to save time\n      setupBuildFiles();\n      Files.createDirectories(srcFolder);\n      Files.walkFileTree(projectHome.toPath(), new FileTransferProcessor()); \n    }\n    catch (Exception e) { throw new RuntimeException(e); }\n  }","code":"private void init() {\n    try { \n     \n     \n      setupBuildFiles();\n      Files.createDirectories(srcFolder);\n      Files.walkFileTree(projectHome.toPath(), new FileTransferProcessor()); \n    }\n    catch (Exception e) { throw new RuntimeException(e); }\n  }","cleancode":"private void init() { try { setupbuildfiles(); files.createdirectories(srcfolder); files.walkfiletree(projecthome.topath(), new filetransferprocessor()); } catch (exception e) { throw new runtimeexception(e); } }","comment":"\/\/ todo: detect if already have a gradle setup \/\/ todo: later, use always same and symlink if possible to save time","repo":"K1UBC\/BlangModel","code_context_2":"private void init() {\ntry {\n\/\/ TODO: detect if already have a gradle setup\n\/\/ TODO: later, use always same and symlink if possible to save time\nsetupBuildFiles();\nFiles.createDirectories(srcFolder);","code_context_10":"private void init() {\ntry {\n\/\/ TODO: detect if already have a gradle setup\n\/\/ TODO: later, use always same and symlink if possible to save time\nsetupBuildFiles();\nFiles.createDirectories(srcFolder);\nFiles.walkFileTree(projectHome.toPath(), new FileTransferProcessor());\n}\ncatch (Exception e) { throw new RuntimeException(e); }\n}","code_context_20":"private void init() {\ntry {\n\/\/ TODO: detect if already have a gradle setup\n\/\/ TODO: later, use always same and symlink if possible to save time\nsetupBuildFiles();\nFiles.createDirectories(srcFolder);\nFiles.walkFileTree(projectHome.toPath(), new FileTransferProcessor());\n}\ncatch (Exception e) { throw new RuntimeException(e); }\n}","label":[1,0,0,0]}
{"id":30159,"original_code":"public <T> DynamicType.Builder<T> apply(DynamicType.Builder<T> builder) {\n\t\tTypeDescription description = builder.toTypeDescription();\n\t\tList<MethodDescription> methods = getMethodDescriptionList(description);\n\t\tenhanceCasesByDynamicDefinitions(methods);\n\t\tbuilder = enhanceCasesByOverrides(builder, description, methods);\n\t\tif(cases.isEmpty()) return builder;\n\t\tCase[] cases = this.cases.toArray(new Case[this.cases.size()]);\n\t\t\/\/Lets cache presence of methods per condition\n\t\tboolean[] hasMatchedMethods = new boolean[cases.length];\n\t\tboolean[] hasOpositeMatchedMethods = new boolean[cases.length];\n\t\tfor (int i=0; i<cases.length; i++) {\n\t\t\thasMatchedMethods[i] = hasMatch(methods, cases[i].getMatcher());\n\t\t\thasOpositeMatchedMethods[i] = hasMatch(methods, not(cases[i].getMatcher()));\n\t\t}\n\t\tBigInteger permutationsTotal = BigInteger.ONE.shiftLeft(cases.length).subtract(BigInteger.ONE);\n\t\tfor(BigInteger currentPermutation = BigInteger.ONE; \n\t\t\t\tcurrentPermutation.compareTo(permutationsTotal)<=0;\n\t\t\t\tcurrentPermutation = currentPermutation.add(BigInteger.ONE)) {\n\t\t\t\/\/Finding Base Implementation: mostly recently added implementation (not Advice)\n\t\t\tImplementation baseImplementation = null;\n\t\t\tfor(int i=cases.length-1; i>=0; i--) {\n\t\t\t\tif(currentPermutation.testBit(i)) {\n\t\t\t\t\tImplementation impl = cases[i].getImplementation();\n\t\t\t\t\tif(baseImplementation==null) baseImplementation=cases[i].getImplementation();\n\t\t\t\t\tif(!(impl instanceof Advice)) {\n\t\t\t\t\t\tbaseImplementation = impl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tElementMatcher.Junction<? super MethodDescription> matcher = any();\n\t\t\tImplementation implementation = baseImplementation;\n\t\t\tint i = cases.length-1;\n\t\t\tfor(; i>=0; i--) {\n\t\t\t\tCase c = cases[i];\n\t\t\t\tboolean caseIncluded = currentPermutation.testBit(i); \/\/ Included or excluded\n\t\t\t\tif(!caseIncluded) continue; \/\/Advice will not be included in any case: moving forward\n\t\t\t\tif(!(caseIncluded?hasMatchedMethods[i]:hasOpositeMatchedMethods[i])) break; \/\/No such methods at all\n\t\t\t\tmatcher = matcher.and(caseIncluded?c.getMatcher():not(c.getMatcher()));\n\t\t\t\tif(caseIncluded \n\t\t\t\t\t\t&& c.getImplementation() instanceof Advice\n\t\t\t\t\t\t&& c.getImplementation() != baseImplementation) {\n\t\t\t\t\timplementation = ((Advice)c.getImplementation()).wrap(implementation);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i<0)\n\t\t\t\tbuilder = builder.method(matcher).intercept(implementation);\n\t\t}\n\t\treturn builder;\n\t}","code":"public <T> DynamicType.Builder<T> apply(DynamicType.Builder<T> builder) {\n\t\tTypeDescription description = builder.toTypeDescription();\n\t\tList<MethodDescription> methods = getMethodDescriptionList(description);\n\t\tenhanceCasesByDynamicDefinitions(methods);\n\t\tbuilder = enhanceCasesByOverrides(builder, description, methods);\n\t\tif(cases.isEmpty()) return builder;\n\t\tCase[] cases = this.cases.toArray(new Case[this.cases.size()]);\n\t\n\t\tboolean[] hasMatchedMethods = new boolean[cases.length];\n\t\tboolean[] hasOpositeMatchedMethods = new boolean[cases.length];\n\t\tfor (int i=0; i<cases.length; i++) {\n\t\t\thasMatchedMethods[i] = hasMatch(methods, cases[i].getMatcher());\n\t\t\thasOpositeMatchedMethods[i] = hasMatch(methods, not(cases[i].getMatcher()));\n\t\t}\n\t\tBigInteger permutationsTotal = BigInteger.ONE.shiftLeft(cases.length).subtract(BigInteger.ONE);\n\t\tfor(BigInteger currentPermutation = BigInteger.ONE; \n\t\t\t\tcurrentPermutation.compareTo(permutationsTotal)<=0;\n\t\t\t\tcurrentPermutation = currentPermutation.add(BigInteger.ONE)) {\n\t\t\n\t\t\tImplementation baseImplementation = null;\n\t\t\tfor(int i=cases.length-1; i>=0; i--) {\n\t\t\t\tif(currentPermutation.testBit(i)) {\n\t\t\t\t\tImplementation impl = cases[i].getImplementation();\n\t\t\t\t\tif(baseImplementation==null) baseImplementation=cases[i].getImplementation();\n\t\t\t\t\tif(!(impl instanceof Advice)) {\n\t\t\t\t\t\tbaseImplementation = impl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tElementMatcher.Junction<? super MethodDescription> matcher = any();\n\t\t\tImplementation implementation = baseImplementation;\n\t\t\tint i = cases.length-1;\n\t\t\tfor(; i>=0; i--) {\n\t\t\t\tCase c = cases[i];\n\t\t\t\tboolean caseIncluded = currentPermutation.testBit(i);\n\t\t\t\tif(!caseIncluded) continue;\n\t\t\t\tif(!(caseIncluded?hasMatchedMethods[i]:hasOpositeMatchedMethods[i])) break;\n\t\t\t\tmatcher = matcher.and(caseIncluded?c.getMatcher():not(c.getMatcher()));\n\t\t\t\tif(caseIncluded \n\t\t\t\t\t\t&& c.getImplementation() instanceof Advice\n\t\t\t\t\t\t&& c.getImplementation() != baseImplementation) {\n\t\t\t\t\timplementation = ((Advice)c.getImplementation()).wrap(implementation);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i<0)\n\t\t\t\tbuilder = builder.method(matcher).intercept(implementation);\n\t\t}\n\t\treturn builder;\n\t}","cleancode":"public <t> dynamictype.builder<t> apply(dynamictype.builder<t> builder) { typedescription description = builder.totypedescription(); list<methoddescription> methods = getmethoddescriptionlist(description); enhancecasesbydynamicdefinitions(methods); builder = enhancecasesbyoverrides(builder, description, methods); if(cases.isempty()) return builder; case[] cases = this.cases.toarray(new case[this.cases.size()]); boolean[] hasmatchedmethods = new boolean[cases.length]; boolean[] hasopositematchedmethods = new boolean[cases.length]; for (int i=0; i<cases.length; i++) { hasmatchedmethods[i] = hasmatch(methods, cases[i].getmatcher()); hasopositematchedmethods[i] = hasmatch(methods, not(cases[i].getmatcher())); } biginteger permutationstotal = biginteger.one.shiftleft(cases.length).subtract(biginteger.one); for(biginteger currentpermutation = biginteger.one; currentpermutation.compareto(permutationstotal)<=0; currentpermutation = currentpermutation.add(biginteger.one)) { implementation baseimplementation = null; for(int i=cases.length-1; i>=0; i--) { if(currentpermutation.testbit(i)) { implementation impl = cases[i].getimplementation(); if(baseimplementation==null) baseimplementation=cases[i].getimplementation(); if(!(impl instanceof advice)) { baseimplementation = impl; break; } } } elementmatcher.junction<? super methoddescription> matcher = any(); implementation implementation = baseimplementation; int i = cases.length-1; for(; i>=0; i--) { case c = cases[i]; boolean caseincluded = currentpermutation.testbit(i); if(!caseincluded) continue; if(!(caseincluded?hasmatchedmethods[i]:hasopositematchedmethods[i])) break; matcher = matcher.and(caseincluded?c.getmatcher():not(c.getmatcher())); if(caseincluded && c.getimplementation() instanceof advice && c.getimplementation() != baseimplementation) { implementation = ((advice)c.getimplementation()).wrap(implementation); } } if(i<0) builder = builder.method(matcher).intercept(implementation); } return builder; }","comment":"\/** * executed at the end of {@link imutator}s chain to apply all scheduled changes in the builder * @param <t> type of the class to be built * @param builder bytebuddy builder * @return new instance of {@link dynamictype.builder} which contains all required changes *\/\n\/\/lets cache presence of methods per condition\n\/\/finding base implementation: mostly recently added implementation (not advice)\n\/\/ included or excluded\n\/\/advice will not be included in any case: moving forward\n\/\/no such methods at all","repo":"OrienteerBAP\/Transponder","code_context_2":"public <T> DynamicType.Builder<T> apply(DynamicType.Builder<T> builder) {\nTypeDescription description = builder.toTypeDescription();\nList<MethodDescription> methods = getMethodDescriptionList(description);\nenhanceCasesByDynamicDefinitions(methods);\nbuilder = enhanceCasesByOverrides(builder, description, methods);\nif(cases.isEmpty()) return builder;\nCase[] cases = this.cases.toArray(new Case[this.cases.size()]);\n\/\/Lets cache presence of methods per condition\nboolean[] hasMatchedMethods = new boolean[cases.length];\nboolean[] hasOpositeMatchedMethods = new boolean[cases.length];\nfor (int i=0; i<cases.length; i++) {\nhasMatchedMethods[i] = hasMatch(methods, cases[i].getMatcher());\nhasOpositeMatchedMethods[i] = hasMatch(methods, not(cases[i].getMatcher()));\n}\nBigInteger permutationsTotal = BigInteger.ONE.shiftLeft(cases.length).subtract(BigInteger.ONE);\nfor(BigInteger currentPermutation = BigInteger.ONE;\ncurrentPermutation.compareTo(permutationsTotal)<=0;\ncurrentPermutation = currentPermutation.add(BigInteger.ONE)) {\n\/\/Finding Base Implementation: mostly recently added implementation (not Advice)\nImplementation baseImplementation = null;\nfor(int i=cases.length-1; i>=0; i--) {\nif(currentPermutation.testBit(i)) {\nImplementation impl = cases[i].getImplementation();\nif(baseImplementation==null) baseImplementation=cases[i].getImplementation();\nif(!(impl instanceof Advice)) {\nbaseImplementation = impl;\nbreak;\n}\n}\n}\nElementMatcher.Junction<? super MethodDescription> matcher = any();\nImplementation implementation = baseImplementation;\nint i = cases.length-1;\nfor(; i>=0; i--) {\nCase c = cases[i];\nboolean caseIncluded = currentPermutation.testBit(i); \/\/ Included or excluded\nif(!caseIncluded) continue; \/\/Advice will not be included in any case: moving forward\nif(!(caseIncluded?hasMatchedMethods[i]:hasOpositeMatchedMethods[i])) break; \/\/No such methods at all\nmatcher = matcher.and(caseIncluded?c.getMatcher():not(c.getMatcher()));\nif(caseIncluded\n&& c.getImplementation() instanceof Advice\n&& c.getImplementation() != baseImplementation) {\nimplementation = ((Advice)c.getImplementation()).wrap(implementation);\n}\n}\nif(i<0)\nbuilder = builder.method(matcher).intercept(implementation);\n}\nreturn builder;\n}\n\nif(cases.isEmpty()) return builder;\nCase[] cases = this.cases.toArray(new Case[this.cases.size()]);\n\/\/Lets cache presence of methods per condition\nboolean[] hasMatchedMethods = new boolean[cases.length];\nboolean[] hasOpositeMatchedMethods = new boolean[cases.length];\n\ncurrentPermutation.compareTo(permutationsTotal)<=0;\ncurrentPermutation = currentPermutation.add(BigInteger.ONE)) {\n\/\/Finding Base Implementation: mostly recently added implementation (not Advice)\nImplementation baseImplementation = null;\nfor(int i=cases.length-1; i>=0; i--) {\n\nfor(; i>=0; i--) {\nCase c = cases[i];\nboolean caseIncluded = currentPermutation.testBit(i); \/\/ Included or excluded\nif(!caseIncluded) continue; \/\/Advice will not be included in any case: moving forward\nif(!(caseIncluded?hasMatchedMethods[i]:hasOpositeMatchedMethods[i])) break; \/\/No such methods at all\n\nCase c = cases[i];\nboolean caseIncluded = currentPermutation.testBit(i); \/\/ Included or excluded\nif(!caseIncluded) continue; \/\/Advice will not be included in any case: moving forward\nif(!(caseIncluded?hasMatchedMethods[i]:hasOpositeMatchedMethods[i])) break; \/\/No such methods at all\nmatcher = matcher.and(caseIncluded?c.getMatcher():not(c.getMatcher()));\n\nboolean caseIncluded = currentPermutation.testBit(i); \/\/ Included or excluded\nif(!caseIncluded) continue; \/\/Advice will not be included in any case: moving forward\nif(!(caseIncluded?hasMatchedMethods[i]:hasOpositeMatchedMethods[i])) break; \/\/No such methods at all\nmatcher = matcher.and(caseIncluded?c.getMatcher():not(c.getMatcher()));\nif(caseIncluded","code_context_10":"public <T> DynamicType.Builder<T> apply(DynamicType.Builder<T> builder) {\nTypeDescription description = builder.toTypeDescription();\nList<MethodDescription> methods = getMethodDescriptionList(description);\nenhanceCasesByDynamicDefinitions(methods);\nbuilder = enhanceCasesByOverrides(builder, description, methods);\nif(cases.isEmpty()) return builder;\nCase[] cases = this.cases.toArray(new Case[this.cases.size()]);\n\/\/Lets cache presence of methods per condition\nboolean[] hasMatchedMethods = new boolean[cases.length];\nboolean[] hasOpositeMatchedMethods = new boolean[cases.length];\nfor (int i=0; i<cases.length; i++) {\nhasMatchedMethods[i] = hasMatch(methods, cases[i].getMatcher());\nhasOpositeMatchedMethods[i] = hasMatch(methods, not(cases[i].getMatcher()));\n}\nBigInteger permutationsTotal = BigInteger.ONE.shiftLeft(cases.length).subtract(BigInteger.ONE);\nfor(BigInteger currentPermutation = BigInteger.ONE;\ncurrentPermutation.compareTo(permutationsTotal)<=0;\ncurrentPermutation = currentPermutation.add(BigInteger.ONE)) {\n\/\/Finding Base Implementation: mostly recently added implementation (not Advice)\nImplementation baseImplementation = null;\nfor(int i=cases.length-1; i>=0; i--) {\nif(currentPermutation.testBit(i)) {\nImplementation impl = cases[i].getImplementation();\nif(baseImplementation==null) baseImplementation=cases[i].getImplementation();\nif(!(impl instanceof Advice)) {\nbaseImplementation = impl;\nbreak;\n}\n}\n}\nElementMatcher.Junction<? super MethodDescription> matcher = any();\nImplementation implementation = baseImplementation;\nint i = cases.length-1;\nfor(; i>=0; i--) {\nCase c = cases[i];\nboolean caseIncluded = currentPermutation.testBit(i); \/\/ Included or excluded\nif(!caseIncluded) continue; \/\/Advice will not be included in any case: moving forward\nif(!(caseIncluded?hasMatchedMethods[i]:hasOpositeMatchedMethods[i])) break; \/\/No such methods at all\nmatcher = matcher.and(caseIncluded?c.getMatcher():not(c.getMatcher()));\nif(caseIncluded\n&& c.getImplementation() instanceof Advice\n&& c.getImplementation() != baseImplementation) {\nimplementation = ((Advice)c.getImplementation()).wrap(implementation);\n}\n}\nif(i<0)\nbuilder = builder.method(matcher).intercept(implementation);\n}\nreturn builder;\n}\n\npublic <T> DynamicType.Builder<T> apply(DynamicType.Builder<T> builder) {\nTypeDescription description = builder.toTypeDescription();\nList<MethodDescription> methods = getMethodDescriptionList(description);\nenhanceCasesByDynamicDefinitions(methods);\nbuilder = enhanceCasesByOverrides(builder, description, methods);\nif(cases.isEmpty()) return builder;\nCase[] cases = this.cases.toArray(new Case[this.cases.size()]);\n\/\/Lets cache presence of methods per condition\nboolean[] hasMatchedMethods = new boolean[cases.length];\nboolean[] hasOpositeMatchedMethods = new boolean[cases.length];\nfor (int i=0; i<cases.length; i++) {\nhasMatchedMethods[i] = hasMatch(methods, cases[i].getMatcher());\nhasOpositeMatchedMethods[i] = hasMatch(methods, not(cases[i].getMatcher()));\n}\nBigInteger permutationsTotal = BigInteger.ONE.shiftLeft(cases.length).subtract(BigInteger.ONE);\nfor(BigInteger currentPermutation = BigInteger.ONE;\ncurrentPermutation.compareTo(permutationsTotal)<=0;\ncurrentPermutation = currentPermutation.add(BigInteger.ONE)) {\n\nboolean[] hasMatchedMethods = new boolean[cases.length];\nboolean[] hasOpositeMatchedMethods = new boolean[cases.length];\nfor (int i=0; i<cases.length; i++) {\nhasMatchedMethods[i] = hasMatch(methods, cases[i].getMatcher());\nhasOpositeMatchedMethods[i] = hasMatch(methods, not(cases[i].getMatcher()));\n}\nBigInteger permutationsTotal = BigInteger.ONE.shiftLeft(cases.length).subtract(BigInteger.ONE);\nfor(BigInteger currentPermutation = BigInteger.ONE;\ncurrentPermutation.compareTo(permutationsTotal)<=0;\ncurrentPermutation = currentPermutation.add(BigInteger.ONE)) {\n\/\/Finding Base Implementation: mostly recently added implementation (not Advice)\nImplementation baseImplementation = null;\nfor(int i=cases.length-1; i>=0; i--) {\nif(currentPermutation.testBit(i)) {\nImplementation impl = cases[i].getImplementation();\nif(baseImplementation==null) baseImplementation=cases[i].getImplementation();\nif(!(impl instanceof Advice)) {\nbaseImplementation = impl;\nbreak;\n}\n}\n\nbaseImplementation = impl;\nbreak;\n}\n}\n}\nElementMatcher.Junction<? super MethodDescription> matcher = any();\nImplementation implementation = baseImplementation;\nint i = cases.length-1;\nfor(; i>=0; i--) {\nCase c = cases[i];\nboolean caseIncluded = currentPermutation.testBit(i); \/\/ Included or excluded\nif(!caseIncluded) continue; \/\/Advice will not be included in any case: moving forward\nif(!(caseIncluded?hasMatchedMethods[i]:hasOpositeMatchedMethods[i])) break; \/\/No such methods at all\nmatcher = matcher.and(caseIncluded?c.getMatcher():not(c.getMatcher()));\nif(caseIncluded\n&& c.getImplementation() instanceof Advice\n&& c.getImplementation() != baseImplementation) {\nimplementation = ((Advice)c.getImplementation()).wrap(implementation);\n}\n}\nif(i<0)\n\nbreak;\n}\n}\n}\nElementMatcher.Junction<? super MethodDescription> matcher = any();\nImplementation implementation = baseImplementation;\nint i = cases.length-1;\nfor(; i>=0; i--) {\nCase c = cases[i];\nboolean caseIncluded = currentPermutation.testBit(i); \/\/ Included or excluded\nif(!caseIncluded) continue; \/\/Advice will not be included in any case: moving forward\nif(!(caseIncluded?hasMatchedMethods[i]:hasOpositeMatchedMethods[i])) break; \/\/No such methods at all\nmatcher = matcher.and(caseIncluded?c.getMatcher():not(c.getMatcher()));\nif(caseIncluded\n&& c.getImplementation() instanceof Advice\n&& c.getImplementation() != baseImplementation) {\nimplementation = ((Advice)c.getImplementation()).wrap(implementation);\n}\n}\nif(i<0)\nbuilder = builder.method(matcher).intercept(implementation);\n\n}\n}\n}\nElementMatcher.Junction<? super MethodDescription> matcher = any();\nImplementation implementation = baseImplementation;\nint i = cases.length-1;\nfor(; i>=0; i--) {\nCase c = cases[i];\nboolean caseIncluded = currentPermutation.testBit(i); \/\/ Included or excluded\nif(!caseIncluded) continue; \/\/Advice will not be included in any case: moving forward\nif(!(caseIncluded?hasMatchedMethods[i]:hasOpositeMatchedMethods[i])) break; \/\/No such methods at all\nmatcher = matcher.and(caseIncluded?c.getMatcher():not(c.getMatcher()));\nif(caseIncluded\n&& c.getImplementation() instanceof Advice\n&& c.getImplementation() != baseImplementation) {\nimplementation = ((Advice)c.getImplementation()).wrap(implementation);\n}\n}\nif(i<0)\nbuilder = builder.method(matcher).intercept(implementation);\n}","code_context_20":"public <T> DynamicType.Builder<T> apply(DynamicType.Builder<T> builder) {\nTypeDescription description = builder.toTypeDescription();\nList<MethodDescription> methods = getMethodDescriptionList(description);\nenhanceCasesByDynamicDefinitions(methods);\nbuilder = enhanceCasesByOverrides(builder, description, methods);\nif(cases.isEmpty()) return builder;\nCase[] cases = this.cases.toArray(new Case[this.cases.size()]);\n\/\/Lets cache presence of methods per condition\nboolean[] hasMatchedMethods = new boolean[cases.length];\nboolean[] hasOpositeMatchedMethods = new boolean[cases.length];\nfor (int i=0; i<cases.length; i++) {\nhasMatchedMethods[i] = hasMatch(methods, cases[i].getMatcher());\nhasOpositeMatchedMethods[i] = hasMatch(methods, not(cases[i].getMatcher()));\n}\nBigInteger permutationsTotal = BigInteger.ONE.shiftLeft(cases.length).subtract(BigInteger.ONE);\nfor(BigInteger currentPermutation = BigInteger.ONE;\ncurrentPermutation.compareTo(permutationsTotal)<=0;\ncurrentPermutation = currentPermutation.add(BigInteger.ONE)) {\n\/\/Finding Base Implementation: mostly recently added implementation (not Advice)\nImplementation baseImplementation = null;\nfor(int i=cases.length-1; i>=0; i--) {\nif(currentPermutation.testBit(i)) {\nImplementation impl = cases[i].getImplementation();\nif(baseImplementation==null) baseImplementation=cases[i].getImplementation();\nif(!(impl instanceof Advice)) {\nbaseImplementation = impl;\nbreak;\n}\n}\n}\nElementMatcher.Junction<? super MethodDescription> matcher = any();\nImplementation implementation = baseImplementation;\nint i = cases.length-1;\nfor(; i>=0; i--) {\nCase c = cases[i];\nboolean caseIncluded = currentPermutation.testBit(i); \/\/ Included or excluded\nif(!caseIncluded) continue; \/\/Advice will not be included in any case: moving forward\nif(!(caseIncluded?hasMatchedMethods[i]:hasOpositeMatchedMethods[i])) break; \/\/No such methods at all\nmatcher = matcher.and(caseIncluded?c.getMatcher():not(c.getMatcher()));\nif(caseIncluded\n&& c.getImplementation() instanceof Advice\n&& c.getImplementation() != baseImplementation) {\nimplementation = ((Advice)c.getImplementation()).wrap(implementation);\n}\n}\nif(i<0)\nbuilder = builder.method(matcher).intercept(implementation);\n}\nreturn builder;\n}\n\npublic <T> DynamicType.Builder<T> apply(DynamicType.Builder<T> builder) {\nTypeDescription description = builder.toTypeDescription();\nList<MethodDescription> methods = getMethodDescriptionList(description);\nenhanceCasesByDynamicDefinitions(methods);\nbuilder = enhanceCasesByOverrides(builder, description, methods);\nif(cases.isEmpty()) return builder;\nCase[] cases = this.cases.toArray(new Case[this.cases.size()]);\n\/\/Lets cache presence of methods per condition\nboolean[] hasMatchedMethods = new boolean[cases.length];\nboolean[] hasOpositeMatchedMethods = new boolean[cases.length];\nfor (int i=0; i<cases.length; i++) {\nhasMatchedMethods[i] = hasMatch(methods, cases[i].getMatcher());\nhasOpositeMatchedMethods[i] = hasMatch(methods, not(cases[i].getMatcher()));\n}\nBigInteger permutationsTotal = BigInteger.ONE.shiftLeft(cases.length).subtract(BigInteger.ONE);\nfor(BigInteger currentPermutation = BigInteger.ONE;\ncurrentPermutation.compareTo(permutationsTotal)<=0;\ncurrentPermutation = currentPermutation.add(BigInteger.ONE)) {\n\/\/Finding Base Implementation: mostly recently added implementation (not Advice)\nImplementation baseImplementation = null;\nfor(int i=cases.length-1; i>=0; i--) {\nif(currentPermutation.testBit(i)) {\nImplementation impl = cases[i].getImplementation();\nif(baseImplementation==null) baseImplementation=cases[i].getImplementation();\nif(!(impl instanceof Advice)) {\nbaseImplementation = impl;\nbreak;\n}\n\npublic <T> DynamicType.Builder<T> apply(DynamicType.Builder<T> builder) {\nTypeDescription description = builder.toTypeDescription();\nList<MethodDescription> methods = getMethodDescriptionList(description);\nenhanceCasesByDynamicDefinitions(methods);\nbuilder = enhanceCasesByOverrides(builder, description, methods);\nif(cases.isEmpty()) return builder;\nCase[] cases = this.cases.toArray(new Case[this.cases.size()]);\n\/\/Lets cache presence of methods per condition\nboolean[] hasMatchedMethods = new boolean[cases.length];\nboolean[] hasOpositeMatchedMethods = new boolean[cases.length];\nfor (int i=0; i<cases.length; i++) {\nhasMatchedMethods[i] = hasMatch(methods, cases[i].getMatcher());\nhasOpositeMatchedMethods[i] = hasMatch(methods, not(cases[i].getMatcher()));\n}\nBigInteger permutationsTotal = BigInteger.ONE.shiftLeft(cases.length).subtract(BigInteger.ONE);\nfor(BigInteger currentPermutation = BigInteger.ONE;\ncurrentPermutation.compareTo(permutationsTotal)<=0;\ncurrentPermutation = currentPermutation.add(BigInteger.ONE)) {\n\/\/Finding Base Implementation: mostly recently added implementation (not Advice)\nImplementation baseImplementation = null;\nfor(int i=cases.length-1; i>=0; i--) {\nif(currentPermutation.testBit(i)) {\nImplementation impl = cases[i].getImplementation();\nif(baseImplementation==null) baseImplementation=cases[i].getImplementation();\nif(!(impl instanceof Advice)) {\nbaseImplementation = impl;\nbreak;\n}\n}\n}\nElementMatcher.Junction<? super MethodDescription> matcher = any();\nImplementation implementation = baseImplementation;\nint i = cases.length-1;\nfor(; i>=0; i--) {\nCase c = cases[i];\nboolean caseIncluded = currentPermutation.testBit(i); \/\/ Included or excluded\nif(!caseIncluded) continue; \/\/Advice will not be included in any case: moving forward\nif(!(caseIncluded?hasMatchedMethods[i]:hasOpositeMatchedMethods[i])) break; \/\/No such methods at all\nmatcher = matcher.and(caseIncluded?c.getMatcher():not(c.getMatcher()));\n\nfor(BigInteger currentPermutation = BigInteger.ONE;\ncurrentPermutation.compareTo(permutationsTotal)<=0;\ncurrentPermutation = currentPermutation.add(BigInteger.ONE)) {\n\/\/Finding Base Implementation: mostly recently added implementation (not Advice)\nImplementation baseImplementation = null;\nfor(int i=cases.length-1; i>=0; i--) {\nif(currentPermutation.testBit(i)) {\nImplementation impl = cases[i].getImplementation();\nif(baseImplementation==null) baseImplementation=cases[i].getImplementation();\nif(!(impl instanceof Advice)) {\nbaseImplementation = impl;\nbreak;\n}\n}\n}\nElementMatcher.Junction<? super MethodDescription> matcher = any();\nImplementation implementation = baseImplementation;\nint i = cases.length-1;\nfor(; i>=0; i--) {\nCase c = cases[i];\nboolean caseIncluded = currentPermutation.testBit(i); \/\/ Included or excluded\nif(!caseIncluded) continue; \/\/Advice will not be included in any case: moving forward\nif(!(caseIncluded?hasMatchedMethods[i]:hasOpositeMatchedMethods[i])) break; \/\/No such methods at all\nmatcher = matcher.and(caseIncluded?c.getMatcher():not(c.getMatcher()));\nif(caseIncluded\n&& c.getImplementation() instanceof Advice\n&& c.getImplementation() != baseImplementation) {\nimplementation = ((Advice)c.getImplementation()).wrap(implementation);\n}\n}\nif(i<0)\nbuilder = builder.method(matcher).intercept(implementation);\n}\nreturn builder;\n}\n\ncurrentPermutation.compareTo(permutationsTotal)<=0;\ncurrentPermutation = currentPermutation.add(BigInteger.ONE)) {\n\/\/Finding Base Implementation: mostly recently added implementation (not Advice)\nImplementation baseImplementation = null;\nfor(int i=cases.length-1; i>=0; i--) {\nif(currentPermutation.testBit(i)) {\nImplementation impl = cases[i].getImplementation();\nif(baseImplementation==null) baseImplementation=cases[i].getImplementation();\nif(!(impl instanceof Advice)) {\nbaseImplementation = impl;\nbreak;\n}\n}\n}\nElementMatcher.Junction<? super MethodDescription> matcher = any();\nImplementation implementation = baseImplementation;\nint i = cases.length-1;\nfor(; i>=0; i--) {\nCase c = cases[i];\nboolean caseIncluded = currentPermutation.testBit(i); \/\/ Included or excluded\nif(!caseIncluded) continue; \/\/Advice will not be included in any case: moving forward\nif(!(caseIncluded?hasMatchedMethods[i]:hasOpositeMatchedMethods[i])) break; \/\/No such methods at all\nmatcher = matcher.and(caseIncluded?c.getMatcher():not(c.getMatcher()));\nif(caseIncluded\n&& c.getImplementation() instanceof Advice\n&& c.getImplementation() != baseImplementation) {\nimplementation = ((Advice)c.getImplementation()).wrap(implementation);\n}\n}\nif(i<0)\nbuilder = builder.method(matcher).intercept(implementation);\n}\nreturn builder;\n}\n\ncurrentPermutation = currentPermutation.add(BigInteger.ONE)) {\n\/\/Finding Base Implementation: mostly recently added implementation (not Advice)\nImplementation baseImplementation = null;\nfor(int i=cases.length-1; i>=0; i--) {\nif(currentPermutation.testBit(i)) {\nImplementation impl = cases[i].getImplementation();\nif(baseImplementation==null) baseImplementation=cases[i].getImplementation();\nif(!(impl instanceof Advice)) {\nbaseImplementation = impl;\nbreak;\n}\n}\n}\nElementMatcher.Junction<? super MethodDescription> matcher = any();\nImplementation implementation = baseImplementation;\nint i = cases.length-1;\nfor(; i>=0; i--) {\nCase c = cases[i];\nboolean caseIncluded = currentPermutation.testBit(i); \/\/ Included or excluded\nif(!caseIncluded) continue; \/\/Advice will not be included in any case: moving forward\nif(!(caseIncluded?hasMatchedMethods[i]:hasOpositeMatchedMethods[i])) break; \/\/No such methods at all\nmatcher = matcher.and(caseIncluded?c.getMatcher():not(c.getMatcher()));\nif(caseIncluded\n&& c.getImplementation() instanceof Advice\n&& c.getImplementation() != baseImplementation) {\nimplementation = ((Advice)c.getImplementation()).wrap(implementation);\n}\n}\nif(i<0)\nbuilder = builder.method(matcher).intercept(implementation);\n}\nreturn builder;\n}","label":[0,1,0,0]}
{"id":30162,"original_code":"@Ignore\n    @Test\n    public void testDelete() throws Exception {\n        final Map<String, Object> headers = new HashMap<String, Object>();\n        \/\/ parameter type is String\n        headers.put(\"CamelGoogleDrive.fileId\", null);\n        \/\/ parameter type is String\n        headers.put(\"CamelGoogleDrive.parentId\", null);\n        final com.google.api.services.drive.Drive.Parents.Delete result = requestBodyAndHeaders(\"direct:\/\/DELETE\", null, headers);\n        assertNotNull(\"delete result\", result);\n        LOG.debug(\"delete: \" + result);\n    }","code":"@Ignore\n    @Test\n    public void testDelete() throws Exception {\n        final Map<String, Object> headers = new HashMap<String, Object>();\n       \n        headers.put(\"CamelGoogleDrive.fileId\", null);\n       \n        headers.put(\"CamelGoogleDrive.parentId\", null);\n        final com.google.api.services.drive.Drive.Parents.Delete result = requestBodyAndHeaders(\"direct:\/\/DELETE\", null, headers);\n        assertNotNull(\"delete result\", result);\n        LOG.debug(\"delete: \" + result);\n    }","cleancode":"@ignore @test public void testdelete() throws exception { final map<string, object> headers = new hashmap<string, object>(); headers.put(\"camelgoogledrive.fileid\", null); headers.put(\"camelgoogledrive.parentid\", null); final com.google.api.services.drive.drive.parents.delete result = requestbodyandheaders(\"direct:\/\/delete\", null, headers); assertnotnull(\"delete result\", result); log.debug(\"delete: \" + result); }","comment":"\/\/ todo provide parameter values for delete\n\/\/ parameter type is string\n\/\/ parameter type is string","repo":"NelloCarotenuto\/Weakness-Detector-for-Java","code_context_2":"@Ignore\n@Test\npublic void testDelete() throws Exception {\nfinal Map<String, Object> headers = new HashMap<String, Object>();\n\/\/ parameter type is String\nheaders.put(\"CamelGoogleDrive.fileId\", null);\n\/\/ parameter type is String\nheaders.put(\"CamelGoogleDrive.parentId\", null);\nfinal com.google.api.services.drive.Drive.Parents.Delete result = requestBodyAndHeaders(\"direct:\/\/DELETE\", null, headers);\nassertNotNull(\"delete result\", result);\nLOG.debug(\"delete: \" + result);\n}\n\npublic void testDelete() throws Exception {\nfinal Map<String, Object> headers = new HashMap<String, Object>();\n\/\/ parameter type is String\nheaders.put(\"CamelGoogleDrive.fileId\", null);\n\/\/ parameter type is String\n\npublic void testDelete() throws Exception {\nfinal Map<String, Object> headers = new HashMap<String, Object>();\n\/\/ parameter type is String\nheaders.put(\"CamelGoogleDrive.fileId\", null);\n\/\/ parameter type is String","code_context_10":"@Ignore\n@Test\npublic void testDelete() throws Exception {\nfinal Map<String, Object> headers = new HashMap<String, Object>();\n\/\/ parameter type is String\nheaders.put(\"CamelGoogleDrive.fileId\", null);\n\/\/ parameter type is String\nheaders.put(\"CamelGoogleDrive.parentId\", null);\nfinal com.google.api.services.drive.Drive.Parents.Delete result = requestBodyAndHeaders(\"direct:\/\/DELETE\", null, headers);\nassertNotNull(\"delete result\", result);\nLOG.debug(\"delete: \" + result);\n}\n\n@Ignore\n@Test\npublic void testDelete() throws Exception {\nfinal Map<String, Object> headers = new HashMap<String, Object>();\n\/\/ parameter type is String\nheaders.put(\"CamelGoogleDrive.fileId\", null);\n\/\/ parameter type is String\nheaders.put(\"CamelGoogleDrive.parentId\", null);\nfinal com.google.api.services.drive.Drive.Parents.Delete result = requestBodyAndHeaders(\"direct:\/\/DELETE\", null, headers);\nassertNotNull(\"delete result\", result);\nLOG.debug(\"delete: \" + result);\n}\n\n@Ignore\n@Test\npublic void testDelete() throws Exception {\nfinal Map<String, Object> headers = new HashMap<String, Object>();\n\/\/ parameter type is String\nheaders.put(\"CamelGoogleDrive.fileId\", null);\n\/\/ parameter type is String\nheaders.put(\"CamelGoogleDrive.parentId\", null);\nfinal com.google.api.services.drive.Drive.Parents.Delete result = requestBodyAndHeaders(\"direct:\/\/DELETE\", null, headers);\nassertNotNull(\"delete result\", result);\nLOG.debug(\"delete: \" + result);\n}","code_context_20":"@Ignore\n@Test\npublic void testDelete() throws Exception {\nfinal Map<String, Object> headers = new HashMap<String, Object>();\n\/\/ parameter type is String\nheaders.put(\"CamelGoogleDrive.fileId\", null);\n\/\/ parameter type is String\nheaders.put(\"CamelGoogleDrive.parentId\", null);\nfinal com.google.api.services.drive.Drive.Parents.Delete result = requestBodyAndHeaders(\"direct:\/\/DELETE\", null, headers);\nassertNotNull(\"delete result\", result);\nLOG.debug(\"delete: \" + result);\n}\n\n@Ignore\n@Test\npublic void testDelete() throws Exception {\nfinal Map<String, Object> headers = new HashMap<String, Object>();\n\/\/ parameter type is String\nheaders.put(\"CamelGoogleDrive.fileId\", null);\n\/\/ parameter type is String\nheaders.put(\"CamelGoogleDrive.parentId\", null);\nfinal com.google.api.services.drive.Drive.Parents.Delete result = requestBodyAndHeaders(\"direct:\/\/DELETE\", null, headers);\nassertNotNull(\"delete result\", result);\nLOG.debug(\"delete: \" + result);\n}\n\n@Ignore\n@Test\npublic void testDelete() throws Exception {\nfinal Map<String, Object> headers = new HashMap<String, Object>();\n\/\/ parameter type is String\nheaders.put(\"CamelGoogleDrive.fileId\", null);\n\/\/ parameter type is String\nheaders.put(\"CamelGoogleDrive.parentId\", null);\nfinal com.google.api.services.drive.Drive.Parents.Delete result = requestBodyAndHeaders(\"direct:\/\/DELETE\", null, headers);\nassertNotNull(\"delete result\", result);\nLOG.debug(\"delete: \" + result);\n}","label":[1,0,0,0]}
{"id":30229,"original_code":"@Test\n\tpublic void processMessage_shouldSetValue_CodedMatchingABooleanConceptForObsIfTheAnswerIs0Or1AndQuestionDatatypeIsCoded()\n\t        throws Exception {\n\t\tObsService os = Context.getObsService();\n\t\tString hl7string = \"MSH|^~\\\\&|FORMENTRY|AMRS.ELD|HL7LISTENER|AMRS.ELD|20080226102656||ORU^R01|JqnfhKKtouEz8kzTk6Zo|P|2.5|1||||||||16^AMRS.ELD.FORMID\\r\"\n\t\t        + \"PID|||7^^^^||Collet^Test^Chebaskwony||\\r\"\n\t\t        + \"PV1||O|1^Unknown Location||||1^Super User (1-8)|||||||||||||||||||||||||||||||||||||20080212|||||||V\\r\"\n\t\t        + \"ORC|RE||||||||20080226102537|1^Super User\\r\"\n\t\t        + \"OBR|1|||1238^MEDICAL RECORD OBSERVATIONS^99DCT\\r\"\n\t\t        + \"OBX|2|NM|21^CIVIL STATUS^99DCT||1|||||||||20080206\";\n\t\t\/\/ the expected question for the obs in the hl7 message has to be coded\n\t\tAssert.assertEquals(\"Coded\", Context.getConceptService().getConcept(21).getDatatype().getName());\n\t\tList<Obs> oldList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\n\t\tMessage hl7message = parser.parse(hl7string);\n\t\trouter.processMessage(hl7message);\n\t\t\/\/ hacky way to get the newly added obs and make tests on it\n\t\tList<Obs> newList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\n\t\tObs newObservation = null;\n\t\tfor (Obs newObs : newList) {\n\t\t\tif (!oldList.contains(newObs) && !newObs.isObsGrouping()) {\n\t\t\t\tnewObservation = newObs;\n\t\t\t}\n\t\t}\n\t\tAssert.assertEquals(Context.getConceptService().getTrueConcept(), newObservation.getValueCoded());\n\t}","code":"@Test\n\tpublic void processMessage_shouldSetValue_CodedMatchingABooleanConceptForObsIfTheAnswerIs0Or1AndQuestionDatatypeIsCoded()\n\t        throws Exception {\n\t\tObsService os = Context.getObsService();\n\t\tString hl7string = \"MSH|^~\\\\&|FORMENTRY|AMRS.ELD|HL7LISTENER|AMRS.ELD|20080226102656||ORU^R01|JqnfhKKtouEz8kzTk6Zo|P|2.5|1||||||||16^AMRS.ELD.FORMID\\r\"\n\t\t        + \"PID|||7^^^^||Collet^Test^Chebaskwony||\\r\"\n\t\t        + \"PV1||O|1^Unknown Location||||1^Super User (1-8)|||||||||||||||||||||||||||||||||||||20080212|||||||V\\r\"\n\t\t        + \"ORC|RE||||||||20080226102537|1^Super User\\r\"\n\t\t        + \"OBR|1|||1238^MEDICAL RECORD OBSERVATIONS^99DCT\\r\"\n\t\t        + \"OBX|2|NM|21^CIVIL STATUS^99DCT||1|||||||||20080206\";\n\t\n\t\tAssert.assertEquals(\"Coded\", Context.getConceptService().getConcept(21).getDatatype().getName());\n\t\tList<Obs> oldList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\n\t\tMessage hl7message = parser.parse(hl7string);\n\t\trouter.processMessage(hl7message);\n\t\n\t\tList<Obs> newList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\n\t\tObs newObservation = null;\n\t\tfor (Obs newObs : newList) {\n\t\t\tif (!oldList.contains(newObs) && !newObs.isObsGrouping()) {\n\t\t\t\tnewObservation = newObs;\n\t\t\t}\n\t\t}\n\t\tAssert.assertEquals(Context.getConceptService().getTrueConcept(), newObservation.getValueCoded());\n\t}","cleancode":"@test public void processmessage_shouldsetvalue_codedmatchingabooleanconceptforobsiftheansweris0or1andquestiondatatypeiscoded() throws exception { obsservice os = context.getobsservice(); string hl7string = \"msh|^~\\\\&|formentry|amrs.eld|hl7listener|amrs.eld|20080226102656||oru^r01|jqnfhkktouez8kztk6zo|p|2.5|1||||||||16^amrs.eld.formid\\r\" + \"pid|||7^^^^||collet^test^chebaskwony||\\r\" + \"pv1||o|1^unknown location||||1^super user (1-8)|||||||||||||||||||||||||||||||||||||20080212|||||||v\\r\" + \"orc|re||||||||20080226102537|1^super user\\r\" + \"obr|1|||1238^medical record observations^99dct\\r\" + \"obx|2|nm|21^civil status^99dct||1|||||||||20080206\"; assert.assertequals(\"coded\", context.getconceptservice().getconcept(21).getdatatype().getname()); list<obs> oldlist = os.getobservationsbypersonandconcept(new person(7), new concept(21)); message hl7message = parser.parse(hl7string); router.processmessage(hl7message); list<obs> newlist = os.getobservationsbypersonandconcept(new person(7), new concept(21)); obs newobservation = null; for (obs newobs : newlist) { if (!oldlist.contains(newobs) && !newobs.isobsgrouping()) { newobservation = newobs; } } assert.assertequals(context.getconceptservice().gettrueconcept(), newobservation.getvaluecoded()); }","comment":"\/** * @see orur01handler#processmessage(message) *\/\n\/\/ the expected question for the obs in the hl7 message has to be coded\n\/\/ hacky way to get the newly added obs and make tests on it","repo":"RuiDTLima\/diffuzz","code_context_2":"@Test\npublic void processMessage_shouldSetValue_CodedMatchingABooleanConceptForObsIfTheAnswerIs0Or1AndQuestionDatatypeIsCoded()\nthrows Exception {\nObsService os = Context.getObsService();\nString hl7string = \"MSH|^~\\\\&|FORMENTRY|AMRS.ELD|HL7LISTENER|AMRS.ELD|20080226102656||ORU^R01|JqnfhKKtouEz8kzTk6Zo|P|2.5|1||||||||16^AMRS.ELD.FORMID\\r\"\n+ \"PID|||7^^^^||Collet^Test^Chebaskwony||\\r\"\n+ \"PV1||O|1^Unknown Location||||1^Super User (1-8)|||||||||||||||||||||||||||||||||||||20080212|||||||V\\r\"\n+ \"ORC|RE||||||||20080226102537|1^Super User\\r\"\n+ \"OBR|1|||1238^MEDICAL RECORD OBSERVATIONS^99DCT\\r\"\n+ \"OBX|2|NM|21^CIVIL STATUS^99DCT||1|||||||||20080206\";\n\/\/ the expected question for the obs in the hl7 message has to be coded\nAssert.assertEquals(\"Coded\", Context.getConceptService().getConcept(21).getDatatype().getName());\nList<Obs> oldList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\nMessage hl7message = parser.parse(hl7string);\nrouter.processMessage(hl7message);\n\/\/ hacky way to get the newly added obs and make tests on it\nList<Obs> newList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\nObs newObservation = null;\nfor (Obs newObs : newList) {\nif (!oldList.contains(newObs) && !newObs.isObsGrouping()) {\nnewObservation = newObs;\n}\n}\nAssert.assertEquals(Context.getConceptService().getTrueConcept(), newObservation.getValueCoded());\n}\n\n+ \"OBR|1|||1238^MEDICAL RECORD OBSERVATIONS^99DCT\\r\"\n+ \"OBX|2|NM|21^CIVIL STATUS^99DCT||1|||||||||20080206\";\n\/\/ the expected question for the obs in the hl7 message has to be coded\nAssert.assertEquals(\"Coded\", Context.getConceptService().getConcept(21).getDatatype().getName());\nList<Obs> oldList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\n\nMessage hl7message = parser.parse(hl7string);\nrouter.processMessage(hl7message);\n\/\/ hacky way to get the newly added obs and make tests on it\nList<Obs> newList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\nObs newObservation = null;","code_context_10":"@Test\npublic void processMessage_shouldSetValue_CodedMatchingABooleanConceptForObsIfTheAnswerIs0Or1AndQuestionDatatypeIsCoded()\nthrows Exception {\nObsService os = Context.getObsService();\nString hl7string = \"MSH|^~\\\\&|FORMENTRY|AMRS.ELD|HL7LISTENER|AMRS.ELD|20080226102656||ORU^R01|JqnfhKKtouEz8kzTk6Zo|P|2.5|1||||||||16^AMRS.ELD.FORMID\\r\"\n+ \"PID|||7^^^^||Collet^Test^Chebaskwony||\\r\"\n+ \"PV1||O|1^Unknown Location||||1^Super User (1-8)|||||||||||||||||||||||||||||||||||||20080212|||||||V\\r\"\n+ \"ORC|RE||||||||20080226102537|1^Super User\\r\"\n+ \"OBR|1|||1238^MEDICAL RECORD OBSERVATIONS^99DCT\\r\"\n+ \"OBX|2|NM|21^CIVIL STATUS^99DCT||1|||||||||20080206\";\n\/\/ the expected question for the obs in the hl7 message has to be coded\nAssert.assertEquals(\"Coded\", Context.getConceptService().getConcept(21).getDatatype().getName());\nList<Obs> oldList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\nMessage hl7message = parser.parse(hl7string);\nrouter.processMessage(hl7message);\n\/\/ hacky way to get the newly added obs and make tests on it\nList<Obs> newList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\nObs newObservation = null;\nfor (Obs newObs : newList) {\nif (!oldList.contains(newObs) && !newObs.isObsGrouping()) {\nnewObservation = newObs;\n}\n}\nAssert.assertEquals(Context.getConceptService().getTrueConcept(), newObservation.getValueCoded());\n}\n\n@Test\npublic void processMessage_shouldSetValue_CodedMatchingABooleanConceptForObsIfTheAnswerIs0Or1AndQuestionDatatypeIsCoded()\nthrows Exception {\nObsService os = Context.getObsService();\nString hl7string = \"MSH|^~\\\\&|FORMENTRY|AMRS.ELD|HL7LISTENER|AMRS.ELD|20080226102656||ORU^R01|JqnfhKKtouEz8kzTk6Zo|P|2.5|1||||||||16^AMRS.ELD.FORMID\\r\"\n+ \"PID|||7^^^^||Collet^Test^Chebaskwony||\\r\"\n+ \"PV1||O|1^Unknown Location||||1^Super User (1-8)|||||||||||||||||||||||||||||||||||||20080212|||||||V\\r\"\n+ \"ORC|RE||||||||20080226102537|1^Super User\\r\"\n+ \"OBR|1|||1238^MEDICAL RECORD OBSERVATIONS^99DCT\\r\"\n+ \"OBX|2|NM|21^CIVIL STATUS^99DCT||1|||||||||20080206\";\n\/\/ the expected question for the obs in the hl7 message has to be coded\nAssert.assertEquals(\"Coded\", Context.getConceptService().getConcept(21).getDatatype().getName());\nList<Obs> oldList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\nMessage hl7message = parser.parse(hl7string);\nrouter.processMessage(hl7message);\n\/\/ hacky way to get the newly added obs and make tests on it\nList<Obs> newList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\nObs newObservation = null;\nfor (Obs newObs : newList) {\nif (!oldList.contains(newObs) && !newObs.isObsGrouping()) {\nnewObservation = newObs;\n\n+ \"PID|||7^^^^||Collet^Test^Chebaskwony||\\r\"\n+ \"PV1||O|1^Unknown Location||||1^Super User (1-8)|||||||||||||||||||||||||||||||||||||20080212|||||||V\\r\"\n+ \"ORC|RE||||||||20080226102537|1^Super User\\r\"\n+ \"OBR|1|||1238^MEDICAL RECORD OBSERVATIONS^99DCT\\r\"\n+ \"OBX|2|NM|21^CIVIL STATUS^99DCT||1|||||||||20080206\";\n\/\/ the expected question for the obs in the hl7 message has to be coded\nAssert.assertEquals(\"Coded\", Context.getConceptService().getConcept(21).getDatatype().getName());\nList<Obs> oldList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\nMessage hl7message = parser.parse(hl7string);\nrouter.processMessage(hl7message);\n\/\/ hacky way to get the newly added obs and make tests on it\nList<Obs> newList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\nObs newObservation = null;\nfor (Obs newObs : newList) {\nif (!oldList.contains(newObs) && !newObs.isObsGrouping()) {\nnewObservation = newObs;\n}\n}\nAssert.assertEquals(Context.getConceptService().getTrueConcept(), newObservation.getValueCoded());\n}","code_context_20":"@Test\npublic void processMessage_shouldSetValue_CodedMatchingABooleanConceptForObsIfTheAnswerIs0Or1AndQuestionDatatypeIsCoded()\nthrows Exception {\nObsService os = Context.getObsService();\nString hl7string = \"MSH|^~\\\\&|FORMENTRY|AMRS.ELD|HL7LISTENER|AMRS.ELD|20080226102656||ORU^R01|JqnfhKKtouEz8kzTk6Zo|P|2.5|1||||||||16^AMRS.ELD.FORMID\\r\"\n+ \"PID|||7^^^^||Collet^Test^Chebaskwony||\\r\"\n+ \"PV1||O|1^Unknown Location||||1^Super User (1-8)|||||||||||||||||||||||||||||||||||||20080212|||||||V\\r\"\n+ \"ORC|RE||||||||20080226102537|1^Super User\\r\"\n+ \"OBR|1|||1238^MEDICAL RECORD OBSERVATIONS^99DCT\\r\"\n+ \"OBX|2|NM|21^CIVIL STATUS^99DCT||1|||||||||20080206\";\n\/\/ the expected question for the obs in the hl7 message has to be coded\nAssert.assertEquals(\"Coded\", Context.getConceptService().getConcept(21).getDatatype().getName());\nList<Obs> oldList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\nMessage hl7message = parser.parse(hl7string);\nrouter.processMessage(hl7message);\n\/\/ hacky way to get the newly added obs and make tests on it\nList<Obs> newList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\nObs newObservation = null;\nfor (Obs newObs : newList) {\nif (!oldList.contains(newObs) && !newObs.isObsGrouping()) {\nnewObservation = newObs;\n}\n}\nAssert.assertEquals(Context.getConceptService().getTrueConcept(), newObservation.getValueCoded());\n}\n\n@Test\npublic void processMessage_shouldSetValue_CodedMatchingABooleanConceptForObsIfTheAnswerIs0Or1AndQuestionDatatypeIsCoded()\nthrows Exception {\nObsService os = Context.getObsService();\nString hl7string = \"MSH|^~\\\\&|FORMENTRY|AMRS.ELD|HL7LISTENER|AMRS.ELD|20080226102656||ORU^R01|JqnfhKKtouEz8kzTk6Zo|P|2.5|1||||||||16^AMRS.ELD.FORMID\\r\"\n+ \"PID|||7^^^^||Collet^Test^Chebaskwony||\\r\"\n+ \"PV1||O|1^Unknown Location||||1^Super User (1-8)|||||||||||||||||||||||||||||||||||||20080212|||||||V\\r\"\n+ \"ORC|RE||||||||20080226102537|1^Super User\\r\"\n+ \"OBR|1|||1238^MEDICAL RECORD OBSERVATIONS^99DCT\\r\"\n+ \"OBX|2|NM|21^CIVIL STATUS^99DCT||1|||||||||20080206\";\n\/\/ the expected question for the obs in the hl7 message has to be coded\nAssert.assertEquals(\"Coded\", Context.getConceptService().getConcept(21).getDatatype().getName());\nList<Obs> oldList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\nMessage hl7message = parser.parse(hl7string);\nrouter.processMessage(hl7message);\n\/\/ hacky way to get the newly added obs and make tests on it\nList<Obs> newList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\nObs newObservation = null;\nfor (Obs newObs : newList) {\nif (!oldList.contains(newObs) && !newObs.isObsGrouping()) {\nnewObservation = newObs;\n}\n}\nAssert.assertEquals(Context.getConceptService().getTrueConcept(), newObservation.getValueCoded());\n}\n\n@Test\npublic void processMessage_shouldSetValue_CodedMatchingABooleanConceptForObsIfTheAnswerIs0Or1AndQuestionDatatypeIsCoded()\nthrows Exception {\nObsService os = Context.getObsService();\nString hl7string = \"MSH|^~\\\\&|FORMENTRY|AMRS.ELD|HL7LISTENER|AMRS.ELD|20080226102656||ORU^R01|JqnfhKKtouEz8kzTk6Zo|P|2.5|1||||||||16^AMRS.ELD.FORMID\\r\"\n+ \"PID|||7^^^^||Collet^Test^Chebaskwony||\\r\"\n+ \"PV1||O|1^Unknown Location||||1^Super User (1-8)|||||||||||||||||||||||||||||||||||||20080212|||||||V\\r\"\n+ \"ORC|RE||||||||20080226102537|1^Super User\\r\"\n+ \"OBR|1|||1238^MEDICAL RECORD OBSERVATIONS^99DCT\\r\"\n+ \"OBX|2|NM|21^CIVIL STATUS^99DCT||1|||||||||20080206\";\n\/\/ the expected question for the obs in the hl7 message has to be coded\nAssert.assertEquals(\"Coded\", Context.getConceptService().getConcept(21).getDatatype().getName());\nList<Obs> oldList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\nMessage hl7message = parser.parse(hl7string);\nrouter.processMessage(hl7message);\n\/\/ hacky way to get the newly added obs and make tests on it\nList<Obs> newList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\nObs newObservation = null;\nfor (Obs newObs : newList) {\nif (!oldList.contains(newObs) && !newObs.isObsGrouping()) {\nnewObservation = newObs;\n}\n}\nAssert.assertEquals(Context.getConceptService().getTrueConcept(), newObservation.getValueCoded());\n}","label":[1,0,0,0]}
{"id":22244,"original_code":"private static void processPendingMoveToTrash(final Context context, Store remoteStore,\n            Mailbox newMailbox, EmailContent.Message oldMessage,\n            final EmailContent.Message newMessage) throws MessagingException {\n        \/\/ 0. No remote move if the message is local-only\n        if (newMessage.mServerId == null || newMessage.mServerId.equals(\"\")\n                || newMessage.mServerId.startsWith(LOCAL_SERVERID_PREFIX)) {\n            return;\n        }\n        \/\/ 1. Escape early if we can't find the local mailbox\n        \/\/ TODO smaller projection here\n        Mailbox oldMailbox = getRemoteMailboxForMessage(context, oldMessage);\n        if (oldMailbox == null) {\n            \/\/ can't find old mailbox, it may have been deleted.  just return.\n            return;\n        }\n        \/\/ 2. We don't support delete-from-trash here\n        if (oldMailbox.mType == Mailbox.TYPE_TRASH) {\n            return;\n        }\n        \/\/ The rest of this method handles server-side deletion\n        \/\/ 4.  Find the remote mailbox (that we deleted from), and open it\n        Folder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);\n        if (!remoteFolder.exists()) {\n            return;\n        }\n        remoteFolder.open(OpenMode.READ_WRITE);\n        if (remoteFolder.getMode() != OpenMode.READ_WRITE) {\n            remoteFolder.close(false);\n            return;\n        }\n        \/\/ 5. Find the remote original message\n        Message remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);\n        if (remoteMessage == null) {\n            remoteFolder.close(false);\n            return;\n        }\n        \/\/ 6. Find the remote trash folder, and create it if not found\n        Folder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);\n        if (!remoteTrashFolder.exists()) {\n            \/*\n             * If the remote trash folder doesn't exist we try to create it.\n             *\/\n            remoteTrashFolder.create(FolderType.HOLDS_MESSAGES);\n        }\n        \/\/ 7. Try to copy the message into the remote trash folder\n        \/\/ Note, this entire section will be skipped for POP3 because there's no remote trash\n        if (remoteTrashFolder.exists()) {\n            \/*\n             * Because remoteTrashFolder may be new, we need to explicitly open it\n             *\/\n            remoteTrashFolder.open(OpenMode.READ_WRITE);\n            if (remoteTrashFolder.getMode() != OpenMode.READ_WRITE) {\n                remoteFolder.close(false);\n                remoteTrashFolder.close(false);\n                return;\n            }\n            remoteFolder.copyMessages(new Message[] { remoteMessage }, remoteTrashFolder,\n                    new Folder.MessageUpdateCallbacks() {\n                @Override\n                public void onMessageUidChange(Message message, String newUid) {\n                    \/\/ update the UID in the local trash folder, because some stores will\n                    \/\/ have to change it when copying to remoteTrashFolder\n                    ContentValues cv = new ContentValues();\n                    cv.put(MessageColumns.SERVER_ID, newUid);\n                    context.getContentResolver().update(newMessage.getUri(), cv, null, null);\n                }\n                \/**\n                 * This will be called if the deleted message doesn't exist and can't be\n                 * deleted (e.g. it was already deleted from the server.)  In this case,\n                 * attempt to delete the local copy as well.\n                 *\/\n                @Override\n                public void onMessageNotFound(Message message) {\n                    context.getContentResolver().delete(newMessage.getUri(), null, null);\n                }\n            });\n            remoteTrashFolder.close(false);\n        }\n        \/\/ 8. Delete the message from the remote source folder\n        remoteMessage.setFlag(Flag.DELETED, true);\n        remoteFolder.expunge();\n        remoteFolder.close(false);\n    }","code":"private static void processPendingMoveToTrash(final Context context, Store remoteStore,\n            Mailbox newMailbox, EmailContent.Message oldMessage,\n            final EmailContent.Message newMessage) throws MessagingException {\n       \n        if (newMessage.mServerId == null || newMessage.mServerId.equals(\"\")\n                || newMessage.mServerId.startsWith(LOCAL_SERVERID_PREFIX)) {\n            return;\n        }\n       \n       \n        Mailbox oldMailbox = getRemoteMailboxForMessage(context, oldMessage);\n        if (oldMailbox == null) {\n           \n            return;\n        }\n       \n        if (oldMailbox.mType == Mailbox.TYPE_TRASH) {\n            return;\n        }\n       \n       \n        Folder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);\n        if (!remoteFolder.exists()) {\n            return;\n        }\n        remoteFolder.open(OpenMode.READ_WRITE);\n        if (remoteFolder.getMode() != OpenMode.READ_WRITE) {\n            remoteFolder.close(false);\n            return;\n        }\n       \n        Message remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);\n        if (remoteMessage == null) {\n            remoteFolder.close(false);\n            return;\n        }\n       \n        Folder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);\n        if (!remoteTrashFolder.exists()) {\n           \n            remoteTrashFolder.create(FolderType.HOLDS_MESSAGES);\n        }\n       \n       \n        if (remoteTrashFolder.exists()) {\n           \n            remoteTrashFolder.open(OpenMode.READ_WRITE);\n            if (remoteTrashFolder.getMode() != OpenMode.READ_WRITE) {\n                remoteFolder.close(false);\n                remoteTrashFolder.close(false);\n                return;\n            }\n            remoteFolder.copyMessages(new Message[] { remoteMessage }, remoteTrashFolder,\n                    new Folder.MessageUpdateCallbacks() {\n                @Override\n                public void onMessageUidChange(Message message, String newUid) {\n                   \n                   \n                    ContentValues cv = new ContentValues();\n                    cv.put(MessageColumns.SERVER_ID, newUid);\n                    context.getContentResolver().update(newMessage.getUri(), cv, null, null);\n                }\n               \n                @Override\n                public void onMessageNotFound(Message message) {\n                    context.getContentResolver().delete(newMessage.getUri(), null, null);\n                }\n            });\n            remoteTrashFolder.close(false);\n        }\n       \n        remoteMessage.setFlag(Flag.DELETED, true);\n        remoteFolder.expunge();\n        remoteFolder.close(false);\n    }","cleancode":"private static void processpendingmovetotrash(final context context, store remotestore, mailbox newmailbox, emailcontent.message oldmessage, final emailcontent.message newmessage) throws messagingexception { if (newmessage.mserverid == null || newmessage.mserverid.equals(\"\") || newmessage.mserverid.startswith(local_serverid_prefix)) { return; } mailbox oldmailbox = getremotemailboxformessage(context, oldmessage); if (oldmailbox == null) { return; } if (oldmailbox.mtype == mailbox.type_trash) { return; } folder remotefolder = remotestore.getfolder(oldmailbox.mserverid); if (!remotefolder.exists()) { return; } remotefolder.open(openmode.read_write); if (remotefolder.getmode() != openmode.read_write) { remotefolder.close(false); return; } message remotemessage = remotefolder.getmessage(oldmessage.mserverid); if (remotemessage == null) { remotefolder.close(false); return; } folder remotetrashfolder = remotestore.getfolder(newmailbox.mserverid); if (!remotetrashfolder.exists()) { remotetrashfolder.create(foldertype.holds_messages); } if (remotetrashfolder.exists()) { remotetrashfolder.open(openmode.read_write); if (remotetrashfolder.getmode() != openmode.read_write) { remotefolder.close(false); remotetrashfolder.close(false); return; } remotefolder.copymessages(new message[] { remotemessage }, remotetrashfolder, new folder.messageupdatecallbacks() { @override public void onmessageuidchange(message message, string newuid) { contentvalues cv = new contentvalues(); cv.put(messagecolumns.server_id, newuid); context.getcontentresolver().update(newmessage.geturi(), cv, null, null); } @override public void onmessagenotfound(message message) { context.getcontentresolver().delete(newmessage.geturi(), null, null); } }); remotetrashfolder.close(false); } remotemessage.setflag(flag.deleted, true); remotefolder.expunge(); remotefolder.close(false); }","comment":"\/** * process a pending trash message command. * * @param remotestore the remote store we're working in * @param newmailbox the local trash mailbox * @param oldmessage the message copy that was saved in the updates shadow table * @param newmessage the message that was moved to the mailbox *\/\n\/\/ 0. no remote move if the message is local-only\n\/\/ 1. escape early if we can't find the local mailbox \/\/ todo smaller projection here\n\/\/ can't find old mailbox, it may have been deleted. just return.\n\/\/ 2. we don't support delete-from-trash here\n\/\/ the rest of this method handles server-side deletion \/\/ 4. find the remote mailbox (that we deleted from), and open it\n\/\/ 5. find the remote original message\n\/\/ 6. find the remote trash folder, and create it if not found\n\/* * if the remote trash folder doesn't exist we try to create it. *\/\n\/\/ 7. try to copy the message into the remote trash folder \/\/ note, this entire section will be skipped for pop3 because there's no remote trash\n\/* * because remotetrashfolder may be new, we need to explicitly open it *\/\n\/\/ update the uid in the local trash folder, because some stores will \/\/ have to change it when copying to remotetrashfolder\n\/** * this will be called if the deleted message doesn't exist and can't be * deleted (e.g. it was already deleted from the server.) in this case, * attempt to delete the local copy as well. *\/\n\/\/ 8. delete the message from the remote source folder","repo":"Keneral\/apackages","code_context_2":"private static void processPendingMoveToTrash(final Context context, Store remoteStore,\nMailbox newMailbox, EmailContent.Message oldMessage,\nfinal EmailContent.Message newMessage) throws MessagingException {\n\/\/ 0. No remote move if the message is local-only\nif (newMessage.mServerId == null || newMessage.mServerId.equals(\"\")\n|| newMessage.mServerId.startsWith(LOCAL_SERVERID_PREFIX)) {\nreturn;\n}\n\/\/ 1. Escape early if we can't find the local mailbox\n\/\/ TODO smaller projection here\nMailbox oldMailbox = getRemoteMailboxForMessage(context, oldMessage);\nif (oldMailbox == null) {\n\/\/ can't find old mailbox, it may have been deleted. just return.\nreturn;\n}\n\/\/ 2. We don't support delete-from-trash here\nif (oldMailbox.mType == Mailbox.TYPE_TRASH) {\nreturn;\n}\n\/\/ The rest of this method handles server-side deletion\n\/\/ 4. Find the remote mailbox (that we deleted from), and open it\nFolder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);\nif (!remoteFolder.exists()) {\nreturn;\n}\nremoteFolder.open(OpenMode.READ_WRITE);\nif (remoteFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 5. Find the remote original message\nMessage remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);\nif (remoteMessage == null) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 6. Find the remote trash folder, and create it if not found\nFolder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);\nif (!remoteTrashFolder.exists()) {\n\/*\n* If the remote trash folder doesn't exist we try to create it.\n*\/\nremoteTrashFolder.create(FolderType.HOLDS_MESSAGES);\n}\n\/\/ 7. Try to copy the message into the remote trash folder\n\/\/ Note, this entire section will be skipped for POP3 because there's no remote trash\nif (remoteTrashFolder.exists()) {\n\/*\n* Because remoteTrashFolder may be new, we need to explicitly open it\n*\/\nremoteTrashFolder.open(OpenMode.READ_WRITE);\nif (remoteTrashFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nremoteTrashFolder.close(false);\nreturn;\n}\nremoteFolder.copyMessages(new Message[] { remoteMessage }, remoteTrashFolder,\nnew Folder.MessageUpdateCallbacks() {\n@Override\npublic void onMessageUidChange(Message message, String newUid) {\n\/\/ update the UID in the local trash folder, because some stores will\n\/\/ have to change it when copying to remoteTrashFolder\nContentValues cv = new ContentValues();\ncv.put(MessageColumns.SERVER_ID, newUid);\ncontext.getContentResolver().update(newMessage.getUri(), cv, null, null);\n}\n\/**\n* This will be called if the deleted message doesn't exist and can't be\n* deleted (e.g. it was already deleted from the server.) In this case,\n* attempt to delete the local copy as well.\n*\/\n@Override\npublic void onMessageNotFound(Message message) {\ncontext.getContentResolver().delete(newMessage.getUri(), null, null);\n}\n});\nremoteTrashFolder.close(false);\n}\n\/\/ 8. Delete the message from the remote source folder\nremoteMessage.setFlag(Flag.DELETED, true);\nremoteFolder.expunge();\nremoteFolder.close(false);\n}\n\nMailbox newMailbox, EmailContent.Message oldMessage,\nfinal EmailContent.Message newMessage) throws MessagingException {\n\/\/ 0. No remote move if the message is local-only\nif (newMessage.mServerId == null || newMessage.mServerId.equals(\"\")\n|| newMessage.mServerId.startsWith(LOCAL_SERVERID_PREFIX)) {\n\nreturn;\n}\n\/\/ 1. Escape early if we can't find the local mailbox\n\/\/ TODO smaller projection here\nMailbox oldMailbox = getRemoteMailboxForMessage(context, oldMessage);\nif (oldMailbox == null) {\n\nMailbox oldMailbox = getRemoteMailboxForMessage(context, oldMessage);\nif (oldMailbox == null) {\n\/\/ can't find old mailbox, it may have been deleted. just return.\nreturn;\n}\n\nreturn;\n}\n\/\/ 2. We don't support delete-from-trash here\nif (oldMailbox.mType == Mailbox.TYPE_TRASH) {\nreturn;\n\nreturn;\n}\n\/\/ The rest of this method handles server-side deletion\n\/\/ 4. Find the remote mailbox (that we deleted from), and open it\nFolder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);\nif (!remoteFolder.exists()) {\n\nreturn;\n}\n\/\/ 5. Find the remote original message\nMessage remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);\nif (remoteMessage == null) {\n\nreturn;\n}\n\/\/ 6. Find the remote trash folder, and create it if not found\nFolder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);\nif (!remoteTrashFolder.exists()) {\n\nFolder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);\nif (!remoteTrashFolder.exists()) {\n\/*\n* If the remote trash folder doesn't exist we try to create it.\n*\/\nremoteTrashFolder.create(FolderType.HOLDS_MESSAGES);\n}\n\nremoteTrashFolder.create(FolderType.HOLDS_MESSAGES);\n}\n\/\/ 7. Try to copy the message into the remote trash folder\n\/\/ Note, this entire section will be skipped for POP3 because there's no remote trash\nif (remoteTrashFolder.exists()) {\n\/*\n\nFolder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);\nif (!remoteTrashFolder.exists()) {\n\/*\n* If the remote trash folder doesn't exist we try to create it.\n*\/\nremoteTrashFolder.create(FolderType.HOLDS_MESSAGES);\n}\n\n@Override\npublic void onMessageUidChange(Message message, String newUid) {\n\/\/ update the UID in the local trash folder, because some stores will\n\/\/ have to change it when copying to remoteTrashFolder\nContentValues cv = new ContentValues();\ncv.put(MessageColumns.SERVER_ID, newUid);\n\ncontext.getContentResolver().update(newMessage.getUri(), cv, null, null);\n}\n\/**\n* This will be called if the deleted message doesn't exist and can't be\n* deleted (e.g. it was already deleted from the server.) In this case,\n* attempt to delete the local copy as well.\n*\/\n@Override\npublic void onMessageNotFound(Message message) {\n\nremoteTrashFolder.close(false);\n}\n\/\/ 8. Delete the message from the remote source folder\nremoteMessage.setFlag(Flag.DELETED, true);\nremoteFolder.expunge();","code_context_10":"private static void processPendingMoveToTrash(final Context context, Store remoteStore,\nMailbox newMailbox, EmailContent.Message oldMessage,\nfinal EmailContent.Message newMessage) throws MessagingException {\n\/\/ 0. No remote move if the message is local-only\nif (newMessage.mServerId == null || newMessage.mServerId.equals(\"\")\n|| newMessage.mServerId.startsWith(LOCAL_SERVERID_PREFIX)) {\nreturn;\n}\n\/\/ 1. Escape early if we can't find the local mailbox\n\/\/ TODO smaller projection here\nMailbox oldMailbox = getRemoteMailboxForMessage(context, oldMessage);\nif (oldMailbox == null) {\n\/\/ can't find old mailbox, it may have been deleted. just return.\nreturn;\n}\n\/\/ 2. We don't support delete-from-trash here\nif (oldMailbox.mType == Mailbox.TYPE_TRASH) {\nreturn;\n}\n\/\/ The rest of this method handles server-side deletion\n\/\/ 4. Find the remote mailbox (that we deleted from), and open it\nFolder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);\nif (!remoteFolder.exists()) {\nreturn;\n}\nremoteFolder.open(OpenMode.READ_WRITE);\nif (remoteFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 5. Find the remote original message\nMessage remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);\nif (remoteMessage == null) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 6. Find the remote trash folder, and create it if not found\nFolder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);\nif (!remoteTrashFolder.exists()) {\n\/*\n* If the remote trash folder doesn't exist we try to create it.\n*\/\nremoteTrashFolder.create(FolderType.HOLDS_MESSAGES);\n}\n\/\/ 7. Try to copy the message into the remote trash folder\n\/\/ Note, this entire section will be skipped for POP3 because there's no remote trash\nif (remoteTrashFolder.exists()) {\n\/*\n* Because remoteTrashFolder may be new, we need to explicitly open it\n*\/\nremoteTrashFolder.open(OpenMode.READ_WRITE);\nif (remoteTrashFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nremoteTrashFolder.close(false);\nreturn;\n}\nremoteFolder.copyMessages(new Message[] { remoteMessage }, remoteTrashFolder,\nnew Folder.MessageUpdateCallbacks() {\n@Override\npublic void onMessageUidChange(Message message, String newUid) {\n\/\/ update the UID in the local trash folder, because some stores will\n\/\/ have to change it when copying to remoteTrashFolder\nContentValues cv = new ContentValues();\ncv.put(MessageColumns.SERVER_ID, newUid);\ncontext.getContentResolver().update(newMessage.getUri(), cv, null, null);\n}\n\/**\n* This will be called if the deleted message doesn't exist and can't be\n* deleted (e.g. it was already deleted from the server.) In this case,\n* attempt to delete the local copy as well.\n*\/\n@Override\npublic void onMessageNotFound(Message message) {\ncontext.getContentResolver().delete(newMessage.getUri(), null, null);\n}\n});\nremoteTrashFolder.close(false);\n}\n\/\/ 8. Delete the message from the remote source folder\nremoteMessage.setFlag(Flag.DELETED, true);\nremoteFolder.expunge();\nremoteFolder.close(false);\n}\n\nprivate static void processPendingMoveToTrash(final Context context, Store remoteStore,\nMailbox newMailbox, EmailContent.Message oldMessage,\nfinal EmailContent.Message newMessage) throws MessagingException {\n\/\/ 0. No remote move if the message is local-only\nif (newMessage.mServerId == null || newMessage.mServerId.equals(\"\")\n|| newMessage.mServerId.startsWith(LOCAL_SERVERID_PREFIX)) {\nreturn;\n}\n\/\/ 1. Escape early if we can't find the local mailbox\n\/\/ TODO smaller projection here\nMailbox oldMailbox = getRemoteMailboxForMessage(context, oldMessage);\nif (oldMailbox == null) {\n\/\/ can't find old mailbox, it may have been deleted. just return.\nreturn;\n\nprivate static void processPendingMoveToTrash(final Context context, Store remoteStore,\nMailbox newMailbox, EmailContent.Message oldMessage,\nfinal EmailContent.Message newMessage) throws MessagingException {\n\/\/ 0. No remote move if the message is local-only\nif (newMessage.mServerId == null || newMessage.mServerId.equals(\"\")\n|| newMessage.mServerId.startsWith(LOCAL_SERVERID_PREFIX)) {\nreturn;\n}\n\/\/ 1. Escape early if we can't find the local mailbox\n\/\/ TODO smaller projection here\nMailbox oldMailbox = getRemoteMailboxForMessage(context, oldMessage);\nif (oldMailbox == null) {\n\/\/ can't find old mailbox, it may have been deleted. just return.\nreturn;\n}\n\/\/ 2. We don't support delete-from-trash here\nif (oldMailbox.mType == Mailbox.TYPE_TRASH) {\nreturn;\n}\n\/\/ The rest of this method handles server-side deletion\n\nfinal EmailContent.Message newMessage) throws MessagingException {\n\/\/ 0. No remote move if the message is local-only\nif (newMessage.mServerId == null || newMessage.mServerId.equals(\"\")\n|| newMessage.mServerId.startsWith(LOCAL_SERVERID_PREFIX)) {\nreturn;\n}\n\/\/ 1. Escape early if we can't find the local mailbox\n\/\/ TODO smaller projection here\nMailbox oldMailbox = getRemoteMailboxForMessage(context, oldMessage);\nif (oldMailbox == null) {\n\/\/ can't find old mailbox, it may have been deleted. just return.\nreturn;\n}\n\/\/ 2. We don't support delete-from-trash here\nif (oldMailbox.mType == Mailbox.TYPE_TRASH) {\nreturn;\n}\n\/\/ The rest of this method handles server-side deletion\n\/\/ 4. Find the remote mailbox (that we deleted from), and open it\nFolder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);\nif (!remoteFolder.exists()) {\n\n|| newMessage.mServerId.startsWith(LOCAL_SERVERID_PREFIX)) {\nreturn;\n}\n\/\/ 1. Escape early if we can't find the local mailbox\n\/\/ TODO smaller projection here\nMailbox oldMailbox = getRemoteMailboxForMessage(context, oldMessage);\nif (oldMailbox == null) {\n\/\/ can't find old mailbox, it may have been deleted. just return.\nreturn;\n}\n\/\/ 2. We don't support delete-from-trash here\nif (oldMailbox.mType == Mailbox.TYPE_TRASH) {\nreturn;\n}\n\/\/ The rest of this method handles server-side deletion\n\/\/ 4. Find the remote mailbox (that we deleted from), and open it\nFolder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);\nif (!remoteFolder.exists()) {\nreturn;\n}\nremoteFolder.open(OpenMode.READ_WRITE);\n\n\/\/ TODO smaller projection here\nMailbox oldMailbox = getRemoteMailboxForMessage(context, oldMessage);\nif (oldMailbox == null) {\n\/\/ can't find old mailbox, it may have been deleted. just return.\nreturn;\n}\n\/\/ 2. We don't support delete-from-trash here\nif (oldMailbox.mType == Mailbox.TYPE_TRASH) {\nreturn;\n}\n\/\/ The rest of this method handles server-side deletion\n\/\/ 4. Find the remote mailbox (that we deleted from), and open it\nFolder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);\nif (!remoteFolder.exists()) {\nreturn;\n}\nremoteFolder.open(OpenMode.READ_WRITE);\nif (remoteFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 5. Find the remote original message\n\n\/\/ 4. Find the remote mailbox (that we deleted from), and open it\nFolder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);\nif (!remoteFolder.exists()) {\nreturn;\n}\nremoteFolder.open(OpenMode.READ_WRITE);\nif (remoteFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 5. Find the remote original message\nMessage remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);\nif (remoteMessage == null) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 6. Find the remote trash folder, and create it if not found\nFolder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);\nif (!remoteTrashFolder.exists()) {\n\/*\n* If the remote trash folder doesn't exist we try to create it.\n\nif (remoteFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 5. Find the remote original message\nMessage remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);\nif (remoteMessage == null) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 6. Find the remote trash folder, and create it if not found\nFolder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);\nif (!remoteTrashFolder.exists()) {\n\/*\n* If the remote trash folder doesn't exist we try to create it.\n*\/\nremoteTrashFolder.create(FolderType.HOLDS_MESSAGES);\n}\n\/\/ 7. Try to copy the message into the remote trash folder\n\/\/ Note, this entire section will be skipped for POP3 because there's no remote trash\nif (remoteTrashFolder.exists()) {\n\n}\n\/\/ 5. Find the remote original message\nMessage remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);\nif (remoteMessage == null) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 6. Find the remote trash folder, and create it if not found\nFolder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);\nif (!remoteTrashFolder.exists()) {\n\/*\n* If the remote trash folder doesn't exist we try to create it.\n*\/\nremoteTrashFolder.create(FolderType.HOLDS_MESSAGES);\n}\n\/\/ 7. Try to copy the message into the remote trash folder\n\/\/ Note, this entire section will be skipped for POP3 because there's no remote trash\nif (remoteTrashFolder.exists()) {\n\/*\n* Because remoteTrashFolder may be new, we need to explicitly open it\n*\/\nremoteTrashFolder.open(OpenMode.READ_WRITE);\nif (remoteTrashFolder.getMode() != OpenMode.READ_WRITE) {\n\nreturn;\n}\n\/\/ 6. Find the remote trash folder, and create it if not found\nFolder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);\nif (!remoteTrashFolder.exists()) {\n\/*\n* If the remote trash folder doesn't exist we try to create it.\n*\/\nremoteTrashFolder.create(FolderType.HOLDS_MESSAGES);\n}\n\/\/ 7. Try to copy the message into the remote trash folder\n\/\/ Note, this entire section will be skipped for POP3 because there's no remote trash\nif (remoteTrashFolder.exists()) {\n\/*\n* Because remoteTrashFolder may be new, we need to explicitly open it\n*\/\nremoteTrashFolder.open(OpenMode.READ_WRITE);\nif (remoteTrashFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nremoteTrashFolder.close(false);\nreturn;\n}\n\n}\n\/\/ 5. Find the remote original message\nMessage remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);\nif (remoteMessage == null) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 6. Find the remote trash folder, and create it if not found\nFolder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);\nif (!remoteTrashFolder.exists()) {\n\/*\n* If the remote trash folder doesn't exist we try to create it.\n*\/\nremoteTrashFolder.create(FolderType.HOLDS_MESSAGES);\n}\n\/\/ 7. Try to copy the message into the remote trash folder\n\/\/ Note, this entire section will be skipped for POP3 because there's no remote trash\nif (remoteTrashFolder.exists()) {\n\/*\n* Because remoteTrashFolder may be new, we need to explicitly open it\n*\/\nremoteTrashFolder.open(OpenMode.READ_WRITE);\nif (remoteTrashFolder.getMode() != OpenMode.READ_WRITE) {\n\nremoteTrashFolder.open(OpenMode.READ_WRITE);\nif (remoteTrashFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nremoteTrashFolder.close(false);\nreturn;\n}\nremoteFolder.copyMessages(new Message[] { remoteMessage }, remoteTrashFolder,\nnew Folder.MessageUpdateCallbacks() {\n@Override\npublic void onMessageUidChange(Message message, String newUid) {\n\/\/ update the UID in the local trash folder, because some stores will\n\/\/ have to change it when copying to remoteTrashFolder\nContentValues cv = new ContentValues();\ncv.put(MessageColumns.SERVER_ID, newUid);\ncontext.getContentResolver().update(newMessage.getUri(), cv, null, null);\n}\n\/**\n* This will be called if the deleted message doesn't exist and can't be\n* deleted (e.g. it was already deleted from the server.) In this case,\n* attempt to delete the local copy as well.\n*\/\n@Override\n\nremoteFolder.copyMessages(new Message[] { remoteMessage }, remoteTrashFolder,\nnew Folder.MessageUpdateCallbacks() {\n@Override\npublic void onMessageUidChange(Message message, String newUid) {\n\/\/ update the UID in the local trash folder, because some stores will\n\/\/ have to change it when copying to remoteTrashFolder\nContentValues cv = new ContentValues();\ncv.put(MessageColumns.SERVER_ID, newUid);\ncontext.getContentResolver().update(newMessage.getUri(), cv, null, null);\n}\n\/**\n* This will be called if the deleted message doesn't exist and can't be\n* deleted (e.g. it was already deleted from the server.) In this case,\n* attempt to delete the local copy as well.\n*\/\n@Override\npublic void onMessageNotFound(Message message) {\ncontext.getContentResolver().delete(newMessage.getUri(), null, null);\n}\n});\nremoteTrashFolder.close(false);\n}\n\/\/ 8. Delete the message from the remote source folder\nremoteMessage.setFlag(Flag.DELETED, true);\nremoteFolder.expunge();\n\n* deleted (e.g. it was already deleted from the server.) In this case,\n* attempt to delete the local copy as well.\n*\/\n@Override\npublic void onMessageNotFound(Message message) {\ncontext.getContentResolver().delete(newMessage.getUri(), null, null);\n}\n});\nremoteTrashFolder.close(false);\n}\n\/\/ 8. Delete the message from the remote source folder\nremoteMessage.setFlag(Flag.DELETED, true);\nremoteFolder.expunge();\nremoteFolder.close(false);\n}","code_context_20":"private static void processPendingMoveToTrash(final Context context, Store remoteStore,\nMailbox newMailbox, EmailContent.Message oldMessage,\nfinal EmailContent.Message newMessage) throws MessagingException {\n\/\/ 0. No remote move if the message is local-only\nif (newMessage.mServerId == null || newMessage.mServerId.equals(\"\")\n|| newMessage.mServerId.startsWith(LOCAL_SERVERID_PREFIX)) {\nreturn;\n}\n\/\/ 1. Escape early if we can't find the local mailbox\n\/\/ TODO smaller projection here\nMailbox oldMailbox = getRemoteMailboxForMessage(context, oldMessage);\nif (oldMailbox == null) {\n\/\/ can't find old mailbox, it may have been deleted. just return.\nreturn;\n}\n\/\/ 2. We don't support delete-from-trash here\nif (oldMailbox.mType == Mailbox.TYPE_TRASH) {\nreturn;\n}\n\/\/ The rest of this method handles server-side deletion\n\/\/ 4. Find the remote mailbox (that we deleted from), and open it\nFolder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);\nif (!remoteFolder.exists()) {\nreturn;\n}\nremoteFolder.open(OpenMode.READ_WRITE);\nif (remoteFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 5. Find the remote original message\nMessage remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);\nif (remoteMessage == null) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 6. Find the remote trash folder, and create it if not found\nFolder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);\nif (!remoteTrashFolder.exists()) {\n\/*\n* If the remote trash folder doesn't exist we try to create it.\n*\/\nremoteTrashFolder.create(FolderType.HOLDS_MESSAGES);\n}\n\/\/ 7. Try to copy the message into the remote trash folder\n\/\/ Note, this entire section will be skipped for POP3 because there's no remote trash\nif (remoteTrashFolder.exists()) {\n\/*\n* Because remoteTrashFolder may be new, we need to explicitly open it\n*\/\nremoteTrashFolder.open(OpenMode.READ_WRITE);\nif (remoteTrashFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nremoteTrashFolder.close(false);\nreturn;\n}\nremoteFolder.copyMessages(new Message[] { remoteMessage }, remoteTrashFolder,\nnew Folder.MessageUpdateCallbacks() {\n@Override\npublic void onMessageUidChange(Message message, String newUid) {\n\/\/ update the UID in the local trash folder, because some stores will\n\/\/ have to change it when copying to remoteTrashFolder\nContentValues cv = new ContentValues();\ncv.put(MessageColumns.SERVER_ID, newUid);\ncontext.getContentResolver().update(newMessage.getUri(), cv, null, null);\n}\n\/**\n* This will be called if the deleted message doesn't exist and can't be\n* deleted (e.g. it was already deleted from the server.) In this case,\n* attempt to delete the local copy as well.\n*\/\n@Override\npublic void onMessageNotFound(Message message) {\ncontext.getContentResolver().delete(newMessage.getUri(), null, null);\n}\n});\nremoteTrashFolder.close(false);\n}\n\/\/ 8. Delete the message from the remote source folder\nremoteMessage.setFlag(Flag.DELETED, true);\nremoteFolder.expunge();\nremoteFolder.close(false);\n}\n\nprivate static void processPendingMoveToTrash(final Context context, Store remoteStore,\nMailbox newMailbox, EmailContent.Message oldMessage,\nfinal EmailContent.Message newMessage) throws MessagingException {\n\/\/ 0. No remote move if the message is local-only\nif (newMessage.mServerId == null || newMessage.mServerId.equals(\"\")\n|| newMessage.mServerId.startsWith(LOCAL_SERVERID_PREFIX)) {\nreturn;\n}\n\/\/ 1. Escape early if we can't find the local mailbox\n\/\/ TODO smaller projection here\nMailbox oldMailbox = getRemoteMailboxForMessage(context, oldMessage);\nif (oldMailbox == null) {\n\/\/ can't find old mailbox, it may have been deleted. just return.\nreturn;\n}\n\/\/ 2. We don't support delete-from-trash here\nif (oldMailbox.mType == Mailbox.TYPE_TRASH) {\nreturn;\n}\n\/\/ The rest of this method handles server-side deletion\n\/\/ 4. Find the remote mailbox (that we deleted from), and open it\nFolder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);\nif (!remoteFolder.exists()) {\nreturn;\n\nprivate static void processPendingMoveToTrash(final Context context, Store remoteStore,\nMailbox newMailbox, EmailContent.Message oldMessage,\nfinal EmailContent.Message newMessage) throws MessagingException {\n\/\/ 0. No remote move if the message is local-only\nif (newMessage.mServerId == null || newMessage.mServerId.equals(\"\")\n|| newMessage.mServerId.startsWith(LOCAL_SERVERID_PREFIX)) {\nreturn;\n}\n\/\/ 1. Escape early if we can't find the local mailbox\n\/\/ TODO smaller projection here\nMailbox oldMailbox = getRemoteMailboxForMessage(context, oldMessage);\nif (oldMailbox == null) {\n\/\/ can't find old mailbox, it may have been deleted. just return.\nreturn;\n}\n\/\/ 2. We don't support delete-from-trash here\nif (oldMailbox.mType == Mailbox.TYPE_TRASH) {\nreturn;\n}\n\/\/ The rest of this method handles server-side deletion\n\/\/ 4. Find the remote mailbox (that we deleted from), and open it\nFolder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);\nif (!remoteFolder.exists()) {\nreturn;\n}\nremoteFolder.open(OpenMode.READ_WRITE);\nif (remoteFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nreturn;\n}\n\nprivate static void processPendingMoveToTrash(final Context context, Store remoteStore,\nMailbox newMailbox, EmailContent.Message oldMessage,\nfinal EmailContent.Message newMessage) throws MessagingException {\n\/\/ 0. No remote move if the message is local-only\nif (newMessage.mServerId == null || newMessage.mServerId.equals(\"\")\n|| newMessage.mServerId.startsWith(LOCAL_SERVERID_PREFIX)) {\nreturn;\n}\n\/\/ 1. Escape early if we can't find the local mailbox\n\/\/ TODO smaller projection here\nMailbox oldMailbox = getRemoteMailboxForMessage(context, oldMessage);\nif (oldMailbox == null) {\n\/\/ can't find old mailbox, it may have been deleted. just return.\nreturn;\n}\n\/\/ 2. We don't support delete-from-trash here\nif (oldMailbox.mType == Mailbox.TYPE_TRASH) {\nreturn;\n}\n\/\/ The rest of this method handles server-side deletion\n\/\/ 4. Find the remote mailbox (that we deleted from), and open it\nFolder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);\nif (!remoteFolder.exists()) {\nreturn;\n}\nremoteFolder.open(OpenMode.READ_WRITE);\nif (remoteFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 5. Find the remote original message\nMessage remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);\nif (remoteMessage == null) {\n\nprivate static void processPendingMoveToTrash(final Context context, Store remoteStore,\nMailbox newMailbox, EmailContent.Message oldMessage,\nfinal EmailContent.Message newMessage) throws MessagingException {\n\/\/ 0. No remote move if the message is local-only\nif (newMessage.mServerId == null || newMessage.mServerId.equals(\"\")\n|| newMessage.mServerId.startsWith(LOCAL_SERVERID_PREFIX)) {\nreturn;\n}\n\/\/ 1. Escape early if we can't find the local mailbox\n\/\/ TODO smaller projection here\nMailbox oldMailbox = getRemoteMailboxForMessage(context, oldMessage);\nif (oldMailbox == null) {\n\/\/ can't find old mailbox, it may have been deleted. just return.\nreturn;\n}\n\/\/ 2. We don't support delete-from-trash here\nif (oldMailbox.mType == Mailbox.TYPE_TRASH) {\nreturn;\n}\n\/\/ The rest of this method handles server-side deletion\n\/\/ 4. Find the remote mailbox (that we deleted from), and open it\nFolder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);\nif (!remoteFolder.exists()) {\nreturn;\n}\nremoteFolder.open(OpenMode.READ_WRITE);\nif (remoteFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 5. Find the remote original message\nMessage remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);\nif (remoteMessage == null) {\nremoteFolder.close(false);\nreturn;\n}\n\nprivate static void processPendingMoveToTrash(final Context context, Store remoteStore,\nMailbox newMailbox, EmailContent.Message oldMessage,\nfinal EmailContent.Message newMessage) throws MessagingException {\n\/\/ 0. No remote move if the message is local-only\nif (newMessage.mServerId == null || newMessage.mServerId.equals(\"\")\n|| newMessage.mServerId.startsWith(LOCAL_SERVERID_PREFIX)) {\nreturn;\n}\n\/\/ 1. Escape early if we can't find the local mailbox\n\/\/ TODO smaller projection here\nMailbox oldMailbox = getRemoteMailboxForMessage(context, oldMessage);\nif (oldMailbox == null) {\n\/\/ can't find old mailbox, it may have been deleted. just return.\nreturn;\n}\n\/\/ 2. We don't support delete-from-trash here\nif (oldMailbox.mType == Mailbox.TYPE_TRASH) {\nreturn;\n}\n\/\/ The rest of this method handles server-side deletion\n\/\/ 4. Find the remote mailbox (that we deleted from), and open it\nFolder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);\nif (!remoteFolder.exists()) {\nreturn;\n}\nremoteFolder.open(OpenMode.READ_WRITE);\nif (remoteFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 5. Find the remote original message\nMessage remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);\nif (remoteMessage == null) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 6. Find the remote trash folder, and create it if not found\nFolder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);\nif (!remoteTrashFolder.exists()) {\n\/*\n* If the remote trash folder doesn't exist we try to create it.\n\nMailbox oldMailbox = getRemoteMailboxForMessage(context, oldMessage);\nif (oldMailbox == null) {\n\/\/ can't find old mailbox, it may have been deleted. just return.\nreturn;\n}\n\/\/ 2. We don't support delete-from-trash here\nif (oldMailbox.mType == Mailbox.TYPE_TRASH) {\nreturn;\n}\n\/\/ The rest of this method handles server-side deletion\n\/\/ 4. Find the remote mailbox (that we deleted from), and open it\nFolder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);\nif (!remoteFolder.exists()) {\nreturn;\n}\nremoteFolder.open(OpenMode.READ_WRITE);\nif (remoteFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 5. Find the remote original message\nMessage remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);\nif (remoteMessage == null) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 6. Find the remote trash folder, and create it if not found\nFolder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);\nif (!remoteTrashFolder.exists()) {\n\/*\n* If the remote trash folder doesn't exist we try to create it.\n*\/\nremoteTrashFolder.create(FolderType.HOLDS_MESSAGES);\n}\n\/\/ 7. Try to copy the message into the remote trash folder\n\/\/ Note, this entire section will be skipped for POP3 because there's no remote trash\nif (remoteTrashFolder.exists()) {\n\/*\n* Because remoteTrashFolder may be new, we need to explicitly open it\n*\/\nremoteTrashFolder.open(OpenMode.READ_WRITE);\n\nif (oldMailbox.mType == Mailbox.TYPE_TRASH) {\nreturn;\n}\n\/\/ The rest of this method handles server-side deletion\n\/\/ 4. Find the remote mailbox (that we deleted from), and open it\nFolder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);\nif (!remoteFolder.exists()) {\nreturn;\n}\nremoteFolder.open(OpenMode.READ_WRITE);\nif (remoteFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 5. Find the remote original message\nMessage remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);\nif (remoteMessage == null) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 6. Find the remote trash folder, and create it if not found\nFolder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);\nif (!remoteTrashFolder.exists()) {\n\/*\n* If the remote trash folder doesn't exist we try to create it.\n*\/\nremoteTrashFolder.create(FolderType.HOLDS_MESSAGES);\n}\n\/\/ 7. Try to copy the message into the remote trash folder\n\/\/ Note, this entire section will be skipped for POP3 because there's no remote trash\nif (remoteTrashFolder.exists()) {\n\/*\n* Because remoteTrashFolder may be new, we need to explicitly open it\n*\/\nremoteTrashFolder.open(OpenMode.READ_WRITE);\nif (remoteTrashFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nremoteTrashFolder.close(false);\nreturn;\n}\nremoteFolder.copyMessages(new Message[] { remoteMessage }, remoteTrashFolder,\n\n\/\/ The rest of this method handles server-side deletion\n\/\/ 4. Find the remote mailbox (that we deleted from), and open it\nFolder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);\nif (!remoteFolder.exists()) {\nreturn;\n}\nremoteFolder.open(OpenMode.READ_WRITE);\nif (remoteFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 5. Find the remote original message\nMessage remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);\nif (remoteMessage == null) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 6. Find the remote trash folder, and create it if not found\nFolder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);\nif (!remoteTrashFolder.exists()) {\n\/*\n* If the remote trash folder doesn't exist we try to create it.\n*\/\nremoteTrashFolder.create(FolderType.HOLDS_MESSAGES);\n}\n\/\/ 7. Try to copy the message into the remote trash folder\n\/\/ Note, this entire section will be skipped for POP3 because there's no remote trash\nif (remoteTrashFolder.exists()) {\n\/*\n* Because remoteTrashFolder may be new, we need to explicitly open it\n*\/\nremoteTrashFolder.open(OpenMode.READ_WRITE);\nif (remoteTrashFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nremoteTrashFolder.close(false);\nreturn;\n}\nremoteFolder.copyMessages(new Message[] { remoteMessage }, remoteTrashFolder,\nnew Folder.MessageUpdateCallbacks() {\n@Override\npublic void onMessageUidChange(Message message, String newUid) {\n\/\/ update the UID in the local trash folder, because some stores will\n\/\/ have to change it when copying to remoteTrashFolder\n\n}\nremoteFolder.open(OpenMode.READ_WRITE);\nif (remoteFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 5. Find the remote original message\nMessage remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);\nif (remoteMessage == null) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 6. Find the remote trash folder, and create it if not found\nFolder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);\nif (!remoteTrashFolder.exists()) {\n\/*\n* If the remote trash folder doesn't exist we try to create it.\n*\/\nremoteTrashFolder.create(FolderType.HOLDS_MESSAGES);\n}\n\/\/ 7. Try to copy the message into the remote trash folder\n\/\/ Note, this entire section will be skipped for POP3 because there's no remote trash\nif (remoteTrashFolder.exists()) {\n\/*\n* Because remoteTrashFolder may be new, we need to explicitly open it\n*\/\nremoteTrashFolder.open(OpenMode.READ_WRITE);\nif (remoteTrashFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nremoteTrashFolder.close(false);\nreturn;\n}\nremoteFolder.copyMessages(new Message[] { remoteMessage }, remoteTrashFolder,\nnew Folder.MessageUpdateCallbacks() {\n@Override\npublic void onMessageUidChange(Message message, String newUid) {\n\/\/ update the UID in the local trash folder, because some stores will\n\/\/ have to change it when copying to remoteTrashFolder\nContentValues cv = new ContentValues();\ncv.put(MessageColumns.SERVER_ID, newUid);\ncontext.getContentResolver().update(newMessage.getUri(), cv, null, null);\n}\n\n\/\/ The rest of this method handles server-side deletion\n\/\/ 4. Find the remote mailbox (that we deleted from), and open it\nFolder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);\nif (!remoteFolder.exists()) {\nreturn;\n}\nremoteFolder.open(OpenMode.READ_WRITE);\nif (remoteFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 5. Find the remote original message\nMessage remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);\nif (remoteMessage == null) {\nremoteFolder.close(false);\nreturn;\n}\n\/\/ 6. Find the remote trash folder, and create it if not found\nFolder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);\nif (!remoteTrashFolder.exists()) {\n\/*\n* If the remote trash folder doesn't exist we try to create it.\n*\/\nremoteTrashFolder.create(FolderType.HOLDS_MESSAGES);\n}\n\/\/ 7. Try to copy the message into the remote trash folder\n\/\/ Note, this entire section will be skipped for POP3 because there's no remote trash\nif (remoteTrashFolder.exists()) {\n\/*\n* Because remoteTrashFolder may be new, we need to explicitly open it\n*\/\nremoteTrashFolder.open(OpenMode.READ_WRITE);\nif (remoteTrashFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nremoteTrashFolder.close(false);\nreturn;\n}\nremoteFolder.copyMessages(new Message[] { remoteMessage }, remoteTrashFolder,\nnew Folder.MessageUpdateCallbacks() {\n@Override\npublic void onMessageUidChange(Message message, String newUid) {\n\/\/ update the UID in the local trash folder, because some stores will\n\/\/ have to change it when copying to remoteTrashFolder\n\n* If the remote trash folder doesn't exist we try to create it.\n*\/\nremoteTrashFolder.create(FolderType.HOLDS_MESSAGES);\n}\n\/\/ 7. Try to copy the message into the remote trash folder\n\/\/ Note, this entire section will be skipped for POP3 because there's no remote trash\nif (remoteTrashFolder.exists()) {\n\/*\n* Because remoteTrashFolder may be new, we need to explicitly open it\n*\/\nremoteTrashFolder.open(OpenMode.READ_WRITE);\nif (remoteTrashFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nremoteTrashFolder.close(false);\nreturn;\n}\nremoteFolder.copyMessages(new Message[] { remoteMessage }, remoteTrashFolder,\nnew Folder.MessageUpdateCallbacks() {\n@Override\npublic void onMessageUidChange(Message message, String newUid) {\n\/\/ update the UID in the local trash folder, because some stores will\n\/\/ have to change it when copying to remoteTrashFolder\nContentValues cv = new ContentValues();\ncv.put(MessageColumns.SERVER_ID, newUid);\ncontext.getContentResolver().update(newMessage.getUri(), cv, null, null);\n}\n\/**\n* This will be called if the deleted message doesn't exist and can't be\n* deleted (e.g. it was already deleted from the server.) In this case,\n* attempt to delete the local copy as well.\n*\/\n@Override\npublic void onMessageNotFound(Message message) {\ncontext.getContentResolver().delete(newMessage.getUri(), null, null);\n}\n});\nremoteTrashFolder.close(false);\n}\n\/\/ 8. Delete the message from the remote source folder\nremoteMessage.setFlag(Flag.DELETED, true);\nremoteFolder.expunge();\nremoteFolder.close(false);\n\nif (remoteTrashFolder.exists()) {\n\/*\n* Because remoteTrashFolder may be new, we need to explicitly open it\n*\/\nremoteTrashFolder.open(OpenMode.READ_WRITE);\nif (remoteTrashFolder.getMode() != OpenMode.READ_WRITE) {\nremoteFolder.close(false);\nremoteTrashFolder.close(false);\nreturn;\n}\nremoteFolder.copyMessages(new Message[] { remoteMessage }, remoteTrashFolder,\nnew Folder.MessageUpdateCallbacks() {\n@Override\npublic void onMessageUidChange(Message message, String newUid) {\n\/\/ update the UID in the local trash folder, because some stores will\n\/\/ have to change it when copying to remoteTrashFolder\nContentValues cv = new ContentValues();\ncv.put(MessageColumns.SERVER_ID, newUid);\ncontext.getContentResolver().update(newMessage.getUri(), cv, null, null);\n}\n\/**\n* This will be called if the deleted message doesn't exist and can't be\n* deleted (e.g. it was already deleted from the server.) In this case,\n* attempt to delete the local copy as well.\n*\/\n@Override\npublic void onMessageNotFound(Message message) {\ncontext.getContentResolver().delete(newMessage.getUri(), null, null);\n}\n});\nremoteTrashFolder.close(false);\n}\n\/\/ 8. Delete the message from the remote source folder\nremoteMessage.setFlag(Flag.DELETED, true);\nremoteFolder.expunge();\nremoteFolder.close(false);\n}\n\n@Override\npublic void onMessageUidChange(Message message, String newUid) {\n\/\/ update the UID in the local trash folder, because some stores will\n\/\/ have to change it when copying to remoteTrashFolder\nContentValues cv = new ContentValues();\ncv.put(MessageColumns.SERVER_ID, newUid);\ncontext.getContentResolver().update(newMessage.getUri(), cv, null, null);\n}\n\/**\n* This will be called if the deleted message doesn't exist and can't be\n* deleted (e.g. it was already deleted from the server.) In this case,\n* attempt to delete the local copy as well.\n*\/\n@Override\npublic void onMessageNotFound(Message message) {\ncontext.getContentResolver().delete(newMessage.getUri(), null, null);\n}\n});\nremoteTrashFolder.close(false);\n}\n\/\/ 8. Delete the message from the remote source folder\nremoteMessage.setFlag(Flag.DELETED, true);\nremoteFolder.expunge();\nremoteFolder.close(false);\n}","label":[1,0,0,0]}
{"id":14054,"original_code":"@Override\n  public void enableDebug() {\n    \/\/ Turn on Crunch runtime error catching.\n    \/\/TODO: allow configurable\n    getConfiguration().setBoolean(\"crunch.debug\", true);\n  }","code":"@Override\n  public void enableDebug() {\n   \n   \n    getConfiguration().setBoolean(\"crunch.debug\", true);\n  }","cleancode":"@override public void enabledebug() { getconfiguration().setboolean(\"crunch.debug\", true); }","comment":"\/\/ turn on crunch runtime error catching. \/\/todo: allow configurable","repo":"KeerthiYanda91\/crunch","code_context_2":"@Override\npublic void enableDebug() {\n\/\/ Turn on Crunch runtime error catching.\n\/\/TODO: allow configurable\ngetConfiguration().setBoolean(\"crunch.debug\", true);\n}","code_context_10":"@Override\npublic void enableDebug() {\n\/\/ Turn on Crunch runtime error catching.\n\/\/TODO: allow configurable\ngetConfiguration().setBoolean(\"crunch.debug\", true);\n}","code_context_20":"@Override\npublic void enableDebug() {\n\/\/ Turn on Crunch runtime error catching.\n\/\/TODO: allow configurable\ngetConfiguration().setBoolean(\"crunch.debug\", true);\n}","label":[1,0,0,0]}
{"id":14145,"original_code":"private Optional<DecodedJWT> authenticateRequest(HttpServletRequest req, HttpServletResponse resp) {\n        String authHeader = StringUtil.trimToEmpty(req.getHeader(\"Authorization\"));\n        String authBearerToken = authHeader.replaceFirst(\"^Bearer \", \"\");\n        if (authHeader.isEmpty()) {\n            LOG.warn(\"No Authorization header in request\");\n            resp.setStatus(HTTP_FORBIDDEN);\n            return Optional.empty();\n        }\n        if (authBearerToken.isEmpty()) {\n            LOG.warn(\"No Authorization Bearer token in request\");\n            resp.setStatus(HTTP_FORBIDDEN);\n            return Optional.empty();\n        }\n        DecodedJWT decodedJWT = JWT.decode(authBearerToken);\n        RSAKeyProvider keyProvider = new RSAKeyProvider() {\n            @Override\n            public RSAPublicKey getPublicKeyById(String keyId) {\n                Optional<JSONWebKey> key = jwtKeyProvider.getKey(keyId);\n                if (!key.isPresent()) {\n                    \/\/ TODO what do?\n                    resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                    return null;\n                }\n                try {\n                    \/\/ https:\/\/github.com\/auth0\/jwks-rsa-java\/blob\/master\/src\/main\/java\/com\/auth0\/jwk\/Jwk.java#L171\n                    KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n                    JSONWebKey jwk = key.get();\n                    BigInteger modulus = new BigInteger(1, Base64.getUrlDecoder().decode(jwk.n));\n                    BigInteger exponent = new BigInteger(1, Base64.getUrlDecoder().decode(jwk.e));\n                    return (RSAPublicKey) keyFactory.generatePublic(new RSAPublicKeySpec(modulus, exponent));\n\/\/                    String keyDataString = key.get().x509CertificateChain.get(0);\n\/\/                    byte[] keyData = Base64.getDecoder().decode(keyDataString.getBytes(StandardCharsets.UTF_8));\n\/\/                    return (RSAPublicKey) keyFactory.generatePublic(new X509EncodedKeySpec(keyData));\n                } catch (InvalidKeySpecException | NoSuchAlgorithmException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            @Override\n            public RSAPrivateKey getPrivateKey() {\n                return null;\n            }\n            @Override\n            public String getPrivateKeyId() {\n                return null;\n            }\n        };\n        Algorithm algorithm;\n        switch (decodedJWT.getAlgorithm()) {\n            case \"RS256\":\n                algorithm = Algorithm.RSA256(keyProvider);\n                break;\n            default:\n                resp.setStatus(HTTP_BAD_REQUEST);\n                LOG.error(\"Unknown algorithm {}\", decodedJWT.getAlgorithm());\n                return Optional.empty();\n        }\n        JWTVerifier jwtVerifier = JWT.require(algorithm)\n                .acceptLeeway(Duration.ofMinutes(5).getSeconds())\n                .withIssuer(\"https:\/\/api.botframework.com\")\n                \/\/ .withAudience(ap) TODO verify audience if the app id\n                .build();\n        jwtVerifier.verify(authBearerToken);\n        return Optional.of(decodedJWT);\n    }","code":"private Optional<DecodedJWT> authenticateRequest(HttpServletRequest req, HttpServletResponse resp) {\n        String authHeader = StringUtil.trimToEmpty(req.getHeader(\"Authorization\"));\n        String authBearerToken = authHeader.replaceFirst(\"^Bearer \", \"\");\n        if (authHeader.isEmpty()) {\n            LOG.warn(\"No Authorization header in request\");\n            resp.setStatus(HTTP_FORBIDDEN);\n            return Optional.empty();\n        }\n        if (authBearerToken.isEmpty()) {\n            LOG.warn(\"No Authorization Bearer token in request\");\n            resp.setStatus(HTTP_FORBIDDEN);\n            return Optional.empty();\n        }\n        DecodedJWT decodedJWT = JWT.decode(authBearerToken);\n        RSAKeyProvider keyProvider = new RSAKeyProvider() {\n            @Override\n            public RSAPublicKey getPublicKeyById(String keyId) {\n                Optional<JSONWebKey> key = jwtKeyProvider.getKey(keyId);\n                if (!key.isPresent()) {\n                   \n                    resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                    return null;\n                }\n                try {\n                   \n                    KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n                    JSONWebKey jwk = key.get();\n                    BigInteger modulus = new BigInteger(1, Base64.getUrlDecoder().decode(jwk.n));\n                    BigInteger exponent = new BigInteger(1, Base64.getUrlDecoder().decode(jwk.e));\n                    return (RSAPublicKey) keyFactory.generatePublic(new RSAPublicKeySpec(modulus, exponent));\n                } catch (InvalidKeySpecException | NoSuchAlgorithmException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            @Override\n            public RSAPrivateKey getPrivateKey() {\n                return null;\n            }\n            @Override\n            public String getPrivateKeyId() {\n                return null;\n            }\n        };\n        Algorithm algorithm;\n        switch (decodedJWT.getAlgorithm()) {\n            case \"RS256\":\n                algorithm = Algorithm.RSA256(keyProvider);\n                break;\n            default:\n                resp.setStatus(HTTP_BAD_REQUEST);\n                LOG.error(\"Unknown algorithm {}\", decodedJWT.getAlgorithm());\n                return Optional.empty();\n        }\n        JWTVerifier jwtVerifier = JWT.require(algorithm)\n                .acceptLeeway(Duration.ofMinutes(5).getSeconds())\n                .withIssuer(\"https:\/\/api.botframework.com\")\n               \n                .build();\n        jwtVerifier.verify(authBearerToken);\n        return Optional.of(decodedJWT);\n    }","cleancode":"private optional<decodedjwt> authenticaterequest(httpservletrequest req, httpservletresponse resp) { string authheader = stringutil.trimtoempty(req.getheader(\"authorization\")); string authbearertoken = authheader.replacefirst(\"^bearer \", \"\"); if (authheader.isempty()) { log.warn(\"no authorization header in request\"); resp.setstatus(http_forbidden); return optional.empty(); } if (authbearertoken.isempty()) { log.warn(\"no authorization bearer token in request\"); resp.setstatus(http_forbidden); return optional.empty(); } decodedjwt decodedjwt = jwt.decode(authbearertoken); rsakeyprovider keyprovider = new rsakeyprovider() { @override public rsapublickey getpublickeybyid(string keyid) { optional<jsonwebkey> key = jwtkeyprovider.getkey(keyid); if (!key.ispresent()) { resp.setstatus(httpservletresponse.sc_bad_request); return null; } try { keyfactory keyfactory = keyfactory.getinstance(\"rsa\"); jsonwebkey jwk = key.get(); biginteger modulus = new biginteger(1, base64.geturldecoder().decode(jwk.n)); biginteger exponent = new biginteger(1, base64.geturldecoder().decode(jwk.e)); return (rsapublickey) keyfactory.generatepublic(new rsapublickeyspec(modulus, exponent)); } catch (invalidkeyspecexception | nosuchalgorithmexception e) { throw new runtimeexception(e); } } @override public rsaprivatekey getprivatekey() { return null; } @override public string getprivatekeyid() { return null; } }; algorithm algorithm; switch (decodedjwt.getalgorithm()) { case \"rs256\": algorithm = algorithm.rsa256(keyprovider); break; default: resp.setstatus(http_bad_request); log.error(\"unknown algorithm {}\", decodedjwt.getalgorithm()); return optional.empty(); } jwtverifier jwtverifier = jwt.require(algorithm) .acceptleeway(duration.ofminutes(5).getseconds()) .withissuer(\"https:\/\/api.botframework.com\") .build(); jwtverifier.verify(authbearertoken); return optional.of(decodedjwt); }","comment":"\/\/ todo what do?\n\/\/ https:\/\/github.com\/auth0\/jwks-rsa-java\/blob\/master\/src\/main\/java\/com\/auth0\/jwk\/jwk.java#l171\n\/\/ string keydatastring = key.get().x509certificatechain.get(0); \/\/ byte[] keydata = base64.getdecoder().decode(keydatastring.getbytes(standardcharsets.utf_8)); \/\/ return (rsapublickey) keyfactory.generatepublic(new x509encodedkeyspec(keydata));\n\/\/ .withaudience(ap) todo verify audience if the app id","repo":"Mustard\/chatterbox","code_context_2":"Optional<JSONWebKey> key = jwtKeyProvider.getKey(keyId);\nif (!key.isPresent()) {\n\/\/ TODO what do?\nresp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\nreturn null;\n\n}\ntry {\n\/\/ https:\/\/github.com\/auth0\/jwks-rsa-java\/blob\/master\/src\/main\/java\/com\/auth0\/jwk\/Jwk.java#L171\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\nJSONWebKey jwk = key.get();\n\nBigInteger exponent = new BigInteger(1, Base64.getUrlDecoder().decode(jwk.e));\nreturn (RSAPublicKey) keyFactory.generatePublic(new RSAPublicKeySpec(modulus, exponent));\n\/\/ String keyDataString = key.get().x509CertificateChain.get(0);\n\/\/ byte[] keyData = Base64.getDecoder().decode(keyDataString.getBytes(StandardCharsets.UTF_8));\n\/\/ return (RSAPublicKey) keyFactory.generatePublic(new X509EncodedKeySpec(keyData));\n} catch (InvalidKeySpecException | NoSuchAlgorithmException e) {\nthrow new RuntimeException(e);\n\n.acceptLeeway(Duration.ofMinutes(5).getSeconds())\n.withIssuer(\"https:\/\/api.botframework.com\")\n\/\/ .withAudience(ap) TODO verify audience if the app id\n.build();\njwtVerifier.verify(authBearerToken);","code_context_10":"LOG.warn(\"No Authorization Bearer token in request\");\nresp.setStatus(HTTP_FORBIDDEN);\nreturn Optional.empty();\n}\nDecodedJWT decodedJWT = JWT.decode(authBearerToken);\nRSAKeyProvider keyProvider = new RSAKeyProvider() {\n@Override\npublic RSAPublicKey getPublicKeyById(String keyId) {\nOptional<JSONWebKey> key = jwtKeyProvider.getKey(keyId);\nif (!key.isPresent()) {\n\/\/ TODO what do?\nresp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\nreturn null;\n}\ntry {\n\/\/ https:\/\/github.com\/auth0\/jwks-rsa-java\/blob\/master\/src\/main\/java\/com\/auth0\/jwk\/Jwk.java#L171\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\nJSONWebKey jwk = key.get();\nBigInteger modulus = new BigInteger(1, Base64.getUrlDecoder().decode(jwk.n));\nBigInteger exponent = new BigInteger(1, Base64.getUrlDecoder().decode(jwk.e));\nreturn (RSAPublicKey) keyFactory.generatePublic(new RSAPublicKeySpec(modulus, exponent));\n\nRSAKeyProvider keyProvider = new RSAKeyProvider() {\n@Override\npublic RSAPublicKey getPublicKeyById(String keyId) {\nOptional<JSONWebKey> key = jwtKeyProvider.getKey(keyId);\nif (!key.isPresent()) {\n\/\/ TODO what do?\nresp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\nreturn null;\n}\ntry {\n\/\/ https:\/\/github.com\/auth0\/jwks-rsa-java\/blob\/master\/src\/main\/java\/com\/auth0\/jwk\/Jwk.java#L171\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\nJSONWebKey jwk = key.get();\nBigInteger modulus = new BigInteger(1, Base64.getUrlDecoder().decode(jwk.n));\nBigInteger exponent = new BigInteger(1, Base64.getUrlDecoder().decode(jwk.e));\nreturn (RSAPublicKey) keyFactory.generatePublic(new RSAPublicKeySpec(modulus, exponent));\n\/\/ String keyDataString = key.get().x509CertificateChain.get(0);\n\/\/ byte[] keyData = Base64.getDecoder().decode(keyDataString.getBytes(StandardCharsets.UTF_8));\n\/\/ return (RSAPublicKey) keyFactory.generatePublic(new X509EncodedKeySpec(keyData));\n} catch (InvalidKeySpecException | NoSuchAlgorithmException e) {\nthrow new RuntimeException(e);\n\nresp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\nreturn null;\n}\ntry {\n\/\/ https:\/\/github.com\/auth0\/jwks-rsa-java\/blob\/master\/src\/main\/java\/com\/auth0\/jwk\/Jwk.java#L171\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\nJSONWebKey jwk = key.get();\nBigInteger modulus = new BigInteger(1, Base64.getUrlDecoder().decode(jwk.n));\nBigInteger exponent = new BigInteger(1, Base64.getUrlDecoder().decode(jwk.e));\nreturn (RSAPublicKey) keyFactory.generatePublic(new RSAPublicKeySpec(modulus, exponent));\n\/\/ String keyDataString = key.get().x509CertificateChain.get(0);\n\/\/ byte[] keyData = Base64.getDecoder().decode(keyDataString.getBytes(StandardCharsets.UTF_8));\n\/\/ return (RSAPublicKey) keyFactory.generatePublic(new X509EncodedKeySpec(keyData));\n} catch (InvalidKeySpecException | NoSuchAlgorithmException e) {\nthrow new RuntimeException(e);\n}\n}\n@Override\npublic RSAPrivateKey getPrivateKey() {\nreturn null;\n}\n@Override\npublic String getPrivateKeyId() {\n\nalgorithm = Algorithm.RSA256(keyProvider);\nbreak;\ndefault:\nresp.setStatus(HTTP_BAD_REQUEST);\nLOG.error(\"Unknown algorithm {}\", decodedJWT.getAlgorithm());\nreturn Optional.empty();\n}\nJWTVerifier jwtVerifier = JWT.require(algorithm)\n.acceptLeeway(Duration.ofMinutes(5).getSeconds())\n.withIssuer(\"https:\/\/api.botframework.com\")\n\/\/ .withAudience(ap) TODO verify audience if the app id\n.build();\njwtVerifier.verify(authBearerToken);\nreturn Optional.of(decodedJWT);\n}","code_context_20":"private Optional<DecodedJWT> authenticateRequest(HttpServletRequest req, HttpServletResponse resp) {\nString authHeader = StringUtil.trimToEmpty(req.getHeader(\"Authorization\"));\nString authBearerToken = authHeader.replaceFirst(\"^Bearer \", \"\");\nif (authHeader.isEmpty()) {\nLOG.warn(\"No Authorization header in request\");\nresp.setStatus(HTTP_FORBIDDEN);\nreturn Optional.empty();\n}\nif (authBearerToken.isEmpty()) {\nLOG.warn(\"No Authorization Bearer token in request\");\nresp.setStatus(HTTP_FORBIDDEN);\nreturn Optional.empty();\n}\nDecodedJWT decodedJWT = JWT.decode(authBearerToken);\nRSAKeyProvider keyProvider = new RSAKeyProvider() {\n@Override\npublic RSAPublicKey getPublicKeyById(String keyId) {\nOptional<JSONWebKey> key = jwtKeyProvider.getKey(keyId);\nif (!key.isPresent()) {\n\/\/ TODO what do?\nresp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\nreturn null;\n}\ntry {\n\/\/ https:\/\/github.com\/auth0\/jwks-rsa-java\/blob\/master\/src\/main\/java\/com\/auth0\/jwk\/Jwk.java#L171\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\nJSONWebKey jwk = key.get();\nBigInteger modulus = new BigInteger(1, Base64.getUrlDecoder().decode(jwk.n));\nBigInteger exponent = new BigInteger(1, Base64.getUrlDecoder().decode(jwk.e));\nreturn (RSAPublicKey) keyFactory.generatePublic(new RSAPublicKeySpec(modulus, exponent));\n\/\/ String keyDataString = key.get().x509CertificateChain.get(0);\n\/\/ byte[] keyData = Base64.getDecoder().decode(keyDataString.getBytes(StandardCharsets.UTF_8));\n\/\/ return (RSAPublicKey) keyFactory.generatePublic(new X509EncodedKeySpec(keyData));\n} catch (InvalidKeySpecException | NoSuchAlgorithmException e) {\nthrow new RuntimeException(e);\n}\n}\n@Override\npublic RSAPrivateKey getPrivateKey() {\nreturn null;\n\nLOG.warn(\"No Authorization header in request\");\nresp.setStatus(HTTP_FORBIDDEN);\nreturn Optional.empty();\n}\nif (authBearerToken.isEmpty()) {\nLOG.warn(\"No Authorization Bearer token in request\");\nresp.setStatus(HTTP_FORBIDDEN);\nreturn Optional.empty();\n}\nDecodedJWT decodedJWT = JWT.decode(authBearerToken);\nRSAKeyProvider keyProvider = new RSAKeyProvider() {\n@Override\npublic RSAPublicKey getPublicKeyById(String keyId) {\nOptional<JSONWebKey> key = jwtKeyProvider.getKey(keyId);\nif (!key.isPresent()) {\n\/\/ TODO what do?\nresp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\nreturn null;\n}\ntry {\n\/\/ https:\/\/github.com\/auth0\/jwks-rsa-java\/blob\/master\/src\/main\/java\/com\/auth0\/jwk\/Jwk.java#L171\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\nJSONWebKey jwk = key.get();\nBigInteger modulus = new BigInteger(1, Base64.getUrlDecoder().decode(jwk.n));\nBigInteger exponent = new BigInteger(1, Base64.getUrlDecoder().decode(jwk.e));\nreturn (RSAPublicKey) keyFactory.generatePublic(new RSAPublicKeySpec(modulus, exponent));\n\/\/ String keyDataString = key.get().x509CertificateChain.get(0);\n\/\/ byte[] keyData = Base64.getDecoder().decode(keyDataString.getBytes(StandardCharsets.UTF_8));\n\/\/ return (RSAPublicKey) keyFactory.generatePublic(new X509EncodedKeySpec(keyData));\n} catch (InvalidKeySpecException | NoSuchAlgorithmException e) {\nthrow new RuntimeException(e);\n}\n}\n@Override\npublic RSAPrivateKey getPrivateKey() {\nreturn null;\n}\n@Override\npublic String getPrivateKeyId() {\nreturn null;\n}\n\nresp.setStatus(HTTP_FORBIDDEN);\nreturn Optional.empty();\n}\nDecodedJWT decodedJWT = JWT.decode(authBearerToken);\nRSAKeyProvider keyProvider = new RSAKeyProvider() {\n@Override\npublic RSAPublicKey getPublicKeyById(String keyId) {\nOptional<JSONWebKey> key = jwtKeyProvider.getKey(keyId);\nif (!key.isPresent()) {\n\/\/ TODO what do?\nresp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\nreturn null;\n}\ntry {\n\/\/ https:\/\/github.com\/auth0\/jwks-rsa-java\/blob\/master\/src\/main\/java\/com\/auth0\/jwk\/Jwk.java#L171\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\nJSONWebKey jwk = key.get();\nBigInteger modulus = new BigInteger(1, Base64.getUrlDecoder().decode(jwk.n));\nBigInteger exponent = new BigInteger(1, Base64.getUrlDecoder().decode(jwk.e));\nreturn (RSAPublicKey) keyFactory.generatePublic(new RSAPublicKeySpec(modulus, exponent));\n\/\/ String keyDataString = key.get().x509CertificateChain.get(0);\n\/\/ byte[] keyData = Base64.getDecoder().decode(keyDataString.getBytes(StandardCharsets.UTF_8));\n\/\/ return (RSAPublicKey) keyFactory.generatePublic(new X509EncodedKeySpec(keyData));\n} catch (InvalidKeySpecException | NoSuchAlgorithmException e) {\nthrow new RuntimeException(e);\n}\n}\n@Override\npublic RSAPrivateKey getPrivateKey() {\nreturn null;\n}\n@Override\npublic String getPrivateKeyId() {\nreturn null;\n}\n};\nAlgorithm algorithm;\nswitch (decodedJWT.getAlgorithm()) {\ncase \"RS256\":\nalgorithm = Algorithm.RSA256(keyProvider);\nbreak;\ndefault:\nresp.setStatus(HTTP_BAD_REQUEST);\n\nreturn null;\n}\n@Override\npublic String getPrivateKeyId() {\nreturn null;\n}\n};\nAlgorithm algorithm;\nswitch (decodedJWT.getAlgorithm()) {\ncase \"RS256\":\nalgorithm = Algorithm.RSA256(keyProvider);\nbreak;\ndefault:\nresp.setStatus(HTTP_BAD_REQUEST);\nLOG.error(\"Unknown algorithm {}\", decodedJWT.getAlgorithm());\nreturn Optional.empty();\n}\nJWTVerifier jwtVerifier = JWT.require(algorithm)\n.acceptLeeway(Duration.ofMinutes(5).getSeconds())\n.withIssuer(\"https:\/\/api.botframework.com\")\n\/\/ .withAudience(ap) TODO verify audience if the app id\n.build();\njwtVerifier.verify(authBearerToken);\nreturn Optional.of(decodedJWT);\n}","label":[1,1,0,0]}
{"id":22340,"original_code":"public List<DccdSB> getSearchBeans()\n\t{\n\t\tList<DccdSB> searchBeans = new ArrayList<DccdSB>();\n\t\tif (!hasTridas())\n\t\t\treturn searchBeans; \/\/ just an empty list\n\t\t\/\/ get all the ObjectEntity's in the tree\n\t\tList<Entity> entities = getSubTreeAsList();\n\t\tfor (Entity entity : entities)\n\t\t{\n\t\t\t\/\/ only objects, exclude derived series\n\t\t\tif (entity instanceof ObjectEntity)\n\t\t\t{\n\t\t\t\t\/\/ create a bean\n\t\t\t\tDccdSB searchBean = new DccdObjectSB();\n\t\t\t\t\/\/ fill it\n\t\t\t\t\/\/ first with the project info, maybe this can be done more efficiently\n\t\t\t\t\/\/ because same conversions are done for every Object again\n\t\t\t\tsearchBean = fillSearchBean(searchBean);\n\t\t\t\t\/\/ then the object info\n\t\t\t\tsearchBean = entity.fillSearchBean(searchBean);\n\t\t\t\t\/\/ all the ObjectEntities subentities must fill this bean as well\n\t\t\t\t\/\/ but not Objects?\n\t\t\t\tList<Entity> subentities = entity.getSubTreeAsList();\n\t\t\t\tfor (Entity subentity : subentities)\n\t\t\t\t{\n\t\t\t\t\tsearchBean = subentity.fillSearchBean(searchBean);\n\t\t\t\t}\n\t\t\t\t\/\/ Note id should be the (system) identifier in the repository (sid)\n\t\t\t\t\/\/ just hoping that is is set correctly when read from the repository!!!\n\t\t\t\tsearchBean.setDatastreamId(entity.getId());\/\/ should be the repository id for this peace of info\n\t\t\t\t\/\/ add to the list\n\t\t\t\tsearchBeans.add(searchBean);\n\t\t\t}\n\t\t}\n\t\treturn searchBeans;\n\t}","code":"public List<DccdSB> getSearchBeans()\n\t{\n\t\tList<DccdSB> searchBeans = new ArrayList<DccdSB>();\n\t\tif (!hasTridas())\n\t\t\treturn searchBeans;\n\t\n\t\tList<Entity> entities = getSubTreeAsList();\n\t\tfor (Entity entity : entities)\n\t\t{\n\t\t\n\t\t\tif (entity instanceof ObjectEntity)\n\t\t\t{\n\t\t\t\n\t\t\t\tDccdSB searchBean = new DccdObjectSB();\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\tsearchBean = fillSearchBean(searchBean);\n\t\t\t\n\t\t\t\tsearchBean = entity.fillSearchBean(searchBean);\n\t\t\t\n\t\t\t\n\t\t\t\tList<Entity> subentities = entity.getSubTreeAsList();\n\t\t\t\tfor (Entity subentity : subentities)\n\t\t\t\t{\n\t\t\t\t\tsearchBean = subentity.fillSearchBean(searchBean);\n\t\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\tsearchBean.setDatastreamId(entity.getId())\n\t\t\t\n\t\t\t\tsearchBeans.add(searchBean);\n\t\t\t}\n\t\t}\n\t\treturn searchBeans;\n\t}","cleancode":"public list<dccdsb> getsearchbeans() { list<dccdsb> searchbeans = new arraylist<dccdsb>(); if (!hastridas()) return searchbeans; list<entity> entities = getsubtreeaslist(); for (entity entity : entities) { if (entity instanceof objectentity) { dccdsb searchbean = new dccdobjectsb(); searchbean = fillsearchbean(searchbean); searchbean = entity.fillsearchbean(searchbean); list<entity> subentities = entity.getsubtreeaslist(); for (entity subentity : subentities) { searchbean = subentity.fillsearchbean(searchbean); } searchbean.setdatastreamid(entity.getid()) searchbeans.add(searchbean); } } return searchbeans; }","comment":"\/** * get the searchbeans for each objectentity * fill the beans with all information, regardless of permission. * * @return *\/\n\/\/ just an empty list\n\/\/ get all the objectentity's in the tree\n\/\/ only objects, exclude derived series\n\/\/ create a bean\n\/\/ fill it \/\/ first with the project info, maybe this can be done more efficiently \/\/ because same conversions are done for every object again\n\/\/ then the object info\n\/\/ all the objectentities subentities must fill this bean as well \/\/ but not objects?\n\/\/ note id should be the (system) identifier in the repository (sid) \/\/ just hoping that is is set correctly when read from the repository!!!\n\/\/ should be the repository id for this peace of info\n\/\/ add to the list","repo":"PaulBoon\/dccd-lib","code_context_2":"public List<DccdSB> getSearchBeans()\n{\nList<DccdSB> searchBeans = new ArrayList<DccdSB>();\nif (!hasTridas())\nreturn searchBeans; \/\/ just an empty list\n\/\/ get all the ObjectEntity's in the tree\nList<Entity> entities = getSubTreeAsList();\nfor (Entity entity : entities)\n{\n\/\/ only objects, exclude derived series\nif (entity instanceof ObjectEntity)\n{\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\/\/ first with the project info, maybe this can be done more efficiently\n\/\/ because same conversions are done for every Object again\nsearchBean = fillSearchBean(searchBean);\n\/\/ then the object info\nsearchBean = entity.fillSearchBean(searchBean);\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\/\/ but not Objects?\nList<Entity> subentities = entity.getSubTreeAsList();\nfor (Entity subentity : subentities)\n{\nsearchBean = subentity.fillSearchBean(searchBean);\n}\n\/\/ Note id should be the (system) identifier in the repository (sid)\n\/\/ just hoping that is is set correctly when read from the repository!!!\nsearchBean.setDatastreamId(entity.getId());\/\/ should be the repository id for this peace of info\n\/\/ add to the list\nsearchBeans.add(searchBean);\n}\n}\nreturn searchBeans;\n}\n\nList<DccdSB> searchBeans = new ArrayList<DccdSB>();\nif (!hasTridas())\nreturn searchBeans; \/\/ just an empty list\n\/\/ get all the ObjectEntity's in the tree\nList<Entity> entities = getSubTreeAsList();\n\nif (!hasTridas())\nreturn searchBeans; \/\/ just an empty list\n\/\/ get all the ObjectEntity's in the tree\nList<Entity> entities = getSubTreeAsList();\nfor (Entity entity : entities)\n\nfor (Entity entity : entities)\n{\n\/\/ only objects, exclude derived series\nif (entity instanceof ObjectEntity)\n{\n\nif (entity instanceof ObjectEntity)\n{\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\/\/ first with the project info, maybe this can be done more efficiently\n\/\/ because same conversions are done for every Object again\nsearchBean = fillSearchBean(searchBean);\n\/\/ then the object info\n\n\/\/ because same conversions are done for every Object again\nsearchBean = fillSearchBean(searchBean);\n\/\/ then the object info\nsearchBean = entity.fillSearchBean(searchBean);\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\n\/\/ then the object info\nsearchBean = entity.fillSearchBean(searchBean);\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\/\/ but not Objects?\nList<Entity> subentities = entity.getSubTreeAsList();\nfor (Entity subentity : subentities)\n\nsearchBean = subentity.fillSearchBean(searchBean);\n}\n\/\/ Note id should be the (system) identifier in the repository (sid)\n\/\/ just hoping that is is set correctly when read from the repository!!!\nsearchBean.setDatastreamId(entity.getId());\/\/ should be the repository id for this peace of info\n\/\/ add to the list\n\n\/\/ Note id should be the (system) identifier in the repository (sid)\n\/\/ just hoping that is is set correctly when read from the repository!!!\nsearchBean.setDatastreamId(entity.getId());\/\/ should be the repository id for this peace of info\n\/\/ add to the list\nsearchBeans.add(searchBean);\n\n\/\/ just hoping that is is set correctly when read from the repository!!!\nsearchBean.setDatastreamId(entity.getId());\/\/ should be the repository id for this peace of info\n\/\/ add to the list\nsearchBeans.add(searchBean);\n}","code_context_10":"public List<DccdSB> getSearchBeans()\n{\nList<DccdSB> searchBeans = new ArrayList<DccdSB>();\nif (!hasTridas())\nreturn searchBeans; \/\/ just an empty list\n\/\/ get all the ObjectEntity's in the tree\nList<Entity> entities = getSubTreeAsList();\nfor (Entity entity : entities)\n{\n\/\/ only objects, exclude derived series\nif (entity instanceof ObjectEntity)\n{\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\/\/ first with the project info, maybe this can be done more efficiently\n\/\/ because same conversions are done for every Object again\nsearchBean = fillSearchBean(searchBean);\n\/\/ then the object info\nsearchBean = entity.fillSearchBean(searchBean);\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\/\/ but not Objects?\nList<Entity> subentities = entity.getSubTreeAsList();\nfor (Entity subentity : subentities)\n{\nsearchBean = subentity.fillSearchBean(searchBean);\n}\n\/\/ Note id should be the (system) identifier in the repository (sid)\n\/\/ just hoping that is is set correctly when read from the repository!!!\nsearchBean.setDatastreamId(entity.getId());\/\/ should be the repository id for this peace of info\n\/\/ add to the list\nsearchBeans.add(searchBean);\n}\n}\nreturn searchBeans;\n}\n\npublic List<DccdSB> getSearchBeans()\n{\nList<DccdSB> searchBeans = new ArrayList<DccdSB>();\nif (!hasTridas())\nreturn searchBeans; \/\/ just an empty list\n\/\/ get all the ObjectEntity's in the tree\nList<Entity> entities = getSubTreeAsList();\nfor (Entity entity : entities)\n{\n\/\/ only objects, exclude derived series\nif (entity instanceof ObjectEntity)\n{\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\npublic List<DccdSB> getSearchBeans()\n{\nList<DccdSB> searchBeans = new ArrayList<DccdSB>();\nif (!hasTridas())\nreturn searchBeans; \/\/ just an empty list\n\/\/ get all the ObjectEntity's in the tree\nList<Entity> entities = getSubTreeAsList();\nfor (Entity entity : entities)\n{\n\/\/ only objects, exclude derived series\nif (entity instanceof ObjectEntity)\n{\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\/\/ first with the project info, maybe this can be done more efficiently\n\npublic List<DccdSB> getSearchBeans()\n{\nList<DccdSB> searchBeans = new ArrayList<DccdSB>();\nif (!hasTridas())\nreturn searchBeans; \/\/ just an empty list\n\/\/ get all the ObjectEntity's in the tree\nList<Entity> entities = getSubTreeAsList();\nfor (Entity entity : entities)\n{\n\/\/ only objects, exclude derived series\nif (entity instanceof ObjectEntity)\n{\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\/\/ first with the project info, maybe this can be done more efficiently\n\/\/ because same conversions are done for every Object again\nsearchBean = fillSearchBean(searchBean);\n\/\/ then the object info\nsearchBean = entity.fillSearchBean(searchBean);\n\nList<DccdSB> searchBeans = new ArrayList<DccdSB>();\nif (!hasTridas())\nreturn searchBeans; \/\/ just an empty list\n\/\/ get all the ObjectEntity's in the tree\nList<Entity> entities = getSubTreeAsList();\nfor (Entity entity : entities)\n{\n\/\/ only objects, exclude derived series\nif (entity instanceof ObjectEntity)\n{\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\/\/ first with the project info, maybe this can be done more efficiently\n\/\/ because same conversions are done for every Object again\nsearchBean = fillSearchBean(searchBean);\n\/\/ then the object info\nsearchBean = entity.fillSearchBean(searchBean);\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\/\/ but not Objects?\nList<Entity> subentities = entity.getSubTreeAsList();\n\nreturn searchBeans; \/\/ just an empty list\n\/\/ get all the ObjectEntity's in the tree\nList<Entity> entities = getSubTreeAsList();\nfor (Entity entity : entities)\n{\n\/\/ only objects, exclude derived series\nif (entity instanceof ObjectEntity)\n{\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\/\/ first with the project info, maybe this can be done more efficiently\n\/\/ because same conversions are done for every Object again\nsearchBean = fillSearchBean(searchBean);\n\/\/ then the object info\nsearchBean = entity.fillSearchBean(searchBean);\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\/\/ but not Objects?\nList<Entity> subentities = entity.getSubTreeAsList();\nfor (Entity subentity : subentities)\n{\nsearchBean = subentity.fillSearchBean(searchBean);\n}\n\n{\n\/\/ only objects, exclude derived series\nif (entity instanceof ObjectEntity)\n{\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\/\/ first with the project info, maybe this can be done more efficiently\n\/\/ because same conversions are done for every Object again\nsearchBean = fillSearchBean(searchBean);\n\/\/ then the object info\nsearchBean = entity.fillSearchBean(searchBean);\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\/\/ but not Objects?\nList<Entity> subentities = entity.getSubTreeAsList();\nfor (Entity subentity : subentities)\n{\nsearchBean = subentity.fillSearchBean(searchBean);\n}\n\/\/ Note id should be the (system) identifier in the repository (sid)\n\/\/ just hoping that is is set correctly when read from the repository!!!\n\nif (entity instanceof ObjectEntity)\n{\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\/\/ first with the project info, maybe this can be done more efficiently\n\/\/ because same conversions are done for every Object again\nsearchBean = fillSearchBean(searchBean);\n\/\/ then the object info\nsearchBean = entity.fillSearchBean(searchBean);\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\/\/ but not Objects?\nList<Entity> subentities = entity.getSubTreeAsList();\nfor (Entity subentity : subentities)\n{\nsearchBean = subentity.fillSearchBean(searchBean);\n}\n\/\/ Note id should be the (system) identifier in the repository (sid)\n\/\/ just hoping that is is set correctly when read from the repository!!!\nsearchBean.setDatastreamId(entity.getId());\/\/ should be the repository id for this peace of info\n\/\/ add to the list\nsearchBeans.add(searchBean);\n\nsearchBean = fillSearchBean(searchBean);\n\/\/ then the object info\nsearchBean = entity.fillSearchBean(searchBean);\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\/\/ but not Objects?\nList<Entity> subentities = entity.getSubTreeAsList();\nfor (Entity subentity : subentities)\n{\nsearchBean = subentity.fillSearchBean(searchBean);\n}\n\/\/ Note id should be the (system) identifier in the repository (sid)\n\/\/ just hoping that is is set correctly when read from the repository!!!\nsearchBean.setDatastreamId(entity.getId());\/\/ should be the repository id for this peace of info\n\/\/ add to the list\nsearchBeans.add(searchBean);\n}\n}\nreturn searchBeans;\n}\n\nsearchBean = entity.fillSearchBean(searchBean);\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\/\/ but not Objects?\nList<Entity> subentities = entity.getSubTreeAsList();\nfor (Entity subentity : subentities)\n{\nsearchBean = subentity.fillSearchBean(searchBean);\n}\n\/\/ Note id should be the (system) identifier in the repository (sid)\n\/\/ just hoping that is is set correctly when read from the repository!!!\nsearchBean.setDatastreamId(entity.getId());\/\/ should be the repository id for this peace of info\n\/\/ add to the list\nsearchBeans.add(searchBean);\n}\n}\nreturn searchBeans;\n}\n\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\/\/ but not Objects?\nList<Entity> subentities = entity.getSubTreeAsList();\nfor (Entity subentity : subentities)\n{\nsearchBean = subentity.fillSearchBean(searchBean);\n}\n\/\/ Note id should be the (system) identifier in the repository (sid)\n\/\/ just hoping that is is set correctly when read from the repository!!!\nsearchBean.setDatastreamId(entity.getId());\/\/ should be the repository id for this peace of info\n\/\/ add to the list\nsearchBeans.add(searchBean);\n}\n}\nreturn searchBeans;\n}","code_context_20":"public List<DccdSB> getSearchBeans()\n{\nList<DccdSB> searchBeans = new ArrayList<DccdSB>();\nif (!hasTridas())\nreturn searchBeans; \/\/ just an empty list\n\/\/ get all the ObjectEntity's in the tree\nList<Entity> entities = getSubTreeAsList();\nfor (Entity entity : entities)\n{\n\/\/ only objects, exclude derived series\nif (entity instanceof ObjectEntity)\n{\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\/\/ first with the project info, maybe this can be done more efficiently\n\/\/ because same conversions are done for every Object again\nsearchBean = fillSearchBean(searchBean);\n\/\/ then the object info\nsearchBean = entity.fillSearchBean(searchBean);\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\/\/ but not Objects?\nList<Entity> subentities = entity.getSubTreeAsList();\nfor (Entity subentity : subentities)\n{\nsearchBean = subentity.fillSearchBean(searchBean);\n}\n\/\/ Note id should be the (system) identifier in the repository (sid)\n\/\/ just hoping that is is set correctly when read from the repository!!!\nsearchBean.setDatastreamId(entity.getId());\/\/ should be the repository id for this peace of info\n\/\/ add to the list\nsearchBeans.add(searchBean);\n}\n}\nreturn searchBeans;\n}\n\npublic List<DccdSB> getSearchBeans()\n{\nList<DccdSB> searchBeans = new ArrayList<DccdSB>();\nif (!hasTridas())\nreturn searchBeans; \/\/ just an empty list\n\/\/ get all the ObjectEntity's in the tree\nList<Entity> entities = getSubTreeAsList();\nfor (Entity entity : entities)\n{\n\/\/ only objects, exclude derived series\nif (entity instanceof ObjectEntity)\n{\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\/\/ first with the project info, maybe this can be done more efficiently\n\/\/ because same conversions are done for every Object again\nsearchBean = fillSearchBean(searchBean);\n\/\/ then the object info\nsearchBean = entity.fillSearchBean(searchBean);\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\/\/ but not Objects?\nList<Entity> subentities = entity.getSubTreeAsList();\nfor (Entity subentity : subentities)\n{\n\npublic List<DccdSB> getSearchBeans()\n{\nList<DccdSB> searchBeans = new ArrayList<DccdSB>();\nif (!hasTridas())\nreturn searchBeans; \/\/ just an empty list\n\/\/ get all the ObjectEntity's in the tree\nList<Entity> entities = getSubTreeAsList();\nfor (Entity entity : entities)\n{\n\/\/ only objects, exclude derived series\nif (entity instanceof ObjectEntity)\n{\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\/\/ first with the project info, maybe this can be done more efficiently\n\/\/ because same conversions are done for every Object again\nsearchBean = fillSearchBean(searchBean);\n\/\/ then the object info\nsearchBean = entity.fillSearchBean(searchBean);\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\/\/ but not Objects?\nList<Entity> subentities = entity.getSubTreeAsList();\nfor (Entity subentity : subentities)\n{\nsearchBean = subentity.fillSearchBean(searchBean);\n\npublic List<DccdSB> getSearchBeans()\n{\nList<DccdSB> searchBeans = new ArrayList<DccdSB>();\nif (!hasTridas())\nreturn searchBeans; \/\/ just an empty list\n\/\/ get all the ObjectEntity's in the tree\nList<Entity> entities = getSubTreeAsList();\nfor (Entity entity : entities)\n{\n\/\/ only objects, exclude derived series\nif (entity instanceof ObjectEntity)\n{\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\/\/ first with the project info, maybe this can be done more efficiently\n\/\/ because same conversions are done for every Object again\nsearchBean = fillSearchBean(searchBean);\n\/\/ then the object info\nsearchBean = entity.fillSearchBean(searchBean);\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\/\/ but not Objects?\nList<Entity> subentities = entity.getSubTreeAsList();\nfor (Entity subentity : subentities)\n{\nsearchBean = subentity.fillSearchBean(searchBean);\n}\n\/\/ Note id should be the (system) identifier in the repository (sid)\n\/\/ just hoping that is is set correctly when read from the repository!!!\nsearchBean.setDatastreamId(entity.getId());\/\/ should be the repository id for this peace of info\n\npublic List<DccdSB> getSearchBeans()\n{\nList<DccdSB> searchBeans = new ArrayList<DccdSB>();\nif (!hasTridas())\nreturn searchBeans; \/\/ just an empty list\n\/\/ get all the ObjectEntity's in the tree\nList<Entity> entities = getSubTreeAsList();\nfor (Entity entity : entities)\n{\n\/\/ only objects, exclude derived series\nif (entity instanceof ObjectEntity)\n{\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\/\/ first with the project info, maybe this can be done more efficiently\n\/\/ because same conversions are done for every Object again\nsearchBean = fillSearchBean(searchBean);\n\/\/ then the object info\nsearchBean = entity.fillSearchBean(searchBean);\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\/\/ but not Objects?\nList<Entity> subentities = entity.getSubTreeAsList();\nfor (Entity subentity : subentities)\n{\nsearchBean = subentity.fillSearchBean(searchBean);\n}\n\/\/ Note id should be the (system) identifier in the repository (sid)\n\/\/ just hoping that is is set correctly when read from the repository!!!\nsearchBean.setDatastreamId(entity.getId());\/\/ should be the repository id for this peace of info\n\/\/ add to the list\nsearchBeans.add(searchBean);\n}\n\npublic List<DccdSB> getSearchBeans()\n{\nList<DccdSB> searchBeans = new ArrayList<DccdSB>();\nif (!hasTridas())\nreturn searchBeans; \/\/ just an empty list\n\/\/ get all the ObjectEntity's in the tree\nList<Entity> entities = getSubTreeAsList();\nfor (Entity entity : entities)\n{\n\/\/ only objects, exclude derived series\nif (entity instanceof ObjectEntity)\n{\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\/\/ first with the project info, maybe this can be done more efficiently\n\/\/ because same conversions are done for every Object again\nsearchBean = fillSearchBean(searchBean);\n\/\/ then the object info\nsearchBean = entity.fillSearchBean(searchBean);\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\/\/ but not Objects?\nList<Entity> subentities = entity.getSubTreeAsList();\nfor (Entity subentity : subentities)\n{\nsearchBean = subentity.fillSearchBean(searchBean);\n}\n\/\/ Note id should be the (system) identifier in the repository (sid)\n\/\/ just hoping that is is set correctly when read from the repository!!!\nsearchBean.setDatastreamId(entity.getId());\/\/ should be the repository id for this peace of info\n\/\/ add to the list\nsearchBeans.add(searchBean);\n}\n}\nreturn searchBeans;\n}\n\npublic List<DccdSB> getSearchBeans()\n{\nList<DccdSB> searchBeans = new ArrayList<DccdSB>();\nif (!hasTridas())\nreturn searchBeans; \/\/ just an empty list\n\/\/ get all the ObjectEntity's in the tree\nList<Entity> entities = getSubTreeAsList();\nfor (Entity entity : entities)\n{\n\/\/ only objects, exclude derived series\nif (entity instanceof ObjectEntity)\n{\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\/\/ first with the project info, maybe this can be done more efficiently\n\/\/ because same conversions are done for every Object again\nsearchBean = fillSearchBean(searchBean);\n\/\/ then the object info\nsearchBean = entity.fillSearchBean(searchBean);\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\/\/ but not Objects?\nList<Entity> subentities = entity.getSubTreeAsList();\nfor (Entity subentity : subentities)\n{\nsearchBean = subentity.fillSearchBean(searchBean);\n}\n\/\/ Note id should be the (system) identifier in the repository (sid)\n\/\/ just hoping that is is set correctly when read from the repository!!!\nsearchBean.setDatastreamId(entity.getId());\/\/ should be the repository id for this peace of info\n\/\/ add to the list\nsearchBeans.add(searchBean);\n}\n}\nreturn searchBeans;\n}\n\npublic List<DccdSB> getSearchBeans()\n{\nList<DccdSB> searchBeans = new ArrayList<DccdSB>();\nif (!hasTridas())\nreturn searchBeans; \/\/ just an empty list\n\/\/ get all the ObjectEntity's in the tree\nList<Entity> entities = getSubTreeAsList();\nfor (Entity entity : entities)\n{\n\/\/ only objects, exclude derived series\nif (entity instanceof ObjectEntity)\n{\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\/\/ first with the project info, maybe this can be done more efficiently\n\/\/ because same conversions are done for every Object again\nsearchBean = fillSearchBean(searchBean);\n\/\/ then the object info\nsearchBean = entity.fillSearchBean(searchBean);\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\/\/ but not Objects?\nList<Entity> subentities = entity.getSubTreeAsList();\nfor (Entity subentity : subentities)\n{\nsearchBean = subentity.fillSearchBean(searchBean);\n}\n\/\/ Note id should be the (system) identifier in the repository (sid)\n\/\/ just hoping that is is set correctly when read from the repository!!!\nsearchBean.setDatastreamId(entity.getId());\/\/ should be the repository id for this peace of info\n\/\/ add to the list\nsearchBeans.add(searchBean);\n}\n}\nreturn searchBeans;\n}\n\nfor (Entity entity : entities)\n{\n\/\/ only objects, exclude derived series\nif (entity instanceof ObjectEntity)\n{\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\/\/ first with the project info, maybe this can be done more efficiently\n\/\/ because same conversions are done for every Object again\nsearchBean = fillSearchBean(searchBean);\n\/\/ then the object info\nsearchBean = entity.fillSearchBean(searchBean);\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\/\/ but not Objects?\nList<Entity> subentities = entity.getSubTreeAsList();\nfor (Entity subentity : subentities)\n{\nsearchBean = subentity.fillSearchBean(searchBean);\n}\n\/\/ Note id should be the (system) identifier in the repository (sid)\n\/\/ just hoping that is is set correctly when read from the repository!!!\nsearchBean.setDatastreamId(entity.getId());\/\/ should be the repository id for this peace of info\n\/\/ add to the list\nsearchBeans.add(searchBean);\n}\n}\nreturn searchBeans;\n}\n\n\/\/ only objects, exclude derived series\nif (entity instanceof ObjectEntity)\n{\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\/\/ first with the project info, maybe this can be done more efficiently\n\/\/ because same conversions are done for every Object again\nsearchBean = fillSearchBean(searchBean);\n\/\/ then the object info\nsearchBean = entity.fillSearchBean(searchBean);\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\/\/ but not Objects?\nList<Entity> subentities = entity.getSubTreeAsList();\nfor (Entity subentity : subentities)\n{\nsearchBean = subentity.fillSearchBean(searchBean);\n}\n\/\/ Note id should be the (system) identifier in the repository (sid)\n\/\/ just hoping that is is set correctly when read from the repository!!!\nsearchBean.setDatastreamId(entity.getId());\/\/ should be the repository id for this peace of info\n\/\/ add to the list\nsearchBeans.add(searchBean);\n}\n}\nreturn searchBeans;\n}\n\nif (entity instanceof ObjectEntity)\n{\n\/\/ create a bean\nDccdSB searchBean = new DccdObjectSB();\n\/\/ fill it\n\/\/ first with the project info, maybe this can be done more efficiently\n\/\/ because same conversions are done for every Object again\nsearchBean = fillSearchBean(searchBean);\n\/\/ then the object info\nsearchBean = entity.fillSearchBean(searchBean);\n\/\/ all the ObjectEntities subentities must fill this bean as well\n\/\/ but not Objects?\nList<Entity> subentities = entity.getSubTreeAsList();\nfor (Entity subentity : subentities)\n{\nsearchBean = subentity.fillSearchBean(searchBean);\n}\n\/\/ Note id should be the (system) identifier in the repository (sid)\n\/\/ just hoping that is is set correctly when read from the repository!!!\nsearchBean.setDatastreamId(entity.getId());\/\/ should be the repository id for this peace of info\n\/\/ add to the list\nsearchBeans.add(searchBean);\n}\n}\nreturn searchBeans;\n}","label":[1,0,0,0]}
{"id":22391,"original_code":"public Integer getLastmodifiedby() {\n    return this.lastmodifiedby;\n  }","code":"public Integer getLastmodifiedby() {\n    return this.lastmodifiedby;\n  }","cleancode":"public integer getlastmodifiedby() { return this.lastmodifiedby; }","comment":"\/\/ todo: fix how this is rendering in xml","repo":"PLOS\/named-entity.service","code_context_2":"public Integer getLastmodifiedby() {\nreturn this.lastmodifiedby;\n}","code_context_10":"public Integer getLastmodifiedby() {\nreturn this.lastmodifiedby;\n}","code_context_20":"public Integer getLastmodifiedby() {\nreturn this.lastmodifiedby;\n}","label":[0,0,1,0]}
{"id":22404,"original_code":"@Override\n    public Loader<Cursor> onCreateLoader(int id, Bundle args) {\n        \/\/TODO Need a fix to make sure the value is not null\n        String locationSetting = Utility.getPreferredLocation(getActivity());\n        \/\/Sort order: Ascending by date\n        String sortOrder = WeatherContract.WeatherEntry.COLUMN_DATE + \" ASC\";\n        \/\/Build the Uri needed for the query\n        Uri weatherForLocationUri = WeatherContract.WeatherEntry.buildWeatherLocationWithStartDate(locationSetting,\n                System.currentTimeMillis());\n        \/\/Create a cursor loader\n        CursorLoader cursorLoader = new CursorLoader(getActivity(),\n                weatherForLocationUri,\n                FORECAST_COLUMNS,\n                null,\n                null,\n                sortOrder);\n        return cursorLoader;\n    }","code":"@Override\n    public Loader<Cursor> onCreateLoader(int id, Bundle args) {\n       \n        String locationSetting = Utility.getPreferredLocation(getActivity());\n       \n        String sortOrder = WeatherContract.WeatherEntry.COLUMN_DATE + \" ASC\";\n       \n        Uri weatherForLocationUri = WeatherContract.WeatherEntry.buildWeatherLocationWithStartDate(locationSetting,\n                System.currentTimeMillis());\n       \n        CursorLoader cursorLoader = new CursorLoader(getActivity(),\n                weatherForLocationUri,\n                FORECAST_COLUMNS,\n                null,\n                null,\n                sortOrder);\n        return cursorLoader;\n    }","cleancode":"@override public loader<cursor> oncreateloader(int id, bundle args) { string locationsetting = utility.getpreferredlocation(getactivity()); string sortorder = weathercontract.weatherentry.column_date + \" asc\"; uri weatherforlocationuri = weathercontract.weatherentry.buildweatherlocationwithstartdate(locationsetting, system.currenttimemillis()); cursorloader cursorloader = new cursorloader(getactivity(), weatherforlocationuri, forecast_columns, null, null, sortorder); return cursorloader; }","comment":"\/\/todo need a fix to make sure the value is not null\n\/\/sort order: ascending by date\n\/\/build the uri needed for the query\n\/\/create a cursor loader","repo":"SafwanAhmad\/Sunshine-Version-2","code_context_2":"@Override\npublic Loader<Cursor> onCreateLoader(int id, Bundle args) {\n\/\/TODO Need a fix to make sure the value is not null\nString locationSetting = Utility.getPreferredLocation(getActivity());\n\/\/Sort order: Ascending by date\n\n\/\/TODO Need a fix to make sure the value is not null\nString locationSetting = Utility.getPreferredLocation(getActivity());\n\/\/Sort order: Ascending by date\nString sortOrder = WeatherContract.WeatherEntry.COLUMN_DATE + \" ASC\";\n\/\/Build the Uri needed for the query\n\n\/\/Sort order: Ascending by date\nString sortOrder = WeatherContract.WeatherEntry.COLUMN_DATE + \" ASC\";\n\/\/Build the Uri needed for the query\nUri weatherForLocationUri = WeatherContract.WeatherEntry.buildWeatherLocationWithStartDate(locationSetting,\nSystem.currentTimeMillis());\n\nUri weatherForLocationUri = WeatherContract.WeatherEntry.buildWeatherLocationWithStartDate(locationSetting,\nSystem.currentTimeMillis());\n\/\/Create a cursor loader\nCursorLoader cursorLoader = new CursorLoader(getActivity(),\nweatherForLocationUri,","code_context_10":"@Override\npublic Loader<Cursor> onCreateLoader(int id, Bundle args) {\n\/\/TODO Need a fix to make sure the value is not null\nString locationSetting = Utility.getPreferredLocation(getActivity());\n\/\/Sort order: Ascending by date\nString sortOrder = WeatherContract.WeatherEntry.COLUMN_DATE + \" ASC\";\n\/\/Build the Uri needed for the query\nUri weatherForLocationUri = WeatherContract.WeatherEntry.buildWeatherLocationWithStartDate(locationSetting,\nSystem.currentTimeMillis());\n\/\/Create a cursor loader\nCursorLoader cursorLoader = new CursorLoader(getActivity(),\nweatherForLocationUri,\nFORECAST_COLUMNS,\n\n@Override\npublic Loader<Cursor> onCreateLoader(int id, Bundle args) {\n\/\/TODO Need a fix to make sure the value is not null\nString locationSetting = Utility.getPreferredLocation(getActivity());\n\/\/Sort order: Ascending by date\nString sortOrder = WeatherContract.WeatherEntry.COLUMN_DATE + \" ASC\";\n\/\/Build the Uri needed for the query\nUri weatherForLocationUri = WeatherContract.WeatherEntry.buildWeatherLocationWithStartDate(locationSetting,\nSystem.currentTimeMillis());\n\/\/Create a cursor loader\nCursorLoader cursorLoader = new CursorLoader(getActivity(),\nweatherForLocationUri,\nFORECAST_COLUMNS,\nnull,\nnull,\n\n@Override\npublic Loader<Cursor> onCreateLoader(int id, Bundle args) {\n\/\/TODO Need a fix to make sure the value is not null\nString locationSetting = Utility.getPreferredLocation(getActivity());\n\/\/Sort order: Ascending by date\nString sortOrder = WeatherContract.WeatherEntry.COLUMN_DATE + \" ASC\";\n\/\/Build the Uri needed for the query\nUri weatherForLocationUri = WeatherContract.WeatherEntry.buildWeatherLocationWithStartDate(locationSetting,\nSystem.currentTimeMillis());\n\/\/Create a cursor loader\nCursorLoader cursorLoader = new CursorLoader(getActivity(),\nweatherForLocationUri,\nFORECAST_COLUMNS,\nnull,\nnull,\nsortOrder);\nreturn cursorLoader;\n\n@Override\npublic Loader<Cursor> onCreateLoader(int id, Bundle args) {\n\/\/TODO Need a fix to make sure the value is not null\nString locationSetting = Utility.getPreferredLocation(getActivity());\n\/\/Sort order: Ascending by date\nString sortOrder = WeatherContract.WeatherEntry.COLUMN_DATE + \" ASC\";\n\/\/Build the Uri needed for the query\nUri weatherForLocationUri = WeatherContract.WeatherEntry.buildWeatherLocationWithStartDate(locationSetting,\nSystem.currentTimeMillis());\n\/\/Create a cursor loader\nCursorLoader cursorLoader = new CursorLoader(getActivity(),\nweatherForLocationUri,\nFORECAST_COLUMNS,\nnull,\nnull,\nsortOrder);\nreturn cursorLoader;\n}","code_context_20":"@Override\npublic Loader<Cursor> onCreateLoader(int id, Bundle args) {\n\/\/TODO Need a fix to make sure the value is not null\nString locationSetting = Utility.getPreferredLocation(getActivity());\n\/\/Sort order: Ascending by date\nString sortOrder = WeatherContract.WeatherEntry.COLUMN_DATE + \" ASC\";\n\/\/Build the Uri needed for the query\nUri weatherForLocationUri = WeatherContract.WeatherEntry.buildWeatherLocationWithStartDate(locationSetting,\nSystem.currentTimeMillis());\n\/\/Create a cursor loader\nCursorLoader cursorLoader = new CursorLoader(getActivity(),\nweatherForLocationUri,\nFORECAST_COLUMNS,\nnull,\nnull,\nsortOrder);\nreturn cursorLoader;\n}\n\n@Override\npublic Loader<Cursor> onCreateLoader(int id, Bundle args) {\n\/\/TODO Need a fix to make sure the value is not null\nString locationSetting = Utility.getPreferredLocation(getActivity());\n\/\/Sort order: Ascending by date\nString sortOrder = WeatherContract.WeatherEntry.COLUMN_DATE + \" ASC\";\n\/\/Build the Uri needed for the query\nUri weatherForLocationUri = WeatherContract.WeatherEntry.buildWeatherLocationWithStartDate(locationSetting,\nSystem.currentTimeMillis());\n\/\/Create a cursor loader\nCursorLoader cursorLoader = new CursorLoader(getActivity(),\nweatherForLocationUri,\nFORECAST_COLUMNS,\nnull,\nnull,\nsortOrder);\nreturn cursorLoader;\n}\n\n@Override\npublic Loader<Cursor> onCreateLoader(int id, Bundle args) {\n\/\/TODO Need a fix to make sure the value is not null\nString locationSetting = Utility.getPreferredLocation(getActivity());\n\/\/Sort order: Ascending by date\nString sortOrder = WeatherContract.WeatherEntry.COLUMN_DATE + \" ASC\";\n\/\/Build the Uri needed for the query\nUri weatherForLocationUri = WeatherContract.WeatherEntry.buildWeatherLocationWithStartDate(locationSetting,\nSystem.currentTimeMillis());\n\/\/Create a cursor loader\nCursorLoader cursorLoader = new CursorLoader(getActivity(),\nweatherForLocationUri,\nFORECAST_COLUMNS,\nnull,\nnull,\nsortOrder);\nreturn cursorLoader;\n}\n\n@Override\npublic Loader<Cursor> onCreateLoader(int id, Bundle args) {\n\/\/TODO Need a fix to make sure the value is not null\nString locationSetting = Utility.getPreferredLocation(getActivity());\n\/\/Sort order: Ascending by date\nString sortOrder = WeatherContract.WeatherEntry.COLUMN_DATE + \" ASC\";\n\/\/Build the Uri needed for the query\nUri weatherForLocationUri = WeatherContract.WeatherEntry.buildWeatherLocationWithStartDate(locationSetting,\nSystem.currentTimeMillis());\n\/\/Create a cursor loader\nCursorLoader cursorLoader = new CursorLoader(getActivity(),\nweatherForLocationUri,\nFORECAST_COLUMNS,\nnull,\nnull,\nsortOrder);\nreturn cursorLoader;\n}","label":[0,0,1,0]}
{"id":22471,"original_code":"@Test\n\tpublic void inexistentItemTest() {\n\t\tString searchQuery = \"awobsafhtui5we5t57zuo77izufh\";\t\t\n\t\tSearchResultsPage searchQueryPage = startPage.getSearchComponent().searchFor(searchQuery);\n\t\tString searchQueryDisplayText = searchQueryPage.getItemSearchQuery();\n\t\tAssert.assertEquals(searchQueryDisplayText, searchQuery);\n\t\tint numResults = searchQueryPage.getResultCount();\n\t\tAssert.assertEquals(numResults, 0, \"Non-matching results were displayed.\");\n\t}","code":"@Test\n\tpublic void inexistentItemTest() {\n\t\tString searchQuery = \"awobsafhtui5we5t57zuo77izufh\";\t\t\n\t\tSearchResultsPage searchQueryPage = startPage.getSearchComponent().searchFor(searchQuery);\n\t\tString searchQueryDisplayText = searchQueryPage.getItemSearchQuery();\n\t\tAssert.assertEquals(searchQueryDisplayText, searchQuery);\n\t\tint numResults = searchQueryPage.getResultCount();\n\t\tAssert.assertEquals(numResults, 0, \"Non-matching results were displayed.\");\n\t}","cleancode":"@test public void inexistentitemtest() { string searchquery = \"awobsafhtui5we5t57zuo77izufh\"; searchresultspage searchquerypage = startpage.getsearchcomponent().searchfor(searchquery); string searchquerydisplaytext = searchquerypage.getitemsearchquery(); assert.assertequals(searchquerydisplaytext, searchquery); int numresults = searchquerypage.getresultcount(); assert.assertequals(numresults, 0, \"non-matching results were displayed.\"); }","comment":"\/\/fixme: create an item or a collection containing the special characters before searching for them","repo":"MPDL\/imeji-gui-testing","code_context_2":"@Test\npublic void inexistentItemTest() {\nString searchQuery = \"awobsafhtui5we5t57zuo77izufh\";\nSearchResultsPage searchQueryPage = startPage.getSearchComponent().searchFor(searchQuery);\nString searchQueryDisplayText = searchQueryPage.getItemSearchQuery();\nAssert.assertEquals(searchQueryDisplayText, searchQuery);\nint numResults = searchQueryPage.getResultCount();\nAssert.assertEquals(numResults, 0, \"Non-matching results were displayed.\");\n}","code_context_10":"@Test\npublic void inexistentItemTest() {\nString searchQuery = \"awobsafhtui5we5t57zuo77izufh\";\nSearchResultsPage searchQueryPage = startPage.getSearchComponent().searchFor(searchQuery);\nString searchQueryDisplayText = searchQueryPage.getItemSearchQuery();\nAssert.assertEquals(searchQueryDisplayText, searchQuery);\nint numResults = searchQueryPage.getResultCount();\nAssert.assertEquals(numResults, 0, \"Non-matching results were displayed.\");\n}","code_context_20":"@Test\npublic void inexistentItemTest() {\nString searchQuery = \"awobsafhtui5we5t57zuo77izufh\";\nSearchResultsPage searchQueryPage = startPage.getSearchComponent().searchFor(searchQuery);\nString searchQueryDisplayText = searchQueryPage.getItemSearchQuery();\nAssert.assertEquals(searchQueryDisplayText, searchQuery);\nint numResults = searchQueryPage.getResultCount();\nAssert.assertEquals(numResults, 0, \"Non-matching results were displayed.\");\n}","label":[0,1,0,0]}
{"id":30799,"original_code":"public final Node createView(OpenedFile file, String path) {\n        Node node = createView0(file, path);\n        node.getProperties().put(\"editor\", this);\n        node.getProperties().put(\"file\", file); \/\/ probably a memory leak\n        node.getProperties().put(\"path\", path);\n        return node;\n    }","code":"public final Node createView(OpenedFile file, String path) {\n        Node node = createView0(file, path);\n        node.getProperties().put(\"editor\", this);\n        node.getProperties().put(\"file\", file);\n        node.getProperties().put(\"path\", path);\n        return node;\n    }","cleancode":"public final node createview(openedfile file, string path) { node node = createview0(file, path); node.getproperties().put(\"editor\", this); node.getproperties().put(\"file\", file); node.getproperties().put(\"path\", path); return node; }","comment":"\/\/ probably a memory leak","repo":"MiniDigger\/standalone-app","code_context_2":"Node node = createView0(file, path);\nnode.getProperties().put(\"editor\", this);\nnode.getProperties().put(\"file\", file); \/\/ probably a memory leak\nnode.getProperties().put(\"path\", path);\nreturn node;","code_context_10":"public final Node createView(OpenedFile file, String path) {\nNode node = createView0(file, path);\nnode.getProperties().put(\"editor\", this);\nnode.getProperties().put(\"file\", file); \/\/ probably a memory leak\nnode.getProperties().put(\"path\", path);\nreturn node;\n}","code_context_20":"public final Node createView(OpenedFile file, String path) {\nNode node = createView0(file, path);\nnode.getProperties().put(\"editor\", this);\nnode.getProperties().put(\"file\", file); \/\/ probably a memory leak\nnode.getProperties().put(\"path\", path);\nreturn node;\n}","label":[0,0,1,0]}
{"id":30822,"original_code":"public void checkBookmarks() throws IOException {\n        for (Bookmark bookmark : bookmarksService.getBookmarks()) {\n            bookmarksService.doCheck(bookmark);\n            JavaFxUtils.getController(BookmarksController.class).bookmarksTableView.refresh();\n        }\n        JavaFxUtils.getController(BookmarksController.class).tableView.setUserData(null);\n        JavaFxUtils.getController(BookmarksController.class).webView.setUserData(null);\n        \/\/TODO refresh current bookmark if not SAME\n        if (currentBookmark != null\/* && JavaFxUtils.currentBookmark.getStatus() == BookmarkStatus.CHANGED*\/) {\n            JavaFxUtils.getController(BookmarksController.class).refresh();\n        }\n    }","code":"public void checkBookmarks() throws IOException {\n        for (Bookmark bookmark : bookmarksService.getBookmarks()) {\n            bookmarksService.doCheck(bookmark);\n            JavaFxUtils.getController(BookmarksController.class).bookmarksTableView.refresh();\n        }\n        JavaFxUtils.getController(BookmarksController.class).tableView.setUserData(null);\n        JavaFxUtils.getController(BookmarksController.class).webView.setUserData(null);\n       \n        if (currentBookmark != nul) {\n            JavaFxUtils.getController(BookmarksController.class).refresh();\n        }\n    }","cleancode":"public void checkbookmarks() throws ioexception { for (bookmark bookmark : bookmarksservice.getbookmarks()) { bookmarksservice.docheck(bookmark); javafxutils.getcontroller(bookmarkscontroller.class).bookmarkstableview.refresh(); } javafxutils.getcontroller(bookmarkscontroller.class).tableview.setuserdata(null); javafxutils.getcontroller(bookmarkscontroller.class).webview.setuserdata(null); if (currentbookmark != nul) { javafxutils.getcontroller(bookmarkscontroller.class).refresh(); } }","comment":"\/\/todo refresh current bookmark if not same\n\/* && javafxutils.currentbookmark.getstatus() == bookmarkstatus.changed*\/","repo":"LeonisX\/jSite-Watcher","code_context_2":"JavaFxUtils.getController(BookmarksController.class).tableView.setUserData(null);\nJavaFxUtils.getController(BookmarksController.class).webView.setUserData(null);\n\/\/TODO refresh current bookmark if not SAME\nif (currentBookmark != null\/* && JavaFxUtils.currentBookmark.getStatus() == BookmarkStatus.CHANGED*\/) {\nJavaFxUtils.getController(BookmarksController.class).refresh();\n\nJavaFxUtils.getController(BookmarksController.class).webView.setUserData(null);\n\/\/TODO refresh current bookmark if not SAME\nif (currentBookmark != null\/* && JavaFxUtils.currentBookmark.getStatus() == BookmarkStatus.CHANGED*\/) {\nJavaFxUtils.getController(BookmarksController.class).refresh();\n}","code_context_10":"public void checkBookmarks() throws IOException {\nfor (Bookmark bookmark : bookmarksService.getBookmarks()) {\nbookmarksService.doCheck(bookmark);\nJavaFxUtils.getController(BookmarksController.class).bookmarksTableView.refresh();\n}\nJavaFxUtils.getController(BookmarksController.class).tableView.setUserData(null);\nJavaFxUtils.getController(BookmarksController.class).webView.setUserData(null);\n\/\/TODO refresh current bookmark if not SAME\nif (currentBookmark != null\/* && JavaFxUtils.currentBookmark.getStatus() == BookmarkStatus.CHANGED*\/) {\nJavaFxUtils.getController(BookmarksController.class).refresh();\n}\n}\n\npublic void checkBookmarks() throws IOException {\nfor (Bookmark bookmark : bookmarksService.getBookmarks()) {\nbookmarksService.doCheck(bookmark);\nJavaFxUtils.getController(BookmarksController.class).bookmarksTableView.refresh();\n}\nJavaFxUtils.getController(BookmarksController.class).tableView.setUserData(null);\nJavaFxUtils.getController(BookmarksController.class).webView.setUserData(null);\n\/\/TODO refresh current bookmark if not SAME\nif (currentBookmark != null\/* && JavaFxUtils.currentBookmark.getStatus() == BookmarkStatus.CHANGED*\/) {\nJavaFxUtils.getController(BookmarksController.class).refresh();\n}\n}","code_context_20":"public void checkBookmarks() throws IOException {\nfor (Bookmark bookmark : bookmarksService.getBookmarks()) {\nbookmarksService.doCheck(bookmark);\nJavaFxUtils.getController(BookmarksController.class).bookmarksTableView.refresh();\n}\nJavaFxUtils.getController(BookmarksController.class).tableView.setUserData(null);\nJavaFxUtils.getController(BookmarksController.class).webView.setUserData(null);\n\/\/TODO refresh current bookmark if not SAME\nif (currentBookmark != null\/* && JavaFxUtils.currentBookmark.getStatus() == BookmarkStatus.CHANGED*\/) {\nJavaFxUtils.getController(BookmarksController.class).refresh();\n}\n}\n\npublic void checkBookmarks() throws IOException {\nfor (Bookmark bookmark : bookmarksService.getBookmarks()) {\nbookmarksService.doCheck(bookmark);\nJavaFxUtils.getController(BookmarksController.class).bookmarksTableView.refresh();\n}\nJavaFxUtils.getController(BookmarksController.class).tableView.setUserData(null);\nJavaFxUtils.getController(BookmarksController.class).webView.setUserData(null);\n\/\/TODO refresh current bookmark if not SAME\nif (currentBookmark != null\/* && JavaFxUtils.currentBookmark.getStatus() == BookmarkStatus.CHANGED*\/) {\nJavaFxUtils.getController(BookmarksController.class).refresh();\n}\n}","label":[0,1,0,0]}
{"id":22752,"original_code":"public void remove( )\n\t{\n\t\t\/\/ TODO Add remove operation support.\n\t}","code":"public void remove( )\n\t{\n\t\n\t}","cleancode":"public void remove( ) { }","comment":"\/* * (non-javadoc) * * @see java.util.iterator#remove() *\/\n\/\/ todo add remove operation support.","repo":"JamesCao2048\/BlizzardData","code_context_2":"public void remove( )\n{\n\/\/ TODO Add remove operation support.\n}\n\npublic void remove( )\n{\n\/\/ TODO Add remove operation support.\n}","code_context_10":"public void remove( )\n{\n\/\/ TODO Add remove operation support.\n}\n\npublic void remove( )\n{\n\/\/ TODO Add remove operation support.\n}","code_context_20":"public void remove( )\n{\n\/\/ TODO Add remove operation support.\n}\n\npublic void remove( )\n{\n\/\/ TODO Add remove operation support.\n}","label":[0,1,0,0]}
{"id":30989,"original_code":"public String longestPalindrome(String s) {\n        \/\/ TODO\uff1awrite your code here\n        return \"\";\n    }","code":"public String longestPalindrome(String s) {\n              return \"\";\n    }","cleancode":"public string longestpalindrome(string s) { return \"\"; }","comment":"\/** * @param s: input string * @return: the longest palindromic substring *\/\n\/\/ todo\uff1awrite your code here","repo":"MessierObject111\/algorithms-playground","code_context_2":"public String longestPalindrome(String s) {\n\/\/ TODO\uff1awrite your code here\nreturn \"\";\n}\n\npublic String longestPalindrome(String s) {\n\/\/ TODO\uff1awrite your code here\nreturn \"\";\n}","code_context_10":"public String longestPalindrome(String s) {\n\/\/ TODO\uff1awrite your code here\nreturn \"\";\n}\n\npublic String longestPalindrome(String s) {\n\/\/ TODO\uff1awrite your code here\nreturn \"\";\n}","code_context_20":"public String longestPalindrome(String s) {\n\/\/ TODO\uff1awrite your code here\nreturn \"\";\n}\n\npublic String longestPalindrome(String s) {\n\/\/ TODO\uff1awrite your code here\nreturn \"\";\n}","label":[0,1,0,0]}
{"id":30992,"original_code":"public File executeOptimization() throws IOException, InterruptedException {\n            final String path = workingFile.getCanonicalPath();\n            \/\/ FIXME Handle the ImageFileOptimizationException in one of the optimizations so it does not impact the other optimizations.\n            return executePngquant(executeOptipng(executePngout(executeAdvpng(executePngquant(executeOptipng(executePngout(executeAdvpng(workingFile, path), path), path), path), path), path), path), path);\n        }","code":"public File executeOptimization() throws IOException, InterruptedException {\n            final String path = workingFile.getCanonicalPath();\n           \n            return executePngquant(executeOptipng(executePngout(executeAdvpng(executePngquant(executeOptipng(executePngout(executeAdvpng(workingFile, path), path), path), path), path), path), path), path);\n        }","cleancode":"public file executeoptimization() throws ioexception, interruptedexception { final string path = workingfile.getcanonicalpath(); return executepngquant(executeoptipng(executepngout(executeadvpng(executepngquant(executeoptipng(executepngout(executeadvpng(workingfile, path), path), path), path), path), path), path), path); }","comment":"\/** * executes the pngout, optipng, and advpng optimization programs on the * working file passed into the constructor. * * @return the optimized file. * @throws ioexception if there was an issue reading \/ writing to the * file system * @throws interruptedexception if the optimization was interrupted. *\/\n\/\/ fixme handle the imagefileoptimizationexception in one of the optimizations so it does not impact the other optimizations.","repo":"MatthewJuliusScott\/ImageOptimization","code_context_2":"public File executeOptimization() throws IOException, InterruptedException {\nfinal String path = workingFile.getCanonicalPath();\n\/\/ FIXME Handle the ImageFileOptimizationException in one of the optimizations so it does not impact the other optimizations.\nreturn executePngquant(executeOptipng(executePngout(executeAdvpng(executePngquant(executeOptipng(executePngout(executeAdvpng(workingFile, path), path), path), path), path), path), path), path);\n}\n\npublic File executeOptimization() throws IOException, InterruptedException {\nfinal String path = workingFile.getCanonicalPath();\n\/\/ FIXME Handle the ImageFileOptimizationException in one of the optimizations so it does not impact the other optimizations.\nreturn executePngquant(executeOptipng(executePngout(executeAdvpng(executePngquant(executeOptipng(executePngout(executeAdvpng(workingFile, path), path), path), path), path), path), path), path);\n}","code_context_10":"public File executeOptimization() throws IOException, InterruptedException {\nfinal String path = workingFile.getCanonicalPath();\n\/\/ FIXME Handle the ImageFileOptimizationException in one of the optimizations so it does not impact the other optimizations.\nreturn executePngquant(executeOptipng(executePngout(executeAdvpng(executePngquant(executeOptipng(executePngout(executeAdvpng(workingFile, path), path), path), path), path), path), path), path);\n}\n\npublic File executeOptimization() throws IOException, InterruptedException {\nfinal String path = workingFile.getCanonicalPath();\n\/\/ FIXME Handle the ImageFileOptimizationException in one of the optimizations so it does not impact the other optimizations.\nreturn executePngquant(executeOptipng(executePngout(executeAdvpng(executePngquant(executeOptipng(executePngout(executeAdvpng(workingFile, path), path), path), path), path), path), path), path);\n}","code_context_20":"public File executeOptimization() throws IOException, InterruptedException {\nfinal String path = workingFile.getCanonicalPath();\n\/\/ FIXME Handle the ImageFileOptimizationException in one of the optimizations so it does not impact the other optimizations.\nreturn executePngquant(executeOptipng(executePngout(executeAdvpng(executePngquant(executeOptipng(executePngout(executeAdvpng(workingFile, path), path), path), path), path), path), path), path);\n}\n\npublic File executeOptimization() throws IOException, InterruptedException {\nfinal String path = workingFile.getCanonicalPath();\n\/\/ FIXME Handle the ImageFileOptimizationException in one of the optimizations so it does not impact the other optimizations.\nreturn executePngquant(executeOptipng(executePngout(executeAdvpng(executePngquant(executeOptipng(executePngout(executeAdvpng(workingFile, path), path), path), path), path), path), path), path);\n}","label":[1,0,0,0]}
{"id":23231,"original_code":"@Test\n  public void testValueOfJ() {\n    \/\/ workaround to register this test as covering some part of the testee.\n    \/\/ static variable access does not currently register as coverage . . .\n    HasMutableStaticInitializer.noticeMe();\n    assertEquals(101, HasMutableStaticInitializer.j);\n  }","code":"@Test\n  public void testValueOfJ() {\n   \n   \n    HasMutableStaticInitializer.noticeMe();\n    assertEquals(101, HasMutableStaticInitializer.j);\n  }","cleancode":"@test public void testvalueofj() { hasmutablestaticinitializer.noticeme(); assertequals(101, hasmutablestaticinitializer.j); }","comment":"\/\/ workaround to register this test as covering some part of the testee. \/\/ static variable access does not currently register as coverage . . .","repo":"Programming-Systems-Lab\/pitest","code_context_2":"@Test\npublic void testValueOfJ() {\n\/\/ workaround to register this test as covering some part of the testee.\n\/\/ static variable access does not currently register as coverage . . .\nHasMutableStaticInitializer.noticeMe();\nassertEquals(101, HasMutableStaticInitializer.j);","code_context_10":"@Test\npublic void testValueOfJ() {\n\/\/ workaround to register this test as covering some part of the testee.\n\/\/ static variable access does not currently register as coverage . . .\nHasMutableStaticInitializer.noticeMe();\nassertEquals(101, HasMutableStaticInitializer.j);\n}","code_context_20":"@Test\npublic void testValueOfJ() {\n\/\/ workaround to register this test as covering some part of the testee.\n\/\/ static variable access does not currently register as coverage . . .\nHasMutableStaticInitializer.noticeMe();\nassertEquals(101, HasMutableStaticInitializer.j);\n}","label":[0,1,0,0]}
{"id":31477,"original_code":"@Test\n  public void testLineOfCaller() {\n    assumeStackTraceDetailsAvailable();\n    DynamicConverter<ILoggingEvent> converter = new LineOfCallerConverter();\n    StringBuilder buf = new StringBuilder();\n    converter.write(buf, le);\n    \/\/ the number below should be the line number of the previous line\n    assertEquals(\"78\", buf.toString());\n    \/\/ TODO: Refactor this test so that it does not depend on the actual line numbers of this file\n  }","code":"@Test\n  public void testLineOfCaller() {\n    assumeStackTraceDetailsAvailable();\n    DynamicConverter<ILoggingEvent> converter = new LineOfCallerConverter();\n    StringBuilder buf = new StringBuilder();\n    converter.write(buf, le);\n   \n    assertEquals(\"78\", buf.toString());\n   \n  }","cleancode":"@test public void testlineofcaller() { assumestacktracedetailsavailable(); dynamicconverter<iloggingevent> converter = new lineofcallerconverter(); stringbuilder buf = new stringbuilder(); converter.write(buf, le); assertequals(\"78\", buf.tostring()); }","comment":"\/\/ the number below should be the line number of the previous line\n\/\/ todo: refactor this test so that it does not depend on the actual line numbers of this file","repo":"LinZong\/logback-android","code_context_2":"StringBuilder buf = new StringBuilder();\nconverter.write(buf, le);\n\/\/ the number below should be the line number of the previous line\nassertEquals(\"78\", buf.toString());\n\/\/ TODO: Refactor this test so that it does not depend on the actual line numbers of this file\n\n\/\/ the number below should be the line number of the previous line\nassertEquals(\"78\", buf.toString());\n\/\/ TODO: Refactor this test so that it does not depend on the actual line numbers of this file\n}","code_context_10":"@Test\npublic void testLineOfCaller() {\nassumeStackTraceDetailsAvailable();\nDynamicConverter<ILoggingEvent> converter = new LineOfCallerConverter();\nStringBuilder buf = new StringBuilder();\nconverter.write(buf, le);\n\/\/ the number below should be the line number of the previous line\nassertEquals(\"78\", buf.toString());\n\/\/ TODO: Refactor this test so that it does not depend on the actual line numbers of this file\n}\n\n@Test\npublic void testLineOfCaller() {\nassumeStackTraceDetailsAvailable();\nDynamicConverter<ILoggingEvent> converter = new LineOfCallerConverter();\nStringBuilder buf = new StringBuilder();\nconverter.write(buf, le);\n\/\/ the number below should be the line number of the previous line\nassertEquals(\"78\", buf.toString());\n\/\/ TODO: Refactor this test so that it does not depend on the actual line numbers of this file\n}","code_context_20":"@Test\npublic void testLineOfCaller() {\nassumeStackTraceDetailsAvailable();\nDynamicConverter<ILoggingEvent> converter = new LineOfCallerConverter();\nStringBuilder buf = new StringBuilder();\nconverter.write(buf, le);\n\/\/ the number below should be the line number of the previous line\nassertEquals(\"78\", buf.toString());\n\/\/ TODO: Refactor this test so that it does not depend on the actual line numbers of this file\n}\n\n@Test\npublic void testLineOfCaller() {\nassumeStackTraceDetailsAvailable();\nDynamicConverter<ILoggingEvent> converter = new LineOfCallerConverter();\nStringBuilder buf = new StringBuilder();\nconverter.write(buf, le);\n\/\/ the number below should be the line number of the previous line\nassertEquals(\"78\", buf.toString());\n\/\/ TODO: Refactor this test so that it does not depend on the actual line numbers of this file\n}","label":[0,0,0,1]}
{"id":23314,"original_code":"@Override\n    public void runOpMode() throws InterruptedException {\n\/*\n        Initialize the setDrivePowers system variables.  The init() methods of our hardware class\n        does all the work:\n         *\/\n        FtcDashboard dashboard = FtcDashboard.getInstance();\n        Telemetry dashboardTelemetry = dashboard.getTelemetry();\n        robot.init(hardwareMap, this, true, false);\n        \/*\n        Init Delay Option Select:\n        *\/\n        \/\/ After init is pushed but before Start we can change the delay using dpad up\/down \/\/\n        delayTimer.reset();\n        \/\/ Runs a loop to change certain settings while we wait to start\n        while (!opModeIsActive()) {\n            if (this.isStopRequested()) {\n                \/\/ Leave the loop if STOP is pressed\n                return;\n            }\n            if (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {\n                \/\/ Increases the amount of time we wait\n                timeDelay += 1;\n                delayTimer.reset();\n            }\n            if (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n                \/\/ Decreases the amount of time we wait\n                if (timeDelay > 0) {\n                    \/\/ No such thing as negative time\n                    timeDelay -= 1;\n                }\n                delayTimer.reset();\n            }\n            if (((gamepad1.x) && delayTimer.seconds() > 0.8)) {\n                \/\/ Changes Alliance Sides\n                if (isRedAlliance) {\n                    isRedAlliance = false;\n                    robot.isRedAlliance = false;\n                } else {\n                    isRedAlliance = true;\n                    robot.isRedAlliance = true;\n                }\n                delayTimer.reset();\n            }\n            \/**\n             * LED code:\n             *\/\n            if (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.NONE) {\n                robot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_LAVA_PALETTE);\n            }\n            if (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.ONE) {\n                robot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_OCEAN_PALETTE);\n            }\n            if (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.FOUR) {\n                robot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_PARTY_PALETTE);\n            }\n            \/**\n             * Telemetry while waiting for PLAY:\n             *\/\n            telemetry.addData(\"Delay Timer: \", timeDelay);\n            if (isRedAlliance) {\n                telemetry.addData(\"Alliance: \", \"Red\");\n            } else {\n                telemetry.addData(\"Alliance: \", \"Blue\");\n            }\n            telemetry.addData(\"Num of Rings\", \"%s\",robot.eyes.getNumRings().toString());\n            dashboardTelemetry.addData(\"Num of Rings\", \"%s\",robot.eyes.getNumRings().toString());\n            dashboardTelemetry.addData(\"Analysis\", \"%d\", robot.eyes.pipeline.getAnalysis());\n            dashboardTelemetry.update();\n            telemetry.update();\n            \/**\n             * We don't need a \"waitForStart()\" since we've been running our own\n             * loop all this time so that we can make some changes.\n             *\/\n        }\n        CatHW_Vision.UltimateGoalPipeline.numRings numRings = robot.eyes.getNumRings();\n        \/**\n         * Runs after hit start:\n         * DO STUFF FOR the OPMODE!!!\n         *\/\n        \/**\n         * Init the IMU after play so that it is not offset after\n         * remaining idle for a minute or two...\n         *\/\n        robot.driveClassic.IMU_Init();\n        \/\/ Time Delay:\n        robot.robotWait(timeDelay);\n        robot.driveOdo.quickDrive(-4,48,0.5, 0,3.0);\n        for (int i = 0; i < 5; i++) {\n            robot.robotWait(5);\n            Log.d(\"catbot\", String.format(\"Translate  Time wait    current %.2f %.2f %.1f \",\n                    robot.driveOdo.updatesThread.positionUpdate.returnXInches(),\n                    robot.driveOdo.updatesThread.positionUpdate.returnYInches(),\n                    robot.driveOdo.updatesThread.positionUpdate.returnOrientation()\n                    ));\n            robot.driveOdo.quickDrive( -4,96,0.8, 0,5.0);\n            robot.driveOdo.quickDrive(-52,96,0.8, 0,5.0);\n            robot.driveOdo.quickDrive(-52,48,0.8, 0,5.0);\n            robot.driveOdo.quickDrive( -4,48,0.8, 0,5.0);\n        }\n        \/*\n        for (int i = 0; i <= 5; i++) {\n            robot.robotWait(5);\n            robot.driveOdo.quickDrive( -4,96,0.3, -90,3.0);\n            robot.driveOdo.quickDrive(-52,96,0.3, 0,3.0);\n            robot.driveOdo.quickDrive(-52,48,0.3, 90,3.0);\n            robot.driveOdo.quickDrive( -4,48,0.3, 0,3.0);\n        }\n*\/\n        robot.driveOdo.updatesThread.stop();\n    }","code":"@Override\n    public void runOpMode() throws InterruptedException {\n        FtcDashboard dashboard = FtcDashboard.getInstance();\n        Telemetry dashboardTelemetry = dashboard.getTelemetry();\n        robot.init(hardwareMap, this, true, false);\n       \n       \n        delayTimer.reset();\n       \n        while (!opModeIsActive()) {\n            if (this.isStopRequested()) {\n               \n                return;\n            }\n            if (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {\n               \n                timeDelay += 1;\n                delayTimer.reset();\n            }\n            if (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n               \n                if (timeDelay > 0) {\n                   \n                    timeDelay -= 1;\n                }\n                delayTimer.reset();\n            }\n            if (((gamepad1.x) && delayTimer.seconds() > 0.8)) {\n               \n                if (isRedAlliance) {\n                    isRedAlliance = false;\n                    robot.isRedAlliance = false;\n                } else {\n                    isRedAlliance = true;\n                    robot.isRedAlliance = true;\n                }\n                delayTimer.reset();\n            }\n           \n            if (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.NONE) {\n                robot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_LAVA_PALETTE);\n            }\n            if (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.ONE) {\n                robot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_OCEAN_PALETTE);\n            }\n            if (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.FOUR) {\n                robot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_PARTY_PALETTE);\n            }\n           \n            telemetry.addData(\"Delay Timer: \", timeDelay);\n            if (isRedAlliance) {\n                telemetry.addData(\"Alliance: \", \"Red\");\n            } else {\n                telemetry.addData(\"Alliance: \", \"Blue\");\n            }\n            telemetry.addData(\"Num of Rings\", \"%s\",robot.eyes.getNumRings().toString());\n            dashboardTelemetry.addData(\"Num of Rings\", \"%s\",robot.eyes.getNumRings().toString());\n            dashboardTelemetry.addData(\"Analysis\", \"%d\", robot.eyes.pipeline.getAnalysis());\n            dashboardTelemetry.update();\n            telemetry.update();\n           \n        }\n        CatHW_Vision.UltimateGoalPipeline.numRings numRings = robot.eyes.getNumRings();\n       \n       \n        robot.driveClassic.IMU_Init();\n       \n        robot.robotWait(timeDelay);\n        robot.driveOdo.quickDrive(-4,48,0.5, 0,3.0);\n        for (int i = 0; i < 5; i++) {\n            robot.robotWait(5);\n            Log.d(\"catbot\", String.format(\"Translate  Time wait    current %.2f %.2f %.1f \",\n                    robot.driveOdo.updatesThread.positionUpdate.returnXInches(),\n                    robot.driveOdo.updatesThread.positionUpdate.returnYInches(),\n                    robot.driveOdo.updatesThread.positionUpdate.returnOrientation()\n                    ));\n            robot.driveOdo.quickDrive( -4,96,0.8, 0,5.0);\n            robot.driveOdo.quickDrive(-52,96,0.8, 0,5.0);\n            robot.driveOdo.quickDrive(-52,48,0.8, 0,5.0);\n            robot.driveOdo.quickDrive( -4,48,0.8, 0,5.0);\n        }\n       \n        robot.driveOdo.updatesThread.stop();\n    }","cleancode":"@override public void runopmode() throws interruptedexception { ftcdashboard dashboard = ftcdashboard.getinstance(); telemetry dashboardtelemetry = dashboard.gettelemetry(); robot.init(hardwaremap, this, true, false); delaytimer.reset(); while (!opmodeisactive()) { if (this.isstoprequested()) { return; } if (gamepad1.dpad_up && (delaytimer.seconds() > 0.8)) { timedelay += 1; delaytimer.reset(); } if (gamepad1.dpad_down && (delaytimer.seconds() > 0.8)) { if (timedelay > 0) { timedelay -= 1; } delaytimer.reset(); } if (((gamepad1.x) && delaytimer.seconds() > 0.8)) { if (isredalliance) { isredalliance = false; robot.isredalliance = false; } else { isredalliance = true; robot.isredalliance = true; } delaytimer.reset(); } if (robot.eyes.getnumrings() == cathw_vision.ultimategoalpipeline.numrings.none) { robot.lights.setdefaultcolor(revblinkinleddriver.blinkinpattern.rainbow_lava_palette); } if (robot.eyes.getnumrings() == cathw_vision.ultimategoalpipeline.numrings.one) { robot.lights.setdefaultcolor(revblinkinleddriver.blinkinpattern.rainbow_ocean_palette); } if (robot.eyes.getnumrings() == cathw_vision.ultimategoalpipeline.numrings.four) { robot.lights.setdefaultcolor(revblinkinleddriver.blinkinpattern.rainbow_party_palette); } telemetry.adddata(\"delay timer: \", timedelay); if (isredalliance) { telemetry.adddata(\"alliance: \", \"red\"); } else { telemetry.adddata(\"alliance: \", \"blue\"); } telemetry.adddata(\"num of rings\", \"%s\",robot.eyes.getnumrings().tostring()); dashboardtelemetry.adddata(\"num of rings\", \"%s\",robot.eyes.getnumrings().tostring()); dashboardtelemetry.adddata(\"analysis\", \"%d\", robot.eyes.pipeline.getanalysis()); dashboardtelemetry.update(); telemetry.update(); } cathw_vision.ultimategoalpipeline.numrings numrings = robot.eyes.getnumrings(); robot.driveclassic.imu_init(); robot.robotwait(timedelay); robot.driveodo.quickdrive(-4,48,0.5, 0,3.0); for (int i = 0; i < 5; i++) { robot.robotwait(5); log.d(\"catbot\", string.format(\"translate time wait current %.2f %.2f %.1f \", robot.driveodo.updatesthread.positionupdate.returnxinches(), robot.driveodo.updatesthread.positionupdate.returnyinches(), robot.driveodo.updatesthread.positionupdate.returnorientation() )); robot.driveodo.quickdrive( -4,96,0.8, 0,5.0); robot.driveodo.quickdrive(-52,96,0.8, 0,5.0); robot.driveodo.quickdrive(-52,48,0.8, 0,5.0); robot.driveodo.quickdrive( -4,48,0.8, 0,5.0); } robot.driveodo.updatesthread.stop(); }","comment":"\/* initialize the setdrivepowers system variables. the init() methods of our hardware class does all the work: *\/\n\/* init delay option select: *\/\n\/\/ after init is pushed but before start we can change the delay using dpad up\/down \/\/\n\/\/ runs a loop to change certain settings while we wait to start\n\/\/ leave the loop if stop is pressed\n\/\/ increases the amount of time we wait\n\/\/ decreases the amount of time we wait\n\/\/ no such thing as negative time\n\/\/ changes alliance sides\n\/** * led code: *\/\n\/** * telemetry while waiting for play: *\/\n\/** * we don't need a \"waitforstart()\" since we've been running our own * loop all this time so that we can make some changes. *\/\n\/** * runs after hit start: * do stuff for the opmode!!! *\/\n\/** * init the imu after play so that it is not offset after * remaining idle for a minute or two... *\/\n\/\/ time delay:\n\/* for (int i = 0; i <= 5; i++) { robot.robotwait(5); robot.driveodo.quickdrive( -4,96,0.3, -90,3.0); robot.driveodo.quickdrive(-52,96,0.3, 0,3.0); robot.driveodo.quickdrive(-52,48,0.3, 90,3.0); robot.driveodo.quickdrive( -4,48,0.3, 0,3.0); } *\/","repo":"PanzerSchnitter\/UltimateGoal2020","code_context_2":"@Override\npublic void runOpMode() throws InterruptedException {\n\/*\nInitialize the setDrivePowers system variables. The init() methods of our hardware class\ndoes all the work:\n*\/\nFtcDashboard dashboard = FtcDashboard.getInstance();\nTelemetry dashboardTelemetry = dashboard.getTelemetry();\n\n@Override\npublic void runOpMode() throws InterruptedException {\n\/*\nInitialize the setDrivePowers system variables. The init() methods of our hardware class\ndoes all the work:\n*\/\nFtcDashboard dashboard = FtcDashboard.getInstance();\n\nInit Delay Option Select:\n*\/\n\/\/ After init is pushed but before Start we can change the delay using dpad up\/down \/\/\ndelayTimer.reset();\n\/\/ Runs a loop to change certain settings while we wait to start\n\n\/\/ After init is pushed but before Start we can change the delay using dpad up\/down \/\/\ndelayTimer.reset();\n\/\/ Runs a loop to change certain settings while we wait to start\nwhile (!opModeIsActive()) {\nif (this.isStopRequested()) {\n\nwhile (!opModeIsActive()) {\nif (this.isStopRequested()) {\n\/\/ Leave the loop if STOP is pressed\nreturn;\n}\n\n}\nif (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {\n\/\/ Increases the amount of time we wait\ntimeDelay += 1;\ndelayTimer.reset();\n\n}\nif (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n\/\/ Decreases the amount of time we wait\nif (timeDelay > 0) {\n\/\/ No such thing as negative time\n\n\/\/ Decreases the amount of time we wait\nif (timeDelay > 0) {\n\/\/ No such thing as negative time\ntimeDelay -= 1;\n}\n\n}\nif (((gamepad1.x) && delayTimer.seconds() > 0.8)) {\n\/\/ Changes Alliance Sides\nif (isRedAlliance) {\nisRedAlliance = false;\n\ndelayTimer.reset();\n}\n\/**\n* LED code:\n*\/\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.NONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_LAVA_PALETTE);\n\ndelayTimer.reset();\n}\n\/**\n* LED code:\n*\/\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.NONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_LAVA_PALETTE);\n\ndelayTimer.reset();\n}\n\/**\n* LED code:\n*\/\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.NONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_LAVA_PALETTE);\n}\n\ndelayTimer.reset();\n}\n\/**\n* LED code:\n*\/\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.NONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_LAVA_PALETTE);\n}\n\ndelayTimer.reset();\n}\n\/**\n* LED code:\n*\/\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.NONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_LAVA_PALETTE);\n}\n\n*\/\nrobot.driveClassic.IMU_Init();\n\/\/ Time Delay:\nrobot.robotWait(timeDelay);\nrobot.driveOdo.quickDrive(-4,48,0.5, 0,3.0);\n\n@Override\npublic void runOpMode() throws InterruptedException {\n\/*\nInitialize the setDrivePowers system variables. The init() methods of our hardware class\ndoes all the work:\n*\/\nFtcDashboard dashboard = FtcDashboard.getInstance();\nTelemetry dashboardTelemetry = dashboard.getTelemetry();\nrobot.init(hardwareMap, this, true, false);\n\/*\nInit Delay Option Select:\n*\/\n\/\/ After init is pushed but before Start we can change the delay using dpad up\/down \/\/","code_context_10":"@Override\npublic void runOpMode() throws InterruptedException {\n\/*\nInitialize the setDrivePowers system variables. The init() methods of our hardware class\ndoes all the work:\n*\/\nFtcDashboard dashboard = FtcDashboard.getInstance();\nTelemetry dashboardTelemetry = dashboard.getTelemetry();\nrobot.init(hardwareMap, this, true, false);\n\/*\nInit Delay Option Select:\n*\/\n\/\/ After init is pushed but before Start we can change the delay using dpad up\/down \/\/\ndelayTimer.reset();\n\/\/ Runs a loop to change certain settings while we wait to start\nwhile (!opModeIsActive()) {\n\n@Override\npublic void runOpMode() throws InterruptedException {\n\/*\nInitialize the setDrivePowers system variables. The init() methods of our hardware class\ndoes all the work:\n*\/\nFtcDashboard dashboard = FtcDashboard.getInstance();\nTelemetry dashboardTelemetry = dashboard.getTelemetry();\nrobot.init(hardwareMap, this, true, false);\n\/*\nInit Delay Option Select:\n*\/\n\/\/ After init is pushed but before Start we can change the delay using dpad up\/down \/\/\ndelayTimer.reset();\n\/\/ Runs a loop to change certain settings while we wait to start\n\n\/*\nInitialize the setDrivePowers system variables. The init() methods of our hardware class\ndoes all the work:\n*\/\nFtcDashboard dashboard = FtcDashboard.getInstance();\nTelemetry dashboardTelemetry = dashboard.getTelemetry();\nrobot.init(hardwareMap, this, true, false);\n\/*\nInit Delay Option Select:\n*\/\n\/\/ After init is pushed but before Start we can change the delay using dpad up\/down \/\/\ndelayTimer.reset();\n\/\/ Runs a loop to change certain settings while we wait to start\nwhile (!opModeIsActive()) {\nif (this.isStopRequested()) {\n\/\/ Leave the loop if STOP is pressed\nreturn;\n}\nif (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {\n\/\/ Increases the amount of time we wait\ntimeDelay += 1;\n\ndoes all the work:\n*\/\nFtcDashboard dashboard = FtcDashboard.getInstance();\nTelemetry dashboardTelemetry = dashboard.getTelemetry();\nrobot.init(hardwareMap, this, true, false);\n\/*\nInit Delay Option Select:\n*\/\n\/\/ After init is pushed but before Start we can change the delay using dpad up\/down \/\/\ndelayTimer.reset();\n\/\/ Runs a loop to change certain settings while we wait to start\nwhile (!opModeIsActive()) {\nif (this.isStopRequested()) {\n\/\/ Leave the loop if STOP is pressed\nreturn;\n}\nif (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {\n\/\/ Increases the amount of time we wait\ntimeDelay += 1;\ndelayTimer.reset();\n}\n\nTelemetry dashboardTelemetry = dashboard.getTelemetry();\nrobot.init(hardwareMap, this, true, false);\n\/*\nInit Delay Option Select:\n*\/\n\/\/ After init is pushed but before Start we can change the delay using dpad up\/down \/\/\ndelayTimer.reset();\n\/\/ Runs a loop to change certain settings while we wait to start\nwhile (!opModeIsActive()) {\nif (this.isStopRequested()) {\n\/\/ Leave the loop if STOP is pressed\nreturn;\n}\nif (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {\n\/\/ Increases the amount of time we wait\ntimeDelay += 1;\ndelayTimer.reset();\n}\nif (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n\/\/ Decreases the amount of time we wait\nif (timeDelay > 0) {\n\n*\/\n\/\/ After init is pushed but before Start we can change the delay using dpad up\/down \/\/\ndelayTimer.reset();\n\/\/ Runs a loop to change certain settings while we wait to start\nwhile (!opModeIsActive()) {\nif (this.isStopRequested()) {\n\/\/ Leave the loop if STOP is pressed\nreturn;\n}\nif (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {\n\/\/ Increases the amount of time we wait\ntimeDelay += 1;\ndelayTimer.reset();\n}\nif (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n\/\/ Decreases the amount of time we wait\nif (timeDelay > 0) {\n\/\/ No such thing as negative time\ntimeDelay -= 1;\n}\ndelayTimer.reset();\n\nif (this.isStopRequested()) {\n\/\/ Leave the loop if STOP is pressed\nreturn;\n}\nif (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {\n\/\/ Increases the amount of time we wait\ntimeDelay += 1;\ndelayTimer.reset();\n}\nif (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n\/\/ Decreases the amount of time we wait\nif (timeDelay > 0) {\n\/\/ No such thing as negative time\ntimeDelay -= 1;\n}\ndelayTimer.reset();\n}\nif (((gamepad1.x) && delayTimer.seconds() > 0.8)) {\n\/\/ Changes Alliance Sides\nif (isRedAlliance) {\nisRedAlliance = false;\n\nreturn;\n}\nif (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {\n\/\/ Increases the amount of time we wait\ntimeDelay += 1;\ndelayTimer.reset();\n}\nif (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n\/\/ Decreases the amount of time we wait\nif (timeDelay > 0) {\n\/\/ No such thing as negative time\ntimeDelay -= 1;\n}\ndelayTimer.reset();\n}\nif (((gamepad1.x) && delayTimer.seconds() > 0.8)) {\n\/\/ Changes Alliance Sides\nif (isRedAlliance) {\nisRedAlliance = false;\nrobot.isRedAlliance = false;\n} else {\n\n}\nif (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n\/\/ Decreases the amount of time we wait\nif (timeDelay > 0) {\n\/\/ No such thing as negative time\ntimeDelay -= 1;\n}\ndelayTimer.reset();\n}\nif (((gamepad1.x) && delayTimer.seconds() > 0.8)) {\n\/\/ Changes Alliance Sides\nif (isRedAlliance) {\nisRedAlliance = false;\nrobot.isRedAlliance = false;\n} else {\nisRedAlliance = true;\nrobot.isRedAlliance = true;\n}\ndelayTimer.reset();\n}\n\/**\n\n\/\/ Changes Alliance Sides\nif (isRedAlliance) {\nisRedAlliance = false;\nrobot.isRedAlliance = false;\n} else {\nisRedAlliance = true;\nrobot.isRedAlliance = true;\n}\ndelayTimer.reset();\n}\n\/**\n* LED code:\n*\/\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.NONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_LAVA_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.ONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_OCEAN_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.FOUR) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_PARTY_PALETTE);\n}\n\/**\n\n\/\/ Changes Alliance Sides\nif (isRedAlliance) {\nisRedAlliance = false;\nrobot.isRedAlliance = false;\n} else {\nisRedAlliance = true;\nrobot.isRedAlliance = true;\n}\ndelayTimer.reset();\n}\n\/**\n* LED code:\n*\/\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.NONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_LAVA_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.ONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_OCEAN_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.FOUR) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_PARTY_PALETTE);\n}\n\/**\n\n\/\/ Changes Alliance Sides\nif (isRedAlliance) {\nisRedAlliance = false;\nrobot.isRedAlliance = false;\n} else {\nisRedAlliance = true;\nrobot.isRedAlliance = true;\n}\ndelayTimer.reset();\n}\n\/**\n* LED code:\n*\/\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.NONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_LAVA_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.ONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_OCEAN_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.FOUR) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_PARTY_PALETTE);\n}\n\/**\n* Telemetry while waiting for PLAY:\n\n\/\/ Changes Alliance Sides\nif (isRedAlliance) {\nisRedAlliance = false;\nrobot.isRedAlliance = false;\n} else {\nisRedAlliance = true;\nrobot.isRedAlliance = true;\n}\ndelayTimer.reset();\n}\n\/**\n* LED code:\n*\/\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.NONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_LAVA_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.ONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_OCEAN_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.FOUR) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_PARTY_PALETTE);\n}\n\/**\n* Telemetry while waiting for PLAY:\n\n\/\/ Changes Alliance Sides\nif (isRedAlliance) {\nisRedAlliance = false;\nrobot.isRedAlliance = false;\n} else {\nisRedAlliance = true;\nrobot.isRedAlliance = true;\n}\ndelayTimer.reset();\n}\n\/**\n* LED code:\n*\/\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.NONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_LAVA_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.ONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_OCEAN_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.FOUR) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_PARTY_PALETTE);\n}\n\/**\n* Telemetry while waiting for PLAY:\n\nCatHW_Vision.UltimateGoalPipeline.numRings numRings = robot.eyes.getNumRings();\n\/**\n* Runs after hit start:\n* DO STUFF FOR the OPMODE!!!\n*\/\n\/**\n* Init the IMU after play so that it is not offset after\n* remaining idle for a minute or two...\n*\/\nrobot.driveClassic.IMU_Init();\n\/\/ Time Delay:\nrobot.robotWait(timeDelay);\nrobot.driveOdo.quickDrive(-4,48,0.5, 0,3.0);\nfor (int i = 0; i < 5; i++) {\nrobot.robotWait(5);\nLog.d(\"catbot\", String.format(\"Translate Time wait current %.2f %.2f %.1f \",\nrobot.driveOdo.updatesThread.positionUpdate.returnXInches(),\nrobot.driveOdo.updatesThread.positionUpdate.returnYInches(),\nrobot.driveOdo.updatesThread.positionUpdate.returnOrientation()\n));\nrobot.driveOdo.quickDrive( -4,96,0.8, 0,5.0);\n\n@Override\npublic void runOpMode() throws InterruptedException {\n\/*\nInitialize the setDrivePowers system variables. The init() methods of our hardware class\ndoes all the work:\n*\/\nFtcDashboard dashboard = FtcDashboard.getInstance();\nTelemetry dashboardTelemetry = dashboard.getTelemetry();\nrobot.init(hardwareMap, this, true, false);\n\/*\nInit Delay Option Select:\n*\/\n\/\/ After init is pushed but before Start we can change the delay using dpad up\/down \/\/\ndelayTimer.reset();\n\/\/ Runs a loop to change certain settings while we wait to start\nwhile (!opModeIsActive()) {\nif (this.isStopRequested()) {\n\/\/ Leave the loop if STOP is pressed\nreturn;\n}\nif (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {","code_context_20":"@Override\npublic void runOpMode() throws InterruptedException {\n\/*\nInitialize the setDrivePowers system variables. The init() methods of our hardware class\ndoes all the work:\n*\/\nFtcDashboard dashboard = FtcDashboard.getInstance();\nTelemetry dashboardTelemetry = dashboard.getTelemetry();\nrobot.init(hardwareMap, this, true, false);\n\/*\nInit Delay Option Select:\n*\/\n\/\/ After init is pushed but before Start we can change the delay using dpad up\/down \/\/\ndelayTimer.reset();\n\/\/ Runs a loop to change certain settings while we wait to start\nwhile (!opModeIsActive()) {\nif (this.isStopRequested()) {\n\/\/ Leave the loop if STOP is pressed\nreturn;\n}\nif (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {\n\/\/ Increases the amount of time we wait\ntimeDelay += 1;\ndelayTimer.reset();\n}\nif (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n\n@Override\npublic void runOpMode() throws InterruptedException {\n\/*\nInitialize the setDrivePowers system variables. The init() methods of our hardware class\ndoes all the work:\n*\/\nFtcDashboard dashboard = FtcDashboard.getInstance();\nTelemetry dashboardTelemetry = dashboard.getTelemetry();\nrobot.init(hardwareMap, this, true, false);\n\/*\nInit Delay Option Select:\n*\/\n\/\/ After init is pushed but before Start we can change the delay using dpad up\/down \/\/\ndelayTimer.reset();\n\/\/ Runs a loop to change certain settings while we wait to start\nwhile (!opModeIsActive()) {\nif (this.isStopRequested()) {\n\/\/ Leave the loop if STOP is pressed\nreturn;\n}\nif (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {\n\/\/ Increases the amount of time we wait\ntimeDelay += 1;\ndelayTimer.reset();\n}\n\n@Override\npublic void runOpMode() throws InterruptedException {\n\/*\nInitialize the setDrivePowers system variables. The init() methods of our hardware class\ndoes all the work:\n*\/\nFtcDashboard dashboard = FtcDashboard.getInstance();\nTelemetry dashboardTelemetry = dashboard.getTelemetry();\nrobot.init(hardwareMap, this, true, false);\n\/*\nInit Delay Option Select:\n*\/\n\/\/ After init is pushed but before Start we can change the delay using dpad up\/down \/\/\ndelayTimer.reset();\n\/\/ Runs a loop to change certain settings while we wait to start\nwhile (!opModeIsActive()) {\nif (this.isStopRequested()) {\n\/\/ Leave the loop if STOP is pressed\nreturn;\n}\nif (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {\n\/\/ Increases the amount of time we wait\ntimeDelay += 1;\ndelayTimer.reset();\n}\nif (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n\/\/ Decreases the amount of time we wait\nif (timeDelay > 0) {\n\/\/ No such thing as negative time\ntimeDelay -= 1;\n}\ndelayTimer.reset();\n}\n\n@Override\npublic void runOpMode() throws InterruptedException {\n\/*\nInitialize the setDrivePowers system variables. The init() methods of our hardware class\ndoes all the work:\n*\/\nFtcDashboard dashboard = FtcDashboard.getInstance();\nTelemetry dashboardTelemetry = dashboard.getTelemetry();\nrobot.init(hardwareMap, this, true, false);\n\/*\nInit Delay Option Select:\n*\/\n\/\/ After init is pushed but before Start we can change the delay using dpad up\/down \/\/\ndelayTimer.reset();\n\/\/ Runs a loop to change certain settings while we wait to start\nwhile (!opModeIsActive()) {\nif (this.isStopRequested()) {\n\/\/ Leave the loop if STOP is pressed\nreturn;\n}\nif (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {\n\/\/ Increases the amount of time we wait\ntimeDelay += 1;\ndelayTimer.reset();\n}\nif (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n\/\/ Decreases the amount of time we wait\nif (timeDelay > 0) {\n\/\/ No such thing as negative time\ntimeDelay -= 1;\n}\ndelayTimer.reset();\n}\nif (((gamepad1.x) && delayTimer.seconds() > 0.8)) {\n\/\/ Changes Alliance Sides\n\n@Override\npublic void runOpMode() throws InterruptedException {\n\/*\nInitialize the setDrivePowers system variables. The init() methods of our hardware class\ndoes all the work:\n*\/\nFtcDashboard dashboard = FtcDashboard.getInstance();\nTelemetry dashboardTelemetry = dashboard.getTelemetry();\nrobot.init(hardwareMap, this, true, false);\n\/*\nInit Delay Option Select:\n*\/\n\/\/ After init is pushed but before Start we can change the delay using dpad up\/down \/\/\ndelayTimer.reset();\n\/\/ Runs a loop to change certain settings while we wait to start\nwhile (!opModeIsActive()) {\nif (this.isStopRequested()) {\n\/\/ Leave the loop if STOP is pressed\nreturn;\n}\nif (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {\n\/\/ Increases the amount of time we wait\ntimeDelay += 1;\ndelayTimer.reset();\n}\nif (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n\/\/ Decreases the amount of time we wait\nif (timeDelay > 0) {\n\/\/ No such thing as negative time\ntimeDelay -= 1;\n}\ndelayTimer.reset();\n}\nif (((gamepad1.x) && delayTimer.seconds() > 0.8)) {\n\/\/ Changes Alliance Sides\nif (isRedAlliance) {\nisRedAlliance = false;\nrobot.isRedAlliance = false;\n\npublic void runOpMode() throws InterruptedException {\n\/*\nInitialize the setDrivePowers system variables. The init() methods of our hardware class\ndoes all the work:\n*\/\nFtcDashboard dashboard = FtcDashboard.getInstance();\nTelemetry dashboardTelemetry = dashboard.getTelemetry();\nrobot.init(hardwareMap, this, true, false);\n\/*\nInit Delay Option Select:\n*\/\n\/\/ After init is pushed but before Start we can change the delay using dpad up\/down \/\/\ndelayTimer.reset();\n\/\/ Runs a loop to change certain settings while we wait to start\nwhile (!opModeIsActive()) {\nif (this.isStopRequested()) {\n\/\/ Leave the loop if STOP is pressed\nreturn;\n}\nif (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {\n\/\/ Increases the amount of time we wait\ntimeDelay += 1;\ndelayTimer.reset();\n}\nif (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n\/\/ Decreases the amount of time we wait\nif (timeDelay > 0) {\n\/\/ No such thing as negative time\ntimeDelay -= 1;\n}\ndelayTimer.reset();\n}\nif (((gamepad1.x) && delayTimer.seconds() > 0.8)) {\n\/\/ Changes Alliance Sides\nif (isRedAlliance) {\nisRedAlliance = false;\nrobot.isRedAlliance = false;\n} else {\nisRedAlliance = true;\nrobot.isRedAlliance = true;\n}\n\nFtcDashboard dashboard = FtcDashboard.getInstance();\nTelemetry dashboardTelemetry = dashboard.getTelemetry();\nrobot.init(hardwareMap, this, true, false);\n\/*\nInit Delay Option Select:\n*\/\n\/\/ After init is pushed but before Start we can change the delay using dpad up\/down \/\/\ndelayTimer.reset();\n\/\/ Runs a loop to change certain settings while we wait to start\nwhile (!opModeIsActive()) {\nif (this.isStopRequested()) {\n\/\/ Leave the loop if STOP is pressed\nreturn;\n}\nif (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {\n\/\/ Increases the amount of time we wait\ntimeDelay += 1;\ndelayTimer.reset();\n}\nif (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n\/\/ Decreases the amount of time we wait\nif (timeDelay > 0) {\n\/\/ No such thing as negative time\ntimeDelay -= 1;\n}\ndelayTimer.reset();\n}\nif (((gamepad1.x) && delayTimer.seconds() > 0.8)) {\n\/\/ Changes Alliance Sides\nif (isRedAlliance) {\nisRedAlliance = false;\nrobot.isRedAlliance = false;\n} else {\nisRedAlliance = true;\nrobot.isRedAlliance = true;\n}\ndelayTimer.reset();\n}\n\/**\n* LED code:\n*\/\n\nrobot.init(hardwareMap, this, true, false);\n\/*\nInit Delay Option Select:\n*\/\n\/\/ After init is pushed but before Start we can change the delay using dpad up\/down \/\/\ndelayTimer.reset();\n\/\/ Runs a loop to change certain settings while we wait to start\nwhile (!opModeIsActive()) {\nif (this.isStopRequested()) {\n\/\/ Leave the loop if STOP is pressed\nreturn;\n}\nif (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {\n\/\/ Increases the amount of time we wait\ntimeDelay += 1;\ndelayTimer.reset();\n}\nif (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n\/\/ Decreases the amount of time we wait\nif (timeDelay > 0) {\n\/\/ No such thing as negative time\ntimeDelay -= 1;\n}\ndelayTimer.reset();\n}\nif (((gamepad1.x) && delayTimer.seconds() > 0.8)) {\n\/\/ Changes Alliance Sides\nif (isRedAlliance) {\nisRedAlliance = false;\nrobot.isRedAlliance = false;\n} else {\nisRedAlliance = true;\nrobot.isRedAlliance = true;\n}\ndelayTimer.reset();\n}\n\/**\n* LED code:\n*\/\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.NONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_LAVA_PALETTE);\n\n\/\/ Runs a loop to change certain settings while we wait to start\nwhile (!opModeIsActive()) {\nif (this.isStopRequested()) {\n\/\/ Leave the loop if STOP is pressed\nreturn;\n}\nif (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {\n\/\/ Increases the amount of time we wait\ntimeDelay += 1;\ndelayTimer.reset();\n}\nif (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n\/\/ Decreases the amount of time we wait\nif (timeDelay > 0) {\n\/\/ No such thing as negative time\ntimeDelay -= 1;\n}\ndelayTimer.reset();\n}\nif (((gamepad1.x) && delayTimer.seconds() > 0.8)) {\n\/\/ Changes Alliance Sides\nif (isRedAlliance) {\nisRedAlliance = false;\nrobot.isRedAlliance = false;\n} else {\nisRedAlliance = true;\nrobot.isRedAlliance = true;\n}\ndelayTimer.reset();\n}\n\/**\n* LED code:\n*\/\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.NONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_LAVA_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.ONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_OCEAN_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.FOUR) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_PARTY_PALETTE);\n\n}\nif (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n\/\/ Decreases the amount of time we wait\nif (timeDelay > 0) {\n\/\/ No such thing as negative time\ntimeDelay -= 1;\n}\ndelayTimer.reset();\n}\nif (((gamepad1.x) && delayTimer.seconds() > 0.8)) {\n\/\/ Changes Alliance Sides\nif (isRedAlliance) {\nisRedAlliance = false;\nrobot.isRedAlliance = false;\n} else {\nisRedAlliance = true;\nrobot.isRedAlliance = true;\n}\ndelayTimer.reset();\n}\n\/**\n* LED code:\n*\/\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.NONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_LAVA_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.ONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_OCEAN_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.FOUR) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_PARTY_PALETTE);\n}\n\/**\n* Telemetry while waiting for PLAY:\n*\/\ntelemetry.addData(\"Delay Timer: \", timeDelay);\nif (isRedAlliance) {\ntelemetry.addData(\"Alliance: \", \"Red\");\n} else {\ntelemetry.addData(\"Alliance: \", \"Blue\");\n}\ntelemetry.addData(\"Num of Rings\", \"%s\",robot.eyes.getNumRings().toString());\ndashboardTelemetry.addData(\"Num of Rings\", \"%s\",robot.eyes.getNumRings().toString());\n\n}\nif (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n\/\/ Decreases the amount of time we wait\nif (timeDelay > 0) {\n\/\/ No such thing as negative time\ntimeDelay -= 1;\n}\ndelayTimer.reset();\n}\nif (((gamepad1.x) && delayTimer.seconds() > 0.8)) {\n\/\/ Changes Alliance Sides\nif (isRedAlliance) {\nisRedAlliance = false;\nrobot.isRedAlliance = false;\n} else {\nisRedAlliance = true;\nrobot.isRedAlliance = true;\n}\ndelayTimer.reset();\n}\n\/**\n* LED code:\n*\/\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.NONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_LAVA_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.ONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_OCEAN_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.FOUR) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_PARTY_PALETTE);\n}\n\/**\n* Telemetry while waiting for PLAY:\n*\/\ntelemetry.addData(\"Delay Timer: \", timeDelay);\nif (isRedAlliance) {\ntelemetry.addData(\"Alliance: \", \"Red\");\n} else {\ntelemetry.addData(\"Alliance: \", \"Blue\");\n}\ntelemetry.addData(\"Num of Rings\", \"%s\",robot.eyes.getNumRings().toString());\ndashboardTelemetry.addData(\"Num of Rings\", \"%s\",robot.eyes.getNumRings().toString());\n\n}\nif (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n\/\/ Decreases the amount of time we wait\nif (timeDelay > 0) {\n\/\/ No such thing as negative time\ntimeDelay -= 1;\n}\ndelayTimer.reset();\n}\nif (((gamepad1.x) && delayTimer.seconds() > 0.8)) {\n\/\/ Changes Alliance Sides\nif (isRedAlliance) {\nisRedAlliance = false;\nrobot.isRedAlliance = false;\n} else {\nisRedAlliance = true;\nrobot.isRedAlliance = true;\n}\ndelayTimer.reset();\n}\n\/**\n* LED code:\n*\/\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.NONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_LAVA_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.ONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_OCEAN_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.FOUR) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_PARTY_PALETTE);\n}\n\/**\n* Telemetry while waiting for PLAY:\n*\/\ntelemetry.addData(\"Delay Timer: \", timeDelay);\nif (isRedAlliance) {\ntelemetry.addData(\"Alliance: \", \"Red\");\n} else {\ntelemetry.addData(\"Alliance: \", \"Blue\");\n}\ntelemetry.addData(\"Num of Rings\", \"%s\",robot.eyes.getNumRings().toString());\ndashboardTelemetry.addData(\"Num of Rings\", \"%s\",robot.eyes.getNumRings().toString());\ndashboardTelemetry.addData(\"Analysis\", \"%d\", robot.eyes.pipeline.getAnalysis());\n\n}\nif (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n\/\/ Decreases the amount of time we wait\nif (timeDelay > 0) {\n\/\/ No such thing as negative time\ntimeDelay -= 1;\n}\ndelayTimer.reset();\n}\nif (((gamepad1.x) && delayTimer.seconds() > 0.8)) {\n\/\/ Changes Alliance Sides\nif (isRedAlliance) {\nisRedAlliance = false;\nrobot.isRedAlliance = false;\n} else {\nisRedAlliance = true;\nrobot.isRedAlliance = true;\n}\ndelayTimer.reset();\n}\n\/**\n* LED code:\n*\/\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.NONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_LAVA_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.ONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_OCEAN_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.FOUR) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_PARTY_PALETTE);\n}\n\/**\n* Telemetry while waiting for PLAY:\n*\/\ntelemetry.addData(\"Delay Timer: \", timeDelay);\nif (isRedAlliance) {\ntelemetry.addData(\"Alliance: \", \"Red\");\n} else {\ntelemetry.addData(\"Alliance: \", \"Blue\");\n}\ntelemetry.addData(\"Num of Rings\", \"%s\",robot.eyes.getNumRings().toString());\ndashboardTelemetry.addData(\"Num of Rings\", \"%s\",robot.eyes.getNumRings().toString());\ndashboardTelemetry.addData(\"Analysis\", \"%d\", robot.eyes.pipeline.getAnalysis());\n\n}\nif (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n\/\/ Decreases the amount of time we wait\nif (timeDelay > 0) {\n\/\/ No such thing as negative time\ntimeDelay -= 1;\n}\ndelayTimer.reset();\n}\nif (((gamepad1.x) && delayTimer.seconds() > 0.8)) {\n\/\/ Changes Alliance Sides\nif (isRedAlliance) {\nisRedAlliance = false;\nrobot.isRedAlliance = false;\n} else {\nisRedAlliance = true;\nrobot.isRedAlliance = true;\n}\ndelayTimer.reset();\n}\n\/**\n* LED code:\n*\/\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.NONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_LAVA_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.ONE) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_OCEAN_PALETTE);\n}\nif (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.FOUR) {\nrobot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_PARTY_PALETTE);\n}\n\/**\n* Telemetry while waiting for PLAY:\n*\/\ntelemetry.addData(\"Delay Timer: \", timeDelay);\nif (isRedAlliance) {\ntelemetry.addData(\"Alliance: \", \"Red\");\n} else {\ntelemetry.addData(\"Alliance: \", \"Blue\");\n}\ntelemetry.addData(\"Num of Rings\", \"%s\",robot.eyes.getNumRings().toString());\ndashboardTelemetry.addData(\"Num of Rings\", \"%s\",robot.eyes.getNumRings().toString());\ndashboardTelemetry.addData(\"Analysis\", \"%d\", robot.eyes.pipeline.getAnalysis());\n\ntelemetry.addData(\"Num of Rings\", \"%s\",robot.eyes.getNumRings().toString());\ndashboardTelemetry.addData(\"Num of Rings\", \"%s\",robot.eyes.getNumRings().toString());\ndashboardTelemetry.addData(\"Analysis\", \"%d\", robot.eyes.pipeline.getAnalysis());\ndashboardTelemetry.update();\ntelemetry.update();\n\/**\n* We don't need a \"waitForStart()\" since we've been running our own\n* loop all this time so that we can make some changes.\n*\/\n}\nCatHW_Vision.UltimateGoalPipeline.numRings numRings = robot.eyes.getNumRings();\n\/**\n* Runs after hit start:\n* DO STUFF FOR the OPMODE!!!\n*\/\n\/**\n* Init the IMU after play so that it is not offset after\n* remaining idle for a minute or two...\n*\/\nrobot.driveClassic.IMU_Init();\n\/\/ Time Delay:\nrobot.robotWait(timeDelay);\nrobot.driveOdo.quickDrive(-4,48,0.5, 0,3.0);\nfor (int i = 0; i < 5; i++) {\nrobot.robotWait(5);\nLog.d(\"catbot\", String.format(\"Translate Time wait current %.2f %.2f %.1f \",\nrobot.driveOdo.updatesThread.positionUpdate.returnXInches(),\nrobot.driveOdo.updatesThread.positionUpdate.returnYInches(),\nrobot.driveOdo.updatesThread.positionUpdate.returnOrientation()\n));\nrobot.driveOdo.quickDrive( -4,96,0.8, 0,5.0);\nrobot.driveOdo.quickDrive(-52,96,0.8, 0,5.0);\nrobot.driveOdo.quickDrive(-52,48,0.8, 0,5.0);\nrobot.driveOdo.quickDrive( -4,48,0.8, 0,5.0);\n}\n\/*\nfor (int i = 0; i <= 5; i++) {\nrobot.robotWait(5);\nrobot.driveOdo.quickDrive( -4,96,0.3, -90,3.0);\nrobot.driveOdo.quickDrive(-52,96,0.3, 0,3.0);\nrobot.driveOdo.quickDrive(-52,48,0.3, 90,3.0);\n\n@Override\npublic void runOpMode() throws InterruptedException {\n\/*\nInitialize the setDrivePowers system variables. The init() methods of our hardware class\ndoes all the work:\n*\/\nFtcDashboard dashboard = FtcDashboard.getInstance();\nTelemetry dashboardTelemetry = dashboard.getTelemetry();\nrobot.init(hardwareMap, this, true, false);\n\/*\nInit Delay Option Select:\n*\/\n\/\/ After init is pushed but before Start we can change the delay using dpad up\/down \/\/\ndelayTimer.reset();\n\/\/ Runs a loop to change certain settings while we wait to start\nwhile (!opModeIsActive()) {\nif (this.isStopRequested()) {\n\/\/ Leave the loop if STOP is pressed\nreturn;\n}\nif (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {\n\/\/ Increases the amount of time we wait\ntimeDelay += 1;\ndelayTimer.reset();\n}\nif (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n\/\/ Decreases the amount of time we wait\nif (timeDelay > 0) {\n\/\/ No such thing as negative time\ntimeDelay -= 1;\n}","label":[0,0,0,0]}
{"id":15126,"original_code":"private void clanList(L2PcInstance activeChar, int index)\n\t{\n\t\tif (index < 1)\n\t\t{\n\t\t\tindex = 1;\n\t\t}\n\t\t\/\/ header\n\t\tfinal StringBuilder html = StringUtil.startAppend(2000, \"<html><body><br><br><center><br1><br1><table border=0 cellspacing=0 cellpadding=0><tr><td FIXWIDTH=15>&nbsp;<\/td><td width=610 height=30 align=left><a action=\\\"bypass _bbsclan_clanlist\\\"> CLAN COMMUNITY <\/a><\/td><\/tr><\/table><table border=0 cellspacing=0 cellpadding=0 width=610 bgcolor=434343><tr><td height=10><\/td><\/tr><tr><td fixWIDTH=5><\/td><td fixWIDTH=600><a action=\\\"bypass _bbsclan_clanhome;\", String.valueOf((activeChar.getClan() != null) ? activeChar.getClan().getId() : 0), \"\\\">[GO TO MY CLAN]<\/a>&nbsp;&nbsp;<\/td><td fixWIDTH=5><\/td><\/tr><tr><td height=10><\/td><\/tr><\/table><br><table border=0 cellspacing=0 cellpadding=2 bgcolor=5A5A5A width=610><tr><td FIXWIDTH=5><\/td><td FIXWIDTH=200 align=center>CLAN NAME<\/td><td FIXWIDTH=200 align=center>CLAN LEADER<\/td><td FIXWIDTH=100 align=center>CLAN LEVEL<\/td><td FIXWIDTH=100 align=center>CLAN MEMBERS<\/td><td FIXWIDTH=5><\/td><\/tr><\/table><img src=\\\"L2UI.Squareblank\\\" width=\\\"1\\\" height=\\\"5\\\">\");\n\t\tint i = 0;\n\t\tfor (L2Clan cl : ClanTable.getInstance().getClans())\n\t\t{\n\t\t\tif (i > ((index + 1) * 7))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i++ >= ((index - 1) * 7))\n\t\t\t{\n\t\t\t\tStringUtil.append(html, \"<img src=\\\"L2UI.SquareBlank\\\" width=\\\"610\\\" height=\\\"3\\\"><table border=0 cellspacing=0 cellpadding=0 width=610><tr> <td FIXWIDTH=5><\/td><td FIXWIDTH=200 align=center><a action=\\\"bypass _bbsclan_clanhome;\", String.valueOf(cl.getId()), \"\\\">\", cl.getName(), \"<\/a><\/td><td FIXWIDTH=200 align=center>\", cl.getLeaderName(), \"<\/td><td FIXWIDTH=100 align=center>\", String.valueOf(cl.getLevel()), \"<\/td><td FIXWIDTH=100 align=center>\", String.valueOf(cl.getMembersCount()), \"<\/td><td FIXWIDTH=5><\/td><\/tr><tr><td height=5><\/td><\/tr><\/table><img src=\\\"L2UI.SquareBlank\\\" width=\\\"610\\\" height=\\\"3\\\"><img src=\\\"L2UI.SquareGray\\\" width=\\\"610\\\" height=\\\"1\\\">\");\n\t\t\t}\n\t\t}\n\t\thtml.append(\"<img src=\\\"L2UI.SquareBlank\\\" width=\\\"610\\\" height=\\\"2\\\"><table cellpadding=0 cellspacing=2 border=0><tr>\");\n\t\tif (index == 1)\n\t\t{\n\t\t\thtml.append(\"<td><button action=\\\"\\\" back=\\\"l2ui_ch3.prev1_down\\\" fore=\\\"l2ui_ch3.prev1\\\" width=16 height=16 ><\/td>\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStringUtil.append(html, \"<td><button action=\\\"_bbsclan_clanlist;\", String.valueOf(index - 1), \"\\\" back=\\\"l2ui_ch3.prev1_down\\\" fore=\\\"l2ui_ch3.prev1\\\" width=16 height=16 ><\/td>\");\n\t\t}\n\t\ti = 0;\n\t\tint nbp = ClanTable.getInstance().getClanCount() \/ 8;\n\t\tif ((nbp * 8) != ClanTable.getInstance().getClanCount())\n\t\t{\n\t\t\tnbp++;\n\t\t}\n\t\tfor (i = 1; i <= nbp; i++)\n\t\t{\n\t\t\tif (i == index)\n\t\t\t{\n\t\t\t\tStringUtil.append(html, \"<td> \", String.valueOf(i), \" <\/td>\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tStringUtil.append(html, \"<td><a action=\\\"bypass _bbsclan_clanlist;\", String.valueOf(i), \"\\\"> \", String.valueOf(i), \" <\/a><\/td>\");\n\t\t\t}\n\t\t}\n\t\tif (index == nbp)\n\t\t{\n\t\t\thtml.append(\"<td><button action=\\\"\\\" back=\\\"l2ui_ch3.next1_down\\\" fore=\\\"l2ui_ch3.next1\\\" width=16 height=16 ><\/td>\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStringUtil.append(html, \"<td><button action=\\\"bypass _bbsclan_clanlist;\", String.valueOf(index + 1), \"\\\" back=\\\"l2ui_ch3.next1_down\\\" fore=\\\"l2ui_ch3.next1\\\" width=16 height=16 ><\/td>\");\n\t\t}\n\t\thtml.append(\"<\/tr><\/table><table border=0 cellspacing=0 cellpadding=0><tr><td width=610><img src=\\\"sek.cbui141\\\" width=\\\"610\\\" height=\\\"1\\\"><\/td><\/tr><\/table><table border=0><tr><td><combobox width=65 var=keyword list=\\\"Name;Ruler\\\"><\/td><td><edit var = \\\"Search\\\" width=130 height=11 length=\\\"16\\\"><\/td>\" +\n\t\t\/\/ TODO: search (Write in BBS)\n\t\t\"<td><button value=\\\"&$420;\\\" action=\\\"Write 5 -1 0 Search keyword keyword\\\" back=\\\"l2ui_ch3.smallbutton2_down\\\" width=65 height=20 fore=\\\"l2ui_ch3.smallbutton2\\\"> <\/td> <\/tr><\/table><br><br><\/center><\/body><\/html>\");\n\t\tCommunityBoardHandler.separateAndSend(html.toString(), activeChar);\n\t}","code":"private void clanList(L2PcInstance activeChar, int index)\n\t{\n\t\tif (index < 1)\n\t\t{\n\t\t\tindex = 1;\n\t\t}\n\t\n\t\tfinal StringBuilder html = StringUtil.startAppend(2000, \"<html><body><br><br><center><br1><br1><table border=0 cellspacing=0 cellpadding=0><tr><td FIXWIDTH=15>&nbsp;<\/td><td width=610 height=30 align=left><a action=\\\"bypass _bbsclan_clanlist\\\"> CLAN COMMUNITY <\/a><\/td><\/tr><\/table><table border=0 cellspacing=0 cellpadding=0 width=610 bgcolor=434343><tr><td height=10><\/td><\/tr><tr><td fixWIDTH=5><\/td><td fixWIDTH=600><a action=\\\"bypass _bbsclan_clanhome;\", String.valueOf((activeChar.getClan() != null) ? activeChar.getClan().getId() : 0), \"\\\">[GO TO MY CLAN]<\/a>&nbsp;&nbsp;<\/td><td fixWIDTH=5><\/td><\/tr><tr><td height=10><\/td><\/tr><\/table><br><table border=0 cellspacing=0 cellpadding=2 bgcolor=5A5A5A width=610><tr><td FIXWIDTH=5><\/td><td FIXWIDTH=200 align=center>CLAN NAME<\/td><td FIXWIDTH=200 align=center>CLAN LEADER<\/td><td FIXWIDTH=100 align=center>CLAN LEVEL<\/td><td FIXWIDTH=100 align=center>CLAN MEMBERS<\/td><td FIXWIDTH=5><\/td><\/tr><\/table><img src=\\\"L2UI.Squareblank\\\" width=\\\"1\\\" height=\\\"5\\\">\");\n\t\tint i = 0;\n\t\tfor (L2Clan cl : ClanTable.getInstance().getClans())\n\t\t{\n\t\t\tif (i > ((index + 1) * 7))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i++ >= ((index - 1) * 7))\n\t\t\t{\n\t\t\t\tStringUtil.append(html, \"<img src=\\\"L2UI.SquareBlank\\\" width=\\\"610\\\" height=\\\"3\\\"><table border=0 cellspacing=0 cellpadding=0 width=610><tr> <td FIXWIDTH=5><\/td><td FIXWIDTH=200 align=center><a action=\\\"bypass _bbsclan_clanhome;\", String.valueOf(cl.getId()), \"\\\">\", cl.getName(), \"<\/a><\/td><td FIXWIDTH=200 align=center>\", cl.getLeaderName(), \"<\/td><td FIXWIDTH=100 align=center>\", String.valueOf(cl.getLevel()), \"<\/td><td FIXWIDTH=100 align=center>\", String.valueOf(cl.getMembersCount()), \"<\/td><td FIXWIDTH=5><\/td><\/tr><tr><td height=5><\/td><\/tr><\/table><img src=\\\"L2UI.SquareBlank\\\" width=\\\"610\\\" height=\\\"3\\\"><img src=\\\"L2UI.SquareGray\\\" width=\\\"610\\\" height=\\\"1\\\">\");\n\t\t\t}\n\t\t}\n\t\thtml.append(\"<img src=\\\"L2UI.SquareBlank\\\" width=\\\"610\\\" height=\\\"2\\\"><table cellpadding=0 cellspacing=2 border=0><tr>\");\n\t\tif (index == 1)\n\t\t{\n\t\t\thtml.append(\"<td><button action=\\\"\\\" back=\\\"l2ui_ch3.prev1_down\\\" fore=\\\"l2ui_ch3.prev1\\\" width=16 height=16 ><\/td>\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStringUtil.append(html, \"<td><button action=\\\"_bbsclan_clanlist;\", String.valueOf(index - 1), \"\\\" back=\\\"l2ui_ch3.prev1_down\\\" fore=\\\"l2ui_ch3.prev1\\\" width=16 height=16 ><\/td>\");\n\t\t}\n\t\ti = 0;\n\t\tint nbp = ClanTable.getInstance().getClanCount() \/ 8;\n\t\tif ((nbp * 8) != ClanTable.getInstance().getClanCount())\n\t\t{\n\t\t\tnbp++;\n\t\t}\n\t\tfor (i = 1; i <= nbp; i++)\n\t\t{\n\t\t\tif (i == index)\n\t\t\t{\n\t\t\t\tStringUtil.append(html, \"<td> \", String.valueOf(i), \" <\/td>\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tStringUtil.append(html, \"<td><a action=\\\"bypass _bbsclan_clanlist;\", String.valueOf(i), \"\\\"> \", String.valueOf(i), \" <\/a><\/td>\");\n\t\t\t}\n\t\t}\n\t\tif (index == nbp)\n\t\t{\n\t\t\thtml.append(\"<td><button action=\\\"\\\" back=\\\"l2ui_ch3.next1_down\\\" fore=\\\"l2ui_ch3.next1\\\" width=16 height=16 ><\/td>\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStringUtil.append(html, \"<td><button action=\\\"bypass _bbsclan_clanlist;\", String.valueOf(index + 1), \"\\\" back=\\\"l2ui_ch3.next1_down\\\" fore=\\\"l2ui_ch3.next1\\\" width=16 height=16 ><\/td>\");\n\t\t}\n\t\thtml.append(\"<\/tr><\/table><table border=0 cellspacing=0 cellpadding=0><tr><td width=610><img src=\\\"sek.cbui141\\\" width=\\\"610\\\" height=\\\"1\\\"><\/td><\/tr><\/table><table border=0><tr><td><combobox width=65 var=keyword list=\\\"Name;Ruler\\\"><\/td><td><edit var = \\\"Search\\\" width=130 height=11 length=\\\"16\\\"><\/td>\" +\n\t\n\t\t\"<td><button value=\\\"&$420;\\\" action=\\\"Write 5 -1 0 Search keyword keyword\\\" back=\\\"l2ui_ch3.smallbutton2_down\\\" width=65 height=20 fore=\\\"l2ui_ch3.smallbutton2\\\"> <\/td> <\/tr><\/table><br><br><\/center><\/body><\/html>\");\n\t\tCommunityBoardHandler.separateAndSend(html.toString(), activeChar);\n\t}","cleancode":"private void clanlist(l2pcinstance activechar, int index) { if (index < 1) { index = 1; } final stringbuilder html = stringutil.startappend(2000, \"<html><body><br><br><center><br1><br1><table border=0 cellspacing=0 cellpadding=0><tr><td fixwidth=15>&nbsp;<\/td><td width=610 height=30 align=left><a action=\\\"bypass _bbsclan_clanlist\\\"> clan community <\/a><\/td><\/tr><\/table><table border=0 cellspacing=0 cellpadding=0 width=610 bgcolor=434343><tr><td height=10><\/td><\/tr><tr><td fixwidth=5><\/td><td fixwidth=600><a action=\\\"bypass _bbsclan_clanhome;\", string.valueof((activechar.getclan() != null) ? activechar.getclan().getid() : 0), \"\\\">[go to my clan]<\/a>&nbsp;&nbsp;<\/td><td fixwidth=5><\/td><\/tr><tr><td height=10><\/td><\/tr><\/table><br><table border=0 cellspacing=0 cellpadding=2 bgcolor=5a5a5a width=610><tr><td fixwidth=5><\/td><td fixwidth=200 align=center>clan name<\/td><td fixwidth=200 align=center>clan leader<\/td><td fixwidth=100 align=center>clan level<\/td><td fixwidth=100 align=center>clan members<\/td><td fixwidth=5><\/td><\/tr><\/table><img src=\\\"l2ui.squareblank\\\" width=\\\"1\\\" height=\\\"5\\\">\"); int i = 0; for (l2clan cl : clantable.getinstance().getclans()) { if (i > ((index + 1) * 7)) { break; } if (i++ >= ((index - 1) * 7)) { stringutil.append(html, \"<img src=\\\"l2ui.squareblank\\\" width=\\\"610\\\" height=\\\"3\\\"><table border=0 cellspacing=0 cellpadding=0 width=610><tr> <td fixwidth=5><\/td><td fixwidth=200 align=center><a action=\\\"bypass _bbsclan_clanhome;\", string.valueof(cl.getid()), \"\\\">\", cl.getname(), \"<\/a><\/td><td fixwidth=200 align=center>\", cl.getleadername(), \"<\/td><td fixwidth=100 align=center>\", string.valueof(cl.getlevel()), \"<\/td><td fixwidth=100 align=center>\", string.valueof(cl.getmemberscount()), \"<\/td><td fixwidth=5><\/td><\/tr><tr><td height=5><\/td><\/tr><\/table><img src=\\\"l2ui.squareblank\\\" width=\\\"610\\\" height=\\\"3\\\"><img src=\\\"l2ui.squaregray\\\" width=\\\"610\\\" height=\\\"1\\\">\"); } } html.append(\"<img src=\\\"l2ui.squareblank\\\" width=\\\"610\\\" height=\\\"2\\\"><table cellpadding=0 cellspacing=2 border=0><tr>\"); if (index == 1) { html.append(\"<td><button action=\\\"\\\" back=\\\"l2ui_ch3.prev1_down\\\" fore=\\\"l2ui_ch3.prev1\\\" width=16 height=16 ><\/td>\"); } else { stringutil.append(html, \"<td><button action=\\\"_bbsclan_clanlist;\", string.valueof(index - 1), \"\\\" back=\\\"l2ui_ch3.prev1_down\\\" fore=\\\"l2ui_ch3.prev1\\\" width=16 height=16 ><\/td>\"); } i = 0; int nbp = clantable.getinstance().getclancount() \/ 8; if ((nbp * 8) != clantable.getinstance().getclancount()) { nbp++; } for (i = 1; i <= nbp; i++) { if (i == index) { stringutil.append(html, \"<td> \", string.valueof(i), \" <\/td>\"); } else { stringutil.append(html, \"<td><a action=\\\"bypass _bbsclan_clanlist;\", string.valueof(i), \"\\\"> \", string.valueof(i), \" <\/a><\/td>\"); } } if (index == nbp) { html.append(\"<td><button action=\\\"\\\" back=\\\"l2ui_ch3.next1_down\\\" fore=\\\"l2ui_ch3.next1\\\" width=16 height=16 ><\/td>\"); } else { stringutil.append(html, \"<td><button action=\\\"bypass _bbsclan_clanlist;\", string.valueof(index + 1), \"\\\" back=\\\"l2ui_ch3.next1_down\\\" fore=\\\"l2ui_ch3.next1\\\" width=16 height=16 ><\/td>\"); } html.append(\"<\/tr><\/table><table border=0 cellspacing=0 cellpadding=0><tr><td width=610><img src=\\\"sek.cbui141\\\" width=\\\"610\\\" height=\\\"1\\\"><\/td><\/tr><\/table><table border=0><tr><td><combobox width=65 var=keyword list=\\\"name;ruler\\\"><\/td><td><edit var = \\\"search\\\" width=130 height=11 length=\\\"16\\\"><\/td>\" + \"<td><button value=\\\"&$420;\\\" action=\\\"write 5 -1 0 search keyword keyword\\\" back=\\\"l2ui_ch3.smallbutton2_down\\\" width=65 height=20 fore=\\\"l2ui_ch3.smallbutton2\\\"> <\/td> <\/tr><\/table><br><br><\/center><\/body><\/html>\"); communityboardhandler.separateandsend(html.tostring(), activechar); }","comment":"\/\/ header\n\/\/ todo: search (write in bbs)","repo":"RollingSoftware\/L2J_HighFive_Hardcore","code_context_2":"index = 1;\n}\n\/\/ header\nfinal StringBuilder html = StringUtil.startAppend(2000, \"<html><body><br><br><center><br1><br1><table border=0 cellspacing=0 cellpadding=0><tr><td FIXWIDTH=15>&nbsp;<\/td><td width=610 height=30 align=left><a action=\\\"bypass _bbsclan_clanlist\\\"> CLAN COMMUNITY <\/a><\/td><\/tr><\/table><table border=0 cellspacing=0 cellpadding=0 width=610 bgcolor=434343><tr><td height=10><\/td><\/tr><tr><td fixWIDTH=5><\/td><td fixWIDTH=600><a action=\\\"bypass _bbsclan_clanhome;\", String.valueOf((activeChar.getClan() != null) ? activeChar.getClan().getId() : 0), \"\\\">[GO TO MY CLAN]<\/a>&nbsp;&nbsp;<\/td><td fixWIDTH=5><\/td><\/tr><tr><td height=10><\/td><\/tr><\/table><br><table border=0 cellspacing=0 cellpadding=2 bgcolor=5A5A5A width=610><tr><td FIXWIDTH=5><\/td><td FIXWIDTH=200 align=center>CLAN NAME<\/td><td FIXWIDTH=200 align=center>CLAN LEADER<\/td><td FIXWIDTH=100 align=center>CLAN LEVEL<\/td><td FIXWIDTH=100 align=center>CLAN MEMBERS<\/td><td FIXWIDTH=5><\/td><\/tr><\/table><img src=\\\"L2UI.Squareblank\\\" width=\\\"1\\\" height=\\\"5\\\">\");\nint i = 0;\n\n}\nhtml.append(\"<\/tr><\/table><table border=0 cellspacing=0 cellpadding=0><tr><td width=610><img src=\\\"sek.cbui141\\\" width=\\\"610\\\" height=\\\"1\\\"><\/td><\/tr><\/table><table border=0><tr><td><combobox width=65 var=keyword list=\\\"Name;Ruler\\\"><\/td><td><edit var = \\\"Search\\\" width=130 height=11 length=\\\"16\\\"><\/td>\" +\n\/\/ TODO: search (Write in BBS)\n\"<td><button value=\\\"&$420;\\\" action=\\\"Write 5 -1 0 Search keyword keyword\\\" back=\\\"l2ui_ch3.smallbutton2_down\\\" width=65 height=20 fore=\\\"l2ui_ch3.smallbutton2\\\"> <\/td> <\/tr><\/table><br><br><\/center><\/body><\/html>\");\nCommunityBoardHandler.separateAndSend(html.toString(), activeChar);","code_context_10":"private void clanList(L2PcInstance activeChar, int index)\n{\nif (index < 1)\n{\nindex = 1;\n}\n\/\/ header\nfinal StringBuilder html = StringUtil.startAppend(2000, \"<html><body><br><br><center><br1><br1><table border=0 cellspacing=0 cellpadding=0><tr><td FIXWIDTH=15>&nbsp;<\/td><td width=610 height=30 align=left><a action=\\\"bypass _bbsclan_clanlist\\\"> CLAN COMMUNITY <\/a><\/td><\/tr><\/table><table border=0 cellspacing=0 cellpadding=0 width=610 bgcolor=434343><tr><td height=10><\/td><\/tr><tr><td fixWIDTH=5><\/td><td fixWIDTH=600><a action=\\\"bypass _bbsclan_clanhome;\", String.valueOf((activeChar.getClan() != null) ? activeChar.getClan().getId() : 0), \"\\\">[GO TO MY CLAN]<\/a>&nbsp;&nbsp;<\/td><td fixWIDTH=5><\/td><\/tr><tr><td height=10><\/td><\/tr><\/table><br><table border=0 cellspacing=0 cellpadding=2 bgcolor=5A5A5A width=610><tr><td FIXWIDTH=5><\/td><td FIXWIDTH=200 align=center>CLAN NAME<\/td><td FIXWIDTH=200 align=center>CLAN LEADER<\/td><td FIXWIDTH=100 align=center>CLAN LEVEL<\/td><td FIXWIDTH=100 align=center>CLAN MEMBERS<\/td><td FIXWIDTH=5><\/td><\/tr><\/table><img src=\\\"L2UI.Squareblank\\\" width=\\\"1\\\" height=\\\"5\\\">\");\nint i = 0;\nfor (L2Clan cl : ClanTable.getInstance().getClans())\n{\nif (i > ((index + 1) * 7))\n{\nbreak;\n}\nif (i++ >= ((index - 1) * 7))\n{\n\n}\nif (index == nbp)\n{\nhtml.append(\"<td><button action=\\\"\\\" back=\\\"l2ui_ch3.next1_down\\\" fore=\\\"l2ui_ch3.next1\\\" width=16 height=16 ><\/td>\");\n}\nelse\n{\nStringUtil.append(html, \"<td><button action=\\\"bypass _bbsclan_clanlist;\", String.valueOf(index + 1), \"\\\" back=\\\"l2ui_ch3.next1_down\\\" fore=\\\"l2ui_ch3.next1\\\" width=16 height=16 ><\/td>\");\n}\nhtml.append(\"<\/tr><\/table><table border=0 cellspacing=0 cellpadding=0><tr><td width=610><img src=\\\"sek.cbui141\\\" width=\\\"610\\\" height=\\\"1\\\"><\/td><\/tr><\/table><table border=0><tr><td><combobox width=65 var=keyword list=\\\"Name;Ruler\\\"><\/td><td><edit var = \\\"Search\\\" width=130 height=11 length=\\\"16\\\"><\/td>\" +\n\/\/ TODO: search (Write in BBS)\n\"<td><button value=\\\"&$420;\\\" action=\\\"Write 5 -1 0 Search keyword keyword\\\" back=\\\"l2ui_ch3.smallbutton2_down\\\" width=65 height=20 fore=\\\"l2ui_ch3.smallbutton2\\\"> <\/td> <\/tr><\/table><br><br><\/center><\/body><\/html>\");\nCommunityBoardHandler.separateAndSend(html.toString(), activeChar);\n}","code_context_20":"private void clanList(L2PcInstance activeChar, int index)\n{\nif (index < 1)\n{\nindex = 1;\n}\n\/\/ header\nfinal StringBuilder html = StringUtil.startAppend(2000, \"<html><body><br><br><center><br1><br1><table border=0 cellspacing=0 cellpadding=0><tr><td FIXWIDTH=15>&nbsp;<\/td><td width=610 height=30 align=left><a action=\\\"bypass _bbsclan_clanlist\\\"> CLAN COMMUNITY <\/a><\/td><\/tr><\/table><table border=0 cellspacing=0 cellpadding=0 width=610 bgcolor=434343><tr><td height=10><\/td><\/tr><tr><td fixWIDTH=5><\/td><td fixWIDTH=600><a action=\\\"bypass _bbsclan_clanhome;\", String.valueOf((activeChar.getClan() != null) ? activeChar.getClan().getId() : 0), \"\\\">[GO TO MY CLAN]<\/a>&nbsp;&nbsp;<\/td><td fixWIDTH=5><\/td><\/tr><tr><td height=10><\/td><\/tr><\/table><br><table border=0 cellspacing=0 cellpadding=2 bgcolor=5A5A5A width=610><tr><td FIXWIDTH=5><\/td><td FIXWIDTH=200 align=center>CLAN NAME<\/td><td FIXWIDTH=200 align=center>CLAN LEADER<\/td><td FIXWIDTH=100 align=center>CLAN LEVEL<\/td><td FIXWIDTH=100 align=center>CLAN MEMBERS<\/td><td FIXWIDTH=5><\/td><\/tr><\/table><img src=\\\"L2UI.Squareblank\\\" width=\\\"1\\\" height=\\\"5\\\">\");\nint i = 0;\nfor (L2Clan cl : ClanTable.getInstance().getClans())\n{\nif (i > ((index + 1) * 7))\n{\nbreak;\n}\nif (i++ >= ((index - 1) * 7))\n{\nStringUtil.append(html, \"<img src=\\\"L2UI.SquareBlank\\\" width=\\\"610\\\" height=\\\"3\\\"><table border=0 cellspacing=0 cellpadding=0 width=610><tr> <td FIXWIDTH=5><\/td><td FIXWIDTH=200 align=center><a action=\\\"bypass _bbsclan_clanhome;\", String.valueOf(cl.getId()), \"\\\">\", cl.getName(), \"<\/a><\/td><td FIXWIDTH=200 align=center>\", cl.getLeaderName(), \"<\/td><td FIXWIDTH=100 align=center>\", String.valueOf(cl.getLevel()), \"<\/td><td FIXWIDTH=100 align=center>\", String.valueOf(cl.getMembersCount()), \"<\/td><td FIXWIDTH=5><\/td><\/tr><tr><td height=5><\/td><\/tr><\/table><img src=\\\"L2UI.SquareBlank\\\" width=\\\"610\\\" height=\\\"3\\\"><img src=\\\"L2UI.SquareGray\\\" width=\\\"610\\\" height=\\\"1\\\">\");\n}\n}\nhtml.append(\"<img src=\\\"L2UI.SquareBlank\\\" width=\\\"610\\\" height=\\\"2\\\"><table cellpadding=0 cellspacing=2 border=0><tr>\");\nif (index == 1)\n{\nhtml.append(\"<td><button action=\\\"\\\" back=\\\"l2ui_ch3.prev1_down\\\" fore=\\\"l2ui_ch3.prev1\\\" width=16 height=16 ><\/td>\");\n}\nelse\n{\n\nfor (i = 1; i <= nbp; i++)\n{\nif (i == index)\n{\nStringUtil.append(html, \"<td> \", String.valueOf(i), \" <\/td>\");\n}\nelse\n{\nStringUtil.append(html, \"<td><a action=\\\"bypass _bbsclan_clanlist;\", String.valueOf(i), \"\\\"> \", String.valueOf(i), \" <\/a><\/td>\");\n}\n}\nif (index == nbp)\n{\nhtml.append(\"<td><button action=\\\"\\\" back=\\\"l2ui_ch3.next1_down\\\" fore=\\\"l2ui_ch3.next1\\\" width=16 height=16 ><\/td>\");\n}\nelse\n{\nStringUtil.append(html, \"<td><button action=\\\"bypass _bbsclan_clanlist;\", String.valueOf(index + 1), \"\\\" back=\\\"l2ui_ch3.next1_down\\\" fore=\\\"l2ui_ch3.next1\\\" width=16 height=16 ><\/td>\");\n}\nhtml.append(\"<\/tr><\/table><table border=0 cellspacing=0 cellpadding=0><tr><td width=610><img src=\\\"sek.cbui141\\\" width=\\\"610\\\" height=\\\"1\\\"><\/td><\/tr><\/table><table border=0><tr><td><combobox width=65 var=keyword list=\\\"Name;Ruler\\\"><\/td><td><edit var = \\\"Search\\\" width=130 height=11 length=\\\"16\\\"><\/td>\" +\n\/\/ TODO: search (Write in BBS)\n\"<td><button value=\\\"&$420;\\\" action=\\\"Write 5 -1 0 Search keyword keyword\\\" back=\\\"l2ui_ch3.smallbutton2_down\\\" width=65 height=20 fore=\\\"l2ui_ch3.smallbutton2\\\"> <\/td> <\/tr><\/table><br><br><\/center><\/body><\/html>\");\nCommunityBoardHandler.separateAndSend(html.toString(), activeChar);\n}","label":[0,1,0,0]}
{"id":23375,"original_code":"public void sendErrorEmail(RequestCycle cycle, Exception ex, IRequestLogger logger) {\n        try {\n            String customer = Utils.getCustomer();\n            Url url = cycle.getRequest().getUrl();\n            Url clientUrl = cycle.getRequest().getClientUrl();\n            String exStr = ExceptionUtils.getStackTrace(ex);\n            String fullUrl = cycle.getUrlRenderer().renderFullUrl(url);\n            int currUserId = 0;\n            RequestData currRd = logger.getCurrentRequest();\n            String currSessId = Session.get().getId();\n            SessionData sd = null;\n            if(currSessId != null) {\n                SessionData[] sessions = logger.getLiveSessions();\n                for(SessionData s : sessions) {\n                    if(s.getSessionId().equals(currSessId)) {\n                        sd = s;\n                        break;\n                    }\n                }\n            }\n            String currReq = ((CustomRequestLogger)logger).createRequestData(currRd, sd);\n            StringBuilder currSessStr = new StringBuilder();\n            if(sd != null) {\n                currSessStr.append(\"id:\").append(sd.getSessionId()).append('\\n');\n                currSessStr.append(\"requestCount:\").append(sd.getNumberOfRequests()).append('\\n');\n                currSessStr.append(\"requestsTime:\").append(sd.getTotalTimeTaken()).append('\\n');\n                currSessStr.append(\"sessionSize:\").append(Bytes.bytes(sd.getSessionSize())).append('\\n');\n                currSessStr.append(\"sessionInfo:\").append(sd.getSessionInfo()).append('\\n');\n                currSessStr.append(\"startDate:\").append(sd.getStartDate()).append('\\n');\n                currSessStr.append(\"lastRequestTime:\").append(sd.getLastActive()).append('\\n');\n                currSessStr.append(\"numberOfRequests:\").append(sd.getNumberOfRequests()).append('\\n');\n                currSessStr.append(\"totalTimeTaken:\").append(sd.getTotalTimeTaken()).append(\"\\n\\n\\n\");\n            }\n            currSessStr.append(\"Requests: \\n\");\n            ((CustomRequestLogger)logger).getRequests(currSessStr);\n            String template = \"param1: %s \\n url: %s \\n client url: %s \\n user: %s \\n\\n \"\n                    + \"curr req: %s \\n\\n\\n curr session: %s \\n\\n\\n stack trace: %s\";\n            String body = String.format(template, customer, fullUrl, clientUrl.toString(), currUserId, currReq, currSessStr.toString(), exStr);\n            String subject = customer + \" error\";\n            \/\/TODO send email here\n        } catch (Exception e) {\n            \/\/ignore\n        }\n    }","code":"public void sendErrorEmail(RequestCycle cycle, Exception ex, IRequestLogger logger) {\n        try {\n            String customer = Utils.getCustomer();\n            Url url = cycle.getRequest().getUrl();\n            Url clientUrl = cycle.getRequest().getClientUrl();\n            String exStr = ExceptionUtils.getStackTrace(ex);\n            String fullUrl = cycle.getUrlRenderer().renderFullUrl(url);\n            int currUserId = 0;\n            RequestData currRd = logger.getCurrentRequest();\n            String currSessId = Session.get().getId();\n            SessionData sd = null;\n            if(currSessId != null) {\n                SessionData[] sessions = logger.getLiveSessions();\n                for(SessionData s : sessions) {\n                    if(s.getSessionId().equals(currSessId)) {\n                        sd = s;\n                        break;\n                    }\n                }\n            }\n            String currReq = ((CustomRequestLogger)logger).createRequestData(currRd, sd);\n            StringBuilder currSessStr = new StringBuilder();\n            if(sd != null) {\n                currSessStr.append(\"id:\").append(sd.getSessionId()).append('\\n');\n                currSessStr.append(\"requestCount:\").append(sd.getNumberOfRequests()).append('\\n');\n                currSessStr.append(\"requestsTime:\").append(sd.getTotalTimeTaken()).append('\\n');\n                currSessStr.append(\"sessionSize:\").append(Bytes.bytes(sd.getSessionSize())).append('\\n');\n                currSessStr.append(\"sessionInfo:\").append(sd.getSessionInfo()).append('\\n');\n                currSessStr.append(\"startDate:\").append(sd.getStartDate()).append('\\n');\n                currSessStr.append(\"lastRequestTime:\").append(sd.getLastActive()).append('\\n');\n                currSessStr.append(\"numberOfRequests:\").append(sd.getNumberOfRequests()).append('\\n');\n                currSessStr.append(\"totalTimeTaken:\").append(sd.getTotalTimeTaken()).append(\"\\n\\n\\n\");\n            }\n            currSessStr.append(\"Requests: \\n\");\n            ((CustomRequestLogger)logger).getRequests(currSessStr);\n            String template = \"param1: %s \\n url: %s \\n client url: %s \\n user: %s \\n\\n \"\n                    + \"curr req: %s \\n\\n\\n curr session: %s \\n\\n\\n stack trace: %s\";\n            String body = String.format(template, customer, fullUrl, clientUrl.toString(), currUserId, currReq, currSessStr.toString(), exStr);\n            String subject = customer + \" error\";\n           \n        } catch (Exception e) {\n           \n        }\n    }","cleancode":"public void senderroremail(requestcycle cycle, exception ex, irequestlogger logger) { try { string customer = utils.getcustomer(); url url = cycle.getrequest().geturl(); url clienturl = cycle.getrequest().getclienturl(); string exstr = exceptionutils.getstacktrace(ex); string fullurl = cycle.geturlrenderer().renderfullurl(url); int curruserid = 0; requestdata currrd = logger.getcurrentrequest(); string currsessid = session.get().getid(); sessiondata sd = null; if(currsessid != null) { sessiondata[] sessions = logger.getlivesessions(); for(sessiondata s : sessions) { if(s.getsessionid().equals(currsessid)) { sd = s; break; } } } string currreq = ((customrequestlogger)logger).createrequestdata(currrd, sd); stringbuilder currsessstr = new stringbuilder(); if(sd != null) { currsessstr.append(\"id:\").append(sd.getsessionid()).append('\\n'); currsessstr.append(\"requestcount:\").append(sd.getnumberofrequests()).append('\\n'); currsessstr.append(\"requeststime:\").append(sd.gettotaltimetaken()).append('\\n'); currsessstr.append(\"sessionsize:\").append(bytes.bytes(sd.getsessionsize())).append('\\n'); currsessstr.append(\"sessioninfo:\").append(sd.getsessioninfo()).append('\\n'); currsessstr.append(\"startdate:\").append(sd.getstartdate()).append('\\n'); currsessstr.append(\"lastrequesttime:\").append(sd.getlastactive()).append('\\n'); currsessstr.append(\"numberofrequests:\").append(sd.getnumberofrequests()).append('\\n'); currsessstr.append(\"totaltimetaken:\").append(sd.gettotaltimetaken()).append(\"\\n\\n\\n\"); } currsessstr.append(\"requests: \\n\"); ((customrequestlogger)logger).getrequests(currsessstr); string template = \"param1: %s \\n url: %s \\n client url: %s \\n user: %s \\n\\n \" + \"curr req: %s \\n\\n\\n curr session: %s \\n\\n\\n stack trace: %s\"; string body = string.format(template, customer, fullurl, clienturl.tostring(), curruserid, currreq, currsessstr.tostring(), exstr); string subject = customer + \" error\"; } catch (exception e) { } }","comment":"\/\/todo send email here\n\/\/ignore","repo":"RomanSery\/codesnippets","code_context_2":"String body = String.format(template, customer, fullUrl, clientUrl.toString(), currUserId, currReq, currSessStr.toString(), exStr);\nString subject = customer + \" error\";\n\/\/TODO send email here\n} catch (Exception e) {\n\/\/ignore\n\n\/\/TODO send email here\n} catch (Exception e) {\n\/\/ignore\n}\n}","code_context_10":"currSessStr.append(\"lastRequestTime:\").append(sd.getLastActive()).append('\\n');\ncurrSessStr.append(\"numberOfRequests:\").append(sd.getNumberOfRequests()).append('\\n');\ncurrSessStr.append(\"totalTimeTaken:\").append(sd.getTotalTimeTaken()).append(\"\\n\\n\\n\");\n}\ncurrSessStr.append(\"Requests: \\n\");\n((CustomRequestLogger)logger).getRequests(currSessStr);\nString template = \"param1: %s \\n url: %s \\n client url: %s \\n user: %s \\n\\n \"\n+ \"curr req: %s \\n\\n\\n curr session: %s \\n\\n\\n stack trace: %s\";\nString body = String.format(template, customer, fullUrl, clientUrl.toString(), currUserId, currReq, currSessStr.toString(), exStr);\nString subject = customer + \" error\";\n\/\/TODO send email here\n} catch (Exception e) {\n\/\/ignore\n}\n}\n\ncurrSessStr.append(\"totalTimeTaken:\").append(sd.getTotalTimeTaken()).append(\"\\n\\n\\n\");\n}\ncurrSessStr.append(\"Requests: \\n\");\n((CustomRequestLogger)logger).getRequests(currSessStr);\nString template = \"param1: %s \\n url: %s \\n client url: %s \\n user: %s \\n\\n \"\n+ \"curr req: %s \\n\\n\\n curr session: %s \\n\\n\\n stack trace: %s\";\nString body = String.format(template, customer, fullUrl, clientUrl.toString(), currUserId, currReq, currSessStr.toString(), exStr);\nString subject = customer + \" error\";\n\/\/TODO send email here\n} catch (Exception e) {\n\/\/ignore\n}\n}","code_context_20":"}\nString currReq = ((CustomRequestLogger)logger).createRequestData(currRd, sd);\nStringBuilder currSessStr = new StringBuilder();\nif(sd != null) {\ncurrSessStr.append(\"id:\").append(sd.getSessionId()).append('\\n');\ncurrSessStr.append(\"requestCount:\").append(sd.getNumberOfRequests()).append('\\n');\ncurrSessStr.append(\"requestsTime:\").append(sd.getTotalTimeTaken()).append('\\n');\ncurrSessStr.append(\"sessionSize:\").append(Bytes.bytes(sd.getSessionSize())).append('\\n');\ncurrSessStr.append(\"sessionInfo:\").append(sd.getSessionInfo()).append('\\n');\ncurrSessStr.append(\"startDate:\").append(sd.getStartDate()).append('\\n');\ncurrSessStr.append(\"lastRequestTime:\").append(sd.getLastActive()).append('\\n');\ncurrSessStr.append(\"numberOfRequests:\").append(sd.getNumberOfRequests()).append('\\n');\ncurrSessStr.append(\"totalTimeTaken:\").append(sd.getTotalTimeTaken()).append(\"\\n\\n\\n\");\n}\ncurrSessStr.append(\"Requests: \\n\");\n((CustomRequestLogger)logger).getRequests(currSessStr);\nString template = \"param1: %s \\n url: %s \\n client url: %s \\n user: %s \\n\\n \"\n+ \"curr req: %s \\n\\n\\n curr session: %s \\n\\n\\n stack trace: %s\";\nString body = String.format(template, customer, fullUrl, clientUrl.toString(), currUserId, currReq, currSessStr.toString(), exStr);\nString subject = customer + \" error\";\n\/\/TODO send email here\n} catch (Exception e) {\n\/\/ignore\n}\n}\n\nStringBuilder currSessStr = new StringBuilder();\nif(sd != null) {\ncurrSessStr.append(\"id:\").append(sd.getSessionId()).append('\\n');\ncurrSessStr.append(\"requestCount:\").append(sd.getNumberOfRequests()).append('\\n');\ncurrSessStr.append(\"requestsTime:\").append(sd.getTotalTimeTaken()).append('\\n');\ncurrSessStr.append(\"sessionSize:\").append(Bytes.bytes(sd.getSessionSize())).append('\\n');\ncurrSessStr.append(\"sessionInfo:\").append(sd.getSessionInfo()).append('\\n');\ncurrSessStr.append(\"startDate:\").append(sd.getStartDate()).append('\\n');\ncurrSessStr.append(\"lastRequestTime:\").append(sd.getLastActive()).append('\\n');\ncurrSessStr.append(\"numberOfRequests:\").append(sd.getNumberOfRequests()).append('\\n');\ncurrSessStr.append(\"totalTimeTaken:\").append(sd.getTotalTimeTaken()).append(\"\\n\\n\\n\");\n}\ncurrSessStr.append(\"Requests: \\n\");\n((CustomRequestLogger)logger).getRequests(currSessStr);\nString template = \"param1: %s \\n url: %s \\n client url: %s \\n user: %s \\n\\n \"\n+ \"curr req: %s \\n\\n\\n curr session: %s \\n\\n\\n stack trace: %s\";\nString body = String.format(template, customer, fullUrl, clientUrl.toString(), currUserId, currReq, currSessStr.toString(), exStr);\nString subject = customer + \" error\";\n\/\/TODO send email here\n} catch (Exception e) {\n\/\/ignore\n}\n}","label":[0,1,0,0]}
{"id":23575,"original_code":"public static void main(String[] args) {\n\t\t\/\/ TODO Auto-generated method stub\n\t\t\/\/Assuming stock of each sport is 2\n\t\tSports sp1=new IndoorSports();\n\t\tSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\n\t\tsp1=new Billiards(sp1);\n\t\tSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\n\t\tsp1=new Carrom(sp1);\n\t\tSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\n\t\tsp1=new Badminton(sp1);\n\t\tSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\n\t\tSports sp2=new OutdoorSports();\n\t\tSystem.out.println(\"\\nTotal Outdoor Sports Stock:\"+sp2.getCurrentStock());\n\t\tsp2=new Trekking(sp2);\n\t\tSystem.out.println(\"Total Outdoor Sports Stock:\"+sp2.getCurrentStock());\n\t\tsp2=new Cricket(sp2);\n\t\tSystem.out.println(\"Total Outdoor Sports Stock:\"+sp2.getCurrentStock());\n\t\tsp2=new HighJump(sp2);\n\t\tSystem.out.println(\"Total Outdoor Sports Stock:\"+sp2.getCurrentStock());\n\t\tsp2=new LongJump(sp2);\n\t\tSystem.out.println(\"Total Outdoor Sports Stock:\"+sp2.getCurrentStock());\n\t}","code":"public static void main(String[] args) {\n\t\n\t\n\t\tSports sp1=new IndoorSports();\n\t\tSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\n\t\tsp1=new Billiards(sp1);\n\t\tSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\n\t\tsp1=new Carrom(sp1);\n\t\tSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\n\t\tsp1=new Badminton(sp1);\n\t\tSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\n\t\tSports sp2=new OutdoorSports();\n\t\tSystem.out.println(\"\\nTotal Outdoor Sports Stock:\"+sp2.getCurrentStock());\n\t\tsp2=new Trekking(sp2);\n\t\tSystem.out.println(\"Total Outdoor Sports Stock:\"+sp2.getCurrentStock());\n\t\tsp2=new Cricket(sp2);\n\t\tSystem.out.println(\"Total Outdoor Sports Stock:\"+sp2.getCurrentStock());\n\t\tsp2=new HighJump(sp2);\n\t\tSystem.out.println(\"Total Outdoor Sports Stock:\"+sp2.getCurrentStock());\n\t\tsp2=new LongJump(sp2);\n\t\tSystem.out.println(\"Total Outdoor Sports Stock:\"+sp2.getCurrentStock());\n\t}","cleancode":"public static void main(string[] args) { sports sp1=new indoorsports(); system.out.println(\"total indoor sports stock:\"+sp1.getcurrentstock()); sp1=new billiards(sp1); system.out.println(\"total indoor sports stock:\"+sp1.getcurrentstock()); sp1=new carrom(sp1); system.out.println(\"total indoor sports stock:\"+sp1.getcurrentstock()); sp1=new badminton(sp1); system.out.println(\"total indoor sports stock:\"+sp1.getcurrentstock()); sports sp2=new outdoorsports(); system.out.println(\"\\ntotal outdoor sports stock:\"+sp2.getcurrentstock()); sp2=new trekking(sp2); system.out.println(\"total outdoor sports stock:\"+sp2.getcurrentstock()); sp2=new cricket(sp2); system.out.println(\"total outdoor sports stock:\"+sp2.getcurrentstock()); sp2=new highjump(sp2); system.out.println(\"total outdoor sports stock:\"+sp2.getcurrentstock()); sp2=new longjump(sp2); system.out.println(\"total outdoor sports stock:\"+sp2.getcurrentstock()); }","comment":"\/\/ todo auto-generated method stub \/\/assuming stock of each sport is 2","repo":"Saba-d-coder\/6thSemIse","code_context_2":"public static void main(String[] args) {\n\/\/ TODO Auto-generated method stub\n\/\/Assuming stock of each sport is 2\nSports sp1=new IndoorSports();\nSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());","code_context_10":"public static void main(String[] args) {\n\/\/ TODO Auto-generated method stub\n\/\/Assuming stock of each sport is 2\nSports sp1=new IndoorSports();\nSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\nsp1=new Billiards(sp1);\nSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\nsp1=new Carrom(sp1);\nSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\nsp1=new Badminton(sp1);\nSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\nSports sp2=new OutdoorSports();\nSystem.out.println(\"\\nTotal Outdoor Sports Stock:\"+sp2.getCurrentStock());","code_context_20":"public static void main(String[] args) {\n\/\/ TODO Auto-generated method stub\n\/\/Assuming stock of each sport is 2\nSports sp1=new IndoorSports();\nSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\nsp1=new Billiards(sp1);\nSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\nsp1=new Carrom(sp1);\nSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\nsp1=new Badminton(sp1);\nSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\nSports sp2=new OutdoorSports();\nSystem.out.println(\"\\nTotal Outdoor Sports Stock:\"+sp2.getCurrentStock());\nsp2=new Trekking(sp2);\nSystem.out.println(\"Total Outdoor Sports Stock:\"+sp2.getCurrentStock());\nsp2=new Cricket(sp2);\nSystem.out.println(\"Total Outdoor Sports Stock:\"+sp2.getCurrentStock());\nsp2=new HighJump(sp2);\nSystem.out.println(\"Total Outdoor Sports Stock:\"+sp2.getCurrentStock());\nsp2=new LongJump(sp2);\nSystem.out.println(\"Total Outdoor Sports Stock:\"+sp2.getCurrentStock());\n}","label":[1,0,0,0]}
{"id":15413,"original_code":"public void put(String name, Scriptable start, Object value) {\n\t    try {\n\t\tObjectLocation variable = this.extractFieldVariable(name);\n\t\tif (value instanceof NativeArray) {\n\t\t    \/\/ FIXME this breaks referential equality, but maybe it's OK\n\t\t    variable.set(this.sequenceFromArray((NativeArray)value, start));\n\t\t    return;\n\t\t}\n\t\t\/\/System.err.println(\"variable \" + variable + \" new value \" + value + \" type \" + variable.getClass().getName());\n\t\tif (variable instanceof FloatLocation) { \/\/ FIXME FIXME super ad-hoc\n\t\t    value = Context.jsToJava(value, Float.class);\n\t\t} else if (value instanceof ObjectLocation) {\n\t\t    \/\/ here's a place where two locations could be bound to each other?\n\t\t    value = ((ObjectLocation)value).get();\n\t\t} else if (value instanceof Wrapper) {\n\t\t    \/\/ FIXME is there a better way???\n\t\t    value = ((Wrapper)value).unwrap();\n\t\t    if (value instanceof ObjectLocation) {\n\t\t\tvalue = ((ObjectLocation)value).get();\n\t\t    }\n\t\t}\n\t\tvariable.set(value); \n\t\treturn;\n\t    } catch (Exception e) { \n\t\te.printStackTrace(System.err);\n\t    }\n\t}","code":"public void put(String name, Scriptable start, Object value) {\n\t    try {\n\t\tObjectLocation variable = this.extractFieldVariable(name);\n\t\tif (value instanceof NativeArray) {\n\t\t   \n\t\t    variable.set(this.sequenceFromArray((NativeArray)value, start));\n\t\t    return;\n\t\t}\n\t\n\t\tif (variable instanceof FloatLocation) {\n\t\t    value = Context.jsToJava(value, Float.class);\n\t\t} else if (value instanceof ObjectLocation) {\n\t\t   \n\t\t    value = ((ObjectLocation)value).get();\n\t\t} else if (value instanceof Wrapper) {\n\t\t   \n\t\t    value = ((Wrapper)value).unwrap();\n\t\t    if (value instanceof ObjectLocation) {\n\t\t\tvalue = ((ObjectLocation)value).get();\n\t\t    }\n\t\t}\n\t\tvariable.set(value); \n\t\treturn;\n\t    } catch (Exception e) { \n\t\te.printStackTrace(System.err);\n\t    }\n\t}","cleancode":"public void put(string name, scriptable start, object value) { try { objectlocation variable = this.extractfieldvariable(name); if (value instanceof nativearray) { variable.set(this.sequencefromarray((nativearray)value, start)); return; } if (variable instanceof floatlocation) { value = context.jstojava(value, float.class); } else if (value instanceof objectlocation) { value = ((objectlocation)value).get(); } else if (value instanceof wrapper) { value = ((wrapper)value).unwrap(); if (value instanceof objectlocation) { value = ((objectlocation)value).get(); } } variable.set(value); return; } catch (exception e) { e.printstacktrace(system.err); } }","comment":"\/\/ fixme this breaks referential equality, but maybe it's ok\n\/\/system.err.println(\"variable \" + variable + \" new value \" + value + \" type \" + variable.getclass().getname());\n\/\/ fixme fixme super ad-hoc\n\/\/ here's a place where two locations could be bound to each other?\n\/\/ fixme is there a better way???","repo":"LivelyKernel\/sunlabs-kernel","code_context_2":"ObjectLocation variable = this.extractFieldVariable(name);\nif (value instanceof NativeArray) {\n\/\/ FIXME this breaks referential equality, but maybe it's OK\nvariable.set(this.sequenceFromArray((NativeArray)value, start));\nreturn;\n\nreturn;\n}\n\/\/System.err.println(\"variable \" + variable + \" new value \" + value + \" type \" + variable.getClass().getName());\nif (variable instanceof FloatLocation) { \/\/ FIXME FIXME super ad-hoc\nvalue = Context.jsToJava(value, Float.class);\n\n}\n\/\/System.err.println(\"variable \" + variable + \" new value \" + value + \" type \" + variable.getClass().getName());\nif (variable instanceof FloatLocation) { \/\/ FIXME FIXME super ad-hoc\nvalue = Context.jsToJava(value, Float.class);\n} else if (value instanceof ObjectLocation) {\n\nvalue = Context.jsToJava(value, Float.class);\n} else if (value instanceof ObjectLocation) {\n\/\/ here's a place where two locations could be bound to each other?\nvalue = ((ObjectLocation)value).get();\n} else if (value instanceof Wrapper) {\n\nvalue = ((ObjectLocation)value).get();\n} else if (value instanceof Wrapper) {\n\/\/ FIXME is there a better way???\nvalue = ((Wrapper)value).unwrap();\nif (value instanceof ObjectLocation) {","code_context_10":"public void put(String name, Scriptable start, Object value) {\ntry {\nObjectLocation variable = this.extractFieldVariable(name);\nif (value instanceof NativeArray) {\n\/\/ FIXME this breaks referential equality, but maybe it's OK\nvariable.set(this.sequenceFromArray((NativeArray)value, start));\nreturn;\n}\n\/\/System.err.println(\"variable \" + variable + \" new value \" + value + \" type \" + variable.getClass().getName());\nif (variable instanceof FloatLocation) { \/\/ FIXME FIXME super ad-hoc\nvalue = Context.jsToJava(value, Float.class);\n} else if (value instanceof ObjectLocation) {\n\/\/ here's a place where two locations could be bound to each other?\nvalue = ((ObjectLocation)value).get();\n} else if (value instanceof Wrapper) {\n\npublic void put(String name, Scriptable start, Object value) {\ntry {\nObjectLocation variable = this.extractFieldVariable(name);\nif (value instanceof NativeArray) {\n\/\/ FIXME this breaks referential equality, but maybe it's OK\nvariable.set(this.sequenceFromArray((NativeArray)value, start));\nreturn;\n}\n\/\/System.err.println(\"variable \" + variable + \" new value \" + value + \" type \" + variable.getClass().getName());\nif (variable instanceof FloatLocation) { \/\/ FIXME FIXME super ad-hoc\nvalue = Context.jsToJava(value, Float.class);\n} else if (value instanceof ObjectLocation) {\n\/\/ here's a place where two locations could be bound to each other?\nvalue = ((ObjectLocation)value).get();\n} else if (value instanceof Wrapper) {\n\/\/ FIXME is there a better way???\nvalue = ((Wrapper)value).unwrap();\nif (value instanceof ObjectLocation) {\nvalue = ((ObjectLocation)value).get();\n\npublic void put(String name, Scriptable start, Object value) {\ntry {\nObjectLocation variable = this.extractFieldVariable(name);\nif (value instanceof NativeArray) {\n\/\/ FIXME this breaks referential equality, but maybe it's OK\nvariable.set(this.sequenceFromArray((NativeArray)value, start));\nreturn;\n}\n\/\/System.err.println(\"variable \" + variable + \" new value \" + value + \" type \" + variable.getClass().getName());\nif (variable instanceof FloatLocation) { \/\/ FIXME FIXME super ad-hoc\nvalue = Context.jsToJava(value, Float.class);\n} else if (value instanceof ObjectLocation) {\n\/\/ here's a place where two locations could be bound to each other?\nvalue = ((ObjectLocation)value).get();\n} else if (value instanceof Wrapper) {\n\/\/ FIXME is there a better way???\nvalue = ((Wrapper)value).unwrap();\nif (value instanceof ObjectLocation) {\nvalue = ((ObjectLocation)value).get();\n}\n\nObjectLocation variable = this.extractFieldVariable(name);\nif (value instanceof NativeArray) {\n\/\/ FIXME this breaks referential equality, but maybe it's OK\nvariable.set(this.sequenceFromArray((NativeArray)value, start));\nreturn;\n}\n\/\/System.err.println(\"variable \" + variable + \" new value \" + value + \" type \" + variable.getClass().getName());\nif (variable instanceof FloatLocation) { \/\/ FIXME FIXME super ad-hoc\nvalue = Context.jsToJava(value, Float.class);\n} else if (value instanceof ObjectLocation) {\n\/\/ here's a place where two locations could be bound to each other?\nvalue = ((ObjectLocation)value).get();\n} else if (value instanceof Wrapper) {\n\/\/ FIXME is there a better way???\nvalue = ((Wrapper)value).unwrap();\nif (value instanceof ObjectLocation) {\nvalue = ((ObjectLocation)value).get();\n}\n}\nvariable.set(value);\nreturn;\n\nvariable.set(this.sequenceFromArray((NativeArray)value, start));\nreturn;\n}\n\/\/System.err.println(\"variable \" + variable + \" new value \" + value + \" type \" + variable.getClass().getName());\nif (variable instanceof FloatLocation) { \/\/ FIXME FIXME super ad-hoc\nvalue = Context.jsToJava(value, Float.class);\n} else if (value instanceof ObjectLocation) {\n\/\/ here's a place where two locations could be bound to each other?\nvalue = ((ObjectLocation)value).get();\n} else if (value instanceof Wrapper) {\n\/\/ FIXME is there a better way???\nvalue = ((Wrapper)value).unwrap();\nif (value instanceof ObjectLocation) {\nvalue = ((ObjectLocation)value).get();\n}\n}\nvariable.set(value);\nreturn;\n} catch (Exception e) {\ne.printStackTrace(System.err);\n}","code_context_20":"public void put(String name, Scriptable start, Object value) {\ntry {\nObjectLocation variable = this.extractFieldVariable(name);\nif (value instanceof NativeArray) {\n\/\/ FIXME this breaks referential equality, but maybe it's OK\nvariable.set(this.sequenceFromArray((NativeArray)value, start));\nreturn;\n}\n\/\/System.err.println(\"variable \" + variable + \" new value \" + value + \" type \" + variable.getClass().getName());\nif (variable instanceof FloatLocation) { \/\/ FIXME FIXME super ad-hoc\nvalue = Context.jsToJava(value, Float.class);\n} else if (value instanceof ObjectLocation) {\n\/\/ here's a place where two locations could be bound to each other?\nvalue = ((ObjectLocation)value).get();\n} else if (value instanceof Wrapper) {\n\/\/ FIXME is there a better way???\nvalue = ((Wrapper)value).unwrap();\nif (value instanceof ObjectLocation) {\nvalue = ((ObjectLocation)value).get();\n}\n}\nvariable.set(value);\nreturn;\n} catch (Exception e) {\ne.printStackTrace(System.err);\n\npublic void put(String name, Scriptable start, Object value) {\ntry {\nObjectLocation variable = this.extractFieldVariable(name);\nif (value instanceof NativeArray) {\n\/\/ FIXME this breaks referential equality, but maybe it's OK\nvariable.set(this.sequenceFromArray((NativeArray)value, start));\nreturn;\n}\n\/\/System.err.println(\"variable \" + variable + \" new value \" + value + \" type \" + variable.getClass().getName());\nif (variable instanceof FloatLocation) { \/\/ FIXME FIXME super ad-hoc\nvalue = Context.jsToJava(value, Float.class);\n} else if (value instanceof ObjectLocation) {\n\/\/ here's a place where two locations could be bound to each other?\nvalue = ((ObjectLocation)value).get();\n} else if (value instanceof Wrapper) {\n\/\/ FIXME is there a better way???\nvalue = ((Wrapper)value).unwrap();\nif (value instanceof ObjectLocation) {\nvalue = ((ObjectLocation)value).get();\n}\n}\nvariable.set(value);\nreturn;\n} catch (Exception e) {\ne.printStackTrace(System.err);\n}\n}\n\npublic void put(String name, Scriptable start, Object value) {\ntry {\nObjectLocation variable = this.extractFieldVariable(name);\nif (value instanceof NativeArray) {\n\/\/ FIXME this breaks referential equality, but maybe it's OK\nvariable.set(this.sequenceFromArray((NativeArray)value, start));\nreturn;\n}\n\/\/System.err.println(\"variable \" + variable + \" new value \" + value + \" type \" + variable.getClass().getName());\nif (variable instanceof FloatLocation) { \/\/ FIXME FIXME super ad-hoc\nvalue = Context.jsToJava(value, Float.class);\n} else if (value instanceof ObjectLocation) {\n\/\/ here's a place where two locations could be bound to each other?\nvalue = ((ObjectLocation)value).get();\n} else if (value instanceof Wrapper) {\n\/\/ FIXME is there a better way???\nvalue = ((Wrapper)value).unwrap();\nif (value instanceof ObjectLocation) {\nvalue = ((ObjectLocation)value).get();\n}\n}\nvariable.set(value);\nreturn;\n} catch (Exception e) {\ne.printStackTrace(System.err);\n}\n}\n\npublic void put(String name, Scriptable start, Object value) {\ntry {\nObjectLocation variable = this.extractFieldVariable(name);\nif (value instanceof NativeArray) {\n\/\/ FIXME this breaks referential equality, but maybe it's OK\nvariable.set(this.sequenceFromArray((NativeArray)value, start));\nreturn;\n}\n\/\/System.err.println(\"variable \" + variable + \" new value \" + value + \" type \" + variable.getClass().getName());\nif (variable instanceof FloatLocation) { \/\/ FIXME FIXME super ad-hoc\nvalue = Context.jsToJava(value, Float.class);\n} else if (value instanceof ObjectLocation) {\n\/\/ here's a place where two locations could be bound to each other?\nvalue = ((ObjectLocation)value).get();\n} else if (value instanceof Wrapper) {\n\/\/ FIXME is there a better way???\nvalue = ((Wrapper)value).unwrap();\nif (value instanceof ObjectLocation) {\nvalue = ((ObjectLocation)value).get();\n}\n}\nvariable.set(value);\nreturn;\n} catch (Exception e) {\ne.printStackTrace(System.err);\n}\n}\n\npublic void put(String name, Scriptable start, Object value) {\ntry {\nObjectLocation variable = this.extractFieldVariable(name);\nif (value instanceof NativeArray) {\n\/\/ FIXME this breaks referential equality, but maybe it's OK\nvariable.set(this.sequenceFromArray((NativeArray)value, start));\nreturn;\n}\n\/\/System.err.println(\"variable \" + variable + \" new value \" + value + \" type \" + variable.getClass().getName());\nif (variable instanceof FloatLocation) { \/\/ FIXME FIXME super ad-hoc\nvalue = Context.jsToJava(value, Float.class);\n} else if (value instanceof ObjectLocation) {\n\/\/ here's a place where two locations could be bound to each other?\nvalue = ((ObjectLocation)value).get();\n} else if (value instanceof Wrapper) {\n\/\/ FIXME is there a better way???\nvalue = ((Wrapper)value).unwrap();\nif (value instanceof ObjectLocation) {\nvalue = ((ObjectLocation)value).get();\n}\n}\nvariable.set(value);\nreturn;\n} catch (Exception e) {\ne.printStackTrace(System.err);\n}\n}","label":[1,0,1,0]}
{"id":15430,"original_code":"private static Method getMethod() {\n\t\treturn method.get(0);\n\t}","code":"private static Method getMethod() {\n\t\treturn method.get(0);\n\t}","cleancode":"private static method getmethod() { return method.get(0); }","comment":"\/\/ note: do not change method","repo":"Modify24x7\/ApkStringDecryptor","code_context_2":"private static Method getMethod() {\nreturn method.get(0);\n}","code_context_10":"private static Method getMethod() {\nreturn method.get(0);\n}","code_context_20":"private static Method getMethod() {\nreturn method.get(0);\n}","label":[1,0,0,0]}
{"id":15621,"original_code":"private boolean initCipher() {\n        try {\n            \/\/Obtain a cipher instance and configure it with the properties required for fingerprint authentication\/\/\n            if(this.cipher == null) {\n                this.cipher = Cipher.getInstance(\n                        KeyProperties.KEY_ALGORITHM_AES + \"\/\"\n                                + KeyProperties.BLOCK_MODE_CBC + \"\/\"\n                                + KeyProperties.ENCRYPTION_PADDING_PKCS7);\n            }\n        } catch (NoSuchAlgorithmException |\n                NoSuchPaddingException e) {\n            e.printStackTrace();\n            return false;\n        }\n        try {\n            if(this.secretKey == null) {\n                this.secretKey = generateKey();\n            }\n            if(this.keyStore != null) {\n                if(!this.keystoreInitialized) {\n                    this.keyStore.load(null);\n                    this.keystoreInitialized = true;\n                }\n            }\n\/\/            key = (SecretKey) this.keyStore.getKey(keyName, null); todo needed?\n            if(this.cipher != null) {\n                if (!this.cipherInitialized) {\n                    this.cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);\n                    this.cipherInitialized = true;\n                }\n            }\n            \/\/Return true if the cipher has been initialized successfully\/\/\n            return true;\n        } catch (KeyPermanentlyInvalidatedException e) {\n            \/\/Return false if cipher initialization failed\/\/\n            return false;\n        } catch (CertificateException \/\/KeyStoreException\n                | IOException \/\/UnrecoverableKeyException\n                | NullPointerException\n                | NoSuchAlgorithmException | InvalidKeyException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }","code":"private boolean initCipher() {\n        try {\n           \n            if(this.cipher == null) {\n                this.cipher = Cipher.getInstance(\n                        KeyProperties.KEY_ALGORITHM_AES + \"\/\"\n                                + KeyProperties.BLOCK_MODE_CBC + \"\/\"\n                                + KeyProperties.ENCRYPTION_PADDING_PKCS7);\n            }\n        } catch (NoSuchAlgorithmException |\n                NoSuchPaddingException e) {\n            e.printStackTrace();\n            return false;\n        }\n        try {\n            if(this.secretKey == null) {\n                this.secretKey = generateKey();\n            }\n            if(this.keyStore != null) {\n                if(!this.keystoreInitialized) {\n                    this.keyStore.load(null);\n                    this.keystoreInitialized = true;\n                }\n            }\n            if(this.cipher != null) {\n                if (!this.cipherInitialized) {\n                    this.cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);\n                    this.cipherInitialized = true;\n                }\n            }\n           \n            return true;\n        } catch (KeyPermanentlyInvalidatedException e) {\n           \n            return false;\n        } catch (CertificateException\n                | IOException\n                | NullPointerException\n                | NoSuchAlgorithmException | InvalidKeyException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }","cleancode":"private boolean initcipher() { try { if(this.cipher == null) { this.cipher = cipher.getinstance( keyproperties.key_algorithm_aes + \"\/\" + keyproperties.block_mode_cbc + \"\/\" + keyproperties.encryption_padding_pkcs7); } } catch (nosuchalgorithmexception | nosuchpaddingexception e) { e.printstacktrace(); return false; } try { if(this.secretkey == null) { this.secretkey = generatekey(); } if(this.keystore != null) { if(!this.keystoreinitialized) { this.keystore.load(null); this.keystoreinitialized = true; } } if(this.cipher != null) { if (!this.cipherinitialized) { this.cipher.init(cipher.encrypt_mode, this.secretkey); this.cipherinitialized = true; } } return true; } catch (keypermanentlyinvalidatedexception e) { return false; } catch (certificateexception | ioexception | nullpointerexception | nosuchalgorithmexception | invalidkeyexception e) { e.printstacktrace(); return false; } }","comment":"\/** * initialize the cipher * @return true if it succeeded false if it did not *\/\n\/\/obtain a cipher instance and configure it with the properties required for fingerprint authentication\/\/\n\/\/ key = (secretkey) this.keystore.getkey(keyname, null); todo needed?\n\/\/return true if the cipher has been initialized successfully\/\/\n\/\/return false if cipher initialization failed\/\/\n\/\/keystoreexception\n\/\/unrecoverablekeyexception","repo":"PGMacDesign\/PGMacTips","code_context_2":"private boolean initCipher() {\ntry {\n\/\/Obtain a cipher instance and configure it with the properties required for fingerprint authentication\/\/\nif(this.cipher == null) {\nthis.cipher = Cipher.getInstance(\nKeyProperties.KEY_ALGORITHM_AES + \"\/\"\n+ KeyProperties.BLOCK_MODE_CBC + \"\/\"\n+ KeyProperties.ENCRYPTION_PADDING_PKCS7);\n}\n} catch (NoSuchAlgorithmException |\nNoSuchPaddingException e) {\ne.printStackTrace();\nreturn false;\n}\ntry {\nif(this.secretKey == null) {\nthis.secretKey = generateKey();\n}\nif(this.keyStore != null) {\nif(!this.keystoreInitialized) {\nthis.keyStore.load(null);\nthis.keystoreInitialized = true;\n}\n}\n\/\/ key = (SecretKey) this.keyStore.getKey(keyName, null); todo needed?\nif(this.cipher != null) {\nif (!this.cipherInitialized) {\nthis.cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);\nthis.cipherInitialized = true;\n}\n}\n\/\/Return true if the cipher has been initialized successfully\/\/\nreturn true;\n} catch (KeyPermanentlyInvalidatedException e) {\n\/\/Return false if cipher initialization failed\/\/\nreturn false;\n} catch (CertificateException \/\/KeyStoreException\n| IOException \/\/UnrecoverableKeyException\n| NullPointerException\n| NoSuchAlgorithmException | InvalidKeyException e) {\ne.printStackTrace();\nreturn false;\n}\n}\n\nprivate boolean initCipher() {\ntry {\n\/\/Obtain a cipher instance and configure it with the properties required for fingerprint authentication\/\/\nif(this.cipher == null) {\nthis.cipher = Cipher.getInstance(\n\n}\n}\n\/\/ key = (SecretKey) this.keyStore.getKey(keyName, null); todo needed?\nif(this.cipher != null) {\nif (!this.cipherInitialized) {\n\n}\n}\n\/\/Return true if the cipher has been initialized successfully\/\/\nreturn true;\n} catch (KeyPermanentlyInvalidatedException e) {\n\nreturn true;\n} catch (KeyPermanentlyInvalidatedException e) {\n\/\/Return false if cipher initialization failed\/\/\nreturn false;\n} catch (CertificateException \/\/KeyStoreException\n\n\/\/Return false if cipher initialization failed\/\/\nreturn false;\n} catch (CertificateException \/\/KeyStoreException\n| IOException \/\/UnrecoverableKeyException\n| NullPointerException\n\nreturn false;\n} catch (CertificateException \/\/KeyStoreException\n| IOException \/\/UnrecoverableKeyException\n| NullPointerException\n| NoSuchAlgorithmException | InvalidKeyException e) {","code_context_10":"private boolean initCipher() {\ntry {\n\/\/Obtain a cipher instance and configure it with the properties required for fingerprint authentication\/\/\nif(this.cipher == null) {\nthis.cipher = Cipher.getInstance(\nKeyProperties.KEY_ALGORITHM_AES + \"\/\"\n+ KeyProperties.BLOCK_MODE_CBC + \"\/\"\n+ KeyProperties.ENCRYPTION_PADDING_PKCS7);\n}\n} catch (NoSuchAlgorithmException |\nNoSuchPaddingException e) {\ne.printStackTrace();\nreturn false;\n}\ntry {\nif(this.secretKey == null) {\nthis.secretKey = generateKey();\n}\nif(this.keyStore != null) {\nif(!this.keystoreInitialized) {\nthis.keyStore.load(null);\nthis.keystoreInitialized = true;\n}\n}\n\/\/ key = (SecretKey) this.keyStore.getKey(keyName, null); todo needed?\nif(this.cipher != null) {\nif (!this.cipherInitialized) {\nthis.cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);\nthis.cipherInitialized = true;\n}\n}\n\/\/Return true if the cipher has been initialized successfully\/\/\nreturn true;\n} catch (KeyPermanentlyInvalidatedException e) {\n\/\/Return false if cipher initialization failed\/\/\nreturn false;\n} catch (CertificateException \/\/KeyStoreException\n| IOException \/\/UnrecoverableKeyException\n| NullPointerException\n| NoSuchAlgorithmException | InvalidKeyException e) {\ne.printStackTrace();\nreturn false;\n}\n}\n\nprivate boolean initCipher() {\ntry {\n\/\/Obtain a cipher instance and configure it with the properties required for fingerprint authentication\/\/\nif(this.cipher == null) {\nthis.cipher = Cipher.getInstance(\nKeyProperties.KEY_ALGORITHM_AES + \"\/\"\n+ KeyProperties.BLOCK_MODE_CBC + \"\/\"\n+ KeyProperties.ENCRYPTION_PADDING_PKCS7);\n}\n} catch (NoSuchAlgorithmException |\nNoSuchPaddingException e) {\ne.printStackTrace();\nreturn false;\n\ntry {\nif(this.secretKey == null) {\nthis.secretKey = generateKey();\n}\nif(this.keyStore != null) {\nif(!this.keystoreInitialized) {\nthis.keyStore.load(null);\nthis.keystoreInitialized = true;\n}\n}\n\/\/ key = (SecretKey) this.keyStore.getKey(keyName, null); todo needed?\nif(this.cipher != null) {\nif (!this.cipherInitialized) {\nthis.cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);\nthis.cipherInitialized = true;\n}\n}\n\/\/Return true if the cipher has been initialized successfully\/\/\nreturn true;\n} catch (KeyPermanentlyInvalidatedException e) {\n\/\/Return false if cipher initialization failed\/\/\n\nthis.keystoreInitialized = true;\n}\n}\n\/\/ key = (SecretKey) this.keyStore.getKey(keyName, null); todo needed?\nif(this.cipher != null) {\nif (!this.cipherInitialized) {\nthis.cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);\nthis.cipherInitialized = true;\n}\n}\n\/\/Return true if the cipher has been initialized successfully\/\/\nreturn true;\n} catch (KeyPermanentlyInvalidatedException e) {\n\/\/Return false if cipher initialization failed\/\/\nreturn false;\n} catch (CertificateException \/\/KeyStoreException\n| IOException \/\/UnrecoverableKeyException\n| NullPointerException\n| NoSuchAlgorithmException | InvalidKeyException e) {\ne.printStackTrace();\nreturn false;\n\n\/\/ key = (SecretKey) this.keyStore.getKey(keyName, null); todo needed?\nif(this.cipher != null) {\nif (!this.cipherInitialized) {\nthis.cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);\nthis.cipherInitialized = true;\n}\n}\n\/\/Return true if the cipher has been initialized successfully\/\/\nreturn true;\n} catch (KeyPermanentlyInvalidatedException e) {\n\/\/Return false if cipher initialization failed\/\/\nreturn false;\n} catch (CertificateException \/\/KeyStoreException\n| IOException \/\/UnrecoverableKeyException\n| NullPointerException\n| NoSuchAlgorithmException | InvalidKeyException e) {\ne.printStackTrace();\nreturn false;\n}\n}\n\nif (!this.cipherInitialized) {\nthis.cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);\nthis.cipherInitialized = true;\n}\n}\n\/\/Return true if the cipher has been initialized successfully\/\/\nreturn true;\n} catch (KeyPermanentlyInvalidatedException e) {\n\/\/Return false if cipher initialization failed\/\/\nreturn false;\n} catch (CertificateException \/\/KeyStoreException\n| IOException \/\/UnrecoverableKeyException\n| NullPointerException\n| NoSuchAlgorithmException | InvalidKeyException e) {\ne.printStackTrace();\nreturn false;\n}\n}\n\nthis.cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);\nthis.cipherInitialized = true;\n}\n}\n\/\/Return true if the cipher has been initialized successfully\/\/\nreturn true;\n} catch (KeyPermanentlyInvalidatedException e) {\n\/\/Return false if cipher initialization failed\/\/\nreturn false;\n} catch (CertificateException \/\/KeyStoreException\n| IOException \/\/UnrecoverableKeyException\n| NullPointerException\n| NoSuchAlgorithmException | InvalidKeyException e) {\ne.printStackTrace();\nreturn false;\n}\n}","code_context_20":"private boolean initCipher() {\ntry {\n\/\/Obtain a cipher instance and configure it with the properties required for fingerprint authentication\/\/\nif(this.cipher == null) {\nthis.cipher = Cipher.getInstance(\nKeyProperties.KEY_ALGORITHM_AES + \"\/\"\n+ KeyProperties.BLOCK_MODE_CBC + \"\/\"\n+ KeyProperties.ENCRYPTION_PADDING_PKCS7);\n}\n} catch (NoSuchAlgorithmException |\nNoSuchPaddingException e) {\ne.printStackTrace();\nreturn false;\n}\ntry {\nif(this.secretKey == null) {\nthis.secretKey = generateKey();\n}\nif(this.keyStore != null) {\nif(!this.keystoreInitialized) {\nthis.keyStore.load(null);\nthis.keystoreInitialized = true;\n}\n}\n\/\/ key = (SecretKey) this.keyStore.getKey(keyName, null); todo needed?\nif(this.cipher != null) {\nif (!this.cipherInitialized) {\nthis.cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);\nthis.cipherInitialized = true;\n}\n}\n\/\/Return true if the cipher has been initialized successfully\/\/\nreturn true;\n} catch (KeyPermanentlyInvalidatedException e) {\n\/\/Return false if cipher initialization failed\/\/\nreturn false;\n} catch (CertificateException \/\/KeyStoreException\n| IOException \/\/UnrecoverableKeyException\n| NullPointerException\n| NoSuchAlgorithmException | InvalidKeyException e) {\ne.printStackTrace();\nreturn false;\n}\n}\n\nprivate boolean initCipher() {\ntry {\n\/\/Obtain a cipher instance and configure it with the properties required for fingerprint authentication\/\/\nif(this.cipher == null) {\nthis.cipher = Cipher.getInstance(\nKeyProperties.KEY_ALGORITHM_AES + \"\/\"\n+ KeyProperties.BLOCK_MODE_CBC + \"\/\"\n+ KeyProperties.ENCRYPTION_PADDING_PKCS7);\n}\n} catch (NoSuchAlgorithmException |\nNoSuchPaddingException e) {\ne.printStackTrace();\nreturn false;\n}\ntry {\nif(this.secretKey == null) {\nthis.secretKey = generateKey();\n}\nif(this.keyStore != null) {\nif(!this.keystoreInitialized) {\nthis.keyStore.load(null);\nthis.keystoreInitialized = true;\n}\n\nthis.cipher = Cipher.getInstance(\nKeyProperties.KEY_ALGORITHM_AES + \"\/\"\n+ KeyProperties.BLOCK_MODE_CBC + \"\/\"\n+ KeyProperties.ENCRYPTION_PADDING_PKCS7);\n}\n} catch (NoSuchAlgorithmException |\nNoSuchPaddingException e) {\ne.printStackTrace();\nreturn false;\n}\ntry {\nif(this.secretKey == null) {\nthis.secretKey = generateKey();\n}\nif(this.keyStore != null) {\nif(!this.keystoreInitialized) {\nthis.keyStore.load(null);\nthis.keystoreInitialized = true;\n}\n}\n\/\/ key = (SecretKey) this.keyStore.getKey(keyName, null); todo needed?\nif(this.cipher != null) {\nif (!this.cipherInitialized) {\nthis.cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);\nthis.cipherInitialized = true;\n}\n}\n\/\/Return true if the cipher has been initialized successfully\/\/\nreturn true;\n} catch (KeyPermanentlyInvalidatedException e) {\n\/\/Return false if cipher initialization failed\/\/\nreturn false;\n} catch (CertificateException \/\/KeyStoreException\n| IOException \/\/UnrecoverableKeyException\n| NullPointerException\n| NoSuchAlgorithmException | InvalidKeyException e) {\ne.printStackTrace();\nreturn false;\n}\n}\n\ne.printStackTrace();\nreturn false;\n}\ntry {\nif(this.secretKey == null) {\nthis.secretKey = generateKey();\n}\nif(this.keyStore != null) {\nif(!this.keystoreInitialized) {\nthis.keyStore.load(null);\nthis.keystoreInitialized = true;\n}\n}\n\/\/ key = (SecretKey) this.keyStore.getKey(keyName, null); todo needed?\nif(this.cipher != null) {\nif (!this.cipherInitialized) {\nthis.cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);\nthis.cipherInitialized = true;\n}\n}\n\/\/Return true if the cipher has been initialized successfully\/\/\nreturn true;\n} catch (KeyPermanentlyInvalidatedException e) {\n\/\/Return false if cipher initialization failed\/\/\nreturn false;\n} catch (CertificateException \/\/KeyStoreException\n| IOException \/\/UnrecoverableKeyException\n| NullPointerException\n| NoSuchAlgorithmException | InvalidKeyException e) {\ne.printStackTrace();\nreturn false;\n}\n}\n\ntry {\nif(this.secretKey == null) {\nthis.secretKey = generateKey();\n}\nif(this.keyStore != null) {\nif(!this.keystoreInitialized) {\nthis.keyStore.load(null);\nthis.keystoreInitialized = true;\n}\n}\n\/\/ key = (SecretKey) this.keyStore.getKey(keyName, null); todo needed?\nif(this.cipher != null) {\nif (!this.cipherInitialized) {\nthis.cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);\nthis.cipherInitialized = true;\n}\n}\n\/\/Return true if the cipher has been initialized successfully\/\/\nreturn true;\n} catch (KeyPermanentlyInvalidatedException e) {\n\/\/Return false if cipher initialization failed\/\/\nreturn false;\n} catch (CertificateException \/\/KeyStoreException\n| IOException \/\/UnrecoverableKeyException\n| NullPointerException\n| NoSuchAlgorithmException | InvalidKeyException e) {\ne.printStackTrace();\nreturn false;\n}\n}\n\nthis.secretKey = generateKey();\n}\nif(this.keyStore != null) {\nif(!this.keystoreInitialized) {\nthis.keyStore.load(null);\nthis.keystoreInitialized = true;\n}\n}\n\/\/ key = (SecretKey) this.keyStore.getKey(keyName, null); todo needed?\nif(this.cipher != null) {\nif (!this.cipherInitialized) {\nthis.cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);\nthis.cipherInitialized = true;\n}\n}\n\/\/Return true if the cipher has been initialized successfully\/\/\nreturn true;\n} catch (KeyPermanentlyInvalidatedException e) {\n\/\/Return false if cipher initialization failed\/\/\nreturn false;\n} catch (CertificateException \/\/KeyStoreException\n| IOException \/\/UnrecoverableKeyException\n| NullPointerException\n| NoSuchAlgorithmException | InvalidKeyException e) {\ne.printStackTrace();\nreturn false;\n}\n}\n\n}\nif(this.keyStore != null) {\nif(!this.keystoreInitialized) {\nthis.keyStore.load(null);\nthis.keystoreInitialized = true;\n}\n}\n\/\/ key = (SecretKey) this.keyStore.getKey(keyName, null); todo needed?\nif(this.cipher != null) {\nif (!this.cipherInitialized) {\nthis.cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);\nthis.cipherInitialized = true;\n}\n}\n\/\/Return true if the cipher has been initialized successfully\/\/\nreturn true;\n} catch (KeyPermanentlyInvalidatedException e) {\n\/\/Return false if cipher initialization failed\/\/\nreturn false;\n} catch (CertificateException \/\/KeyStoreException\n| IOException \/\/UnrecoverableKeyException\n| NullPointerException\n| NoSuchAlgorithmException | InvalidKeyException e) {\ne.printStackTrace();\nreturn false;\n}\n}","label":[1,0,0,0]}
{"id":23837,"original_code":"private void writeRunnerProject() throws IOException, XmlException, ParseException {\n        \/\/ TODO revise whole method\n        \/\/ TODO now using a newer JAPA (suuports java 8), -> maybe ANTLR supports better\n        PathUtils.createDir(getRunnerProjectSettings().getBaseDir().toPath());\n        \/\/ copy snippets\n        PathUtils.copy(getSnippetProject().getSourceDir(),\n                getRunnerProjectSettings().getSnippetSourceDirectory().toPath());\n        \/\/ create INFO file\n        writeInfoFile();\n        \/\/ remove SETTE annotations and imports from file\n        Collection<File> filesWritten = Files\n                .walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n                .filter(Files::isRegularFile).map(Path::toFile).sorted()\n                .collect(Collectors.toList());\n        for (File file : filesWritten) {\n            \/\/ parse source with JavaParser\n            log.debug(\"Parsing with JavaParser: {}\", file);\n            CompilationUnit compilationUnit = JavaParser.parse(file);\n            log.debug(\"Parsed with JavaParser: {}\", file);\n            \/\/ extract type\n            List<TypeDeclaration> types = compilationUnit.getTypes();\n            if (types.size() != 1) {\n                \/\/ NOTE better exception type\n                throw new RuntimeException(\n                        \"Java source files containing more that one types are not supported\");\n            }\n            TypeDeclaration type = types.get(0);\n            \/\/ skip file if Java version is not supported by the tool (@SetteSnippetContainer)\n            \/\/ NOTE it can be also done with snippet containers... (and also done in CATG\n            \/\/ generator!)\n            List<AnnotationExpr> classAnnotations = type.getAnnotations();\n            JavaVersion reqJavaVer = getRequiredJavaVersion(classAnnotations);\n            if (reqJavaVer != null && !getTool().supportsJavaVersion(reqJavaVer)) {\n                System.err.println(\n                        \"Skipping file: \" + file + \" (required Java version: \" + reqJavaVer + \")\");\n                PathUtils.delete(file.toPath());\n            } else {\n                \/\/ remove SETTE annotations from the class\n                Predicate<AnnotationExpr> isSetteAnnotation = (a -> a.getName().getName()\n                        .startsWith(\"Sette\"));\n                classAnnotations.removeIf(isSetteAnnotation);\n                \/\/ remove SETTE annotations from the members\n                for (BodyDeclaration member : type.getMembers()) {\n                    member.getAnnotations().removeIf(isSetteAnnotation);\n                }\n                \/\/ TODO enhance\n                List<String> toRemovePrefixes = new ArrayList<>();\n                toRemovePrefixes.add(\"hu.bme.mit.sette.snippets.inputs\");\n                toRemovePrefixes.add(\"hu.bme.mit.sette.common\");\n                \/\/ remove SETTE imports\n                compilationUnit.getImports().removeIf(importDeclaration -> {\n                    String impDecl = importDeclaration.getName().toString();\n                    for (String prefix : toRemovePrefixes) {\n                        if (impDecl.startsWith(prefix)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                });\n                \/\/ save edited source code\n                String source = compilationUnit.toString();\n                if (type instanceof EnumDeclaration) {\n                    \/\/ FIXME remove after javaparser bug is fixed\n                    source = source.replaceFirst(type.getName() + \"\\\\s+implements\\\\s*\\\\{\",\n                            type.getName() + \" {\");\n                }\n                PathUtils.write(file.toPath(), source.getBytes());\n            }\n        }\n        \/\/ copy libraries\n        if (getSnippetProject().getLibDir().toFile().exists()) {\n            PathUtils.copy(getSnippetProject().getLibDir(),\n                    getRunnerProjectSettings().getSnippetLibraryDirectory().toPath());\n        }\n        \/\/ create project\n        this.eclipseProject.save(getRunnerProjectSettings().getBaseDir().toPath());\n    }","code":"private void writeRunnerProject() throws IOException, XmlException, ParseException {\n       \n       \n        PathUtils.createDir(getRunnerProjectSettings().getBaseDir().toPath());\n       \n        PathUtils.copy(getSnippetProject().getSourceDir(),\n                getRunnerProjectSettings().getSnippetSourceDirectory().toPath());\n       \n        writeInfoFile();\n       \n        Collection<File> filesWritten = Files\n                .walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n                .filter(Files::isRegularFile).map(Path::toFile).sorted()\n                .collect(Collectors.toList());\n        for (File file : filesWritten) {\n           \n            log.debug(\"Parsing with JavaParser: {}\", file);\n            CompilationUnit compilationUnit = JavaParser.parse(file);\n            log.debug(\"Parsed with JavaParser: {}\", file);\n           \n            List<TypeDeclaration> types = compilationUnit.getTypes();\n            if (types.size() != 1) {\n               \n                throw new RuntimeException(\n                        \"Java source files containing more that one types are not supported\");\n            }\n            TypeDeclaration type = types.get(0);\n           \n           \n           \n            List<AnnotationExpr> classAnnotations = type.getAnnotations();\n            JavaVersion reqJavaVer = getRequiredJavaVersion(classAnnotations);\n            if (reqJavaVer != null && !getTool().supportsJavaVersion(reqJavaVer)) {\n                System.err.println(\n                        \"Skipping file: \" + file + \" (required Java version: \" + reqJavaVer + \")\");\n                PathUtils.delete(file.toPath());\n            } else {\n               \n                Predicate<AnnotationExpr> isSetteAnnotation = (a -> a.getName().getName()\n                        .startsWith(\"Sette\"));\n                classAnnotations.removeIf(isSetteAnnotation);\n               \n                for (BodyDeclaration member : type.getMembers()) {\n                    member.getAnnotations().removeIf(isSetteAnnotation);\n                }\n               \n                List<String> toRemovePrefixes = new ArrayList<>();\n                toRemovePrefixes.add(\"hu.bme.mit.sette.snippets.inputs\");\n                toRemovePrefixes.add(\"hu.bme.mit.sette.common\");\n               \n                compilationUnit.getImports().removeIf(importDeclaration -> {\n                    String impDecl = importDeclaration.getName().toString();\n                    for (String prefix : toRemovePrefixes) {\n                        if (impDecl.startsWith(prefix)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                });\n               \n                String source = compilationUnit.toString();\n                if (type instanceof EnumDeclaration) {\n                   \n                    source = source.replaceFirst(type.getName() + \"\\\\s+implements\\\\s*\\\\{\",\n                            type.getName() + \" {\");\n                }\n                PathUtils.write(file.toPath(), source.getBytes());\n            }\n        }\n       \n        if (getSnippetProject().getLibDir().toFile().exists()) {\n            PathUtils.copy(getSnippetProject().getLibDir(),\n                    getRunnerProjectSettings().getSnippetLibraryDirectory().toPath());\n        }\n       \n        this.eclipseProject.save(getRunnerProjectSettings().getBaseDir().toPath());\n    }","cleancode":"private void writerunnerproject() throws ioexception, xmlexception, parseexception { pathutils.createdir(getrunnerprojectsettings().getbasedir().topath()); pathutils.copy(getsnippetproject().getsourcedir(), getrunnerprojectsettings().getsnippetsourcedirectory().topath()); writeinfofile(); collection<file> fileswritten = files .walk(getrunnerprojectsettings().getsnippetsourcedirectory().topath()) .filter(files::isregularfile).map(path::tofile).sorted() .collect(collectors.tolist()); for (file file : fileswritten) { log.debug(\"parsing with javaparser: {}\", file); compilationunit compilationunit = javaparser.parse(file); log.debug(\"parsed with javaparser: {}\", file); list<typedeclaration> types = compilationunit.gettypes(); if (types.size() != 1) { throw new runtimeexception( \"java source files containing more that one types are not supported\"); } typedeclaration type = types.get(0); list<annotationexpr> classannotations = type.getannotations(); javaversion reqjavaver = getrequiredjavaversion(classannotations); if (reqjavaver != null && !gettool().supportsjavaversion(reqjavaver)) { system.err.println( \"skipping file: \" + file + \" (required java version: \" + reqjavaver + \")\"); pathutils.delete(file.topath()); } else { predicate<annotationexpr> issetteannotation = (a -> a.getname().getname() .startswith(\"sette\")); classannotations.removeif(issetteannotation); for (bodydeclaration member : type.getmembers()) { member.getannotations().removeif(issetteannotation); } list<string> toremoveprefixes = new arraylist<>(); toremoveprefixes.add(\"hu.bme.mit.sette.snippets.inputs\"); toremoveprefixes.add(\"hu.bme.mit.sette.common\"); compilationunit.getimports().removeif(importdeclaration -> { string impdecl = importdeclaration.getname().tostring(); for (string prefix : toremoveprefixes) { if (impdecl.startswith(prefix)) { return true; } } return false; }); string source = compilationunit.tostring(); if (type instanceof enumdeclaration) { source = source.replacefirst(type.getname() + \"\\\\s+implements\\\\s*\\\\{\", type.getname() + \" {\"); } pathutils.write(file.topath(), source.getbytes()); } } if (getsnippetproject().getlibdir().tofile().exists()) { pathutils.copy(getsnippetproject().getlibdir(), getrunnerprojectsettings().getsnippetlibrarydirectory().topath()); } this.eclipseproject.save(getrunnerprojectsettings().getbasedir().topath()); }","comment":"\/** * writes the runner project out. * * @throws ioexception * signals that an i\/o exception has occurred. * @throws parseexception * if the source code has parser errors. * @throws xmlexception * if an xml related exception occurs. *\/\n\/\/ todo revise whole method \/\/ todo now using a newer japa (suuports java 8), -> maybe antlr supports better\n\/\/ copy snippets\n\/\/ create info file\n\/\/ remove sette annotations and imports from file\n\/\/ parse source with javaparser\n\/\/ extract type\n\/\/ note better exception type\n\/\/ skip file if java version is not supported by the tool (@settesnippetcontainer) \/\/ note it can be also done with snippet containers... (and also done in catg \/\/ generator!)\n\/\/ remove sette annotations from the class\n\/\/ remove sette annotations from the members\n\/\/ todo enhance\n\/\/ remove sette imports\n\/\/ save edited source code\n\/\/ fixme remove after javaparser bug is fixed\n\/\/ copy libraries\n\/\/ create project","repo":"SETTE-Testing\/sette-tool","code_context_2":"private void writeRunnerProject() throws IOException, XmlException, ParseException {\n\/\/ TODO revise whole method\n\/\/ TODO now using a newer JAPA (suuports java 8), -> maybe ANTLR supports better\nPathUtils.createDir(getRunnerProjectSettings().getBaseDir().toPath());\n\/\/ copy snippets\nPathUtils.copy(getSnippetProject().getSourceDir(),\ngetRunnerProjectSettings().getSnippetSourceDirectory().toPath());\n\/\/ create INFO file\nwriteInfoFile();\n\/\/ remove SETTE annotations and imports from file\nCollection<File> filesWritten = Files\n.walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n.filter(Files::isRegularFile).map(Path::toFile).sorted()\n.collect(Collectors.toList());\nfor (File file : filesWritten) {\n\/\/ parse source with JavaParser\nlog.debug(\"Parsing with JavaParser: {}\", file);\nCompilationUnit compilationUnit = JavaParser.parse(file);\nlog.debug(\"Parsed with JavaParser: {}\", file);\n\/\/ extract type\nList<TypeDeclaration> types = compilationUnit.getTypes();\nif (types.size() != 1) {\n\/\/ NOTE better exception type\nthrow new RuntimeException(\n\"Java source files containing more that one types are not supported\");\n}\nTypeDeclaration type = types.get(0);\n\/\/ skip file if Java version is not supported by the tool (@SetteSnippetContainer)\n\/\/ NOTE it can be also done with snippet containers... (and also done in CATG\n\/\/ generator!)\nList<AnnotationExpr> classAnnotations = type.getAnnotations();\nJavaVersion reqJavaVer = getRequiredJavaVersion(classAnnotations);\nif (reqJavaVer != null && !getTool().supportsJavaVersion(reqJavaVer)) {\nSystem.err.println(\n\"Skipping file: \" + file + \" (required Java version: \" + reqJavaVer + \")\");\nPathUtils.delete(file.toPath());\n} else {\n\/\/ remove SETTE annotations from the class\nPredicate<AnnotationExpr> isSetteAnnotation = (a -> a.getName().getName()\n.startsWith(\"Sette\"));\nclassAnnotations.removeIf(isSetteAnnotation);\n\/\/ remove SETTE annotations from the members\nfor (BodyDeclaration member : type.getMembers()) {\nmember.getAnnotations().removeIf(isSetteAnnotation);\n}\n\/\/ TODO enhance\nList<String> toRemovePrefixes = new ArrayList<>();\ntoRemovePrefixes.add(\"hu.bme.mit.sette.snippets.inputs\");\ntoRemovePrefixes.add(\"hu.bme.mit.sette.common\");\n\/\/ remove SETTE imports\ncompilationUnit.getImports().removeIf(importDeclaration -> {\nString impDecl = importDeclaration.getName().toString();\nfor (String prefix : toRemovePrefixes) {\nif (impDecl.startsWith(prefix)) {\nreturn true;\n}\n}\nreturn false;\n});\n\/\/ save edited source code\nString source = compilationUnit.toString();\nif (type instanceof EnumDeclaration) {\n\/\/ FIXME remove after javaparser bug is fixed\nsource = source.replaceFirst(type.getName() + \"\\\\s+implements\\\\s*\\\\{\",\ntype.getName() + \" {\");\n}\nPathUtils.write(file.toPath(), source.getBytes());\n}\n}\n\/\/ copy libraries\nif (getSnippetProject().getLibDir().toFile().exists()) {\nPathUtils.copy(getSnippetProject().getLibDir(),\ngetRunnerProjectSettings().getSnippetLibraryDirectory().toPath());\n}\n\/\/ create project\nthis.eclipseProject.save(getRunnerProjectSettings().getBaseDir().toPath());\n}\n\nprivate void writeRunnerProject() throws IOException, XmlException, ParseException {\n\/\/ TODO revise whole method\n\/\/ TODO now using a newer JAPA (suuports java 8), -> maybe ANTLR supports better\nPathUtils.createDir(getRunnerProjectSettings().getBaseDir().toPath());\n\/\/ copy snippets\n\n\/\/ TODO now using a newer JAPA (suuports java 8), -> maybe ANTLR supports better\nPathUtils.createDir(getRunnerProjectSettings().getBaseDir().toPath());\n\/\/ copy snippets\nPathUtils.copy(getSnippetProject().getSourceDir(),\ngetRunnerProjectSettings().getSnippetSourceDirectory().toPath());\n\nPathUtils.copy(getSnippetProject().getSourceDir(),\ngetRunnerProjectSettings().getSnippetSourceDirectory().toPath());\n\/\/ create INFO file\nwriteInfoFile();\n\/\/ remove SETTE annotations and imports from file\n\n\/\/ create INFO file\nwriteInfoFile();\n\/\/ remove SETTE annotations and imports from file\nCollection<File> filesWritten = Files\n.walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n\n.collect(Collectors.toList());\nfor (File file : filesWritten) {\n\/\/ parse source with JavaParser\nlog.debug(\"Parsing with JavaParser: {}\", file);\nCompilationUnit compilationUnit = JavaParser.parse(file);\n\nCompilationUnit compilationUnit = JavaParser.parse(file);\nlog.debug(\"Parsed with JavaParser: {}\", file);\n\/\/ extract type\nList<TypeDeclaration> types = compilationUnit.getTypes();\nif (types.size() != 1) {\n\nList<TypeDeclaration> types = compilationUnit.getTypes();\nif (types.size() != 1) {\n\/\/ NOTE better exception type\nthrow new RuntimeException(\n\"Java source files containing more that one types are not supported\");\n\n}\nTypeDeclaration type = types.get(0);\n\/\/ skip file if Java version is not supported by the tool (@SetteSnippetContainer)\n\/\/ NOTE it can be also done with snippet containers... (and also done in CATG\n\/\/ generator!)\nList<AnnotationExpr> classAnnotations = type.getAnnotations();\nJavaVersion reqJavaVer = getRequiredJavaVersion(classAnnotations);\n\nPathUtils.delete(file.toPath());\n} else {\n\/\/ remove SETTE annotations from the class\nPredicate<AnnotationExpr> isSetteAnnotation = (a -> a.getName().getName()\n.startsWith(\"Sette\"));\n\n.startsWith(\"Sette\"));\nclassAnnotations.removeIf(isSetteAnnotation);\n\/\/ remove SETTE annotations from the members\nfor (BodyDeclaration member : type.getMembers()) {\nmember.getAnnotations().removeIf(isSetteAnnotation);\n\nmember.getAnnotations().removeIf(isSetteAnnotation);\n}\n\/\/ TODO enhance\nList<String> toRemovePrefixes = new ArrayList<>();\ntoRemovePrefixes.add(\"hu.bme.mit.sette.snippets.inputs\");\n\ntoRemovePrefixes.add(\"hu.bme.mit.sette.snippets.inputs\");\ntoRemovePrefixes.add(\"hu.bme.mit.sette.common\");\n\/\/ remove SETTE imports\ncompilationUnit.getImports().removeIf(importDeclaration -> {\nString impDecl = importDeclaration.getName().toString();\n\nreturn false;\n});\n\/\/ save edited source code\nString source = compilationUnit.toString();\nif (type instanceof EnumDeclaration) {\n\nString source = compilationUnit.toString();\nif (type instanceof EnumDeclaration) {\n\/\/ FIXME remove after javaparser bug is fixed\nsource = source.replaceFirst(type.getName() + \"\\\\s+implements\\\\s*\\\\{\",\ntype.getName() + \" {\");\n\n}\n}\n\/\/ copy libraries\nif (getSnippetProject().getLibDir().toFile().exists()) {\nPathUtils.copy(getSnippetProject().getLibDir(),\n\ngetRunnerProjectSettings().getSnippetLibraryDirectory().toPath());\n}\n\/\/ create project\nthis.eclipseProject.save(getRunnerProjectSettings().getBaseDir().toPath());\n}","code_context_10":"private void writeRunnerProject() throws IOException, XmlException, ParseException {\n\/\/ TODO revise whole method\n\/\/ TODO now using a newer JAPA (suuports java 8), -> maybe ANTLR supports better\nPathUtils.createDir(getRunnerProjectSettings().getBaseDir().toPath());\n\/\/ copy snippets\nPathUtils.copy(getSnippetProject().getSourceDir(),\ngetRunnerProjectSettings().getSnippetSourceDirectory().toPath());\n\/\/ create INFO file\nwriteInfoFile();\n\/\/ remove SETTE annotations and imports from file\nCollection<File> filesWritten = Files\n.walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n.filter(Files::isRegularFile).map(Path::toFile).sorted()\n.collect(Collectors.toList());\nfor (File file : filesWritten) {\n\/\/ parse source with JavaParser\nlog.debug(\"Parsing with JavaParser: {}\", file);\nCompilationUnit compilationUnit = JavaParser.parse(file);\nlog.debug(\"Parsed with JavaParser: {}\", file);\n\/\/ extract type\nList<TypeDeclaration> types = compilationUnit.getTypes();\nif (types.size() != 1) {\n\/\/ NOTE better exception type\nthrow new RuntimeException(\n\"Java source files containing more that one types are not supported\");\n}\nTypeDeclaration type = types.get(0);\n\/\/ skip file if Java version is not supported by the tool (@SetteSnippetContainer)\n\/\/ NOTE it can be also done with snippet containers... (and also done in CATG\n\/\/ generator!)\nList<AnnotationExpr> classAnnotations = type.getAnnotations();\nJavaVersion reqJavaVer = getRequiredJavaVersion(classAnnotations);\nif (reqJavaVer != null && !getTool().supportsJavaVersion(reqJavaVer)) {\nSystem.err.println(\n\"Skipping file: \" + file + \" (required Java version: \" + reqJavaVer + \")\");\nPathUtils.delete(file.toPath());\n} else {\n\/\/ remove SETTE annotations from the class\nPredicate<AnnotationExpr> isSetteAnnotation = (a -> a.getName().getName()\n.startsWith(\"Sette\"));\nclassAnnotations.removeIf(isSetteAnnotation);\n\/\/ remove SETTE annotations from the members\nfor (BodyDeclaration member : type.getMembers()) {\nmember.getAnnotations().removeIf(isSetteAnnotation);\n}\n\/\/ TODO enhance\nList<String> toRemovePrefixes = new ArrayList<>();\ntoRemovePrefixes.add(\"hu.bme.mit.sette.snippets.inputs\");\ntoRemovePrefixes.add(\"hu.bme.mit.sette.common\");\n\/\/ remove SETTE imports\ncompilationUnit.getImports().removeIf(importDeclaration -> {\nString impDecl = importDeclaration.getName().toString();\nfor (String prefix : toRemovePrefixes) {\nif (impDecl.startsWith(prefix)) {\nreturn true;\n}\n}\nreturn false;\n});\n\/\/ save edited source code\nString source = compilationUnit.toString();\nif (type instanceof EnumDeclaration) {\n\/\/ FIXME remove after javaparser bug is fixed\nsource = source.replaceFirst(type.getName() + \"\\\\s+implements\\\\s*\\\\{\",\ntype.getName() + \" {\");\n}\nPathUtils.write(file.toPath(), source.getBytes());\n}\n}\n\/\/ copy libraries\nif (getSnippetProject().getLibDir().toFile().exists()) {\nPathUtils.copy(getSnippetProject().getLibDir(),\ngetRunnerProjectSettings().getSnippetLibraryDirectory().toPath());\n}\n\/\/ create project\nthis.eclipseProject.save(getRunnerProjectSettings().getBaseDir().toPath());\n}\n\nprivate void writeRunnerProject() throws IOException, XmlException, ParseException {\n\/\/ TODO revise whole method\n\/\/ TODO now using a newer JAPA (suuports java 8), -> maybe ANTLR supports better\nPathUtils.createDir(getRunnerProjectSettings().getBaseDir().toPath());\n\/\/ copy snippets\nPathUtils.copy(getSnippetProject().getSourceDir(),\ngetRunnerProjectSettings().getSnippetSourceDirectory().toPath());\n\/\/ create INFO file\nwriteInfoFile();\n\/\/ remove SETTE annotations and imports from file\nCollection<File> filesWritten = Files\n.walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n.filter(Files::isRegularFile).map(Path::toFile).sorted()\n\nprivate void writeRunnerProject() throws IOException, XmlException, ParseException {\n\/\/ TODO revise whole method\n\/\/ TODO now using a newer JAPA (suuports java 8), -> maybe ANTLR supports better\nPathUtils.createDir(getRunnerProjectSettings().getBaseDir().toPath());\n\/\/ copy snippets\nPathUtils.copy(getSnippetProject().getSourceDir(),\ngetRunnerProjectSettings().getSnippetSourceDirectory().toPath());\n\/\/ create INFO file\nwriteInfoFile();\n\/\/ remove SETTE annotations and imports from file\nCollection<File> filesWritten = Files\n.walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n.filter(Files::isRegularFile).map(Path::toFile).sorted()\n.collect(Collectors.toList());\nfor (File file : filesWritten) {\n\nprivate void writeRunnerProject() throws IOException, XmlException, ParseException {\n\/\/ TODO revise whole method\n\/\/ TODO now using a newer JAPA (suuports java 8), -> maybe ANTLR supports better\nPathUtils.createDir(getRunnerProjectSettings().getBaseDir().toPath());\n\/\/ copy snippets\nPathUtils.copy(getSnippetProject().getSourceDir(),\ngetRunnerProjectSettings().getSnippetSourceDirectory().toPath());\n\/\/ create INFO file\nwriteInfoFile();\n\/\/ remove SETTE annotations and imports from file\nCollection<File> filesWritten = Files\n.walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n.filter(Files::isRegularFile).map(Path::toFile).sorted()\n.collect(Collectors.toList());\nfor (File file : filesWritten) {\n\/\/ parse source with JavaParser\nlog.debug(\"Parsing with JavaParser: {}\", file);\nCompilationUnit compilationUnit = JavaParser.parse(file);\n\nprivate void writeRunnerProject() throws IOException, XmlException, ParseException {\n\/\/ TODO revise whole method\n\/\/ TODO now using a newer JAPA (suuports java 8), -> maybe ANTLR supports better\nPathUtils.createDir(getRunnerProjectSettings().getBaseDir().toPath());\n\/\/ copy snippets\nPathUtils.copy(getSnippetProject().getSourceDir(),\ngetRunnerProjectSettings().getSnippetSourceDirectory().toPath());\n\/\/ create INFO file\nwriteInfoFile();\n\/\/ remove SETTE annotations and imports from file\nCollection<File> filesWritten = Files\n.walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n.filter(Files::isRegularFile).map(Path::toFile).sorted()\n.collect(Collectors.toList());\nfor (File file : filesWritten) {\n\/\/ parse source with JavaParser\nlog.debug(\"Parsing with JavaParser: {}\", file);\nCompilationUnit compilationUnit = JavaParser.parse(file);\nlog.debug(\"Parsed with JavaParser: {}\", file);\n\/\/ extract type\n\nPathUtils.copy(getSnippetProject().getSourceDir(),\ngetRunnerProjectSettings().getSnippetSourceDirectory().toPath());\n\/\/ create INFO file\nwriteInfoFile();\n\/\/ remove SETTE annotations and imports from file\nCollection<File> filesWritten = Files\n.walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n.filter(Files::isRegularFile).map(Path::toFile).sorted()\n.collect(Collectors.toList());\nfor (File file : filesWritten) {\n\/\/ parse source with JavaParser\nlog.debug(\"Parsing with JavaParser: {}\", file);\nCompilationUnit compilationUnit = JavaParser.parse(file);\nlog.debug(\"Parsed with JavaParser: {}\", file);\n\/\/ extract type\nList<TypeDeclaration> types = compilationUnit.getTypes();\nif (types.size() != 1) {\n\/\/ NOTE better exception type\nthrow new RuntimeException(\n\"Java source files containing more that one types are not supported\");\n}\n\n\/\/ remove SETTE annotations and imports from file\nCollection<File> filesWritten = Files\n.walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n.filter(Files::isRegularFile).map(Path::toFile).sorted()\n.collect(Collectors.toList());\nfor (File file : filesWritten) {\n\/\/ parse source with JavaParser\nlog.debug(\"Parsing with JavaParser: {}\", file);\nCompilationUnit compilationUnit = JavaParser.parse(file);\nlog.debug(\"Parsed with JavaParser: {}\", file);\n\/\/ extract type\nList<TypeDeclaration> types = compilationUnit.getTypes();\nif (types.size() != 1) {\n\/\/ NOTE better exception type\nthrow new RuntimeException(\n\"Java source files containing more that one types are not supported\");\n}\nTypeDeclaration type = types.get(0);\n\/\/ skip file if Java version is not supported by the tool (@SetteSnippetContainer)\n\/\/ NOTE it can be also done with snippet containers... (and also done in CATG\n\/\/ generator!)\n\n.filter(Files::isRegularFile).map(Path::toFile).sorted()\n.collect(Collectors.toList());\nfor (File file : filesWritten) {\n\/\/ parse source with JavaParser\nlog.debug(\"Parsing with JavaParser: {}\", file);\nCompilationUnit compilationUnit = JavaParser.parse(file);\nlog.debug(\"Parsed with JavaParser: {}\", file);\n\/\/ extract type\nList<TypeDeclaration> types = compilationUnit.getTypes();\nif (types.size() != 1) {\n\/\/ NOTE better exception type\nthrow new RuntimeException(\n\"Java source files containing more that one types are not supported\");\n}\nTypeDeclaration type = types.get(0);\n\/\/ skip file if Java version is not supported by the tool (@SetteSnippetContainer)\n\/\/ NOTE it can be also done with snippet containers... (and also done in CATG\n\/\/ generator!)\nList<AnnotationExpr> classAnnotations = type.getAnnotations();\nJavaVersion reqJavaVer = getRequiredJavaVersion(classAnnotations);\nif (reqJavaVer != null && !getTool().supportsJavaVersion(reqJavaVer)) {\n\nCompilationUnit compilationUnit = JavaParser.parse(file);\nlog.debug(\"Parsed with JavaParser: {}\", file);\n\/\/ extract type\nList<TypeDeclaration> types = compilationUnit.getTypes();\nif (types.size() != 1) {\n\/\/ NOTE better exception type\nthrow new RuntimeException(\n\"Java source files containing more that one types are not supported\");\n}\nTypeDeclaration type = types.get(0);\n\/\/ skip file if Java version is not supported by the tool (@SetteSnippetContainer)\n\/\/ NOTE it can be also done with snippet containers... (and also done in CATG\n\/\/ generator!)\nList<AnnotationExpr> classAnnotations = type.getAnnotations();\nJavaVersion reqJavaVer = getRequiredJavaVersion(classAnnotations);\nif (reqJavaVer != null && !getTool().supportsJavaVersion(reqJavaVer)) {\nSystem.err.println(\n\"Skipping file: \" + file + \" (required Java version: \" + reqJavaVer + \")\");\nPathUtils.delete(file.toPath());\n} else {\n\/\/ remove SETTE annotations from the class\nPredicate<AnnotationExpr> isSetteAnnotation = (a -> a.getName().getName()\n.startsWith(\"Sette\"));\n\n\/\/ skip file if Java version is not supported by the tool (@SetteSnippetContainer)\n\/\/ NOTE it can be also done with snippet containers... (and also done in CATG\n\/\/ generator!)\nList<AnnotationExpr> classAnnotations = type.getAnnotations();\nJavaVersion reqJavaVer = getRequiredJavaVersion(classAnnotations);\nif (reqJavaVer != null && !getTool().supportsJavaVersion(reqJavaVer)) {\nSystem.err.println(\n\"Skipping file: \" + file + \" (required Java version: \" + reqJavaVer + \")\");\nPathUtils.delete(file.toPath());\n} else {\n\/\/ remove SETTE annotations from the class\nPredicate<AnnotationExpr> isSetteAnnotation = (a -> a.getName().getName()\n.startsWith(\"Sette\"));\nclassAnnotations.removeIf(isSetteAnnotation);\n\/\/ remove SETTE annotations from the members\nfor (BodyDeclaration member : type.getMembers()) {\nmember.getAnnotations().removeIf(isSetteAnnotation);\n}\n\/\/ TODO enhance\nList<String> toRemovePrefixes = new ArrayList<>();\ntoRemovePrefixes.add(\"hu.bme.mit.sette.snippets.inputs\");\n\nJavaVersion reqJavaVer = getRequiredJavaVersion(classAnnotations);\nif (reqJavaVer != null && !getTool().supportsJavaVersion(reqJavaVer)) {\nSystem.err.println(\n\"Skipping file: \" + file + \" (required Java version: \" + reqJavaVer + \")\");\nPathUtils.delete(file.toPath());\n} else {\n\/\/ remove SETTE annotations from the class\nPredicate<AnnotationExpr> isSetteAnnotation = (a -> a.getName().getName()\n.startsWith(\"Sette\"));\nclassAnnotations.removeIf(isSetteAnnotation);\n\/\/ remove SETTE annotations from the members\nfor (BodyDeclaration member : type.getMembers()) {\nmember.getAnnotations().removeIf(isSetteAnnotation);\n}\n\/\/ TODO enhance\nList<String> toRemovePrefixes = new ArrayList<>();\ntoRemovePrefixes.add(\"hu.bme.mit.sette.snippets.inputs\");\ntoRemovePrefixes.add(\"hu.bme.mit.sette.common\");\n\/\/ remove SETTE imports\ncompilationUnit.getImports().removeIf(importDeclaration -> {\nString impDecl = importDeclaration.getName().toString();\n\nPathUtils.delete(file.toPath());\n} else {\n\/\/ remove SETTE annotations from the class\nPredicate<AnnotationExpr> isSetteAnnotation = (a -> a.getName().getName()\n.startsWith(\"Sette\"));\nclassAnnotations.removeIf(isSetteAnnotation);\n\/\/ remove SETTE annotations from the members\nfor (BodyDeclaration member : type.getMembers()) {\nmember.getAnnotations().removeIf(isSetteAnnotation);\n}\n\/\/ TODO enhance\nList<String> toRemovePrefixes = new ArrayList<>();\ntoRemovePrefixes.add(\"hu.bme.mit.sette.snippets.inputs\");\ntoRemovePrefixes.add(\"hu.bme.mit.sette.common\");\n\/\/ remove SETTE imports\ncompilationUnit.getImports().removeIf(importDeclaration -> {\nString impDecl = importDeclaration.getName().toString();\nfor (String prefix : toRemovePrefixes) {\nif (impDecl.startsWith(prefix)) {\nreturn true;\n}\n\n.startsWith(\"Sette\"));\nclassAnnotations.removeIf(isSetteAnnotation);\n\/\/ remove SETTE annotations from the members\nfor (BodyDeclaration member : type.getMembers()) {\nmember.getAnnotations().removeIf(isSetteAnnotation);\n}\n\/\/ TODO enhance\nList<String> toRemovePrefixes = new ArrayList<>();\ntoRemovePrefixes.add(\"hu.bme.mit.sette.snippets.inputs\");\ntoRemovePrefixes.add(\"hu.bme.mit.sette.common\");\n\/\/ remove SETTE imports\ncompilationUnit.getImports().removeIf(importDeclaration -> {\nString impDecl = importDeclaration.getName().toString();\nfor (String prefix : toRemovePrefixes) {\nif (impDecl.startsWith(prefix)) {\nreturn true;\n}\n}\nreturn false;\n});\n\/\/ save edited source code\n\n\/\/ remove SETTE imports\ncompilationUnit.getImports().removeIf(importDeclaration -> {\nString impDecl = importDeclaration.getName().toString();\nfor (String prefix : toRemovePrefixes) {\nif (impDecl.startsWith(prefix)) {\nreturn true;\n}\n}\nreturn false;\n});\n\/\/ save edited source code\nString source = compilationUnit.toString();\nif (type instanceof EnumDeclaration) {\n\/\/ FIXME remove after javaparser bug is fixed\nsource = source.replaceFirst(type.getName() + \"\\\\s+implements\\\\s*\\\\{\",\ntype.getName() + \" {\");\n}\nPathUtils.write(file.toPath(), source.getBytes());\n}\n}\n\/\/ copy libraries\n\nfor (String prefix : toRemovePrefixes) {\nif (impDecl.startsWith(prefix)) {\nreturn true;\n}\n}\nreturn false;\n});\n\/\/ save edited source code\nString source = compilationUnit.toString();\nif (type instanceof EnumDeclaration) {\n\/\/ FIXME remove after javaparser bug is fixed\nsource = source.replaceFirst(type.getName() + \"\\\\s+implements\\\\s*\\\\{\",\ntype.getName() + \" {\");\n}\nPathUtils.write(file.toPath(), source.getBytes());\n}\n}\n\/\/ copy libraries\nif (getSnippetProject().getLibDir().toFile().exists()) {\nPathUtils.copy(getSnippetProject().getLibDir(),\ngetRunnerProjectSettings().getSnippetLibraryDirectory().toPath());\n\n\/\/ save edited source code\nString source = compilationUnit.toString();\nif (type instanceof EnumDeclaration) {\n\/\/ FIXME remove after javaparser bug is fixed\nsource = source.replaceFirst(type.getName() + \"\\\\s+implements\\\\s*\\\\{\",\ntype.getName() + \" {\");\n}\nPathUtils.write(file.toPath(), source.getBytes());\n}\n}\n\/\/ copy libraries\nif (getSnippetProject().getLibDir().toFile().exists()) {\nPathUtils.copy(getSnippetProject().getLibDir(),\ngetRunnerProjectSettings().getSnippetLibraryDirectory().toPath());\n}\n\/\/ create project\nthis.eclipseProject.save(getRunnerProjectSettings().getBaseDir().toPath());\n}\n\ntype.getName() + \" {\");\n}\nPathUtils.write(file.toPath(), source.getBytes());\n}\n}\n\/\/ copy libraries\nif (getSnippetProject().getLibDir().toFile().exists()) {\nPathUtils.copy(getSnippetProject().getLibDir(),\ngetRunnerProjectSettings().getSnippetLibraryDirectory().toPath());\n}\n\/\/ create project\nthis.eclipseProject.save(getRunnerProjectSettings().getBaseDir().toPath());\n}","code_context_20":"private void writeRunnerProject() throws IOException, XmlException, ParseException {\n\/\/ TODO revise whole method\n\/\/ TODO now using a newer JAPA (suuports java 8), -> maybe ANTLR supports better\nPathUtils.createDir(getRunnerProjectSettings().getBaseDir().toPath());\n\/\/ copy snippets\nPathUtils.copy(getSnippetProject().getSourceDir(),\ngetRunnerProjectSettings().getSnippetSourceDirectory().toPath());\n\/\/ create INFO file\nwriteInfoFile();\n\/\/ remove SETTE annotations and imports from file\nCollection<File> filesWritten = Files\n.walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n.filter(Files::isRegularFile).map(Path::toFile).sorted()\n.collect(Collectors.toList());\nfor (File file : filesWritten) {\n\/\/ parse source with JavaParser\nlog.debug(\"Parsing with JavaParser: {}\", file);\nCompilationUnit compilationUnit = JavaParser.parse(file);\nlog.debug(\"Parsed with JavaParser: {}\", file);\n\/\/ extract type\nList<TypeDeclaration> types = compilationUnit.getTypes();\nif (types.size() != 1) {\n\/\/ NOTE better exception type\nthrow new RuntimeException(\n\"Java source files containing more that one types are not supported\");\n}\nTypeDeclaration type = types.get(0);\n\/\/ skip file if Java version is not supported by the tool (@SetteSnippetContainer)\n\/\/ NOTE it can be also done with snippet containers... (and also done in CATG\n\/\/ generator!)\nList<AnnotationExpr> classAnnotations = type.getAnnotations();\nJavaVersion reqJavaVer = getRequiredJavaVersion(classAnnotations);\nif (reqJavaVer != null && !getTool().supportsJavaVersion(reqJavaVer)) {\nSystem.err.println(\n\"Skipping file: \" + file + \" (required Java version: \" + reqJavaVer + \")\");\nPathUtils.delete(file.toPath());\n} else {\n\/\/ remove SETTE annotations from the class\nPredicate<AnnotationExpr> isSetteAnnotation = (a -> a.getName().getName()\n.startsWith(\"Sette\"));\nclassAnnotations.removeIf(isSetteAnnotation);\n\/\/ remove SETTE annotations from the members\nfor (BodyDeclaration member : type.getMembers()) {\nmember.getAnnotations().removeIf(isSetteAnnotation);\n}\n\/\/ TODO enhance\nList<String> toRemovePrefixes = new ArrayList<>();\ntoRemovePrefixes.add(\"hu.bme.mit.sette.snippets.inputs\");\ntoRemovePrefixes.add(\"hu.bme.mit.sette.common\");\n\/\/ remove SETTE imports\ncompilationUnit.getImports().removeIf(importDeclaration -> {\nString impDecl = importDeclaration.getName().toString();\nfor (String prefix : toRemovePrefixes) {\nif (impDecl.startsWith(prefix)) {\nreturn true;\n}\n}\nreturn false;\n});\n\/\/ save edited source code\nString source = compilationUnit.toString();\nif (type instanceof EnumDeclaration) {\n\/\/ FIXME remove after javaparser bug is fixed\nsource = source.replaceFirst(type.getName() + \"\\\\s+implements\\\\s*\\\\{\",\ntype.getName() + \" {\");\n}\nPathUtils.write(file.toPath(), source.getBytes());\n}\n}\n\/\/ copy libraries\nif (getSnippetProject().getLibDir().toFile().exists()) {\nPathUtils.copy(getSnippetProject().getLibDir(),\ngetRunnerProjectSettings().getSnippetLibraryDirectory().toPath());\n}\n\/\/ create project\nthis.eclipseProject.save(getRunnerProjectSettings().getBaseDir().toPath());\n}\n\nprivate void writeRunnerProject() throws IOException, XmlException, ParseException {\n\/\/ TODO revise whole method\n\/\/ TODO now using a newer JAPA (suuports java 8), -> maybe ANTLR supports better\nPathUtils.createDir(getRunnerProjectSettings().getBaseDir().toPath());\n\/\/ copy snippets\nPathUtils.copy(getSnippetProject().getSourceDir(),\ngetRunnerProjectSettings().getSnippetSourceDirectory().toPath());\n\/\/ create INFO file\nwriteInfoFile();\n\/\/ remove SETTE annotations and imports from file\nCollection<File> filesWritten = Files\n.walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n.filter(Files::isRegularFile).map(Path::toFile).sorted()\n.collect(Collectors.toList());\nfor (File file : filesWritten) {\n\/\/ parse source with JavaParser\nlog.debug(\"Parsing with JavaParser: {}\", file);\nCompilationUnit compilationUnit = JavaParser.parse(file);\nlog.debug(\"Parsed with JavaParser: {}\", file);\n\/\/ extract type\nList<TypeDeclaration> types = compilationUnit.getTypes();\nif (types.size() != 1) {\n\/\/ NOTE better exception type\n\nprivate void writeRunnerProject() throws IOException, XmlException, ParseException {\n\/\/ TODO revise whole method\n\/\/ TODO now using a newer JAPA (suuports java 8), -> maybe ANTLR supports better\nPathUtils.createDir(getRunnerProjectSettings().getBaseDir().toPath());\n\/\/ copy snippets\nPathUtils.copy(getSnippetProject().getSourceDir(),\ngetRunnerProjectSettings().getSnippetSourceDirectory().toPath());\n\/\/ create INFO file\nwriteInfoFile();\n\/\/ remove SETTE annotations and imports from file\nCollection<File> filesWritten = Files\n.walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n.filter(Files::isRegularFile).map(Path::toFile).sorted()\n.collect(Collectors.toList());\nfor (File file : filesWritten) {\n\/\/ parse source with JavaParser\nlog.debug(\"Parsing with JavaParser: {}\", file);\nCompilationUnit compilationUnit = JavaParser.parse(file);\nlog.debug(\"Parsed with JavaParser: {}\", file);\n\/\/ extract type\nList<TypeDeclaration> types = compilationUnit.getTypes();\nif (types.size() != 1) {\n\/\/ NOTE better exception type\nthrow new RuntimeException(\n\"Java source files containing more that one types are not supported\");\n\nprivate void writeRunnerProject() throws IOException, XmlException, ParseException {\n\/\/ TODO revise whole method\n\/\/ TODO now using a newer JAPA (suuports java 8), -> maybe ANTLR supports better\nPathUtils.createDir(getRunnerProjectSettings().getBaseDir().toPath());\n\/\/ copy snippets\nPathUtils.copy(getSnippetProject().getSourceDir(),\ngetRunnerProjectSettings().getSnippetSourceDirectory().toPath());\n\/\/ create INFO file\nwriteInfoFile();\n\/\/ remove SETTE annotations and imports from file\nCollection<File> filesWritten = Files\n.walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n.filter(Files::isRegularFile).map(Path::toFile).sorted()\n.collect(Collectors.toList());\nfor (File file : filesWritten) {\n\/\/ parse source with JavaParser\nlog.debug(\"Parsing with JavaParser: {}\", file);\nCompilationUnit compilationUnit = JavaParser.parse(file);\nlog.debug(\"Parsed with JavaParser: {}\", file);\n\/\/ extract type\nList<TypeDeclaration> types = compilationUnit.getTypes();\nif (types.size() != 1) {\n\/\/ NOTE better exception type\nthrow new RuntimeException(\n\"Java source files containing more that one types are not supported\");\n}\nTypeDeclaration type = types.get(0);\n\/\/ skip file if Java version is not supported by the tool (@SetteSnippetContainer)\n\nprivate void writeRunnerProject() throws IOException, XmlException, ParseException {\n\/\/ TODO revise whole method\n\/\/ TODO now using a newer JAPA (suuports java 8), -> maybe ANTLR supports better\nPathUtils.createDir(getRunnerProjectSettings().getBaseDir().toPath());\n\/\/ copy snippets\nPathUtils.copy(getSnippetProject().getSourceDir(),\ngetRunnerProjectSettings().getSnippetSourceDirectory().toPath());\n\/\/ create INFO file\nwriteInfoFile();\n\/\/ remove SETTE annotations and imports from file\nCollection<File> filesWritten = Files\n.walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n.filter(Files::isRegularFile).map(Path::toFile).sorted()\n.collect(Collectors.toList());\nfor (File file : filesWritten) {\n\/\/ parse source with JavaParser\nlog.debug(\"Parsing with JavaParser: {}\", file);\nCompilationUnit compilationUnit = JavaParser.parse(file);\nlog.debug(\"Parsed with JavaParser: {}\", file);\n\/\/ extract type\nList<TypeDeclaration> types = compilationUnit.getTypes();\nif (types.size() != 1) {\n\/\/ NOTE better exception type\nthrow new RuntimeException(\n\"Java source files containing more that one types are not supported\");\n}\nTypeDeclaration type = types.get(0);\n\/\/ skip file if Java version is not supported by the tool (@SetteSnippetContainer)\n\/\/ NOTE it can be also done with snippet containers... (and also done in CATG\n\/\/ generator!)\n\nprivate void writeRunnerProject() throws IOException, XmlException, ParseException {\n\/\/ TODO revise whole method\n\/\/ TODO now using a newer JAPA (suuports java 8), -> maybe ANTLR supports better\nPathUtils.createDir(getRunnerProjectSettings().getBaseDir().toPath());\n\/\/ copy snippets\nPathUtils.copy(getSnippetProject().getSourceDir(),\ngetRunnerProjectSettings().getSnippetSourceDirectory().toPath());\n\/\/ create INFO file\nwriteInfoFile();\n\/\/ remove SETTE annotations and imports from file\nCollection<File> filesWritten = Files\n.walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n.filter(Files::isRegularFile).map(Path::toFile).sorted()\n.collect(Collectors.toList());\nfor (File file : filesWritten) {\n\/\/ parse source with JavaParser\nlog.debug(\"Parsing with JavaParser: {}\", file);\nCompilationUnit compilationUnit = JavaParser.parse(file);\nlog.debug(\"Parsed with JavaParser: {}\", file);\n\/\/ extract type\nList<TypeDeclaration> types = compilationUnit.getTypes();\nif (types.size() != 1) {\n\/\/ NOTE better exception type\nthrow new RuntimeException(\n\"Java source files containing more that one types are not supported\");\n}\nTypeDeclaration type = types.get(0);\n\/\/ skip file if Java version is not supported by the tool (@SetteSnippetContainer)\n\/\/ NOTE it can be also done with snippet containers... (and also done in CATG\n\/\/ generator!)\nList<AnnotationExpr> classAnnotations = type.getAnnotations();\nJavaVersion reqJavaVer = getRequiredJavaVersion(classAnnotations);\nif (reqJavaVer != null && !getTool().supportsJavaVersion(reqJavaVer)) {\nSystem.err.println(\n\"Skipping file: \" + file + \" (required Java version: \" + reqJavaVer + \")\");\nPathUtils.delete(file.toPath());\n\nprivate void writeRunnerProject() throws IOException, XmlException, ParseException {\n\/\/ TODO revise whole method\n\/\/ TODO now using a newer JAPA (suuports java 8), -> maybe ANTLR supports better\nPathUtils.createDir(getRunnerProjectSettings().getBaseDir().toPath());\n\/\/ copy snippets\nPathUtils.copy(getSnippetProject().getSourceDir(),\ngetRunnerProjectSettings().getSnippetSourceDirectory().toPath());\n\/\/ create INFO file\nwriteInfoFile();\n\/\/ remove SETTE annotations and imports from file\nCollection<File> filesWritten = Files\n.walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n.filter(Files::isRegularFile).map(Path::toFile).sorted()\n.collect(Collectors.toList());\nfor (File file : filesWritten) {\n\/\/ parse source with JavaParser\nlog.debug(\"Parsing with JavaParser: {}\", file);\nCompilationUnit compilationUnit = JavaParser.parse(file);\nlog.debug(\"Parsed with JavaParser: {}\", file);\n\/\/ extract type\nList<TypeDeclaration> types = compilationUnit.getTypes();\nif (types.size() != 1) {\n\/\/ NOTE better exception type\nthrow new RuntimeException(\n\"Java source files containing more that one types are not supported\");\n}\nTypeDeclaration type = types.get(0);\n\/\/ skip file if Java version is not supported by the tool (@SetteSnippetContainer)\n\/\/ NOTE it can be also done with snippet containers... (and also done in CATG\n\/\/ generator!)\nList<AnnotationExpr> classAnnotations = type.getAnnotations();\nJavaVersion reqJavaVer = getRequiredJavaVersion(classAnnotations);\nif (reqJavaVer != null && !getTool().supportsJavaVersion(reqJavaVer)) {\nSystem.err.println(\n\"Skipping file: \" + file + \" (required Java version: \" + reqJavaVer + \")\");\nPathUtils.delete(file.toPath());\n} else {\n\/\/ remove SETTE annotations from the class\nPredicate<AnnotationExpr> isSetteAnnotation = (a -> a.getName().getName()\n.startsWith(\"Sette\"));\n\n\/\/ TODO now using a newer JAPA (suuports java 8), -> maybe ANTLR supports better\nPathUtils.createDir(getRunnerProjectSettings().getBaseDir().toPath());\n\/\/ copy snippets\nPathUtils.copy(getSnippetProject().getSourceDir(),\ngetRunnerProjectSettings().getSnippetSourceDirectory().toPath());\n\/\/ create INFO file\nwriteInfoFile();\n\/\/ remove SETTE annotations and imports from file\nCollection<File> filesWritten = Files\n.walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n.filter(Files::isRegularFile).map(Path::toFile).sorted()\n.collect(Collectors.toList());\nfor (File file : filesWritten) {\n\/\/ parse source with JavaParser\nlog.debug(\"Parsing with JavaParser: {}\", file);\nCompilationUnit compilationUnit = JavaParser.parse(file);\nlog.debug(\"Parsed with JavaParser: {}\", file);\n\/\/ extract type\nList<TypeDeclaration> types = compilationUnit.getTypes();\nif (types.size() != 1) {\n\/\/ NOTE better exception type\nthrow new RuntimeException(\n\"Java source files containing more that one types are not supported\");\n}\nTypeDeclaration type = types.get(0);\n\/\/ skip file if Java version is not supported by the tool (@SetteSnippetContainer)\n\/\/ NOTE it can be also done with snippet containers... (and also done in CATG\n\/\/ generator!)\nList<AnnotationExpr> classAnnotations = type.getAnnotations();\nJavaVersion reqJavaVer = getRequiredJavaVersion(classAnnotations);\nif (reqJavaVer != null && !getTool().supportsJavaVersion(reqJavaVer)) {\nSystem.err.println(\n\"Skipping file: \" + file + \" (required Java version: \" + reqJavaVer + \")\");\nPathUtils.delete(file.toPath());\n} else {\n\/\/ remove SETTE annotations from the class\nPredicate<AnnotationExpr> isSetteAnnotation = (a -> a.getName().getName()\n.startsWith(\"Sette\"));\nclassAnnotations.removeIf(isSetteAnnotation);\n\/\/ remove SETTE annotations from the members\nfor (BodyDeclaration member : type.getMembers()) {\n\n\/\/ create INFO file\nwriteInfoFile();\n\/\/ remove SETTE annotations and imports from file\nCollection<File> filesWritten = Files\n.walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n.filter(Files::isRegularFile).map(Path::toFile).sorted()\n.collect(Collectors.toList());\nfor (File file : filesWritten) {\n\/\/ parse source with JavaParser\nlog.debug(\"Parsing with JavaParser: {}\", file);\nCompilationUnit compilationUnit = JavaParser.parse(file);\nlog.debug(\"Parsed with JavaParser: {}\", file);\n\/\/ extract type\nList<TypeDeclaration> types = compilationUnit.getTypes();\nif (types.size() != 1) {\n\/\/ NOTE better exception type\nthrow new RuntimeException(\n\"Java source files containing more that one types are not supported\");\n}\nTypeDeclaration type = types.get(0);\n\/\/ skip file if Java version is not supported by the tool (@SetteSnippetContainer)\n\/\/ NOTE it can be also done with snippet containers... (and also done in CATG\n\/\/ generator!)\nList<AnnotationExpr> classAnnotations = type.getAnnotations();\nJavaVersion reqJavaVer = getRequiredJavaVersion(classAnnotations);\nif (reqJavaVer != null && !getTool().supportsJavaVersion(reqJavaVer)) {\nSystem.err.println(\n\"Skipping file: \" + file + \" (required Java version: \" + reqJavaVer + \")\");\nPathUtils.delete(file.toPath());\n} else {\n\/\/ remove SETTE annotations from the class\nPredicate<AnnotationExpr> isSetteAnnotation = (a -> a.getName().getName()\n.startsWith(\"Sette\"));\nclassAnnotations.removeIf(isSetteAnnotation);\n\/\/ remove SETTE annotations from the members\nfor (BodyDeclaration member : type.getMembers()) {\nmember.getAnnotations().removeIf(isSetteAnnotation);\n}\n\/\/ TODO enhance\nList<String> toRemovePrefixes = new ArrayList<>();\ntoRemovePrefixes.add(\"hu.bme.mit.sette.snippets.inputs\");\ntoRemovePrefixes.add(\"hu.bme.mit.sette.common\");\n\/\/ remove SETTE imports\n\nCompilationUnit compilationUnit = JavaParser.parse(file);\nlog.debug(\"Parsed with JavaParser: {}\", file);\n\/\/ extract type\nList<TypeDeclaration> types = compilationUnit.getTypes();\nif (types.size() != 1) {\n\/\/ NOTE better exception type\nthrow new RuntimeException(\n\"Java source files containing more that one types are not supported\");\n}\nTypeDeclaration type = types.get(0);\n\/\/ skip file if Java version is not supported by the tool (@SetteSnippetContainer)\n\/\/ NOTE it can be also done with snippet containers... (and also done in CATG\n\/\/ generator!)\nList<AnnotationExpr> classAnnotations = type.getAnnotations();\nJavaVersion reqJavaVer = getRequiredJavaVersion(classAnnotations);\nif (reqJavaVer != null && !getTool().supportsJavaVersion(reqJavaVer)) {\nSystem.err.println(\n\"Skipping file: \" + file + \" (required Java version: \" + reqJavaVer + \")\");\nPathUtils.delete(file.toPath());\n} else {\n\/\/ remove SETTE annotations from the class\nPredicate<AnnotationExpr> isSetteAnnotation = (a -> a.getName().getName()\n.startsWith(\"Sette\"));\nclassAnnotations.removeIf(isSetteAnnotation);\n\/\/ remove SETTE annotations from the members\nfor (BodyDeclaration member : type.getMembers()) {\nmember.getAnnotations().removeIf(isSetteAnnotation);\n}\n\/\/ TODO enhance\nList<String> toRemovePrefixes = new ArrayList<>();\ntoRemovePrefixes.add(\"hu.bme.mit.sette.snippets.inputs\");\ntoRemovePrefixes.add(\"hu.bme.mit.sette.common\");\n\/\/ remove SETTE imports\ncompilationUnit.getImports().removeIf(importDeclaration -> {\nString impDecl = importDeclaration.getName().toString();\nfor (String prefix : toRemovePrefixes) {\nif (impDecl.startsWith(prefix)) {\nreturn true;\n}\n}\nreturn false;\n\nif (types.size() != 1) {\n\/\/ NOTE better exception type\nthrow new RuntimeException(\n\"Java source files containing more that one types are not supported\");\n}\nTypeDeclaration type = types.get(0);\n\/\/ skip file if Java version is not supported by the tool (@SetteSnippetContainer)\n\/\/ NOTE it can be also done with snippet containers... (and also done in CATG\n\/\/ generator!)\nList<AnnotationExpr> classAnnotations = type.getAnnotations();\nJavaVersion reqJavaVer = getRequiredJavaVersion(classAnnotations);\nif (reqJavaVer != null && !getTool().supportsJavaVersion(reqJavaVer)) {\nSystem.err.println(\n\"Skipping file: \" + file + \" (required Java version: \" + reqJavaVer + \")\");\nPathUtils.delete(file.toPath());\n} else {\n\/\/ remove SETTE annotations from the class\nPredicate<AnnotationExpr> isSetteAnnotation = (a -> a.getName().getName()\n.startsWith(\"Sette\"));\nclassAnnotations.removeIf(isSetteAnnotation);\n\/\/ remove SETTE annotations from the members\nfor (BodyDeclaration member : type.getMembers()) {\nmember.getAnnotations().removeIf(isSetteAnnotation);\n}\n\/\/ TODO enhance\nList<String> toRemovePrefixes = new ArrayList<>();\ntoRemovePrefixes.add(\"hu.bme.mit.sette.snippets.inputs\");\ntoRemovePrefixes.add(\"hu.bme.mit.sette.common\");\n\/\/ remove SETTE imports\ncompilationUnit.getImports().removeIf(importDeclaration -> {\nString impDecl = importDeclaration.getName().toString();\nfor (String prefix : toRemovePrefixes) {\nif (impDecl.startsWith(prefix)) {\nreturn true;\n}\n}\nreturn false;\n});\n\/\/ save edited source code\nString source = compilationUnit.toString();\nif (type instanceof EnumDeclaration) {\n\n}\nTypeDeclaration type = types.get(0);\n\/\/ skip file if Java version is not supported by the tool (@SetteSnippetContainer)\n\/\/ NOTE it can be also done with snippet containers... (and also done in CATG\n\/\/ generator!)\nList<AnnotationExpr> classAnnotations = type.getAnnotations();\nJavaVersion reqJavaVer = getRequiredJavaVersion(classAnnotations);\nif (reqJavaVer != null && !getTool().supportsJavaVersion(reqJavaVer)) {\nSystem.err.println(\n\"Skipping file: \" + file + \" (required Java version: \" + reqJavaVer + \")\");\nPathUtils.delete(file.toPath());\n} else {\n\/\/ remove SETTE annotations from the class\nPredicate<AnnotationExpr> isSetteAnnotation = (a -> a.getName().getName()\n.startsWith(\"Sette\"));\nclassAnnotations.removeIf(isSetteAnnotation);\n\/\/ remove SETTE annotations from the members\nfor (BodyDeclaration member : type.getMembers()) {\nmember.getAnnotations().removeIf(isSetteAnnotation);\n}\n\/\/ TODO enhance\nList<String> toRemovePrefixes = new ArrayList<>();\ntoRemovePrefixes.add(\"hu.bme.mit.sette.snippets.inputs\");\ntoRemovePrefixes.add(\"hu.bme.mit.sette.common\");\n\/\/ remove SETTE imports\ncompilationUnit.getImports().removeIf(importDeclaration -> {\nString impDecl = importDeclaration.getName().toString();\nfor (String prefix : toRemovePrefixes) {\nif (impDecl.startsWith(prefix)) {\nreturn true;\n}\n}\nreturn false;\n});\n\/\/ save edited source code\nString source = compilationUnit.toString();\nif (type instanceof EnumDeclaration) {\n\/\/ FIXME remove after javaparser bug is fixed\nsource = source.replaceFirst(type.getName() + \"\\\\s+implements\\\\s*\\\\{\",\ntype.getName() + \" {\");\n}\n\n\/\/ generator!)\nList<AnnotationExpr> classAnnotations = type.getAnnotations();\nJavaVersion reqJavaVer = getRequiredJavaVersion(classAnnotations);\nif (reqJavaVer != null && !getTool().supportsJavaVersion(reqJavaVer)) {\nSystem.err.println(\n\"Skipping file: \" + file + \" (required Java version: \" + reqJavaVer + \")\");\nPathUtils.delete(file.toPath());\n} else {\n\/\/ remove SETTE annotations from the class\nPredicate<AnnotationExpr> isSetteAnnotation = (a -> a.getName().getName()\n.startsWith(\"Sette\"));\nclassAnnotations.removeIf(isSetteAnnotation);\n\/\/ remove SETTE annotations from the members\nfor (BodyDeclaration member : type.getMembers()) {\nmember.getAnnotations().removeIf(isSetteAnnotation);\n}\n\/\/ TODO enhance\nList<String> toRemovePrefixes = new ArrayList<>();\ntoRemovePrefixes.add(\"hu.bme.mit.sette.snippets.inputs\");\ntoRemovePrefixes.add(\"hu.bme.mit.sette.common\");\n\/\/ remove SETTE imports\ncompilationUnit.getImports().removeIf(importDeclaration -> {\nString impDecl = importDeclaration.getName().toString();\nfor (String prefix : toRemovePrefixes) {\nif (impDecl.startsWith(prefix)) {\nreturn true;\n}\n}\nreturn false;\n});\n\/\/ save edited source code\nString source = compilationUnit.toString();\nif (type instanceof EnumDeclaration) {\n\/\/ FIXME remove after javaparser bug is fixed\nsource = source.replaceFirst(type.getName() + \"\\\\s+implements\\\\s*\\\\{\",\ntype.getName() + \" {\");\n}\nPathUtils.write(file.toPath(), source.getBytes());\n}\n}\n\/\/ copy libraries\n\n.startsWith(\"Sette\"));\nclassAnnotations.removeIf(isSetteAnnotation);\n\/\/ remove SETTE annotations from the members\nfor (BodyDeclaration member : type.getMembers()) {\nmember.getAnnotations().removeIf(isSetteAnnotation);\n}\n\/\/ TODO enhance\nList<String> toRemovePrefixes = new ArrayList<>();\ntoRemovePrefixes.add(\"hu.bme.mit.sette.snippets.inputs\");\ntoRemovePrefixes.add(\"hu.bme.mit.sette.common\");\n\/\/ remove SETTE imports\ncompilationUnit.getImports().removeIf(importDeclaration -> {\nString impDecl = importDeclaration.getName().toString();\nfor (String prefix : toRemovePrefixes) {\nif (impDecl.startsWith(prefix)) {\nreturn true;\n}\n}\nreturn false;\n});\n\/\/ save edited source code\nString source = compilationUnit.toString();\nif (type instanceof EnumDeclaration) {\n\/\/ FIXME remove after javaparser bug is fixed\nsource = source.replaceFirst(type.getName() + \"\\\\s+implements\\\\s*\\\\{\",\ntype.getName() + \" {\");\n}\nPathUtils.write(file.toPath(), source.getBytes());\n}\n}\n\/\/ copy libraries\nif (getSnippetProject().getLibDir().toFile().exists()) {\nPathUtils.copy(getSnippetProject().getLibDir(),\ngetRunnerProjectSettings().getSnippetLibraryDirectory().toPath());\n}\n\/\/ create project\nthis.eclipseProject.save(getRunnerProjectSettings().getBaseDir().toPath());\n}\n\nfor (BodyDeclaration member : type.getMembers()) {\nmember.getAnnotations().removeIf(isSetteAnnotation);\n}\n\/\/ TODO enhance\nList<String> toRemovePrefixes = new ArrayList<>();\ntoRemovePrefixes.add(\"hu.bme.mit.sette.snippets.inputs\");\ntoRemovePrefixes.add(\"hu.bme.mit.sette.common\");\n\/\/ remove SETTE imports\ncompilationUnit.getImports().removeIf(importDeclaration -> {\nString impDecl = importDeclaration.getName().toString();\nfor (String prefix : toRemovePrefixes) {\nif (impDecl.startsWith(prefix)) {\nreturn true;\n}\n}\nreturn false;\n});\n\/\/ save edited source code\nString source = compilationUnit.toString();\nif (type instanceof EnumDeclaration) {\n\/\/ FIXME remove after javaparser bug is fixed\nsource = source.replaceFirst(type.getName() + \"\\\\s+implements\\\\s*\\\\{\",\ntype.getName() + \" {\");\n}\nPathUtils.write(file.toPath(), source.getBytes());\n}\n}\n\/\/ copy libraries\nif (getSnippetProject().getLibDir().toFile().exists()) {\nPathUtils.copy(getSnippetProject().getLibDir(),\ngetRunnerProjectSettings().getSnippetLibraryDirectory().toPath());\n}\n\/\/ create project\nthis.eclipseProject.save(getRunnerProjectSettings().getBaseDir().toPath());\n}\n\n\/\/ remove SETTE imports\ncompilationUnit.getImports().removeIf(importDeclaration -> {\nString impDecl = importDeclaration.getName().toString();\nfor (String prefix : toRemovePrefixes) {\nif (impDecl.startsWith(prefix)) {\nreturn true;\n}\n}\nreturn false;\n});\n\/\/ save edited source code\nString source = compilationUnit.toString();\nif (type instanceof EnumDeclaration) {\n\/\/ FIXME remove after javaparser bug is fixed\nsource = source.replaceFirst(type.getName() + \"\\\\s+implements\\\\s*\\\\{\",\ntype.getName() + \" {\");\n}\nPathUtils.write(file.toPath(), source.getBytes());\n}\n}\n\/\/ copy libraries\nif (getSnippetProject().getLibDir().toFile().exists()) {\nPathUtils.copy(getSnippetProject().getLibDir(),\ngetRunnerProjectSettings().getSnippetLibraryDirectory().toPath());\n}\n\/\/ create project\nthis.eclipseProject.save(getRunnerProjectSettings().getBaseDir().toPath());\n}\n\nreturn true;\n}\n}\nreturn false;\n});\n\/\/ save edited source code\nString source = compilationUnit.toString();\nif (type instanceof EnumDeclaration) {\n\/\/ FIXME remove after javaparser bug is fixed\nsource = source.replaceFirst(type.getName() + \"\\\\s+implements\\\\s*\\\\{\",\ntype.getName() + \" {\");\n}\nPathUtils.write(file.toPath(), source.getBytes());\n}\n}\n\/\/ copy libraries\nif (getSnippetProject().getLibDir().toFile().exists()) {\nPathUtils.copy(getSnippetProject().getLibDir(),\ngetRunnerProjectSettings().getSnippetLibraryDirectory().toPath());\n}\n\/\/ create project\nthis.eclipseProject.save(getRunnerProjectSettings().getBaseDir().toPath());\n}","label":[1,0,1,0]}
{"id":15691,"original_code":"public boolean isSubjectEmpty() {\n        return TextUtils.getTrimmedLength(mSubject.getText()) == 0;\n    }","code":"public boolean isSubjectEmpty() {\n        return TextUtils.getTrimmedLength(mSubject.getText()) == 0;\n    }","cleancode":"public boolean issubjectempty() { return textutils.gettrimmedlength(msubject.gettext()) == 0; }","comment":"\/** * test to see if the subject is empty. * * @return boolean. *\/ \/\/ todo: this will likely go away when composearea.focus() is implemented \/\/ after all the widget control is moved over.","repo":"Keneral\/apackages","code_context_2":"public boolean isSubjectEmpty() {\nreturn TextUtils.getTrimmedLength(mSubject.getText()) == 0;\n}","code_context_10":"public boolean isSubjectEmpty() {\nreturn TextUtils.getTrimmedLength(mSubject.getText()) == 0;\n}","code_context_20":"public boolean isSubjectEmpty() {\nreturn TextUtils.getTrimmedLength(mSubject.getText()) == 0;\n}","label":[1,0,0,0]}
{"id":23891,"original_code":"public void buildOutAssignment(StringBuilder sb, PLSQLargument outArg, PLSQLStoredProcedureCall call) {\n        String sql2PlName = call.getPl2SQLName(this);\n        if (sql2PlName == null) {\n            \/\/ TODO: Error.\n            throw new NullPointerException(\"no Pl2SQL conversion routine for \" + typeName);\n        }\n        String target = databaseTypeHelper.buildTarget(outArg);\n        sb.append(\"  :\");\n        sb.append(outArg.outIndex);\n        sb.append(\" := \");\n        sb.append(sql2PlName);\n        sb.append(\"(\");\n        sb.append(target);\n        sb.append(\");\");\n        sb.append(NL);\n    }","code":"public void buildOutAssignment(StringBuilder sb, PLSQLargument outArg, PLSQLStoredProcedureCall call) {\n        String sql2PlName = call.getPl2SQLName(this);\n        if (sql2PlName == null) {\n           \n            throw new NullPointerException(\"no Pl2SQL conversion routine for \" + typeName);\n        }\n        String target = databaseTypeHelper.buildTarget(outArg);\n        sb.append(\"  :\");\n        sb.append(outArg.outIndex);\n        sb.append(\" := \");\n        sb.append(sql2PlName);\n        sb.append(\"(\");\n        sb.append(target);\n        sb.append(\");\");\n        sb.append(NL);\n    }","cleancode":"public void buildoutassignment(stringbuilder sb, plsqlargument outarg, plsqlstoredprocedurecall call) { string sql2plname = call.getpl2sqlname(this); if (sql2plname == null) { throw new nullpointerexception(\"no pl2sql conversion routine for \" + typename); } string target = databasetypehelper.buildtarget(outarg); sb.append(\" :\"); sb.append(outarg.outindex); sb.append(\" := \"); sb.append(sql2plname); sb.append(\"(\"); sb.append(target); sb.append(\");\"); sb.append(nl); }","comment":"\/\/ todo: error.","repo":"Pandrex247\/patched-src-eclipselink","code_context_2":"String sql2PlName = call.getPl2SQLName(this);\nif (sql2PlName == null) {\n\/\/ TODO: Error.\nthrow new NullPointerException(\"no Pl2SQL conversion routine for \" + typeName);\n}","code_context_10":"public void buildOutAssignment(StringBuilder sb, PLSQLargument outArg, PLSQLStoredProcedureCall call) {\nString sql2PlName = call.getPl2SQLName(this);\nif (sql2PlName == null) {\n\/\/ TODO: Error.\nthrow new NullPointerException(\"no Pl2SQL conversion routine for \" + typeName);\n}\nString target = databaseTypeHelper.buildTarget(outArg);\nsb.append(\" :\");\nsb.append(outArg.outIndex);\nsb.append(\" := \");\nsb.append(sql2PlName);\nsb.append(\"(\");\nsb.append(target);\nsb.append(\");\");","code_context_20":"public void buildOutAssignment(StringBuilder sb, PLSQLargument outArg, PLSQLStoredProcedureCall call) {\nString sql2PlName = call.getPl2SQLName(this);\nif (sql2PlName == null) {\n\/\/ TODO: Error.\nthrow new NullPointerException(\"no Pl2SQL conversion routine for \" + typeName);\n}\nString target = databaseTypeHelper.buildTarget(outArg);\nsb.append(\" :\");\nsb.append(outArg.outIndex);\nsb.append(\" := \");\nsb.append(sql2PlName);\nsb.append(\"(\");\nsb.append(target);\nsb.append(\");\");\nsb.append(NL);\n}","label":[0,0,1,0]}
{"id":23901,"original_code":"private void guestSearchActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_guestSearchActionPerformed\n        \/\/ TODO add your handling code here:\n        \/\/Guestsearch guestsearch = new Guestsearch(jFrameInstance, email);\n        \/\/jFrameInstance.changePanelToSpecific(guestsearch);\n    }","code":"private void guestSearchActionPerformed(java.awt.event.ActionEvent evt) {       \n       \n       \n    }","cleancode":"private void guestsearchactionperformed(java.awt.event.actionevent evt) { }","comment":"\/\/gen-first:event_guestsearchactionperformed\n\/\/ todo add your handling code here: \/\/guestsearch guestsearch = new guestsearch(jframeinstance, email); \/\/jframeinstance.changepaneltospecific(guestsearch);","repo":"Jed-g\/property-booking-system","code_context_2":"private void guestSearchActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_guestSearchActionPerformed\n\/\/ TODO add your handling code here:\n\/\/Guestsearch guestsearch = new Guestsearch(jFrameInstance, email);\n\nprivate void guestSearchActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_guestSearchActionPerformed\n\/\/ TODO add your handling code here:\n\/\/Guestsearch guestsearch = new Guestsearch(jFrameInstance, email);\n\/\/jFrameInstance.changePanelToSpecific(guestsearch);\n}","code_context_10":"private void guestSearchActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_guestSearchActionPerformed\n\/\/ TODO add your handling code here:\n\/\/Guestsearch guestsearch = new Guestsearch(jFrameInstance, email);\n\/\/jFrameInstance.changePanelToSpecific(guestsearch);\n}\n\nprivate void guestSearchActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_guestSearchActionPerformed\n\/\/ TODO add your handling code here:\n\/\/Guestsearch guestsearch = new Guestsearch(jFrameInstance, email);\n\/\/jFrameInstance.changePanelToSpecific(guestsearch);\n}","code_context_20":"private void guestSearchActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_guestSearchActionPerformed\n\/\/ TODO add your handling code here:\n\/\/Guestsearch guestsearch = new Guestsearch(jFrameInstance, email);\n\/\/jFrameInstance.changePanelToSpecific(guestsearch);\n}\n\nprivate void guestSearchActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_guestSearchActionPerformed\n\/\/ TODO add your handling code here:\n\/\/Guestsearch guestsearch = new Guestsearch(jFrameInstance, email);\n\/\/jFrameInstance.changePanelToSpecific(guestsearch);\n}","label":[0,1,0,0]}
{"id":32148,"original_code":"@Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        \/\/ TODO: This test will actually mess with contacts on your phone.\n        \/\/ Ideally we would use a fake content provider to give us contact data...\n        FakeFactory.registerWithoutFakeContext(getTestContext());\n        \/\/ add test contacts.\n        addTestContact(\"John\", \"650-123-1233\", \"john@gmail.com\", false);\n        addTestContact(\"Joe\", \"(650)123-1233\", \"joe@gmail.com\", false);\n        addTestContact(\"Jim\", \"650 123 1233\", \"jim@gmail.com\", false);\n        addTestContact(\"Samantha\", \"650-123-1235\", \"samantha@gmail.com\", true);\n        addTestContact(\"Adrienne\", \"650-123-1236\", \"adrienne@gmail.com\", true);\n    }","code":"@Override\n    protected void setUp() throws Exception {\n        super.setUp();\n       \n       \n        FakeFactory.registerWithoutFakeContext(getTestContext());\n       \n        addTestContact(\"John\", \"650-123-1233\", \"john@gmail.com\", false);\n        addTestContact(\"Joe\", \"(650)123-1233\", \"joe@gmail.com\", false);\n        addTestContact(\"Jim\", \"650 123 1233\", \"jim@gmail.com\", false);\n        addTestContact(\"Samantha\", \"650-123-1235\", \"samantha@gmail.com\", true);\n        addTestContact(\"Adrienne\", \"650-123-1236\", \"adrienne@gmail.com\", true);\n    }","cleancode":"@override protected void setup() throws exception { super.setup(); fakefactory.registerwithoutfakecontext(gettestcontext()); addtestcontact(\"john\", \"650-123-1233\", \"john@gmail.com\", false); addtestcontact(\"joe\", \"(650)123-1233\", \"joe@gmail.com\", false); addtestcontact(\"jim\", \"650 123 1233\", \"jim@gmail.com\", false); addtestcontact(\"samantha\", \"650-123-1235\", \"samantha@gmail.com\", true); addtestcontact(\"adrienne\", \"650-123-1236\", \"adrienne@gmail.com\", true); }","comment":"\/\/ todo: this test will actually mess with contacts on your phone. \/\/ ideally we would use a fake content provider to give us contact data...\n\/\/ add test contacts.","repo":"Keneral\/apackages","code_context_2":"protected void setUp() throws Exception {\nsuper.setUp();\n\/\/ TODO: This test will actually mess with contacts on your phone.\n\/\/ Ideally we would use a fake content provider to give us contact data...\nFakeFactory.registerWithoutFakeContext(getTestContext());\n\/\/ add test contacts.\n\n\/\/ Ideally we would use a fake content provider to give us contact data...\nFakeFactory.registerWithoutFakeContext(getTestContext());\n\/\/ add test contacts.\naddTestContact(\"John\", \"650-123-1233\", \"john@gmail.com\", false);\naddTestContact(\"Joe\", \"(650)123-1233\", \"joe@gmail.com\", false);","code_context_10":"@Override\nprotected void setUp() throws Exception {\nsuper.setUp();\n\/\/ TODO: This test will actually mess with contacts on your phone.\n\/\/ Ideally we would use a fake content provider to give us contact data...\nFakeFactory.registerWithoutFakeContext(getTestContext());\n\/\/ add test contacts.\naddTestContact(\"John\", \"650-123-1233\", \"john@gmail.com\", false);\naddTestContact(\"Joe\", \"(650)123-1233\", \"joe@gmail.com\", false);\naddTestContact(\"Jim\", \"650 123 1233\", \"jim@gmail.com\", false);\naddTestContact(\"Samantha\", \"650-123-1235\", \"samantha@gmail.com\", true);\naddTestContact(\"Adrienne\", \"650-123-1236\", \"adrienne@gmail.com\", true);\n}\n\n@Override\nprotected void setUp() throws Exception {\nsuper.setUp();\n\/\/ TODO: This test will actually mess with contacts on your phone.\n\/\/ Ideally we would use a fake content provider to give us contact data...\nFakeFactory.registerWithoutFakeContext(getTestContext());\n\/\/ add test contacts.\naddTestContact(\"John\", \"650-123-1233\", \"john@gmail.com\", false);\naddTestContact(\"Joe\", \"(650)123-1233\", \"joe@gmail.com\", false);\naddTestContact(\"Jim\", \"650 123 1233\", \"jim@gmail.com\", false);\naddTestContact(\"Samantha\", \"650-123-1235\", \"samantha@gmail.com\", true);\naddTestContact(\"Adrienne\", \"650-123-1236\", \"adrienne@gmail.com\", true);\n}","code_context_20":"@Override\nprotected void setUp() throws Exception {\nsuper.setUp();\n\/\/ TODO: This test will actually mess with contacts on your phone.\n\/\/ Ideally we would use a fake content provider to give us contact data...\nFakeFactory.registerWithoutFakeContext(getTestContext());\n\/\/ add test contacts.\naddTestContact(\"John\", \"650-123-1233\", \"john@gmail.com\", false);\naddTestContact(\"Joe\", \"(650)123-1233\", \"joe@gmail.com\", false);\naddTestContact(\"Jim\", \"650 123 1233\", \"jim@gmail.com\", false);\naddTestContact(\"Samantha\", \"650-123-1235\", \"samantha@gmail.com\", true);\naddTestContact(\"Adrienne\", \"650-123-1236\", \"adrienne@gmail.com\", true);\n}\n\n@Override\nprotected void setUp() throws Exception {\nsuper.setUp();\n\/\/ TODO: This test will actually mess with contacts on your phone.\n\/\/ Ideally we would use a fake content provider to give us contact data...\nFakeFactory.registerWithoutFakeContext(getTestContext());\n\/\/ add test contacts.\naddTestContact(\"John\", \"650-123-1233\", \"john@gmail.com\", false);\naddTestContact(\"Joe\", \"(650)123-1233\", \"joe@gmail.com\", false);\naddTestContact(\"Jim\", \"650 123 1233\", \"jim@gmail.com\", false);\naddTestContact(\"Samantha\", \"650-123-1235\", \"samantha@gmail.com\", true);\naddTestContact(\"Adrienne\", \"650-123-1236\", \"adrienne@gmail.com\", true);\n}","label":[0,0,0,1]}
{"id":15785,"original_code":"@Override\n\tpublic ItemStack transferStackInSlot(EntityPlayer player, int slot) {\n\t\t\/\/ TODO: Try to come up with a generic way of implementing this\n\t\treturn null;\n\t}","code":"@Override\n\tpublic ItemStack transferStackInSlot(EntityPlayer player, int slot) {\n\t\n\t\treturn null;\n\t}","cleancode":"@override public itemstack transferstackinslot(entityplayer player, int slot) { return null; }","comment":"\/\/ todo: try to come up with a generic way of implementing this","repo":"PC-Logix\/GregsLighting-Reloaded","code_context_2":"@Override\npublic ItemStack transferStackInSlot(EntityPlayer player, int slot) {\n\/\/ TODO: Try to come up with a generic way of implementing this\nreturn null;\n}","code_context_10":"@Override\npublic ItemStack transferStackInSlot(EntityPlayer player, int slot) {\n\/\/ TODO: Try to come up with a generic way of implementing this\nreturn null;\n}","code_context_20":"@Override\npublic ItemStack transferStackInSlot(EntityPlayer player, int slot) {\n\/\/ TODO: Try to come up with a generic way of implementing this\nreturn null;\n}","label":[1,0,0,0]}
{"id":7631,"original_code":"public JSONArray getProjectRevisions(ProjectEndpoint endpoint) {\n\t\t\/\/TODO need to add paging somewhere (page, items) to handle long commit histories\n\t\tString json = restInterface.get(TeamworkCloudEndpoints.GET_PROJECT_REVISIONS.buildUrl(endpoint.getHost(),\n\t\t\t\tendpoint.getCollection(), endpoint.getProject(), \"true\"), endpoint.getToken(), String.class);\n\t\treturn new JSONArray(json);\n\t}","code":"public JSONArray getProjectRevisions(ProjectEndpoint endpoint) {\n\t\n\t\tString json = restInterface.get(TeamworkCloudEndpoints.GET_PROJECT_REVISIONS.buildUrl(endpoint.getHost(),\n\t\t\t\tendpoint.getCollection(), endpoint.getProject(), \"true\"), endpoint.getToken(), String.class);\n\t\treturn new JSONArray(json);\n\t}","cleancode":"public jsonarray getprojectrevisions(projectendpoint endpoint) { string json = restinterface.get(teamworkcloudendpoints.get_project_revisions.buildurl(endpoint.gethost(), endpoint.getcollection(), endpoint.getproject(), \"true\"), endpoint.gettoken(), string.class); return new jsonarray(json); }","comment":"\/\/todo need to add paging somewhere (page, items) to handle long commit histories","repo":"Open-MBEE\/sync-service","code_context_2":"public JSONArray getProjectRevisions(ProjectEndpoint endpoint) {\n\/\/TODO need to add paging somewhere (page, items) to handle long commit histories\nString json = restInterface.get(TeamworkCloudEndpoints.GET_PROJECT_REVISIONS.buildUrl(endpoint.getHost(),\nendpoint.getCollection(), endpoint.getProject(), \"true\"), endpoint.getToken(), String.class);","code_context_10":"public JSONArray getProjectRevisions(ProjectEndpoint endpoint) {\n\/\/TODO need to add paging somewhere (page, items) to handle long commit histories\nString json = restInterface.get(TeamworkCloudEndpoints.GET_PROJECT_REVISIONS.buildUrl(endpoint.getHost(),\nendpoint.getCollection(), endpoint.getProject(), \"true\"), endpoint.getToken(), String.class);\nreturn new JSONArray(json);\n}","code_context_20":"public JSONArray getProjectRevisions(ProjectEndpoint endpoint) {\n\/\/TODO need to add paging somewhere (page, items) to handle long commit histories\nString json = restInterface.get(TeamworkCloudEndpoints.GET_PROJECT_REVISIONS.buildUrl(endpoint.getHost(),\nendpoint.getCollection(), endpoint.getProject(), \"true\"), endpoint.getToken(), String.class);\nreturn new JSONArray(json);\n}","label":[0,1,0,0]}
{"id":24107,"original_code":"public void ClearScreenTest(){\n        press(R.id.btn_1);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.binary_number_2);\n        press(R.id.btn_1);\n        press(R.id.btn_0);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_divide);\n        press(R.id.btn_all_clear);\n        checkResult(\"\");\n        checkBinary1(\"\");\n        checkBinary2(\"\");\n    }","code":"public void ClearScreenTest(){\n        press(R.id.btn_1);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.binary_number_2);\n        press(R.id.btn_1);\n        press(R.id.btn_0);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_divide);\n        press(R.id.btn_all_clear);\n        checkResult(\"\");\n        checkBinary1(\"\");\n        checkBinary2(\"\");\n    }","cleancode":"public void clearscreentest(){ press(r.id.btn_1); press(r.id.btn_0); press(r.id.btn_0); press(r.id.btn_0); press(r.id.btn_0); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_1); press(r.id.binary_number_2); press(r.id.btn_1); press(r.id.btn_0); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_divide); press(r.id.btn_all_clear); checkresult(\"\"); checkbinary1(\"\"); checkbinary2(\"\"); }","comment":"\/\/todo: figure our why these tests fail on ci build, despite passing locally \/\/@test","repo":"ModestosV\/Simple-Calculator","code_context_2":"public void ClearScreenTest(){\npress(R.id.btn_1);\npress(R.id.btn_0);\npress(R.id.btn_0);\npress(R.id.btn_0);\npress(R.id.btn_0);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.binary_number_2);\npress(R.id.btn_1);\npress(R.id.btn_0);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_divide);\npress(R.id.btn_all_clear);\ncheckResult(\"\");\ncheckBinary1(\"\");\ncheckBinary2(\"\");\n}","code_context_10":"public void ClearScreenTest(){\npress(R.id.btn_1);\npress(R.id.btn_0);\npress(R.id.btn_0);\npress(R.id.btn_0);\npress(R.id.btn_0);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.binary_number_2);\npress(R.id.btn_1);\npress(R.id.btn_0);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_divide);\npress(R.id.btn_all_clear);\ncheckResult(\"\");\ncheckBinary1(\"\");\ncheckBinary2(\"\");\n}","code_context_20":"public void ClearScreenTest(){\npress(R.id.btn_1);\npress(R.id.btn_0);\npress(R.id.btn_0);\npress(R.id.btn_0);\npress(R.id.btn_0);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.binary_number_2);\npress(R.id.btn_1);\npress(R.id.btn_0);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_divide);\npress(R.id.btn_all_clear);\ncheckResult(\"\");\ncheckBinary1(\"\");\ncheckBinary2(\"\");\n}","label":[0,0,0,1]}
{"id":24108,"original_code":"public void DeleteTest(){\n        press(R.id.btn_1);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_del);\n        checkBinary1(\"1000011111\");\n        press(R.id.binary_number_2);\n        press(R.id.btn_1);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_del);\n        checkBinary2(\"10\");\n    }","code":"public void DeleteTest(){\n        press(R.id.btn_1);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_del);\n        checkBinary1(\"1000011111\");\n        press(R.id.binary_number_2);\n        press(R.id.btn_1);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_del);\n        checkBinary2(\"10\");\n    }","cleancode":"public void deletetest(){ press(r.id.btn_1); press(r.id.btn_0); press(r.id.btn_0); press(r.id.btn_0); press(r.id.btn_0); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_del); checkbinary1(\"1000011111\"); press(r.id.binary_number_2); press(r.id.btn_1); press(r.id.btn_0); press(r.id.btn_0); press(r.id.btn_del); checkbinary2(\"10\"); }","comment":"\/\/todo: figure our why these tests fail on ci build, despite passing locally \/\/@test","repo":"ModestosV\/Simple-Calculator","code_context_2":"public void DeleteTest(){\npress(R.id.btn_1);\npress(R.id.btn_0);\npress(R.id.btn_0);\npress(R.id.btn_0);\npress(R.id.btn_0);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_del);\ncheckBinary1(\"1000011111\");\npress(R.id.binary_number_2);\npress(R.id.btn_1);\npress(R.id.btn_0);\npress(R.id.btn_0);\npress(R.id.btn_del);\ncheckBinary2(\"10\");\n}","code_context_10":"public void DeleteTest(){\npress(R.id.btn_1);\npress(R.id.btn_0);\npress(R.id.btn_0);\npress(R.id.btn_0);\npress(R.id.btn_0);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_del);\ncheckBinary1(\"1000011111\");\npress(R.id.binary_number_2);\npress(R.id.btn_1);\npress(R.id.btn_0);\npress(R.id.btn_0);\npress(R.id.btn_del);\ncheckBinary2(\"10\");\n}","code_context_20":"public void DeleteTest(){\npress(R.id.btn_1);\npress(R.id.btn_0);\npress(R.id.btn_0);\npress(R.id.btn_0);\npress(R.id.btn_0);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_1);\npress(R.id.btn_del);\ncheckBinary1(\"1000011111\");\npress(R.id.binary_number_2);\npress(R.id.btn_1);\npress(R.id.btn_0);\npress(R.id.btn_0);\npress(R.id.btn_del);\ncheckBinary2(\"10\");\n}","label":[0,0,0,1]}
{"id":15927,"original_code":"public int ExecuteGFXCommand(int cmd, int len, byte[] cmddata, int[] hasret)\n\t{\n\t\tlen -= 4; \/\/ for the 4 byte header\n\t    hasret[0] = 0; \/\/ Nothing to return by default\n\/\/\t\tSystem.out.println(\"GFXCMD=\" + cmd);\n\t\t\/\/ make sure the frame is still valid or we could crash on fullscreen mode switches\n\t\tif((cmd != GFXCMD_INIT) && (cmd != GFXCMD_DEINIT))\n\t\t{\n\t\t\tif((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\n\/\/\t\t\t\tSystem.out.println(\"GFXCMD while frame not displayable\");\n\t\t\t\t\/\/ spin until the frame is valid and displayable, if we don't we'll lose parts of the UI or crash\n\t\t\t\twhile((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tThread.sleep(10);\n\t\t\t\t\t} catch(InterruptedException ex) {}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c != null)\n\t\t{\n\t\t\tswitch(cmd)\n\t\t\t{\n\t\t\t\tcase GFXCMD_INIT:\n\t\t\t\tcase GFXCMD_DEINIT:\n\t\t\t\tcase GFXCMD_STARTFRAME:\n\t\t\t\tcase GFXCMD_FLIPBUFFER:\n\t\t\t\t\tc.setCursor(null);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GFXCMD_DRAWRECT:\n\t\t\t\tcase GFXCMD_FILLRECT:\n\t\t\t\tcase GFXCMD_CLEARRECT:\n\t\t\t\tcase GFXCMD_DRAWOVAL:\n\t\t\t\tcase GFXCMD_FILLOVAL:\n\t\t\t\tcase GFXCMD_DRAWROUNDRECT:\n\t\t\t\tcase GFXCMD_FILLROUNDRECT:\n\t\t\t\tcase GFXCMD_DRAWTEXT:\n\t\t\t\tcase GFXCMD_DRAWTEXTURED:\n\t\t\t\tcase GFXCMD_DRAWLINE:\n\t\t\t\tcase GFXCMD_LOADIMAGE:\n\t\t\t\tcase GFXCMD_LOADIMAGETARGETED:\n\t\t\t\tcase GFXCMD_UNLOADIMAGE:\n\t\t\t\tcase GFXCMD_LOADFONT:\n\t\t\t\tcase GFXCMD_UNLOADFONT:\n\t\t\t\tcase GFXCMD_SETTARGETSURFACE:\n\t\t\t\tcase GFXCMD_CREATESURFACE:\n\t\t\t\t\tbreak;\n\t\t\t\tcase GFXCMD_PREPIMAGE:\n\t\t\t\tcase GFXCMD_LOADIMAGELINE:\n\t\t\t\tcase GFXCMD_LOADIMAGECOMPRESSED:\n\t\t\t\tcase GFXCMD_XFMIMAGE:\n\t\t\t\tcase GFXCMD_LOADCACHEDIMAGE:\n\t\t\t\tcase GFXCMD_PREPIMAGETARGETED:\n\t\t\t\t\tif (!cursorHidden)\n\t\t\t\t\t\tc.setCursor(java.awt.Cursor.getPredefinedCursor(java.awt.Cursor.WAIT_CURSOR));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswitch(cmd)\n\t\t{\n\t\t\tcase GFXCMD_INIT:\n\t\t\t\thasret[0] = 1;\n\/\/\t\t\t\tSystem.out.println(\"INIT\");\n\t\t\t\t\/\/ start up native renderer\n\t\t\t\tinit0();\n\t\t\t\tint windowTitleStyle = 0;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\twindowTitleStyle = Integer.parseInt(MiniClient.myProperties.getProperty(\"window_title_style\", \"0\"));\n\t\t\t\t}\n\t\t\t\tcatch (NumberFormatException e){}\n\t\t\t\tif (!\"true\".equals(MiniClient.myProperties.getProperty(\"enable_custom_title_bar\", MiniClient.MAC_OS_X ? \"false\" : \"true\")))\n\t\t\t\t\twindowTitleStyle = 10; \/\/ platform default\n\t\t\t\tf = new MiniClientWindow(myConn.getWindowTitle(), windowTitleStyle);\n\t\t\t\tjava.awt.LayoutManager layer = new java.awt.LayoutManager()\n\t\t\t\t\t{\n\t\t\t\t\t\tpublic void addLayoutComponent(String name, java.awt.Component comp)\n\t\t\t\t\t\t{}\n\t\t\t\t\t\tpublic java.awt.Dimension minimumLayoutSize(java.awt.Container parent)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn preferredLayoutSize(parent);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic java.awt.Dimension preferredLayoutSize(java.awt.Container parent)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn parent.getPreferredSize();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void removeLayoutComponent(java.awt.Component comp)\n\t\t\t\t\t\t{}\n\t\t\t\t\t\tpublic void layoutContainer(java.awt.Container parent)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc.setBounds(parent.getInsets().left, parent.getInsets().top, parent.getWidth() - parent.getInsets().left - parent.getInsets().right,\n\t\t\t\t\t\t\t\tparent.getHeight() - parent.getInsets().top - parent.getInsets().bottom);\n\/\/System.out.println(\"LAYOUT frame bounds=\" + f.getBounds() + \" videoBounds=\" + videoBounds + \" parentBounds=\" + parent.getBounds());\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tf.getContentPane().setLayout(layer);\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tbgImage = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/Background.jpg\"));\n\t\t\t\t\tensureImageIsLoaded(bgImage);\n\t\t\t\t\tlogoImage = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/SageLogo256.png\"));\n\t\t\t\t\tensureImageIsLoaded(logoImage);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"ERROR:\" + e);\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tf.setFocusTraversalKeysEnabled(false);\n\t\t\t\t\/*\n\t\t\t\t\tif not connecting to localhost:\n\t\t\t\t\t\t- draw background to bounds (scaled)\n\t\t\t\t\t\t- draw logo to {{2% from left, 15% from top}{20% view width, 7% view height}}, no clipping, alpha = 0.85, adjust size to keep aspect ratio\n\t\t\t\t\t\t- load Arial 32 bold\n\t\t\t\t\t\t- draw the following text, double spaced using Arial 32 bold, white with black shadow (offset by (+2,+2))\n\t\t\t\t\t\t\t\"SageTV Placeshifter is connecting to\"\n\t\t\t\t\t\t\t\"the server: \"+myConn.getServerName()\n\t\t\t\t\t\t\t\"Please Wait...\"\n\t\t\t\t\t\ttext is centered in the view on the middle line, use font metrics to determine proper location\n\t\t\t\t\t\t g.setFont(pleaseWaitFont);\n\t\t\t\t\t\t g.setColor(java.awt.Color.black);\n\t\t\t\t\t\t y += 2;\n\t\t\t\t\t\t g.drawString(str1, 2 + (getWidth()\/2) - (fm.stringWidth(str1)\/2), y + fm.getAscent());\n\t\t\t\t\t\t y += fm.getHeight();\n\t\t\t\t\t\t g.drawString(str2, 2 + (getWidth()\/2) - (fm.stringWidth(str2)\/2), y + fm.getAscent());\n\t\t\t\t\t\t y += 2*fm.getHeight();\n\t\t\t\t\t\t g.drawString(str3, 2 + (getWidth()\/2) - (fm.stringWidth(str3)\/2), y + fm.getAscent());\n\t\t\t\t\t\t g.setColor(java.awt.Color.white);\n\t\t\t\t\t\t y = (getHeight() \/ 2) - fh\/2;\n\t\t\t\t\t\t g.drawString(str1, (getWidth()\/2) - (fm.stringWidth(str1)\/2), y + fm.getAscent());\n\t\t\t\t\t\t y += fm.getHeight();\n\t\t\t\t\t\t g.drawString(str2, (getWidth()\/2) - (fm.stringWidth(str2)\/2), y + fm.getAscent());\n\t\t\t\t\t\t y += 2*fm.getHeight();\n\t\t\t\t\t\t g.drawString(str3, (getWidth()\/2) - (fm.stringWidth(str3)\/2), y + fm.getAscent());\n\t\t\t\t *\/\n\t\t\t\tjava.awt.Dimension panelSize = f.getContentPane().getSize();\n\t\t\t\tc = new QuartzRendererView();\n\t\t\t\tc.setSize(panelSize);\n\t\t\t\tc.setFocusTraversalKeysEnabled(false);\n\t\t\t\tf.getContentPane().add(c);\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tjava.awt.Image frameIcon = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/tvicon.gif\"));\n\t\t\t\t\tensureImageIsLoaded(frameIcon);\n\t\t\t\t\tf.setIconImage(frameIcon);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"ERROR:\" + e);\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tf.addWindowListener(new java.awt.event.WindowAdapter()\n\t\t\t\t{\n\t\t\t\t\tpublic void windowClosing(java.awt.event.WindowEvent evt)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!f.isFullScreen() || System.getProperty(\"os.name\").toLowerCase().indexOf(\"windows\") != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMiniClient.myProperties.setProperty(\"main_window_width\", Integer.toString(f.getWidth()));\n\t\t\t\t\t\t\tMiniClient.myProperties.setProperty(\"main_window_height\", Integer.toString(f.getHeight()));\n\t\t\t\t\t\t\tMiniClient.myProperties.setProperty(\"main_window_x\", Integer.toString(f.getX()));\n\t\t\t\t\t\t\tMiniClient.myProperties.setProperty(\"main_window_y\", Integer.toString(f.getY()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmyConn.close();\n\/*\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (myConn.getMediaCmd().getPlaya() != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmyConn.getMediaCmd().getPlaya().stop();\n\t\t\t\t\t\t\t\tmyConn.getMediaCmd().getPlaya().free();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}catch (Exception e){}\n\t\t\t\t\t\tSystem.exit(0);*\/\n\t\t\t\t\t\tclose();\n\/\/\t\t\t\t\t\tf.dispose();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tc.addComponentListener(new java.awt.event.ComponentAdapter()\n\t\t\t\t{\n\t\t\t\t\tpublic void componentResized(java.awt.event.ComponentEvent evt)\n\t\t\t\t\t{\n\t\t\t\t\t\tmyConn.postResizeEvent(new java.awt.Dimension(c.getWidth(), c.getHeight()));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tf.addKeyListener(this);\n\t\t\t\tc.addKeyListener(this);\n\t\t\t\t\/\/f.addMouseListener(this);\n\t\t\t\tf.addMouseWheelListener(this);\n\t\t\t\tc.addMouseListener(this);\n\t\t\t\tif (ENABLE_MOUSE_MOTION_EVENTS)\n\t\t\t\t{\n\t\t\t\t\t\/\/f.addMouseMotionListener(this);\n\t\t\t\t\tc.addMouseMotionListener(this);\n\t\t\t\t}\n\t\t\t\tint frameX = 100;\n\t\t\t\tint frameY = 100;\n\t\t\t\tint frameW = 720;\n\t\t\t\tint frameH = 480;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tframeW = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_width\", \"720\"));\n\t\t\t\t\tframeH = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_height\", \"480\"));\n\t\t\t\t\tframeX = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_x\", \"100\"));\n\t\t\t\t\tframeY = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_y\", \"100\"));\n\t\t\t\t}\n\t\t\t\tcatch (NumberFormatException e){}\n\t\t\t\tjava.awt.Point newPos = new java.awt.Point(frameX, frameY);\n\t\t\t\tboolean foundScreen = sage.UIUtils.isPointOnAScreen(newPos);\n\t\t\t\tif (!foundScreen)\n\t\t\t\t{\n\t\t\t\t\tnewPos.x = 150;\n\t\t\t\t\tnewPos.y = 150;\n\t\t\t\t}\n\t\t\t\tf.setVisible(true);\n\t\t\t\tf.setSize(1,1);\n\t\t\t\tf.setSize(Math.max(frameW, 320), Math.max(frameH, 240));\n\t\t\t\tf.setLocation(newPos);\n\t\t\t\tif (MiniClient.fsStartup)\n\t\t\t\t\tf.setFullScreen(true);\n\t\t\t\tMiniClient.hideSplash();\n\/\/\t\t\t\tf.setVisible(true);\n\t\t\t\treturn 1;\n\t\t\tcase GFXCMD_DEINIT:\n\/\/\t\t\t\tSystem.out.println(\"DEINIT\");\n\t\t\t\tclose();\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWRECT:\n\t\t\t\tif(len==36)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height;\n\t\t\t\t\tint thickness, argbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\tthickness=readInt(16, cmddata);\n\t\t\t\t\targbTL=readInt(20, cmddata);\n\t\t\t\t\targbTR=readInt(24, cmddata);\n\t\t\t\t\targbBR=readInt(28, cmddata);\n\t\t\t\t\targbBL=readInt(32, cmddata);\n\/\/\t\t\t\t\tSystem.out.println(\"DRAWRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") thickness=\"+thickness+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\t\t\t\t\t\/\/ FIXME: no gradients on framed rects yet...\n\t\t\t\t\tdrawRect0(new java.awt.geom.Rectangle2D.Float(x, y, width, height), null,\n\t\t\t\t\t\t\t  0,\n\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), thickness,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWRECT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_FILLRECT:\n\t\t\t\t\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL\n\t\t\t\tif(len==32)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height;\n\t\t\t\t\tint argbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\targbTL=readInt(16, cmddata);\n\t\t\t\t\targbTR=readInt(20, cmddata);\n\t\t\t\t\targbBR=readInt(24, cmddata);\n\t\t\t\t\targbBL=readInt(28, cmddata);\n\/\/\t\t\t\t\tSystem.out.println(\"FILLRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\t\t\t\t\tjava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tif(gp != null) {\n\t\t\t\t\t\tdrawRect0(bounds, null,\n\t\t\t\t\t\t\t\t  0,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  gp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\n\t\t\t\t\t\t\t\t  gp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\t\t\t\t\t\t\t\t  \/\/(float)((argbTL>>24)&0xff)\/255.0f);\n\t\t\t\t\t\t\t\t  1.0f); \/\/ alpha already supplied\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdrawRect0(bounds, null,\n\t\t\t\t\t\t\t\t  0,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_FILLRECT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_CLEARRECT:\n\t\t\t\t\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL\n\t\t\t\tif(len==32)\n\t\t\t\t{\n\t\t\t\t\tint x, y, width, height,\n\t\t\t\t\t\targbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=readInt(0, cmddata);\n\t\t\t\t\ty=readInt(4, cmddata);\n\t\t\t\t\twidth=readInt(8, cmddata);\n\t\t\t\t\theight=readInt(12, cmddata);\n\t\t\t\t\targbTL=readInt(16, cmddata);\n\t\t\t\t\targbTR=readInt(20, cmddata);\n\t\t\t\t\targbBR=readInt(24, cmddata);\n\t\t\t\t\targbBL=readInt(28, cmddata);\n\/\/\t\t\t\t\tSystem.out.println(\"CLEARRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float destRect = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tclearRect0(destRect);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_CLEARRECT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWOVAL:\n\t\t\t\t\/\/ x, y, width, height, thickness, argbTL, argbTR, argbBR, argbBL,\n\t\t\t\t\/\/ clipX, clipY, clipW, clipH\n\t\t\t\tif(len==52)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height, clipX, clipY, clipW, clipH;\n\t\t\t\t\tint thickness, argbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\tthickness=readInt(16, cmddata);\n\t\t\t\t\targbTL=readInt(20, cmddata);\n\t\t\t\t\targbTR=readInt(24, cmddata);\n\t\t\t\t\targbBR=readInt(28, cmddata);\n\t\t\t\t\targbBL=readInt(32, cmddata);\n\t\t\t\t\tclipX=(float)readInt(36, cmddata);\n\t\t\t\t\tclipY=(float)readInt(40, cmddata);\n\t\t\t\t\tclipW=(float)readInt(44, cmddata);\n\t\t\t\t\tclipH=(float)readInt(48, cmddata);\n\/\/\t\t\t\t\tSystem.out.println(\"DRAWOVAL: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") thickness=\"+thickness+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\t\t\t\t\t\/\/ FIXME: no gradient for framed ovals\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\n\t\t\t\t\tdrawOval0(bounds, clipRect,\n\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), thickness,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWOVAL : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_FILLOVAL:\n\t\t\t\t\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL,\n\t\t\t\t\/\/ clipX, clipY, clipW, clipH\n\t\t\t\tif(len==48)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height,\n\t\t\t\t\t\tclipX, clipY, clipW, clipH;\n\t\t\t\t\tint argbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\targbTL=readInt(16, cmddata);\n\t\t\t\t\targbTR=readInt(20, cmddata);\n\t\t\t\t\targbBR=readInt(24, cmddata);\n\t\t\t\t\targbBL=readInt(28, cmddata);\n\t\t\t\t\tclipX=(float)readInt(32, cmddata);\n\t\t\t\t\tclipY=(float)readInt(36, cmddata);\n\t\t\t\t\tclipW=(float)readInt(40, cmddata);\n\t\t\t\t\tclipH=(float)readInt(44, cmddata);\n\/\/\t\t\t\t\tSystem.out.println(\"FILLOVAL: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\t\t\t\t\tjava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\n\t\t\t\t\tif(gp != null) {\n\t\t\t\t\t\tdrawOval0(bounds, clipRect,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  gp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\n\t\t\t\t\t\t\t\t  gp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdrawOval0(bounds, clipRect,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_FILLOVAL : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWROUNDRECT:\n\t\t\t\t\/\/ x, y, width, height, thickness, arcRadius, argbTL, argbTR, argbBR, argbBL,\n\t\t\t\t\/\/ clipX, clipY, clipW, clipH\n\t\t\t\tif(len==56)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height,\n\t\t\t\t\t\tclipX, clipY, clipW, clipH;\n\t\t\t\t\tint thickness, arcRadius,\n\t\t\t\t\t\targbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\tthickness=readInt(16, cmddata);\n\t\t\t\t\tarcRadius=readInt(20, cmddata);\n\t\t\t\t\targbTL=readInt(24, cmddata);\n\t\t\t\t\targbTR=readInt(28, cmddata);\n\t\t\t\t\targbBR=readInt(32, cmddata);\n\t\t\t\t\targbBL=readInt(36, cmddata);\n\t\t\t\t\tclipX=(float)readInt(40, cmddata);\n\t\t\t\t\tclipY=(float)readInt(44, cmddata);\n\t\t\t\t\tclipW=(float)readInt(48, cmddata);\n\t\t\t\t\tclipH=(float)readInt(52, cmddata);\n\/\/\t\t\t\t\tSystem.out.println(\"DRAWROUNDRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") thickness=\"+thickness+\" arcRadius=\"+arcRadius+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\t\t\t\t\t\/\/ FIXME: no gradients on stroked shapes\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\n\t\t\t\t\tdrawRect0(bounds, clipRect,\n\t\t\t\t\t\t\t  arcRadius,\n\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), thickness,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWROUNDRECT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_FILLROUNDRECT:\n\t\t\t\t\/\/ x, y, width, height, arcRadius, argbTL, argbTR, argbBR, argbBL,\n\t\t\t\t\/\/ clipX, clipY, clipW, clipH\n\t\t\t\tif(len==52)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height,\n\t\t\t\t\t\tclipX, clipY, clipW, clipH;\n\t\t\t\t\tint arcRadius, argbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\tarcRadius=readInt(16, cmddata);\n\t\t\t\t\targbTL=readInt(20, cmddata);\n\t\t\t\t\targbTR=readInt(24, cmddata);\n\t\t\t\t\targbBR=readInt(28, cmddata);\n\t\t\t\t\targbBL=readInt(32, cmddata);\n\t\t\t\t\tclipX=(float)readInt(36, cmddata);\n\t\t\t\t\tclipY=(float)readInt(40, cmddata);\n\t\t\t\t\tclipW=(float)readInt(44, cmddata);\n\t\t\t\t\tclipH=(float)readInt(48, cmddata);\n\/\/\t\t\t\t\tSystem.out.println(\"FILLROUNDRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") arcRadius=\"+arcRadius+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\t\t\t\t\tjava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\n\t\t\t\t\tif(gp != null) {\n\t\t\t\t\t\tdrawRect0(bounds, clipRect,\n\t\t\t\t\t\t\t\t  arcRadius,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  gp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\n\t\t\t\t\t\t\t\t  gp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\t\t\t\t\t\t\t\t  \/\/(float)((argbTL>>24)&0xff)\/255.0f);\n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdrawRect0(bounds, clipRect,\n\t\t\t\t\t\t\t\t  arcRadius,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_FILLROUNDRECT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWTEXT:\n\t\t\t\t\/\/ x, y, len, text, handle, argb, clipX, clipY, clipW, clipH\n\t\t\t\tif(len>=36 && len>=(36+readInt(8, cmddata)*2))\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, clipX, clipY, clipW, clipH;\n\t\t\t\t\tint textlen, fontHandle, argb;\n\t\t\t\t\tStringBuffer text = new StringBuffer();\n\t\t\t\t\tint i;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\ttextlen=readInt(8, cmddata);\n\t\t\t\t\tfor(i=0;i<textlen;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttext.append((char)readShort(12+i*2, cmddata));\n\t\t\t\t\t}\n\t\t\t\t\tfontHandle=readInt(textlen*2+12, cmddata);\n\t\t\t\t\targb=readInt(textlen*2+16, cmddata);\n\t\t\t\t\tclipX=(float)readInt(textlen*2+20, cmddata);\n\t\t\t\t\tclipY=(float)readInt(textlen*2+24, cmddata);\n\t\t\t\t\tclipW=(float)readInt(textlen*2+28, cmddata);\n\t\t\t\t\tclipH=(float)readInt(textlen*2+32, cmddata);\n\t\t\t\t\t\/\/ TODO: check if this is needed\n\/\/\t\t\t\t\tif (System.getProperty(\"java.version\").startsWith(\"1.4\"))\n\/\/\t\t\t\t\t\tclipW = clipW * 5 \/ 4;\n\/\/\t\t\t\t\tSystem.out.println(\"DRAWTEXT: dest=(\"+x+\",\"+y+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") fontHandle=\"+fontHandle+\" argb=\"+Integer.toHexString(argb)+\" text=\"+text.toString());\n\t\t\t\t\tMcFont fontPtr = (McFont)fontMap.get(new Integer(fontHandle));\n\t\t\t\t\tif(fontPtr != null) {\n\t\t\t\t\t\t\/\/ use AWT string bounds or we'll clip on occasion\n\t\t\t\t\t\tString theString = text.toString();\n\/\/\t\t\t\t\t\tjava.awt.Dimension textSize = fontPtr.getStringSize(theString);\n\t\t\t\t\t\tfloat[] positions = fontPtr.getGlyphPositions(theString);\n\/\/\t\t\t\t\t\tSystem.out.println(\"drawText: \\\"\"+theString+\"\\\"  loc=(\"+x+\",\"+y+\") num positions=\"+positions.length);\n\t\t\t\t\t\tdrawTextWithPositions0(theString, fontPtr.nativeFont,\n\t\t\t\t\t\t\tx, y, positions, new java.awt.geom.Rectangle2D.Float(clipX,clipY,clipW,clipH),\n\t\t\t\t\t\t\tnew java.awt.Color(argb, true));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWTEXTURED:\n\t\t\t\t\/\/ x, y, width, height, handle, srcx, srcy, srcwidth, srcheight, blend\n\t\t\t\tif(len==40)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height,\n\t\t\t\t\t\tsrcx, srcy, srcwidth, srcheight;\n\t\t\t\t\tint handle, blend; \/\/ blend is a color, use alpha component for blending\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\thandle=readInt(16, cmddata);\t\t\t\/\/ either an image handle or layer handle (if not in imageMap)\n\t\t\t\t\tsrcx=(float)readInt(20, cmddata);\n\t\t\t\t\tsrcy=(float)readInt(24, cmddata);\n\t\t\t\t\tsrcwidth=(float)readInt(28, cmddata);\n\t\t\t\t\tsrcheight=(float)readInt(32, cmddata);\n\t\t\t\t\tblend=readInt(36, cmddata);\n\t\t\t\t\t\/*\n\t\t\t\t\t\tif height < 0\n\t\t\t\t\t\t\tdisable blending\n\t\t\t\t\t\tif width < 0 (font mode, composite with background and blend with given color)\n\t\t\t\t\t\t\tblend with full RGBA color\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tblend with alpha only\n\t\t\t\t\t *\/\n\/\/\t\t\t\t\tSystem.out.println(\"DRAWTEXTURED: handle=\"+handle+\" dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") src=(\"+srcx+\",\"+srcy+\" \"+srcwidth+\"x\"+srcheight+\") blend=\"+Integer.toHexString(blend));\n\t\t\t\t\tboolean doBlend = true;\n\t\t\t\t\tif(height < 0) {\n\t\t\t\t\t\tdoBlend = false;\n\t\t\t\t\t\theight *= -1;\n\t\t\t\t\t}\n\t\t\t\t\tif(width < 0) {\n\t\t\t\t\t\twidth *= -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(doBlend)\n\t\t\t\t\t\t\tblend |= 0x00ffffff; \/\/ only use alpha\n\t\t\t\t\t}\n\t\t\t\t\tLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float destRect = new java.awt.geom.Rectangle2D.Float(x,y,width,height);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float srcRect = new java.awt.geom.Rectangle2D.Float(srcx,srcy,srcwidth,srcheight);\n\t\t\t\t\tif(imagePtr != null) {\n\t\t\t\t\t\tmyConn.registerImageAccess(handle);\n\/\/\t\t\t\t\t\tSystem.out.println(\"              (drawing image) imagePtr=\"+imagePtr);\n\t\t\t\t\t\tdrawImage1(imagePtr.longValue(),\n\t\t\t\t\t\t\t\t   destRect, srcRect,\n\t\t\t\t\t\t\t\t   (doBlend) ? new java.awt.Color(blend, true) : null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\timagePtr = (Long)layerMap.get(new Integer(handle));\n\t\t\t\t\t\tif(imagePtr != null) {\n\t\t\t\t\t\t\tmyConn.registerImageAccess(handle);\n\/\/\t\t\t\t\t\t\tSystem.out.println(\"              (compositing surface) layerPtr=\"+Long.toHexString(imagePtr.longValue())+\" currentLayer=\"+currentLayer);\n\t\t\t\t\t\t\tfloat alpha = (doBlend ? (float)(((blend >> 24)&0xff))\/255.0f : 1.0f);\n\t\t\t\t\t\t\tcomposite0(imagePtr.longValue(), currentLayer, srcRect, destRect, alpha, doBlend);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR invalid handle passed for texture rendering of: \" + handle);\n\t\t\t\t\t\t\tabortRenderCycle = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXTURED : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWLINE:\n\t\t\t\t\/\/ x1, y1, x2, y2, argb1, argb2\n\t\t\t\tif(len==24)\n\t\t\t\t{\n\t\t\t\t\tfloat x1, y1, x2, y2;\n\t\t\t\t\tint argb1, argb2;\n\t\t\t\t\tx1=readInt(0, cmddata);\n\t\t\t\t\ty1=readInt(4, cmddata);\n\t\t\t\t\tx2=readInt(8, cmddata);\n\t\t\t\t\ty2=readInt(12, cmddata);\n\t\t\t\t\targb1=readInt(16, cmddata);\n\t\t\t\t\targb2=readInt(20, cmddata);\n\/\/\t\t\t\t\tSystem.out.println(\"DRAWLINE: start=(\"+x1+\",\"+y1+\") end=(\"+x2+\",\"+y2+\") argb1=\"+Integer.toHexString(argb1)+\" argb2=\"+Integer.toHexString(argb2));\n\t\t\t\t\tdrawLine0(x1, y1, x2, y2, 1, new java.awt.Color(argb1, true));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWLINE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADIMAGE:\n\t\t\t\t\/\/ width, height\n\t\t\t\tif(len>=8)\n\t\t\t\t{\n\t\t\t\t\tint width, height;\n\t\t\t\t\tint imghandle = 0;\n\t\t\t\t\twidth=readInt(0, cmddata);\n\t\t\t\t\theight=readInt(4, cmddata);\n\/\/\t\t\t\t\tSystem.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\n\t\t\t\t\tif (width * height * 4 + imageCacheSize > imageCacheLimit)\n\t\t\t\t\t{\n\t\t\t\t\t\timghandle = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\n\t\t\t\t\t\tlong imagePtr = createNewImage0(width, height);\n\t\t\t\t\t\timghandle = handleCount++;\n\/\/\t\t\t\t\t\tSystem.out.println(\"           imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\n\t\t\t\t\t\timageMap.put(new Integer(imghandle), new Long(imagePtr));\t\/\/ actual value is filled in later when it's prepared\n\t\t\t\t\t\timageCacheSize += width * height * 4;\n\t\t\t\t\t}\n\t\t\t\t\thasret[0]=1;\n\t\t\t\t\treturn imghandle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADIMAGETARGETED:\n\t\t\t\t\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\n\t\t\t\tif(len>=12)\n\t\t\t\t{\n\t\t\t\t\tint width, height;\n\t\t\t\t\tint imghandle = readInt(0, cmddata);\n\t\t\t\t\twidth=readInt(4, cmddata);\n\t\t\t\t\theight=readInt(8, cmddata);\n\t\t\t\t\twhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n\t\t\t\t\t{\n\t\t\t\t\t\t\/\/ Keep freeing the oldest image until we have enough memory to do this\n\t\t\t\t\t\tint oldestImage = myConn.getOldestImage();\n\t\t\t\t\t\tif (oldestImage != 0)\n\t\t\t\t\t\t{\nSystem.out.println(\"Freeing image to make room in cache\");\n\t\t\t\t\t\t\tunloadImage(oldestImage);\n\t\t\t\t\t\t\tmyConn.postImageUnload(oldestImage);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlong imagePtr = createNewImage0(width, height);\n\/\/\t\t\t\t\t\tSystem.out.println(\"           imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\n\t\t\t\t\timageMap.put(new Integer(imghandle), new Long(imagePtr));\t\/\/ actual value is filled in later when it's prepared\n\t\t\t\t\timageCacheSize += width * height * 4;\n\t\t\t\t\tmyConn.registerImageAccess(imghandle);\n\t\t\t\t\thasret[0]=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGETARGETED : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_CREATESURFACE:\n\t\t\t\t\/\/ width, height\n\t\t\t\tif(len>=8)\n\t\t\t\t{\n\t\t\t\t\tint width, height;\n\t\t\t\t\tint handle = handleCount++;;\n\t\t\t\t\twidth=readInt(0, cmddata);\n\t\t\t\t\theight=readInt(4, cmddata);\n\t\t\t\t\t\/\/ width\/height is managed here\n\t\t\t\t\tlong layerPtr = createLayer0(c.getSize());\n\t\t\t\t\tlayerMap.put(new Integer(handle), new Long(layerPtr));\n\/\/\t\t\t\t\tSystem.out.println(\"CREATESURFACE: (\"+width+\",\"+height+\") handle=\"+handle+\" layerPtr=\"+layerPtr);\n\t\t\t\t\thasret[0]=1;\n\t\t\t\t\treturn handle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_CREATESURFACE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_PREPIMAGE:\n\t\t\t\t\/\/ width, height\n\t\t\t\tif(len>=8)\n\t\t\t\t{\n\t\t\t\t\tint width, height;\n\t\t\t\t\t\/\/int imghandle = handleCount++;;\n\t\t\t\t\twidth=readInt(0, cmddata);\n\t\t\t\t\theight=readInt(4, cmddata);\n\t\t\t\t\tint imghandle = 1;\n\/\/\t\t\t\t\tSystem.out.println(\"PREPIMAGE: size=(\"+width+\"x\"+height+\")\");\n\t\t\t\t\tif (width * height * 4 + imageCacheSize > imageCacheLimit)\n\t\t\t\t\t\timghandle = 0;\n\t\t\t\t\telse if (len >= 12)\n\t\t\t\t\t{\n\t\t\t\t\t\t\/\/ We've got enough room for it and there's a cache ID, check if we've got it cached locally\n\t\t\t\t\t\tint strlen = readInt(8, cmddata);\n\t\t\t\t\t\tif (strlen > 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString rezName = new String(cmddata, 16, strlen - 1);\n\/\/\t\t\t\t\t\t\tSystem.out.println(\"           rezName=\"+rezName);\n\t\t\t\t\t\t\tlastImageResourceID = rezName;\n\t\t\t\t\t\t\t\/\/ We use this hashcode to match it up on the loadCompressedImage call so we know we're caching the right thing\n\t\t\t\t\t\t\tlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\n\t\t\t\t\t\t\tjava.io.File cachedFile = myConn.getCachedImageFile(rezName);\n\t\t\t\t\t\t\tif (cachedFile != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\/\/ We've got it locally in our cache! Read it from there.\n\t\t\t\t\t\t\t\tlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\n\t\t\t\t\t\t\t\tif(imagePtr != 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tjava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\n\t\t\t\t\t\t\t\t\tif(imgSize != null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\/\/ valid image in cache, use it\n\t\t\t\t\t\t\t\t\t\t\timghandle = handleCount++;\n\/\/\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"           loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\n\t\t\t\t\t\t\t\t\t\t\timageMap.put(new Integer(imghandle), new Long(imagePtr));\n\t\t\t\t\t\t\t\t\t\t\timageCacheSize += getImageSize0(imagePtr);\n\t\t\t\t\t\t\t\t\t\t\thasret[0] = 1;\n\t\t\t\t\t\t\t\t\t\t\treturn -1 * imghandle;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\tfreeNativeImage0(imagePtr);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tfreeNativeImage0(imagePtr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\/\/imghandle=STBGFX.GFX_loadImage(width, height);\n\t\t\t\t\thasret[0]=1;\n\t\t\t\t\treturn imghandle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_PREPIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_PREPIMAGETARGETED:\n\t\t\t\t\/\/ handle, width, height, [rezID]\n\t\t\t\tif(len>=12)\n\t\t\t\t{\n\t\t\t\t\tint imghandle, width, height;\n\t\t\t\t\timghandle = readInt(0, cmddata);\n\t\t\t\t\twidth=readInt(4, cmddata);\n\t\t\t\t\theight=readInt(8, cmddata);\n\t\t\t\t\tint strlen = readInt(12, cmddata);\n\t\t\t\t\twhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n\t\t\t\t\t{\n\t\t\t\t\t\t\/\/ Keep freeing the oldest image until we have enough memory to do this\n\t\t\t\t\t\tint oldestImage = myConn.getOldestImage();\n\t\t\t\t\t\tif (oldestImage != 0)\n\t\t\t\t\t\t{\nSystem.out.println(\"Freeing image to make room in cache\");\n\t\t\t\t\t\t\tunloadImage(oldestImage);\n\t\t\t\t\t\t\tmyConn.postImageUnload(oldestImage);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (len >= 16)\n\t\t\t\t\t{\n\t\t\t\t\t\t\/\/ We will not have this cached locally...but setup our vars to track it\n\t\t\t\t\t\tString rezName = new String(cmddata, 20, strlen - 1);\n\t\t\t\t\t\tlastImageResourceID = rezName;\n\t\t\t\t\t\tlastImageResourceIDHandle = imghandle;\nSystem.out.println(\"Prepped targeted image with handle \" + imghandle + \" resource=\" + rezName);\n\t\t\t\t\t}\n\t\t\t\t\tmyConn.registerImageAccess(imghandle);\n\t\t\t\t\thasret[0]=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_PREPIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADCACHEDIMAGE:\n\t\t\t\t\/\/ width, height\n\t\t\t\tif(len>=18)\n\t\t\t\t{\n\t\t\t\t\tint width, height, imghandle;\n\t\t\t\t\timghandle = readInt(0, cmddata);\n\t\t\t\t\twidth = readInt(4, cmddata);\n\t\t\t\t\theight = readInt(8, cmddata);\n\t\t\t\t\tint strlen = readInt(12, cmddata);\n\t\t\t\t\tString rezName = new String(cmddata, 20, strlen - 1);\nSystem.out.println(\"imghandle=\" + imghandle + \" width=\" + width + \" height=\" + height + \" strlen=\" + strlen + \" rezName=\" + rezName);\n\t\t\t\t\twhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n\t\t\t\t\t{\n\t\t\t\t\t\t\/\/ Keep freeing the oldest image until we have enough memory to do this\n\t\t\t\t\t\tint oldestImage = myConn.getOldestImage();\n\t\t\t\t\t\tif (oldestImage != 0)\n\t\t\t\t\t\t{\nSystem.out.println(\"Freeing image to make room in cache\");\n\t\t\t\t\t\t\tunloadImage(oldestImage);\n\t\t\t\t\t\t\tmyConn.postImageUnload(oldestImage);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmyConn.registerImageAccess(imghandle);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(\"Loading resource from cache: \" + rezName);\n\t\t\t\t\t\tjava.io.File cachedFile = myConn.getCachedImageFile(rezName);\n\t\t\t\t\t\tif (cachedFile != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\/\/ We've got it locally in our cache! Read it from there.\n\t\t\t\t\t\t\tSystem.out.println(\"Image found in cache!\");\n\t\t\t\t\t\t\t\/\/ We've got it locally in our cache! Read it from there.\n\t\t\t\t\t\t\tlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\n\t\t\t\t\t\t\tif(imagePtr != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tjava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\n\t\t\t\t\t\t\t\tif(imgSize != null && imgSize.getWidth() == width && imgSize.getHeight() == height)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\/\/ valid image in cache, use it\n\/\/\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"           loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\n\t\t\t\t\t\t\t\t\timageMap.put(new Integer(imghandle), new Long(imagePtr));\n\t\t\t\t\t\t\t\t\timageCacheSize += getImageSize0(imagePtr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (imgSize != null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\/\/ It doesn't match the cache\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"CACHE ID verification failed for rezName=\" + rezName + \" target=\" + width + \"x\" + height + \" actual=\" + imgSize.getWidth() + \"x\" + imgSize.getHeight());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"CACHE Load failed for rezName=\" + rezName);\n\t\t\t\t\t\t\t\t\tcachedFile.delete();\n\t\t\t\t\t\t\t\t\tfreeNativeImage0(imagePtr);\n\t\t\t\t\t\t\t\t\t\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\n\t\t\t\t\t\t\t\t\tmyConn.postImageUnload(imghandle);\n\t\t\t\t\t\t\t\t\tmyConn.postOfflineCacheChange(false, rezName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcachedFile.delete();\n\t\t\t\t\t\t\t\t\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\n\t\t\t\t\t\t\t\tmyConn.postImageUnload(imghandle);\n\t\t\t\t\t\t\t\tmyConn.postOfflineCacheChange(false, rezName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR Image not found in cache that should be there! rezName=\" + rezName);\n\t\t\t\t\t\t\t\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\n\t\t\t\t\t\t\tmyConn.postImageUnload(imghandle);\n\t\t\t\t\t\t\tmyConn.postOfflineCacheChange(false, rezName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (java.io.IOException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(\"ERROR loading compressed image: \" + e);\n\t\t\t\t\t}\n\t\t\t\t\thasret[0]=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_PREPIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_UNLOADIMAGE:\n\t\t\t\t\/\/ handle\n\t\t\t\tif(len==4)\n\t\t\t\t{\n\t\t\t\t\tint handle;\n\t\t\t\t\thandle=readInt(0, cmddata);\n\t\t\t\t\tunloadImage(handle);\n\t\t\t\t\tmyConn.clearImageAccess(handle);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_UNLOADIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_SETTARGETSURFACE:\n\t\t\t\t\/\/ handle\n\t\t\t\tif(len==4)\n\t\t\t\t{\n\t\t\t\t\tint handle;\n\t\t\t\t\thandle=readInt(0, cmddata);\n\t\t\t\t\t\/\/STBGFX.GFX_unloadImage(handle);\n\t\t\t\t\tLong layerPtr = (Long)layerMap.get(new Integer(handle));\n\/\/\t\t\t\t\tSystem.out.println(\"SETTARGETSURFACE: handle=\"+handle+\" layerPtr=\"+ (layerPtr == null ? \"0\" : Long.toHexString(layerPtr.longValue())));\n\t\t\t\t\tcurrentLayer = (layerPtr != null) ? layerPtr.longValue() : 0;\n\t\t\t\t\tjava.awt.Rectangle clipRect = new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight());\n\t\t\t\t\tsetLayer0(currentLayer, c.getSize(), clipRect);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_SETTARGETSURFACE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADFONT:\n\t\t\t\t\/\/ namelen, name, style, size\n\t\t\t\tif(len>=12 && len>=(12+readInt(0, cmddata)))\n\t\t\t\t{\n\t\t\t\t\tint namelen, style, size;\n\t\t\t\t\tStringBuffer name = new StringBuffer();\n\t\t\t\t\tint i;\n\t\t\t\t\tint fonthandle = handleCount++;\n\t\t\t\t\tnamelen=readInt(0, cmddata);\n\t\t\t\t\tfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n\t\t\t\t\t{\n\t\t\t\t\t\tname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n\t\t\t\t\t}\n\t\t\t\t\tstyle=readInt(namelen+4, cmddata);\n\t\t\t\t\tsize=readInt(namelen+8, cmddata);\n\/\/\t\t\t\t\tSystem.out.println(\"LOADFONT: handle=\"+fonthandle+\" name=\"+name.toString()+\" style=\"+Integer.toHexString(style)+\" size=\"+size);\n\t\t\t\t\tMcFont fontPtr = new McFont(name.toString(), style, size);\n\/\/\t\t\t\t\tlong fontPtr = loadFont0(name.toString(), style, size);\n\t\t\t\t\tif(fontPtr == null) {\n\t\t\t\t\t\t\/\/ FIXME: implement!\n\t\t\t\t\t\t\/\/ we don't have the font on this sytem (yet) see if it's cached and try to load it manually\n\/\/\t\t\t\t\t\tString cacheName = name.toString() + \"-\" + style;\n\/\/\t\t\t\t\t\tfontPtr = loadCachedFont0(cacheDir.getAbsolutePath(), name.toString() + \"-\" + myConn.getServerName(), style, size);\n\/\/\t\t\t\t\t\tif (fontPtr == 0) {\n\t\t\t\t\t\t\t\/\/ Return that we don't have this font so it'll load it into our cache\n\t\t\t\t\t\t\thasret[0] = 1;\n\t\t\t\t\t\t\treturn 0;\n\/\/\t\t\t\t\t\t}\n\t\t\t\t\t}\n\/\/\t\t\t\t\tSystem.out.println(\"          fontPtr=\" + fontPtr);\n\t\t\t\t\tfontMap.put(new Integer(fonthandle), fontPtr);\n\t\t\t\t\thasret[0] = 1;\n\t\t\t\t\treturn fonthandle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADFONT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_UNLOADFONT:\n\t\t\t\t\/\/ handle\n\t\t\t\tif(len==4)\n\t\t\t\t{\n\t\t\t\t\tint handle;\n\t\t\t\t\thandle=readInt(0, cmddata);\n\t\t\t\t\t\/\/STBGFX.GFX_unloadFont(handle);\n\t\t\t\t\tMcFont fontPtr = (McFont)fontMap.get(new Integer(handle));\n\/\/\t\t\t\t\tSystem.out.println(\"UNLOADFONT: handle=\"+handle+\" fontPtr=\"+fontPtr);\n\t\t\t\t\tif(fontPtr != null) fontPtr.unload();\n\t\t\t\t\tfontMap.remove(new Integer(handle));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_UNLOADFONT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADFONTSTREAM:\n\t\t\t    \/\/ namelen, name, len, data\n\t\t\t\tif (len>=8)\n\t\t\t\t{\n\t\t\t\t\tStringBuffer name = new StringBuffer();\n\t\t\t\t\tint namelen = readInt(0, cmddata);\n\t\t\t\t\tfor(int i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n\t\t\t\t\t{\n\t\t\t\t\t\tname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n\t\t\t\t\t}\n\t\t\t\t\tint datalen = readInt(4 + namelen, cmddata);\n\t\t\t\t\tif (len >= datalen + 8 + namelen)\n\t\t\t\t\t{\n\/\/\t\t\t\t\t\tSystem.out.println(\"Saving font \" + name.toString() + \" to cache\");\n\t\t\t\t\t\tmyConn.saveCacheData(name.toString() + \"-\" + myConn.getServerName(), cmddata, 12 + namelen, datalen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADFONTSTREAM : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_FLIPBUFFER:\n\/\/\t\t\t\tSystem.out.println(\"FLIPBUFFER\");\n\t\t\t\tif (abortRenderCycle)\n\t\t\t\t{\nSystem.out.println(\"ERROR in painting cycle, ABORT was set...send full repaint command\");\n\t\t\t\t\tmyConn.postRepaintEvent(0, 0, c.getWidth(), c.getHeight());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpresent0(c.nativeView, new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight()));\n\t\t\t\t}\n\t\t\t\thasret[0] = 1;\n\t\t\t\t\/\/STBGFX.GFX_flipBuffer();\n\t\t\t\tfirstFrameDone = true;\n\t\t\t\treturn 0;\n\t\t\tcase GFXCMD_STARTFRAME:\n\/\/\t\t\t\tSystem.out.println(\"STARTFRAME\");\n\t\t\t\t\/\/ prepare for a new frame to be rendered\n\t\t\t\tsetTargetView0(c.nativeView);\n\t\t\t\tsetLayer0(0, c.getSize(), null); \/\/ this makes sure the drawing surface gets resized properly\n\t\t\t\tabortRenderCycle = false;\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADIMAGELINE:\n\t\t\t\t\/\/ handle, line, len, data\n\t\t\t\tif(len>=12 && len>=(12+readInt(8, cmddata)))\n\t\t\t\t{\n\t\t\t\t\tint handle, line, len2;\n\t\t\t\t\t\/\/unsigned char *data=&cmddata[12];\n\t\t\t\t\thandle=readInt(0, cmddata);\n\t\t\t\t\tline=readInt(4, cmddata);\n\t\t\t\t\tlen2=readInt(8, cmddata);\n\t\t\t\t\t\/\/ the last number is the offset into the data array to start reading from\n\t\t\t\t\t\/\/STBGFX.GFX_loadImageLine(handle, line, len, data, 12);\n\t\t\t\t\t\/\/int dataPos = 12;\n\t\t\t\t\tLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\/\/\t\t\t\t\tSystem.out.println(\"LOADIMAGELINE: handle=\"+handle+\" imagePtr=\"+imagePtr+\" line=\"+line+\" len2=\"+len2);\n\t\t\t\t\tif(imagePtr != null)\n\t\t\t\t\t\tloadImageLine0(imagePtr.longValue(), line, cmddata, 16\/*12*\/, len2);\n\t\t\t\t\tmyConn.registerImageAccess(handle);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGELINE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADIMAGECOMPRESSED:\n\t\t\t\t\/\/ handle, line, len, data\n\t\t\t\tif(len>=8 && len>=(8+readInt(4, cmddata)))\n\t\t\t\t{\n\t\t\t\t\tint handle, len2;\n\t\t\t\t\thandle=readInt(0, cmddata);\n\t\t\t\t\tlen2=readInt(4, cmddata);\n\t\t\t\t\tif (lastImageResourceID != null && lastImageResourceIDHandle == handle)\n\t\t\t\t\t{\n\t\t\t\t\t\tmyConn.saveCacheData(lastImageResourceID, cmddata, 12, len2);\n\t\t\t\t\t\tmyConn.postOfflineCacheChange(true, lastImageResourceID);\n\t\t\t\t\t}\n\t\t\t\t\tif (!myConn.doesUseAdvancedImageCaching())\n\t\t\t\t\t{\n\t\t\t\t\t\thandle = handleCount++;\n\t\t\t\t\t\thasret[0] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\thasret[0] = 0;\n\t\t\t\t\tmyConn.registerImageAccess(handle);\n\t\t\t\t\tlong imagePtr = createImageFromBytes0(cmddata, 12, len2, null); \/\/ FIXME: grab extension if possible\n\/\/\t\t\t\t\tSystem.out.println(\"LOADIMAGECOMPRESSED: handle=\"+handle+\" imagePtr=\"+imagePtr+\" len2=\"+len2);\n\t\t\t\t\timageMap.put(new Integer(handle), new Long(imagePtr));\n\t\t\t\t\timageCacheSize += getImageSize0(imagePtr);\n\t\t\t\t\treturn handle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGECOMPRESSED : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_XFMIMAGE:\n\t\t\t\t\/\/ srcHandle, destHandle, destWidth, destHeight, maskCornerArc\n\t\t\t\tif (len >= 20)\n\t\t\t\t{\n\t\t\t\t\tint srcHandle, destHandle, destWidth, destHeight, maskCornerArc;\n\t\t\t\t\tsrcHandle = readInt(0, cmddata);\n\t\t\t\t\tdestHandle = readInt(4, cmddata);\t\t\/\/ seems to be unused\n\t\t\t\t\tdestWidth = readInt(8,  cmddata);\t\t\/\/ scaled size (ignore?)\n\t\t\t\t\tdestHeight = readInt(12, cmddata);\n\t\t\t\t\tmaskCornerArc = readInt(16, cmddata);\n\t\t\t\t\tint rvHandle = destHandle;\n\t\t\t\t\tif (!myConn.doesUseAdvancedImageCaching())\n\t\t\t\t\t{\n\t\t\t\t\t\trvHandle = handleCount++;\n\t\t\t\t\t\thasret[0] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\thasret[0] = 0;\n\t\t\t\t\t\/\/ we cheat and apply the transforms to a metaimage object without actually creating a new image (saves oodles of memory)\n\t\t\t\t\tLong srcImg = (Long)imageMap.get(new Integer(srcHandle));\n\/\/\t\t\t\t\tSystem.out.println(\"XFMIMAGE: srcHandle=\"+srcHandle+\" srcImg=\"+srcImg+\" destHandle=\"+destHandle+\" destWidth=\"+destWidth+\" destHeight=\"+destHeight+\" maskCornerArc=\"+maskCornerArc);\n\t\t\t\t\tif(srcImg != null) {\n\t\t\t\t\t\tlong newImage = transformImage0(srcImg.longValue(), destWidth, destHeight, maskCornerArc);\n\t\t\t\t\t\tif(newImage != 0) {\n\/\/\t\t\t\t\t\t\tSystem.out.println(\"          newImage=\"+newImage);\n\t\t\t\t\t\t\timageMap.put(new Integer(rvHandle), new Long(newImage));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn rvHandle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_XFMIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_SETVIDEOPROP:\n\t\t\t\tif (len >= 40)\n\t\t\t\t{\n\t\t\t\t\tjava.awt.Rectangle srcRect = new java.awt.Rectangle(readInt(4, cmddata), readInt(8, cmddata),\n\t\t\t\t\t\treadInt(12, cmddata), readInt(16, cmddata));\n\t\t\t\t\tjava.awt.Rectangle destRect = new java.awt.Rectangle(readInt(20, cmddata), readInt(24, cmddata),\n\t\t\t\t\t\treadInt(28, cmddata), readInt(32, cmddata));\n\t\t\t\t\tSystem.out.println(\"SETVIDEOPROP: srcRect=\"+srcRect+\" dstRect=\"+destRect);\n\t\t\t\t\tsetVideoBounds(srcRect, destRect);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_SETVIDEOPROP: \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}","code":"public int ExecuteGFXCommand(int cmd, int len, byte[] cmddata, int[] hasret)\n\t{\n\t\tlen -= 4;\n\t    hasret[0] = 0;\n\t\n\t\tif((cmd != GFXCMD_INIT) && (cmd != GFXCMD_DEINIT))\n\t\t{\n\t\t\tif((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\n\t\t\t\n\t\t\t\twhile((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tThread.sleep(10);\n\t\t\t\t\t} catch(InterruptedException ex) {}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c != null)\n\t\t{\n\t\t\tswitch(cmd)\n\t\t\t{\n\t\t\t\tcase GFXCMD_INIT:\n\t\t\t\tcase GFXCMD_DEINIT:\n\t\t\t\tcase GFXCMD_STARTFRAME:\n\t\t\t\tcase GFXCMD_FLIPBUFFER:\n\t\t\t\t\tc.setCursor(null);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GFXCMD_DRAWRECT:\n\t\t\t\tcase GFXCMD_FILLRECT:\n\t\t\t\tcase GFXCMD_CLEARRECT:\n\t\t\t\tcase GFXCMD_DRAWOVAL:\n\t\t\t\tcase GFXCMD_FILLOVAL:\n\t\t\t\tcase GFXCMD_DRAWROUNDRECT:\n\t\t\t\tcase GFXCMD_FILLROUNDRECT:\n\t\t\t\tcase GFXCMD_DRAWTEXT:\n\t\t\t\tcase GFXCMD_DRAWTEXTURED:\n\t\t\t\tcase GFXCMD_DRAWLINE:\n\t\t\t\tcase GFXCMD_LOADIMAGE:\n\t\t\t\tcase GFXCMD_LOADIMAGETARGETED:\n\t\t\t\tcase GFXCMD_UNLOADIMAGE:\n\t\t\t\tcase GFXCMD_LOADFONT:\n\t\t\t\tcase GFXCMD_UNLOADFONT:\n\t\t\t\tcase GFXCMD_SETTARGETSURFACE:\n\t\t\t\tcase GFXCMD_CREATESURFACE:\n\t\t\t\t\tbreak;\n\t\t\t\tcase GFXCMD_PREPIMAGE:\n\t\t\t\tcase GFXCMD_LOADIMAGELINE:\n\t\t\t\tcase GFXCMD_LOADIMAGECOMPRESSED:\n\t\t\t\tcase GFXCMD_XFMIMAGE:\n\t\t\t\tcase GFXCMD_LOADCACHEDIMAGE:\n\t\t\t\tcase GFXCMD_PREPIMAGETARGETED:\n\t\t\t\t\tif (!cursorHidden)\n\t\t\t\t\t\tc.setCursor(java.awt.Cursor.getPredefinedCursor(java.awt.Cursor.WAIT_CURSOR));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswitch(cmd)\n\t\t{\n\t\t\tcase GFXCMD_INIT:\n\t\t\t\thasret[0] = 1;\n\t\t\t\n\t\t\t\tinit0();\n\t\t\t\tint windowTitleStyle = 0;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\twindowTitleStyle = Integer.parseInt(MiniClient.myProperties.getProperty(\"window_title_style\", \"0\"));\n\t\t\t\t}\n\t\t\t\tcatch (NumberFormatException e){}\n\t\t\t\tif (!\"true\".equals(MiniClient.myProperties.getProperty(\"enable_custom_title_bar\", MiniClient.MAC_OS_X ? \"false\" : \"true\")))\n\t\t\t\t\twindowTitleStyle = 10;\n\t\t\t\tf = new MiniClientWindow(myConn.getWindowTitle(), windowTitleStyle);\n\t\t\t\tjava.awt.LayoutManager layer = new java.awt.LayoutManager()\n\t\t\t\t\t{\n\t\t\t\t\t\tpublic void addLayoutComponent(String name, java.awt.Component comp)\n\t\t\t\t\t\t{}\n\t\t\t\t\t\tpublic java.awt.Dimension minimumLayoutSize(java.awt.Container parent)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn preferredLayoutSize(parent);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic java.awt.Dimension preferredLayoutSize(java.awt.Container parent)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn parent.getPreferredSize();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void removeLayoutComponent(java.awt.Component comp)\n\t\t\t\t\t\t{}\n\t\t\t\t\t\tpublic void layoutContainer(java.awt.Container parent)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc.setBounds(parent.getInsets().left, parent.getInsets().top, parent.getWidth() - parent.getInsets().left - parent.getInsets().right,\n\t\t\t\t\t\t\t\tparent.getHeight() - parent.getInsets().top - parent.getInsets().bottom);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tf.getContentPane().setLayout(layer);\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tbgImage = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/Background.jpg\"));\n\t\t\t\t\tensureImageIsLoaded(bgImage);\n\t\t\t\t\tlogoImage = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/SageLogo256.png\"));\n\t\t\t\t\tensureImageIsLoaded(logoImage);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"ERROR:\" + e);\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tf.setFocusTraversalKeysEnabled(false);\n\t\t\t\n\t\t\t\tjava.awt.Dimension panelSize = f.getContentPane().getSize();\n\t\t\t\tc = new QuartzRendererView();\n\t\t\t\tc.setSize(panelSize);\n\t\t\t\tc.setFocusTraversalKeysEnabled(false);\n\t\t\t\tf.getContentPane().add(c);\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tjava.awt.Image frameIcon = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/tvicon.gif\"));\n\t\t\t\t\tensureImageIsLoaded(frameIcon);\n\t\t\t\t\tf.setIconImage(frameIcon);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"ERROR:\" + e);\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tf.addWindowListener(new java.awt.event.WindowAdapter()\n\t\t\t\t{\n\t\t\t\t\tpublic void windowClosing(java.awt.event.WindowEvent evt)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!f.isFullScreen() || System.getProperty(\"os.name\").toLowerCase().indexOf(\"windows\") != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMiniClient.myProperties.setProperty(\"main_window_width\", Integer.toString(f.getWidth()));\n\t\t\t\t\t\t\tMiniClient.myProperties.setProperty(\"main_window_height\", Integer.toString(f.getHeight()));\n\t\t\t\t\t\t\tMiniClient.myProperties.setProperty(\"main_window_x\", Integer.toString(f.getX()));\n\t\t\t\t\t\t\tMiniClient.myProperties.setProperty(\"main_window_y\", Integer.toString(f.getY()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmyConn.close();\n\t\t\t\t\t\tclose();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tc.addComponentListener(new java.awt.event.ComponentAdapter()\n\t\t\t\t{\n\t\t\t\t\tpublic void componentResized(java.awt.event.ComponentEvent evt)\n\t\t\t\t\t{\n\t\t\t\t\t\tmyConn.postResizeEvent(new java.awt.Dimension(c.getWidth(), c.getHeight()));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tf.addKeyListener(this);\n\t\t\t\tc.addKeyListener(this);\n\t\t\t\n\t\t\t\tf.addMouseWheelListener(this);\n\t\t\t\tc.addMouseListener(this);\n\t\t\t\tif (ENABLE_MOUSE_MOTION_EVENTS)\n\t\t\t\t{\n\t\t\t\t\n\t\t\t\t\tc.addMouseMotionListener(this);\n\t\t\t\t}\n\t\t\t\tint frameX = 100;\n\t\t\t\tint frameY = 100;\n\t\t\t\tint frameW = 720;\n\t\t\t\tint frameH = 480;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tframeW = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_width\", \"720\"));\n\t\t\t\t\tframeH = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_height\", \"480\"));\n\t\t\t\t\tframeX = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_x\", \"100\"));\n\t\t\t\t\tframeY = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_y\", \"100\"));\n\t\t\t\t}\n\t\t\t\tcatch (NumberFormatException e){}\n\t\t\t\tjava.awt.Point newPos = new java.awt.Point(frameX, frameY);\n\t\t\t\tboolean foundScreen = sage.UIUtils.isPointOnAScreen(newPos);\n\t\t\t\tif (!foundScreen)\n\t\t\t\t{\n\t\t\t\t\tnewPos.x = 150;\n\t\t\t\t\tnewPos.y = 150;\n\t\t\t\t}\n\t\t\t\tf.setVisible(true);\n\t\t\t\tf.setSize(1,1);\n\t\t\t\tf.setSize(Math.max(frameW, 320), Math.max(frameH, 240));\n\t\t\t\tf.setLocation(newPos);\n\t\t\t\tif (MiniClient.fsStartup)\n\t\t\t\t\tf.setFullScreen(true);\n\t\t\t\tMiniClient.hideSplash();\n\t\t\t\treturn 1;\n\t\t\tcase GFXCMD_DEINIT:\n\t\t\t\tclose();\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWRECT:\n\t\t\t\tif(len==36)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height;\n\t\t\t\t\tint thickness, argbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\tthickness=readInt(16, cmddata);\n\t\t\t\t\targbTL=readInt(20, cmddata);\n\t\t\t\t\targbTR=readInt(24, cmddata);\n\t\t\t\t\targbBR=readInt(28, cmddata);\n\t\t\t\t\targbBL=readInt(32, cmddata);\n\t\t\t\t\n\t\t\t\t\tdrawRect0(new java.awt.geom.Rectangle2D.Float(x, y, width, height), null,\n\t\t\t\t\t\t\t  0,\n\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), thickness,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWRECT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_FILLRECT:\n\t\t\t\n\t\t\t\tif(len==32)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height;\n\t\t\t\t\tint argbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\targbTL=readInt(16, cmddata);\n\t\t\t\t\targbTR=readInt(20, cmddata);\n\t\t\t\t\targbBR=readInt(24, cmddata);\n\t\t\t\t\targbBL=readInt(28, cmddata);\n\t\t\t\t\tjava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tif(gp != null) {\n\t\t\t\t\t\tdrawRect0(bounds, null,\n\t\t\t\t\t\t\t\t  0,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  gp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\n\t\t\t\t\t\t\t\t  gp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdrawRect0(bounds, null,\n\t\t\t\t\t\t\t\t  0,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_FILLRECT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_CLEARRECT:\n\t\t\t\n\t\t\t\tif(len==32)\n\t\t\t\t{\n\t\t\t\t\tint x, y, width, height,\n\t\t\t\t\t\targbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=readInt(0, cmddata);\n\t\t\t\t\ty=readInt(4, cmddata);\n\t\t\t\t\twidth=readInt(8, cmddata);\n\t\t\t\t\theight=readInt(12, cmddata);\n\t\t\t\t\targbTL=readInt(16, cmddata);\n\t\t\t\t\targbTR=readInt(20, cmddata);\n\t\t\t\t\targbBR=readInt(24, cmddata);\n\t\t\t\t\targbBL=readInt(28, cmddata);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float destRect = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tclearRect0(destRect);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_CLEARRECT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWOVAL:\n\t\t\t\n\t\t\t\n\t\t\t\tif(len==52)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height, clipX, clipY, clipW, clipH;\n\t\t\t\t\tint thickness, argbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\tthickness=readInt(16, cmddata);\n\t\t\t\t\targbTL=readInt(20, cmddata);\n\t\t\t\t\targbTR=readInt(24, cmddata);\n\t\t\t\t\targbBR=readInt(28, cmddata);\n\t\t\t\t\targbBL=readInt(32, cmddata);\n\t\t\t\t\tclipX=(float)readInt(36, cmddata);\n\t\t\t\t\tclipY=(float)readInt(40, cmddata);\n\t\t\t\t\tclipW=(float)readInt(44, cmddata);\n\t\t\t\t\tclipH=(float)readInt(48, cmddata);\n\t\t\t\t\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\n\t\t\t\t\tdrawOval0(bounds, clipRect,\n\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), thickness,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWOVAL : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_FILLOVAL:\n\t\t\t\n\t\t\t\n\t\t\t\tif(len==48)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height,\n\t\t\t\t\t\tclipX, clipY, clipW, clipH;\n\t\t\t\t\tint argbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\targbTL=readInt(16, cmddata);\n\t\t\t\t\targbTR=readInt(20, cmddata);\n\t\t\t\t\targbBR=readInt(24, cmddata);\n\t\t\t\t\targbBL=readInt(28, cmddata);\n\t\t\t\t\tclipX=(float)readInt(32, cmddata);\n\t\t\t\t\tclipY=(float)readInt(36, cmddata);\n\t\t\t\t\tclipW=(float)readInt(40, cmddata);\n\t\t\t\t\tclipH=(float)readInt(44, cmddata);\n\t\t\t\t\tjava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\n\t\t\t\t\tif(gp != null) {\n\t\t\t\t\t\tdrawOval0(bounds, clipRect,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  gp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\n\t\t\t\t\t\t\t\t  gp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdrawOval0(bounds, clipRect,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_FILLOVAL : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWROUNDRECT:\n\t\t\t\n\t\t\t\n\t\t\t\tif(len==56)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height,\n\t\t\t\t\t\tclipX, clipY, clipW, clipH;\n\t\t\t\t\tint thickness, arcRadius,\n\t\t\t\t\t\targbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\tthickness=readInt(16, cmddata);\n\t\t\t\t\tarcRadius=readInt(20, cmddata);\n\t\t\t\t\targbTL=readInt(24, cmddata);\n\t\t\t\t\targbTR=readInt(28, cmddata);\n\t\t\t\t\targbBR=readInt(32, cmddata);\n\t\t\t\t\targbBL=readInt(36, cmddata);\n\t\t\t\t\tclipX=(float)readInt(40, cmddata);\n\t\t\t\t\tclipY=(float)readInt(44, cmddata);\n\t\t\t\t\tclipW=(float)readInt(48, cmddata);\n\t\t\t\t\tclipH=(float)readInt(52, cmddata);\n\t\t\t\t\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\n\t\t\t\t\tdrawRect0(bounds, clipRect,\n\t\t\t\t\t\t\t  arcRadius,\n\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), thickness,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWROUNDRECT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_FILLROUNDRECT:\n\t\t\t\n\t\t\t\n\t\t\t\tif(len==52)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height,\n\t\t\t\t\t\tclipX, clipY, clipW, clipH;\n\t\t\t\t\tint arcRadius, argbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\tarcRadius=readInt(16, cmddata);\n\t\t\t\t\targbTL=readInt(20, cmddata);\n\t\t\t\t\targbTR=readInt(24, cmddata);\n\t\t\t\t\targbBR=readInt(28, cmddata);\n\t\t\t\t\targbBL=readInt(32, cmddata);\n\t\t\t\t\tclipX=(float)readInt(36, cmddata);\n\t\t\t\t\tclipY=(float)readInt(40, cmddata);\n\t\t\t\t\tclipW=(float)readInt(44, cmddata);\n\t\t\t\t\tclipH=(float)readInt(48, cmddata);\n\t\t\t\t\tjava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\n\t\t\t\t\tif(gp != null) {\n\t\t\t\t\t\tdrawRect0(bounds, clipRect,\n\t\t\t\t\t\t\t\t  arcRadius,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  gp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\n\t\t\t\t\t\t\t\t  gp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdrawRect0(bounds, clipRect,\n\t\t\t\t\t\t\t\t  arcRadius,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_FILLROUNDRECT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWTEXT:\n\t\t\t\n\t\t\t\tif(len>=36 && len>=(36+readInt(8, cmddata)*2))\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, clipX, clipY, clipW, clipH;\n\t\t\t\t\tint textlen, fontHandle, argb;\n\t\t\t\t\tStringBuffer text = new StringBuffer();\n\t\t\t\t\tint i;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\ttextlen=readInt(8, cmddata);\n\t\t\t\t\tfor(i=0;i<textlen;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttext.append((char)readShort(12+i*2, cmddata));\n\t\t\t\t\t}\n\t\t\t\t\tfontHandle=readInt(textlen*2+12, cmddata);\n\t\t\t\t\targb=readInt(textlen*2+16, cmddata);\n\t\t\t\t\tclipX=(float)readInt(textlen*2+20, cmddata);\n\t\t\t\t\tclipY=(float)readInt(textlen*2+24, cmddata);\n\t\t\t\t\tclipW=(float)readInt(textlen*2+28, cmddata);\n\t\t\t\t\tclipH=(float)readInt(textlen*2+32, cmddata);\n\t\t\t\t\n\t\t\t\t\tMcFont fontPtr = (McFont)fontMap.get(new Integer(fontHandle));\n\t\t\t\t\tif(fontPtr != null) {\n\t\t\t\t\t\n\t\t\t\t\t\tString theString = text.toString();\n\t\t\t\t\t\tfloat[] positions = fontPtr.getGlyphPositions(theString);\n\t\t\t\t\t\tdrawTextWithPositions0(theString, fontPtr.nativeFont,\n\t\t\t\t\t\t\tx, y, positions, new java.awt.geom.Rectangle2D.Float(clipX,clipY,clipW,clipH),\n\t\t\t\t\t\t\tnew java.awt.Color(argb, true));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWTEXTURED:\n\t\t\t\n\t\t\t\tif(len==40)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height,\n\t\t\t\t\t\tsrcx, srcy, srcwidth, srcheight;\n\t\t\t\t\tint handle, blend;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\thandle=readInt(16, cmddata);\t\t\n\t\t\t\t\tsrcx=(float)readInt(20, cmddata);\n\t\t\t\t\tsrcy=(float)readInt(24, cmddata);\n\t\t\t\t\tsrcwidth=(float)readInt(28, cmddata);\n\t\t\t\t\tsrcheight=(float)readInt(32, cmddata);\n\t\t\t\t\tblend=readInt(36, cmddata);\n\t\t\t\t\n\t\t\t\t\tboolean doBlend = true;\n\t\t\t\t\tif(height < 0) {\n\t\t\t\t\t\tdoBlend = false;\n\t\t\t\t\t\theight *= -1;\n\t\t\t\t\t}\n\t\t\t\t\tif(width < 0) {\n\t\t\t\t\t\twidth *= -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(doBlend)\n\t\t\t\t\t\t\tblend |= 0x00ffffff;\n\t\t\t\t\t}\n\t\t\t\t\tLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float destRect = new java.awt.geom.Rectangle2D.Float(x,y,width,height);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float srcRect = new java.awt.geom.Rectangle2D.Float(srcx,srcy,srcwidth,srcheight);\n\t\t\t\t\tif(imagePtr != null) {\n\t\t\t\t\t\tmyConn.registerImageAccess(handle);\n\t\t\t\t\t\tdrawImage1(imagePtr.longValue(),\n\t\t\t\t\t\t\t\t   destRect, srcRect,\n\t\t\t\t\t\t\t\t   (doBlend) ? new java.awt.Color(blend, true) : null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\timagePtr = (Long)layerMap.get(new Integer(handle));\n\t\t\t\t\t\tif(imagePtr != null) {\n\t\t\t\t\t\t\tmyConn.registerImageAccess(handle);\n\t\t\t\t\t\t\tfloat alpha = (doBlend ? (float)(((blend >> 24)&0xff))\/255.0f : 1.0f);\n\t\t\t\t\t\t\tcomposite0(imagePtr.longValue(), currentLayer, srcRect, destRect, alpha, doBlend);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR invalid handle passed for texture rendering of: \" + handle);\n\t\t\t\t\t\t\tabortRenderCycle = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXTURED : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWLINE:\n\t\t\t\n\t\t\t\tif(len==24)\n\t\t\t\t{\n\t\t\t\t\tfloat x1, y1, x2, y2;\n\t\t\t\t\tint argb1, argb2;\n\t\t\t\t\tx1=readInt(0, cmddata);\n\t\t\t\t\ty1=readInt(4, cmddata);\n\t\t\t\t\tx2=readInt(8, cmddata);\n\t\t\t\t\ty2=readInt(12, cmddata);\n\t\t\t\t\targb1=readInt(16, cmddata);\n\t\t\t\t\targb2=readInt(20, cmddata);\n\t\t\t\t\tdrawLine0(x1, y1, x2, y2, 1, new java.awt.Color(argb1, true));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWLINE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADIMAGE:\n\t\t\t\n\t\t\t\tif(len>=8)\n\t\t\t\t{\n\t\t\t\t\tint width, height;\n\t\t\t\t\tint imghandle = 0;\n\t\t\t\t\twidth=readInt(0, cmddata);\n\t\t\t\t\theight=readInt(4, cmddata);\n\t\t\t\t\tif (width * height * 4 + imageCacheSize > imageCacheLimit)\n\t\t\t\t\t{\n\t\t\t\t\t\timghandle = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t\tlong imagePtr = createNewImage0(width, height);\n\t\t\t\t\t\timghandle = handleCount++;\n\t\t\t\t\t\timageMap.put(new Integer(imghandle), new Long(imagePtr));\n\t\t\t\t\t\timageCacheSize += width * height * 4;\n\t\t\t\t\t}\n\t\t\t\t\thasret[0]=1;\n\t\t\t\t\treturn imghandle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADIMAGETARGETED:\n\t\t\t\n\t\t\t\tif(len>=12)\n\t\t\t\t{\n\t\t\t\t\tint width, height;\n\t\t\t\t\tint imghandle = readInt(0, cmddata);\n\t\t\t\t\twidth=readInt(4, cmddata);\n\t\t\t\t\theight=readInt(8, cmddata);\n\t\t\t\t\twhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n\t\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t\tint oldestImage = myConn.getOldestImage();\n\t\t\t\t\t\tif (oldestImage != 0)\n\t\t\t\t\t\t{\nSystem.out.println(\"Freeing image to make room in cache\");\n\t\t\t\t\t\t\tunloadImage(oldestImage);\n\t\t\t\t\t\t\tmyConn.postImageUnload(oldestImage);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlong imagePtr = createNewImage0(width, height);\n\t\t\t\t\timageMap.put(new Integer(imghandle), new Long(imagePtr));\n\t\t\t\t\timageCacheSize += width * height * 4;\n\t\t\t\t\tmyConn.registerImageAccess(imghandle);\n\t\t\t\t\thasret[0]=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGETARGETED : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_CREATESURFACE:\n\t\t\t\n\t\t\t\tif(len>=8)\n\t\t\t\t{\n\t\t\t\t\tint width, height;\n\t\t\t\t\tint handle = handleCount++;;\n\t\t\t\t\twidth=readInt(0, cmddata);\n\t\t\t\t\theight=readInt(4, cmddata);\n\t\t\t\t\n\t\t\t\t\tlong layerPtr = createLayer0(c.getSize());\n\t\t\t\t\tlayerMap.put(new Integer(handle), new Long(layerPtr));\n\t\t\t\t\thasret[0]=1;\n\t\t\t\t\treturn handle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_CREATESURFACE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_PREPIMAGE:\n\t\t\t\n\t\t\t\tif(len>=8)\n\t\t\t\t{\n\t\t\t\t\tint width, height;\n\t\t\t\t\n\t\t\t\t\twidth=readInt(0, cmddata);\n\t\t\t\t\theight=readInt(4, cmddata);\n\t\t\t\t\tint imghandle = 1;\n\t\t\t\t\tif (width * height * 4 + imageCacheSize > imageCacheLimit)\n\t\t\t\t\t\timghandle = 0;\n\t\t\t\t\telse if (len >= 12)\n\t\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t\tint strlen = readInt(8, cmddata);\n\t\t\t\t\t\tif (strlen > 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString rezName = new String(cmddata, 16, strlen - 1);\n\t\t\t\t\t\t\tlastImageResourceID = rezName;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\n\t\t\t\t\t\t\tjava.io.File cachedFile = myConn.getCachedImageFile(rezName);\n\t\t\t\t\t\t\tif (cachedFile != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\n\t\t\t\t\t\t\t\tif(imagePtr != 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tjava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\n\t\t\t\t\t\t\t\t\tif(imgSize != null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\timghandle = handleCount++;\n\t\t\t\t\t\t\t\t\t\t\timageMap.put(new Integer(imghandle), new Long(imagePtr));\n\t\t\t\t\t\t\t\t\t\t\timageCacheSize += getImageSize0(imagePtr);\n\t\t\t\t\t\t\t\t\t\t\thasret[0] = 1;\n\t\t\t\t\t\t\t\t\t\t\treturn -1 * imghandle;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\tfreeNativeImage0(imagePtr);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tfreeNativeImage0(imagePtr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\thasret[0]=1;\n\t\t\t\t\treturn imghandle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_PREPIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_PREPIMAGETARGETED:\n\t\t\t\n\t\t\t\tif(len>=12)\n\t\t\t\t{\n\t\t\t\t\tint imghandle, width, height;\n\t\t\t\t\timghandle = readInt(0, cmddata);\n\t\t\t\t\twidth=readInt(4, cmddata);\n\t\t\t\t\theight=readInt(8, cmddata);\n\t\t\t\t\tint strlen = readInt(12, cmddata);\n\t\t\t\t\twhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n\t\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t\tint oldestImage = myConn.getOldestImage();\n\t\t\t\t\t\tif (oldestImage != 0)\n\t\t\t\t\t\t{\nSystem.out.println(\"Freeing image to make room in cache\");\n\t\t\t\t\t\t\tunloadImage(oldestImage);\n\t\t\t\t\t\t\tmyConn.postImageUnload(oldestImage);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (len >= 16)\n\t\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t\tString rezName = new String(cmddata, 20, strlen - 1);\n\t\t\t\t\t\tlastImageResourceID = rezName;\n\t\t\t\t\t\tlastImageResourceIDHandle = imghandle;\nSystem.out.println(\"Prepped targeted image with handle \" + imghandle + \" resource=\" + rezName);\n\t\t\t\t\t}\n\t\t\t\t\tmyConn.registerImageAccess(imghandle);\n\t\t\t\t\thasret[0]=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_PREPIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADCACHEDIMAGE:\n\t\t\t\n\t\t\t\tif(len>=18)\n\t\t\t\t{\n\t\t\t\t\tint width, height, imghandle;\n\t\t\t\t\timghandle = readInt(0, cmddata);\n\t\t\t\t\twidth = readInt(4, cmddata);\n\t\t\t\t\theight = readInt(8, cmddata);\n\t\t\t\t\tint strlen = readInt(12, cmddata);\n\t\t\t\t\tString rezName = new String(cmddata, 20, strlen - 1);\nSystem.out.println(\"imghandle=\" + imghandle + \" width=\" + width + \" height=\" + height + \" strlen=\" + strlen + \" rezName=\" + rezName);\n\t\t\t\t\twhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n\t\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t\tint oldestImage = myConn.getOldestImage();\n\t\t\t\t\t\tif (oldestImage != 0)\n\t\t\t\t\t\t{\nSystem.out.println(\"Freeing image to make room in cache\");\n\t\t\t\t\t\t\tunloadImage(oldestImage);\n\t\t\t\t\t\t\tmyConn.postImageUnload(oldestImage);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmyConn.registerImageAccess(imghandle);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(\"Loading resource from cache: \" + rezName);\n\t\t\t\t\t\tjava.io.File cachedFile = myConn.getCachedImageFile(rezName);\n\t\t\t\t\t\tif (cachedFile != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tSystem.out.println(\"Image found in cache!\");\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\n\t\t\t\t\t\t\tif(imagePtr != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tjava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\n\t\t\t\t\t\t\t\tif(imgSize != null && imgSize.getWidth() == width && imgSize.getHeight() == height)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\timageMap.put(new Integer(imghandle), new Long(imagePtr));\n\t\t\t\t\t\t\t\t\timageCacheSize += getImageSize0(imagePtr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (imgSize != null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"CACHE ID verification failed for rezName=\" + rezName + \" target=\" + width + \"x\" + height + \" actual=\" + imgSize.getWidth() + \"x\" + imgSize.getHeight());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"CACHE Load failed for rezName=\" + rezName);\n\t\t\t\t\t\t\t\t\tcachedFile.delete();\n\t\t\t\t\t\t\t\t\tfreeNativeImage0(imagePtr);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tmyConn.postImageUnload(imghandle);\n\t\t\t\t\t\t\t\t\tmyConn.postOfflineCacheChange(false, rezName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcachedFile.delete();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tmyConn.postImageUnload(imghandle);\n\t\t\t\t\t\t\t\tmyConn.postOfflineCacheChange(false, rezName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR Image not found in cache that should be there! rezName=\" + rezName);\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tmyConn.postImageUnload(imghandle);\n\t\t\t\t\t\t\tmyConn.postOfflineCacheChange(false, rezName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (java.io.IOException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(\"ERROR loading compressed image: \" + e);\n\t\t\t\t\t}\n\t\t\t\t\thasret[0]=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_PREPIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_UNLOADIMAGE:\n\t\t\t\n\t\t\t\tif(len==4)\n\t\t\t\t{\n\t\t\t\t\tint handle;\n\t\t\t\t\thandle=readInt(0, cmddata);\n\t\t\t\t\tunloadImage(handle);\n\t\t\t\t\tmyConn.clearImageAccess(handle);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_UNLOADIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_SETTARGETSURFACE:\n\t\t\t\n\t\t\t\tif(len==4)\n\t\t\t\t{\n\t\t\t\t\tint handle;\n\t\t\t\t\thandle=readInt(0, cmddata);\n\t\t\t\t\n\t\t\t\t\tLong layerPtr = (Long)layerMap.get(new Integer(handle));\n\t\t\t\t\tcurrentLayer = (layerPtr != null) ? layerPtr.longValue() : 0;\n\t\t\t\t\tjava.awt.Rectangle clipRect = new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight());\n\t\t\t\t\tsetLayer0(currentLayer, c.getSize(), clipRect);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_SETTARGETSURFACE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADFONT:\n\t\t\t\n\t\t\t\tif(len>=12 && len>=(12+readInt(0, cmddata)))\n\t\t\t\t{\n\t\t\t\t\tint namelen, style, size;\n\t\t\t\t\tStringBuffer name = new StringBuffer();\n\t\t\t\t\tint i;\n\t\t\t\t\tint fonthandle = handleCount++;\n\t\t\t\t\tnamelen=readInt(0, cmddata);\n\t\t\t\t\tfor(i=0;i<namelen-1;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tname.append((char) cmddata[8 + i]);\n\t\t\t\t\t}\n\t\t\t\t\tstyle=readInt(namelen+4, cmddata);\n\t\t\t\t\tsize=readInt(namelen+8, cmddata);\n\t\t\t\t\tMcFont fontPtr = new McFont(name.toString(), style, size);\n\t\t\t\t\tif(fontPtr == null) {\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\thasret[0] = 1;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tfontMap.put(new Integer(fonthandle), fontPtr);\n\t\t\t\t\thasret[0] = 1;\n\t\t\t\t\treturn fonthandle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADFONT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_UNLOADFONT:\n\t\t\t\n\t\t\t\tif(len==4)\n\t\t\t\t{\n\t\t\t\t\tint handle;\n\t\t\t\t\thandle=readInt(0, cmddata);\n\t\t\t\t\n\t\t\t\t\tMcFont fontPtr = (McFont)fontMap.get(new Integer(handle));\n\t\t\t\t\tif(fontPtr != null) fontPtr.unload();\n\t\t\t\t\tfontMap.remove(new Integer(handle));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_UNLOADFONT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADFONTSTREAM:\n\t\t\t   \n\t\t\t\tif (len>=8)\n\t\t\t\t{\n\t\t\t\t\tStringBuffer name = new StringBuffer();\n\t\t\t\t\tint namelen = readInt(0, cmddata);\n\t\t\t\t\tfor(int i=0;i<namelen-1;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tname.append((char) cmddata[8 + i]);\n\t\t\t\t\t}\n\t\t\t\t\tint datalen = readInt(4 + namelen, cmddata);\n\t\t\t\t\tif (len >= datalen + 8 + namelen)\n\t\t\t\t\t{\n\t\t\t\t\t\tmyConn.saveCacheData(name.toString() + \"-\" + myConn.getServerName(), cmddata, 12 + namelen, datalen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADFONTSTREAM : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_FLIPBUFFER:\n\t\t\t\tif (abortRenderCycle)\n\t\t\t\t{\nSystem.out.println(\"ERROR in painting cycle, ABORT was set...send full repaint command\");\n\t\t\t\t\tmyConn.postRepaintEvent(0, 0, c.getWidth(), c.getHeight());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpresent0(c.nativeView, new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight()));\n\t\t\t\t}\n\t\t\t\thasret[0] = 1;\n\t\t\t\n\t\t\t\tfirstFrameDone = true;\n\t\t\t\treturn 0;\n\t\t\tcase GFXCMD_STARTFRAME:\n\t\t\t\n\t\t\t\tsetTargetView0(c.nativeView);\n\t\t\t\tsetLayer0(0, c.getSize(), null);\n\t\t\t\tabortRenderCycle = false;\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADIMAGELINE:\n\t\t\t\n\t\t\t\tif(len>=12 && len>=(12+readInt(8, cmddata)))\n\t\t\t\t{\n\t\t\t\t\tint handle, line, len2;\n\t\t\t\t\n\t\t\t\t\thandle=readInt(0, cmddata);\n\t\t\t\t\tline=readInt(4, cmddata);\n\t\t\t\t\tlen2=readInt(8, cmddata);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\tLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\t\t\t\t\tif(imagePtr != null)\n\t\t\t\t\t\tloadImageLine0(imagePtr.longValue(), line, cmddata, 1, len2);\n\t\t\t\t\tmyConn.registerImageAccess(handle);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGELINE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADIMAGECOMPRESSED:\n\t\t\t\n\t\t\t\tif(len>=8 && len>=(8+readInt(4, cmddata)))\n\t\t\t\t{\n\t\t\t\t\tint handle, len2;\n\t\t\t\t\thandle=readInt(0, cmddata);\n\t\t\t\t\tlen2=readInt(4, cmddata);\n\t\t\t\t\tif (lastImageResourceID != null && lastImageResourceIDHandle == handle)\n\t\t\t\t\t{\n\t\t\t\t\t\tmyConn.saveCacheData(lastImageResourceID, cmddata, 12, len2);\n\t\t\t\t\t\tmyConn.postOfflineCacheChange(true, lastImageResourceID);\n\t\t\t\t\t}\n\t\t\t\t\tif (!myConn.doesUseAdvancedImageCaching())\n\t\t\t\t\t{\n\t\t\t\t\t\thandle = handleCount++;\n\t\t\t\t\t\thasret[0] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\thasret[0] = 0;\n\t\t\t\t\tmyConn.registerImageAccess(handle);\n\t\t\t\t\tlong imagePtr = createImageFromBytes0(cmddata, 12, len2, null);\n\t\t\t\t\timageMap.put(new Integer(handle), new Long(imagePtr));\n\t\t\t\t\timageCacheSize += getImageSize0(imagePtr);\n\t\t\t\t\treturn handle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGECOMPRESSED : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_XFMIMAGE:\n\t\t\t\n\t\t\t\tif (len >= 20)\n\t\t\t\t{\n\t\t\t\t\tint srcHandle, destHandle, destWidth, destHeight, maskCornerArc;\n\t\t\t\t\tsrcHandle = readInt(0, cmddata);\n\t\t\t\t\tdestHandle = readInt(4, cmddata);\t\n\t\t\t\t\tdestWidth = readInt(8,  cmddata);\t\n\t\t\t\t\tdestHeight = readInt(12, cmddata);\n\t\t\t\t\tmaskCornerArc = readInt(16, cmddata);\n\t\t\t\t\tint rvHandle = destHandle;\n\t\t\t\t\tif (!myConn.doesUseAdvancedImageCaching())\n\t\t\t\t\t{\n\t\t\t\t\t\trvHandle = handleCount++;\n\t\t\t\t\t\thasret[0] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\thasret[0] = 0;\n\t\t\t\t\n\t\t\t\t\tLong srcImg = (Long)imageMap.get(new Integer(srcHandle));\n\t\t\t\t\tif(srcImg != null) {\n\t\t\t\t\t\tlong newImage = transformImage0(srcImg.longValue(), destWidth, destHeight, maskCornerArc);\n\t\t\t\t\t\tif(newImage != 0) {\n\t\t\t\t\t\t\timageMap.put(new Integer(rvHandle), new Long(newImage));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn rvHandle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_XFMIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_SETVIDEOPROP:\n\t\t\t\tif (len >= 40)\n\t\t\t\t{\n\t\t\t\t\tjava.awt.Rectangle srcRect = new java.awt.Rectangle(readInt(4, cmddata), readInt(8, cmddata),\n\t\t\t\t\t\treadInt(12, cmddata), readInt(16, cmddata));\n\t\t\t\t\tjava.awt.Rectangle destRect = new java.awt.Rectangle(readInt(20, cmddata), readInt(24, cmddata),\n\t\t\t\t\t\treadInt(28, cmddata), readInt(32, cmddata));\n\t\t\t\t\tSystem.out.println(\"SETVIDEOPROP: srcRect=\"+srcRect+\" dstRect=\"+destRect);\n\t\t\t\t\tsetVideoBounds(srcRect, destRect);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_SETVIDEOPROP: \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}","cleancode":"public int executegfxcommand(int cmd, int len, byte[] cmddata, int[] hasret) { len -= 4; hasret[0] = 0; if((cmd != gfxcmd_init) && (cmd != gfxcmd_deinit)) { if((f != null) ? (!f.isdisplayable() || !f.isvalid() || !f.isshowing()) : true) { while((f != null) ? (!f.isdisplayable() || !f.isvalid() || !f.isshowing()) : true) { try { thread.sleep(10); } catch(interruptedexception ex) {} } } } if (c != null) { switch(cmd) { case gfxcmd_init: case gfxcmd_deinit: case gfxcmd_startframe: case gfxcmd_flipbuffer: c.setcursor(null); break; case gfxcmd_drawrect: case gfxcmd_fillrect: case gfxcmd_clearrect: case gfxcmd_drawoval: case gfxcmd_filloval: case gfxcmd_drawroundrect: case gfxcmd_fillroundrect: case gfxcmd_drawtext: case gfxcmd_drawtextured: case gfxcmd_drawline: case gfxcmd_loadimage: case gfxcmd_loadimagetargeted: case gfxcmd_unloadimage: case gfxcmd_loadfont: case gfxcmd_unloadfont: case gfxcmd_settargetsurface: case gfxcmd_createsurface: break; case gfxcmd_prepimage: case gfxcmd_loadimageline: case gfxcmd_loadimagecompressed: case gfxcmd_xfmimage: case gfxcmd_loadcachedimage: case gfxcmd_prepimagetargeted: if (!cursorhidden) c.setcursor(java.awt.cursor.getpredefinedcursor(java.awt.cursor.wait_cursor)); break; } } switch(cmd) { case gfxcmd_init: hasret[0] = 1; init0(); int windowtitlestyle = 0; try { windowtitlestyle = integer.parseint(miniclient.myproperties.getproperty(\"window_title_style\", \"0\")); } catch (numberformatexception e){} if (!\"true\".equals(miniclient.myproperties.getproperty(\"enable_custom_title_bar\", miniclient.mac_os_x ? \"false\" : \"true\"))) windowtitlestyle = 10; f = new miniclientwindow(myconn.getwindowtitle(), windowtitlestyle); java.awt.layoutmanager layer = new java.awt.layoutmanager() { public void addlayoutcomponent(string name, java.awt.component comp) {} public java.awt.dimension minimumlayoutsize(java.awt.container parent) { return preferredlayoutsize(parent); } public java.awt.dimension preferredlayoutsize(java.awt.container parent) { return parent.getpreferredsize(); } public void removelayoutcomponent(java.awt.component comp) {} public void layoutcontainer(java.awt.container parent) { c.setbounds(parent.getinsets().left, parent.getinsets().top, parent.getwidth() - parent.getinsets().left - parent.getinsets().right, parent.getheight() - parent.getinsets().top - parent.getinsets().bottom); } }; f.getcontentpane().setlayout(layer); try { bgimage = java.awt.toolkit.getdefaulttoolkit().createimage(getclass().getclassloader().getresource(\"images\/background.jpg\")); ensureimageisloaded(bgimage); logoimage = java.awt.toolkit.getdefaulttoolkit().createimage(getclass().getclassloader().getresource(\"images\/sagelogo256.png\")); ensureimageisloaded(logoimage); } catch (exception e) { system.out.println(\"error:\" + e); e.printstacktrace(); } f.setfocustraversalkeysenabled(false); java.awt.dimension panelsize = f.getcontentpane().getsize(); c = new quartzrendererview(); c.setsize(panelsize); c.setfocustraversalkeysenabled(false); f.getcontentpane().add(c); try { java.awt.image frameicon = java.awt.toolkit.getdefaulttoolkit().createimage(getclass().getclassloader().getresource(\"images\/tvicon.gif\")); ensureimageisloaded(frameicon); f.seticonimage(frameicon); } catch (exception e) { system.out.println(\"error:\" + e); e.printstacktrace(); } f.addwindowlistener(new java.awt.event.windowadapter() { public void windowclosing(java.awt.event.windowevent evt) { if (!f.isfullscreen() || system.getproperty(\"os.name\").tolowercase().indexof(\"windows\") != -1) { miniclient.myproperties.setproperty(\"main_window_width\", integer.tostring(f.getwidth())); miniclient.myproperties.setproperty(\"main_window_height\", integer.tostring(f.getheight())); miniclient.myproperties.setproperty(\"main_window_x\", integer.tostring(f.getx())); miniclient.myproperties.setproperty(\"main_window_y\", integer.tostring(f.gety())); } myconn.close(); close(); } }); c.addcomponentlistener(new java.awt.event.componentadapter() { public void componentresized(java.awt.event.componentevent evt) { myconn.postresizeevent(new java.awt.dimension(c.getwidth(), c.getheight())); } }); f.addkeylistener(this); c.addkeylistener(this); f.addmousewheellistener(this); c.addmouselistener(this); if (enable_mouse_motion_events) { c.addmousemotionlistener(this); } int framex = 100; int framey = 100; int framew = 720; int frameh = 480; try { framew = integer.parseint(miniclient.myproperties.getproperty(\"main_window_width\", \"720\")); frameh = integer.parseint(miniclient.myproperties.getproperty(\"main_window_height\", \"480\")); framex = integer.parseint(miniclient.myproperties.getproperty(\"main_window_x\", \"100\")); framey = integer.parseint(miniclient.myproperties.getproperty(\"main_window_y\", \"100\")); } catch (numberformatexception e){} java.awt.point newpos = new java.awt.point(framex, framey); boolean foundscreen = sage.uiutils.ispointonascreen(newpos); if (!foundscreen) { newpos.x = 150; newpos.y = 150; } f.setvisible(true); f.setsize(1,1); f.setsize(math.max(framew, 320), math.max(frameh, 240)); f.setlocation(newpos); if (miniclient.fsstartup) f.setfullscreen(true); miniclient.hidesplash(); return 1; case gfxcmd_deinit: close(); break; case gfxcmd_drawrect: if(len==36) { float x, y, width, height; int thickness, argbtl, argbtr, argbbr, argbbl; x=(float)readint(0, cmddata); y=(float)readint(4, cmddata); width=(float)readint(8, cmddata); height=(float)readint(12, cmddata); thickness=readint(16, cmddata); argbtl=readint(20, cmddata); argbtr=readint(24, cmddata); argbbr=readint(28, cmddata); argbbl=readint(32, cmddata); drawrect0(new java.awt.geom.rectangle2d.float(x, y, width, height), null, 0, new java.awt.color(argbtl, true), thickness, null, 0.0f, 0.0f, null, 0.0f, 0.0f, 1.0f); } else { system.out.println(\"invalid len for gfxcmd_drawrect : \" + len); } break; case gfxcmd_fillrect: if(len==32) { float x, y, width, height; int argbtl, argbtr, argbbr, argbbl; x=(float)readint(0, cmddata); y=(float)readint(4, cmddata); width=(float)readint(8, cmddata); height=(float)readint(12, cmddata); argbtl=readint(16, cmddata); argbtr=readint(20, cmddata); argbbr=readint(24, cmddata); argbbl=readint(28, cmddata); java.awt.gradientpaint gp = getgradient(x, y, width, height, argbtl, argbtr, argbbl, argbbr); java.awt.geom.rectangle2d.float bounds = new java.awt.geom.rectangle2d.float(x, y, width, height); if(gp != null) { drawrect0(bounds, null, 0, null, 0, gp.getcolor1(), (float)gp.getpoint1().getx(), (float)gp.getpoint1().gety(), gp.getcolor2(), (float)gp.getpoint2().getx(), (float)gp.getpoint2().gety(), 1.0f); } else { drawrect0(bounds, null, 0, null, 0, new java.awt.color(argbtl, true), 0.0f, 0.0f, null, 0.0f, 0.0f, 1.0f); } } else { system.out.println(\"invalid len for gfxcmd_fillrect : \" + len); } break; case gfxcmd_clearrect: if(len==32) { int x, y, width, height, argbtl, argbtr, argbbr, argbbl; x=readint(0, cmddata); y=readint(4, cmddata); width=readint(8, cmddata); height=readint(12, cmddata); argbtl=readint(16, cmddata); argbtr=readint(20, cmddata); argbbr=readint(24, cmddata); argbbl=readint(28, cmddata); java.awt.geom.rectangle2d.float destrect = new java.awt.geom.rectangle2d.float(x, y, width, height); clearrect0(destrect); } else { system.out.println(\"invalid len for gfxcmd_clearrect : \" + len); } break; case gfxcmd_drawoval: if(len==52) { float x, y, width, height, clipx, clipy, clipw, cliph; int thickness, argbtl, argbtr, argbbr, argbbl; x=(float)readint(0, cmddata); y=(float)readint(4, cmddata); width=(float)readint(8, cmddata); height=(float)readint(12, cmddata); thickness=readint(16, cmddata); argbtl=readint(20, cmddata); argbtr=readint(24, cmddata); argbbr=readint(28, cmddata); argbbl=readint(32, cmddata); clipx=(float)readint(36, cmddata); clipy=(float)readint(40, cmddata); clipw=(float)readint(44, cmddata); cliph=(float)readint(48, cmddata); java.awt.geom.rectangle2d.float bounds = new java.awt.geom.rectangle2d.float(x, y, width, height); java.awt.geom.rectangle2d.float cliprect = new java.awt.geom.rectangle2d.float(clipx, clipy, clipw, cliph); drawoval0(bounds, cliprect, new java.awt.color(argbtl, true), thickness, null, 0.0f, 0.0f, null, 0.0f, 0.0f, 1.0f); } else { system.out.println(\"invalid len for gfxcmd_drawoval : \" + len); } break; case gfxcmd_filloval: if(len==48) { float x, y, width, height, clipx, clipy, clipw, cliph; int argbtl, argbtr, argbbr, argbbl; x=(float)readint(0, cmddata); y=(float)readint(4, cmddata); width=(float)readint(8, cmddata); height=(float)readint(12, cmddata); argbtl=readint(16, cmddata); argbtr=readint(20, cmddata); argbbr=readint(24, cmddata); argbbl=readint(28, cmddata); clipx=(float)readint(32, cmddata); clipy=(float)readint(36, cmddata); clipw=(float)readint(40, cmddata); cliph=(float)readint(44, cmddata); java.awt.gradientpaint gp = getgradient(x, y, width, height, argbtl, argbtr, argbbl, argbbr); java.awt.geom.rectangle2d.float bounds = new java.awt.geom.rectangle2d.float(x, y, width, height); java.awt.geom.rectangle2d.float cliprect = new java.awt.geom.rectangle2d.float(clipx, clipy, clipw, cliph); if(gp != null) { drawoval0(bounds, cliprect, null, 0, gp.getcolor1(), (float)gp.getpoint1().getx(), (float)gp.getpoint1().gety(), gp.getcolor2(), (float)gp.getpoint2().getx(), (float)gp.getpoint2().gety(), 1.0f); } else { drawoval0(bounds, cliprect, null, 0, new java.awt.color(argbtl, true), 0.0f, 0.0f, null, 0.0f, 0.0f, 1.0f); } } else { system.out.println(\"invalid len for gfxcmd_filloval : \" + len); } break; case gfxcmd_drawroundrect: if(len==56) { float x, y, width, height, clipx, clipy, clipw, cliph; int thickness, arcradius, argbtl, argbtr, argbbr, argbbl; x=(float)readint(0, cmddata); y=(float)readint(4, cmddata); width=(float)readint(8, cmddata); height=(float)readint(12, cmddata); thickness=readint(16, cmddata); arcradius=readint(20, cmddata); argbtl=readint(24, cmddata); argbtr=readint(28, cmddata); argbbr=readint(32, cmddata); argbbl=readint(36, cmddata); clipx=(float)readint(40, cmddata); clipy=(float)readint(44, cmddata); clipw=(float)readint(48, cmddata); cliph=(float)readint(52, cmddata); java.awt.geom.rectangle2d.float bounds = new java.awt.geom.rectangle2d.float(x, y, width, height); java.awt.geom.rectangle2d.float cliprect = new java.awt.geom.rectangle2d.float(clipx, clipy, clipw, cliph); drawrect0(bounds, cliprect, arcradius, new java.awt.color(argbtl, true), thickness, null, 0.0f, 0.0f, null, 0.0f, 0.0f, 1.0f); } else { system.out.println(\"invalid len for gfxcmd_drawroundrect : \" + len); } break; case gfxcmd_fillroundrect: if(len==52) { float x, y, width, height, clipx, clipy, clipw, cliph; int arcradius, argbtl, argbtr, argbbr, argbbl; x=(float)readint(0, cmddata); y=(float)readint(4, cmddata); width=(float)readint(8, cmddata); height=(float)readint(12, cmddata); arcradius=readint(16, cmddata); argbtl=readint(20, cmddata); argbtr=readint(24, cmddata); argbbr=readint(28, cmddata); argbbl=readint(32, cmddata); clipx=(float)readint(36, cmddata); clipy=(float)readint(40, cmddata); clipw=(float)readint(44, cmddata); cliph=(float)readint(48, cmddata); java.awt.gradientpaint gp = getgradient(x, y, width, height, argbtl, argbtr, argbbl, argbbr); java.awt.geom.rectangle2d.float bounds = new java.awt.geom.rectangle2d.float(x, y, width, height); java.awt.geom.rectangle2d.float cliprect = new java.awt.geom.rectangle2d.float(clipx, clipy, clipw, cliph); if(gp != null) { drawrect0(bounds, cliprect, arcradius, null, 0, gp.getcolor1(), (float)gp.getpoint1().getx(), (float)gp.getpoint1().gety(), gp.getcolor2(), (float)gp.getpoint2().getx(), (float)gp.getpoint2().gety(), 1.0f); } else { drawrect0(bounds, cliprect, arcradius, null, 0, new java.awt.color(argbtl, true), 0.0f, 0.0f, null, 0.0f, 0.0f, 1.0f); } } else { system.out.println(\"invalid len for gfxcmd_fillroundrect : \" + len); } break; case gfxcmd_drawtext: if(len>=36 && len>=(36+readint(8, cmddata)*2)) { float x, y, clipx, clipy, clipw, cliph; int textlen, fonthandle, argb; stringbuffer text = new stringbuffer(); int i; x=(float)readint(0, cmddata); y=(float)readint(4, cmddata); textlen=readint(8, cmddata); for(i=0;i<textlen;i++) { text.append((char)readshort(12+i*2, cmddata)); } fonthandle=readint(textlen*2+12, cmddata); argb=readint(textlen*2+16, cmddata); clipx=(float)readint(textlen*2+20, cmddata); clipy=(float)readint(textlen*2+24, cmddata); clipw=(float)readint(textlen*2+28, cmddata); cliph=(float)readint(textlen*2+32, cmddata); mcfont fontptr = (mcfont)fontmap.get(new integer(fonthandle)); if(fontptr != null) { string thestring = text.tostring(); float[] positions = fontptr.getglyphpositions(thestring); drawtextwithpositions0(thestring, fontptr.nativefont, x, y, positions, new java.awt.geom.rectangle2d.float(clipx,clipy,clipw,cliph), new java.awt.color(argb, true)); } } else { system.out.println(\"invalid len for gfxcmd_drawtext : \" + len); } break; case gfxcmd_drawtextured: if(len==40) { float x, y, width, height, srcx, srcy, srcwidth, srcheight; int handle, blend; x=(float)readint(0, cmddata); y=(float)readint(4, cmddata); width=(float)readint(8, cmddata); height=(float)readint(12, cmddata); handle=readint(16, cmddata); srcx=(float)readint(20, cmddata); srcy=(float)readint(24, cmddata); srcwidth=(float)readint(28, cmddata); srcheight=(float)readint(32, cmddata); blend=readint(36, cmddata); boolean doblend = true; if(height < 0) { doblend = false; height *= -1; } if(width < 0) { width *= -1; } else { if(doblend) blend |= 0x00ffffff; } long imageptr = (long)imagemap.get(new integer(handle)); java.awt.geom.rectangle2d.float destrect = new java.awt.geom.rectangle2d.float(x,y,width,height); java.awt.geom.rectangle2d.float srcrect = new java.awt.geom.rectangle2d.float(srcx,srcy,srcwidth,srcheight); if(imageptr != null) { myconn.registerimageaccess(handle); drawimage1(imageptr.longvalue(), destrect, srcrect, (doblend) ? new java.awt.color(blend, true) : null); } else { imageptr = (long)layermap.get(new integer(handle)); if(imageptr != null) { myconn.registerimageaccess(handle); float alpha = (doblend ? (float)(((blend >> 24)&0xff))\/255.0f : 1.0f); composite0(imageptr.longvalue(), currentlayer, srcrect, destrect, alpha, doblend); } else { system.out.println(\"error invalid handle passed for texture rendering of: \" + handle); abortrendercycle = true; } } } else { system.out.println(\"invalid len for gfxcmd_drawtextured : \" + len); } break; case gfxcmd_drawline: if(len==24) { float x1, y1, x2, y2; int argb1, argb2; x1=readint(0, cmddata); y1=readint(4, cmddata); x2=readint(8, cmddata); y2=readint(12, cmddata); argb1=readint(16, cmddata); argb2=readint(20, cmddata); drawline0(x1, y1, x2, y2, 1, new java.awt.color(argb1, true)); } else { system.out.println(\"invalid len for gfxcmd_drawline : \" + len); } break; case gfxcmd_loadimage: if(len>=8) { int width, height; int imghandle = 0; width=readint(0, cmddata); height=readint(4, cmddata); if (width * height * 4 + imagecachesize > imagecachelimit) { imghandle = 0; } else { long imageptr = createnewimage0(width, height); imghandle = handlecount++; imagemap.put(new integer(imghandle), new long(imageptr)); imagecachesize += width * height * 4; } hasret[0]=1; return imghandle; } else { system.out.println(\"invalid len for gfxcmd_loadimage : \" + len); } break; case gfxcmd_loadimagetargeted: if(len>=12) { int width, height; int imghandle = readint(0, cmddata); width=readint(4, cmddata); height=readint(8, cmddata); while (width * height * 4 + imagecachesize > imagecachelimit) { int oldestimage = myconn.getoldestimage(); if (oldestimage != 0) { system.out.println(\"freeing image to make room in cache\"); unloadimage(oldestimage); myconn.postimageunload(oldestimage); } else { system.out.println(\"error cannot free enough from the cache to support loading a new image!!!\"); break; } } long imageptr = createnewimage0(width, height); imagemap.put(new integer(imghandle), new long(imageptr)); imagecachesize += width * height * 4; myconn.registerimageaccess(imghandle); hasret[0]=0; } else { system.out.println(\"invalid len for gfxcmd_loadimagetargeted : \" + len); } break; case gfxcmd_createsurface: if(len>=8) { int width, height; int handle = handlecount++;; width=readint(0, cmddata); height=readint(4, cmddata); long layerptr = createlayer0(c.getsize()); layermap.put(new integer(handle), new long(layerptr)); hasret[0]=1; return handle; } else { system.out.println(\"invalid len for gfxcmd_createsurface : \" + len); } break; case gfxcmd_prepimage: if(len>=8) { int width, height; width=readint(0, cmddata); height=readint(4, cmddata); int imghandle = 1; if (width * height * 4 + imagecachesize > imagecachelimit) imghandle = 0; else if (len >= 12) { int strlen = readint(8, cmddata); if (strlen > 1) { string rezname = new string(cmddata, 16, strlen - 1); lastimageresourceid = rezname; lastimageresourceidhandle = imghandle = math.abs(lastimageresourceid.hashcode()); java.io.file cachedfile = myconn.getcachedimagefile(rezname); if (cachedfile != null) { long imageptr = createimagefrompath0(cachedfile.getabsolutepath()); if(imageptr != 0) { java.awt.dimension imgsize = getimagedimensions0(imageptr); if(imgsize != null) { if(imgsize.getwidth() == width && imgsize.getheight() == height) { imghandle = handlecount++; imagemap.put(new integer(imghandle), new long(imageptr)); imagecachesize += getimagesize0(imageptr); hasret[0] = 1; return -1 * imghandle; } else freenativeimage0(imageptr); } else freenativeimage0(imageptr); } } } } hasret[0]=1; return imghandle; } else { system.out.println(\"invalid len for gfxcmd_prepimage : \" + len); } break; case gfxcmd_prepimagetargeted: if(len>=12) { int imghandle, width, height; imghandle = readint(0, cmddata); width=readint(4, cmddata); height=readint(8, cmddata); int strlen = readint(12, cmddata); while (width * height * 4 + imagecachesize > imagecachelimit) { int oldestimage = myconn.getoldestimage(); if (oldestimage != 0) { system.out.println(\"freeing image to make room in cache\"); unloadimage(oldestimage); myconn.postimageunload(oldestimage); } else { system.out.println(\"error cannot free enough from the cache to support loading a new image!!!\"); break; } } if (len >= 16) { string rezname = new string(cmddata, 20, strlen - 1); lastimageresourceid = rezname; lastimageresourceidhandle = imghandle; system.out.println(\"prepped targeted image with handle \" + imghandle + \" resource=\" + rezname); } myconn.registerimageaccess(imghandle); hasret[0]=0; } else { system.out.println(\"invalid len for gfxcmd_prepimage : \" + len); } break; case gfxcmd_loadcachedimage: if(len>=18) { int width, height, imghandle; imghandle = readint(0, cmddata); width = readint(4, cmddata); height = readint(8, cmddata); int strlen = readint(12, cmddata); string rezname = new string(cmddata, 20, strlen - 1); system.out.println(\"imghandle=\" + imghandle + \" width=\" + width + \" height=\" + height + \" strlen=\" + strlen + \" rezname=\" + rezname); while (width * height * 4 + imagecachesize > imagecachelimit) { int oldestimage = myconn.getoldestimage(); if (oldestimage != 0) { system.out.println(\"freeing image to make room in cache\"); unloadimage(oldestimage); myconn.postimageunload(oldestimage); } else { system.out.println(\"error cannot free enough from the cache to support loading a new image!!!\"); break; } } myconn.registerimageaccess(imghandle); try { system.out.println(\"loading resource from cache: \" + rezname); java.io.file cachedfile = myconn.getcachedimagefile(rezname); if (cachedfile != null) { system.out.println(\"image found in cache!\"); long imageptr = createimagefrompath0(cachedfile.getabsolutepath()); if(imageptr != 0) { java.awt.dimension imgsize = getimagedimensions0(imageptr); if(imgsize != null && imgsize.getwidth() == width && imgsize.getheight() == height) { imagemap.put(new integer(imghandle), new long(imageptr)); imagecachesize += getimagesize0(imageptr); } else { if (imgsize != null) { system.out.println(\"cache id verification failed for rezname=\" + rezname + \" target=\" + width + \"x\" + height + \" actual=\" + imgsize.getwidth() + \"x\" + imgsize.getheight()); } else system.out.println(\"cache load failed for rezname=\" + rezname); cachedfile.delete(); freenativeimage0(imageptr); myconn.postimageunload(imghandle); myconn.postofflinecachechange(false, rezname); } } else { cachedfile.delete(); myconn.postimageunload(imghandle); myconn.postofflinecachechange(false, rezname); } } else { system.out.println(\"error image not found in cache that should be there! rezname=\" + rezname); myconn.postimageunload(imghandle); myconn.postofflinecachechange(false, rezname); } } catch (java.io.ioexception e) { system.out.println(\"error loading compressed image: \" + e); } hasret[0]=0; } else { system.out.println(\"invalid len for gfxcmd_prepimage : \" + len); } break; case gfxcmd_unloadimage: if(len==4) { int handle; handle=readint(0, cmddata); unloadimage(handle); myconn.clearimageaccess(handle); } else { system.out.println(\"invalid len for gfxcmd_unloadimage : \" + len); } break; case gfxcmd_settargetsurface: if(len==4) { int handle; handle=readint(0, cmddata); long layerptr = (long)layermap.get(new integer(handle)); currentlayer = (layerptr != null) ? layerptr.longvalue() : 0; java.awt.rectangle cliprect = new java.awt.rectangle(0, 0, c.getwidth(), c.getheight()); setlayer0(currentlayer, c.getsize(), cliprect); } else { system.out.println(\"invalid len for gfxcmd_settargetsurface : \" + len); } break; case gfxcmd_loadfont: if(len>=12 && len>=(12+readint(0, cmddata))) { int namelen, style, size; stringbuffer name = new stringbuffer(); int i; int fonthandle = handlecount++; namelen=readint(0, cmddata); for(i=0;i<namelen-1;i++) { name.append((char) cmddata[8 + i]); } style=readint(namelen+4, cmddata); size=readint(namelen+8, cmddata); mcfont fontptr = new mcfont(name.tostring(), style, size); if(fontptr == null) { hasret[0] = 1; return 0; } fontmap.put(new integer(fonthandle), fontptr); hasret[0] = 1; return fonthandle; } else { system.out.println(\"invalid len for gfxcmd_loadfont : \" + len); } break; case gfxcmd_unloadfont: if(len==4) { int handle; handle=readint(0, cmddata); mcfont fontptr = (mcfont)fontmap.get(new integer(handle)); if(fontptr != null) fontptr.unload(); fontmap.remove(new integer(handle)); } else { system.out.println(\"invalid len for gfxcmd_unloadfont : \" + len); } break; case gfxcmd_loadfontstream: if (len>=8) { stringbuffer name = new stringbuffer(); int namelen = readint(0, cmddata); for(int i=0;i<namelen-1;i++) { name.append((char) cmddata[8 + i]); } int datalen = readint(4 + namelen, cmddata); if (len >= datalen + 8 + namelen) { myconn.savecachedata(name.tostring() + \"-\" + myconn.getservername(), cmddata, 12 + namelen, datalen); } } else { system.out.println(\"invalid len for gfxcmd_loadfontstream : \" + len); } break; case gfxcmd_flipbuffer: if (abortrendercycle) { system.out.println(\"error in painting cycle, abort was set...send full repaint command\"); myconn.postrepaintevent(0, 0, c.getwidth(), c.getheight()); } else { present0(c.nativeview, new java.awt.rectangle(0, 0, c.getwidth(), c.getheight())); } hasret[0] = 1; firstframedone = true; return 0; case gfxcmd_startframe: settargetview0(c.nativeview); setlayer0(0, c.getsize(), null); abortrendercycle = false; break; case gfxcmd_loadimageline: if(len>=12 && len>=(12+readint(8, cmddata))) { int handle, line, len2; handle=readint(0, cmddata); line=readint(4, cmddata); len2=readint(8, cmddata); long imageptr = (long)imagemap.get(new integer(handle)); if(imageptr != null) loadimageline0(imageptr.longvalue(), line, cmddata, 1, len2); myconn.registerimageaccess(handle); } else { system.out.println(\"invalid len for gfxcmd_loadimageline : \" + len); } break; case gfxcmd_loadimagecompressed: if(len>=8 && len>=(8+readint(4, cmddata))) { int handle, len2; handle=readint(0, cmddata); len2=readint(4, cmddata); if (lastimageresourceid != null && lastimageresourceidhandle == handle) { myconn.savecachedata(lastimageresourceid, cmddata, 12, len2); myconn.postofflinecachechange(true, lastimageresourceid); } if (!myconn.doesuseadvancedimagecaching()) { handle = handlecount++; hasret[0] = 1; } else hasret[0] = 0; myconn.registerimageaccess(handle); long imageptr = createimagefrombytes0(cmddata, 12, len2, null); imagemap.put(new integer(handle), new long(imageptr)); imagecachesize += getimagesize0(imageptr); return handle; } else { system.out.println(\"invalid len for gfxcmd_loadimagecompressed : \" + len); } break; case gfxcmd_xfmimage: if (len >= 20) { int srchandle, desthandle, destwidth, destheight, maskcornerarc; srchandle = readint(0, cmddata); desthandle = readint(4, cmddata); destwidth = readint(8, cmddata); destheight = readint(12, cmddata); maskcornerarc = readint(16, cmddata); int rvhandle = desthandle; if (!myconn.doesuseadvancedimagecaching()) { rvhandle = handlecount++; hasret[0] = 1; } else hasret[0] = 0; long srcimg = (long)imagemap.get(new integer(srchandle)); if(srcimg != null) { long newimage = transformimage0(srcimg.longvalue(), destwidth, destheight, maskcornerarc); if(newimage != 0) { imagemap.put(new integer(rvhandle), new long(newimage)); } } return rvhandle; } else { system.out.println(\"invalid len for gfxcmd_xfmimage : \" + len); } break; case gfxcmd_setvideoprop: if (len >= 40) { java.awt.rectangle srcrect = new java.awt.rectangle(readint(4, cmddata), readint(8, cmddata), readint(12, cmddata), readint(16, cmddata)); java.awt.rectangle destrect = new java.awt.rectangle(readint(20, cmddata), readint(24, cmddata), readint(28, cmddata), readint(32, cmddata)); system.out.println(\"setvideoprop: srcrect=\"+srcrect+\" dstrect=\"+destrect); setvideobounds(srcrect, destrect); } else { system.out.println(\"invalid len for gfxcmd_setvideoprop: \" + len); } break; default: return -1; } return 0; }","comment":"\/\/ for the 4 byte header\n\/\/ nothing to return by default\n\/\/ system.out.println(\"gfxcmd=\" + cmd); \/\/ make sure the frame is still valid or we could crash on fullscreen mode switches\n\/\/ system.out.println(\"gfxcmd while frame not displayable\"); \/\/ spin until the frame is valid and displayable, if we don't we'll lose parts of the ui or crash\n\/\/ system.out.println(\"init\"); \/\/ start up native renderer\n\/\/ platform default\n\/\/system.out.println(\"layout frame bounds=\" + f.getbounds() + \" videobounds=\" + videobounds + \" parentbounds=\" + parent.getbounds());\n\/* if not connecting to localhost: - draw background to bounds (scaled) - draw logo to {{2% from left, 15% from top}{20% view width, 7% view height}}, no clipping, alpha = 0.85, adjust size to keep aspect ratio - load arial 32 bold - draw the following text, double spaced using arial 32 bold, white with black shadow (offset by (+2,+2)) \"sagetv placeshifter is connecting to\" \"the server: \"+myconn.getservername() \"please wait...\" text is centered in the view on the middle line, use font metrics to determine proper location g.setfont(pleasewaitfont); g.setcolor(java.awt.color.black); y += 2; g.drawstring(str1, 2 + (getwidth()\/2) - (fm.stringwidth(str1)\/2), y + fm.getascent()); y += fm.getheight(); g.drawstring(str2, 2 + (getwidth()\/2) - (fm.stringwidth(str2)\/2), y + fm.getascent()); y += 2*fm.getheight(); g.drawstring(str3, 2 + (getwidth()\/2) - (fm.stringwidth(str3)\/2), y + fm.getascent()); g.setcolor(java.awt.color.white); y = (getheight() \/ 2) - fh\/2; g.drawstring(str1, (getwidth()\/2) - (fm.stringwidth(str1)\/2), y + fm.getascent()); y += fm.getheight(); g.drawstring(str2, (getwidth()\/2) - (fm.stringwidth(str2)\/2), y + fm.getascent()); y += 2*fm.getheight(); g.drawstring(str3, (getwidth()\/2) - (fm.stringwidth(str3)\/2), y + fm.getascent()); *\/\n\/* try { if (myconn.getmediacmd().getplaya() != null) { myconn.getmediacmd().getplaya().stop(); myconn.getmediacmd().getplaya().free(); } }catch (exception e){} system.exit(0);*\/\n\/\/ f.dispose();\n\/\/f.addmouselistener(this);\n\/\/f.addmousemotionlistener(this);\n\/\/ f.setvisible(true);\n\/\/ system.out.println(\"deinit\");\n\/\/ system.out.println(\"drawrect: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") thickness=\"+thickness+\" argbtl=\"+integer.tohexstring(argbtl)+\" argbtr=\"+integer.tohexstring(argbtr)+\" argbbl=\"+integer.tohexstring(argbbl)+\" argbbr=\"+integer.tohexstring(argbbr)); \/\/ fixme: no gradients on framed rects yet...\n\/\/ x, y, width, height, argbtl, argbtr, argbbr, argbbl\n\/\/ system.out.println(\"fillrect: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbtl=\"+integer.tohexstring(argbtl)+\" argbtr=\"+integer.tohexstring(argbtr)+\" argbbl=\"+integer.tohexstring(argbbl)+\" argbbr=\"+integer.tohexstring(argbbr));\n\/\/(float)((argbtl>>24)&0xff)\/255.0f);\n\/\/ alpha already supplied\n\/\/ x, y, width, height, argbtl, argbtr, argbbr, argbbl\n\/\/ system.out.println(\"clearrect: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbtl=\"+integer.tohexstring(argbtl)+\" argbtr=\"+integer.tohexstring(argbtr)+\" argbbl=\"+integer.tohexstring(argbbl)+\" argbbr=\"+integer.tohexstring(argbbr));\n\/\/ x, y, width, height, thickness, argbtl, argbtr, argbbr, argbbl, \/\/ clipx, clipy, clipw, cliph\n\/\/ system.out.println(\"drawoval: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipx+\",\"+clipy+\" \"+clipw+\"x\"+cliph+\") thickness=\"+thickness+\" argbtl=\"+integer.tohexstring(argbtl)+\" argbtr=\"+integer.tohexstring(argbtr)+\" argbbl=\"+integer.tohexstring(argbbl)+\" argbbr=\"+integer.tohexstring(argbbr)); \/\/ fixme: no gradient for framed ovals\n\/\/ x, y, width, height, argbtl, argbtr, argbbr, argbbl, \/\/ clipx, clipy, clipw, cliph\n\/\/ system.out.println(\"filloval: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipx+\",\"+clipy+\" \"+clipw+\"x\"+cliph+\") argbtl=\"+integer.tohexstring(argbtl)+\" argbtr=\"+integer.tohexstring(argbtr)+\" argbbl=\"+integer.tohexstring(argbbl)+\" argbbr=\"+integer.tohexstring(argbbr));\n\/\/ x, y, width, height, thickness, arcradius, argbtl, argbtr, argbbr, argbbl, \/\/ clipx, clipy, clipw, cliph\n\/\/ system.out.println(\"drawroundrect: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipx+\",\"+clipy+\" \"+clipw+\"x\"+cliph+\") thickness=\"+thickness+\" arcradius=\"+arcradius+\" argbtl=\"+integer.tohexstring(argbtl)+\" argbtr=\"+integer.tohexstring(argbtr)+\" argbbl=\"+integer.tohexstring(argbbl)+\" argbbr=\"+integer.tohexstring(argbbr)); \/\/ fixme: no gradients on stroked shapes\n\/\/ x, y, width, height, arcradius, argbtl, argbtr, argbbr, argbbl, \/\/ clipx, clipy, clipw, cliph\n\/\/ system.out.println(\"fillroundrect: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipx+\",\"+clipy+\" \"+clipw+\"x\"+cliph+\") arcradius=\"+arcradius+\" argbtl=\"+integer.tohexstring(argbtl)+\" argbtr=\"+integer.tohexstring(argbtr)+\" argbbl=\"+integer.tohexstring(argbbl)+\" argbbr=\"+integer.tohexstring(argbbr));\n\/\/(float)((argbtl>>24)&0xff)\/255.0f);\n\/\/ x, y, len, text, handle, argb, clipx, clipy, clipw, cliph\n\/\/ todo: check if this is needed \/\/ if (system.getproperty(\"java.version\").startswith(\"1.4\")) \/\/ clipw = clipw * 5 \/ 4; \/\/ system.out.println(\"drawtext: dest=(\"+x+\",\"+y+\") clip=(\"+clipx+\",\"+clipy+\" \"+clipw+\"x\"+cliph+\") fonthandle=\"+fonthandle+\" argb=\"+integer.tohexstring(argb)+\" text=\"+text.tostring());\n\/\/ use awt string bounds or we'll clip on occasion\n\/\/ java.awt.dimension textsize = fontptr.getstringsize(thestring);\n\/\/ system.out.println(\"drawtext: \\\"\"+thestring+\"\\\" loc=(\"+x+\",\"+y+\") num positions=\"+positions.length);\n\/\/ x, y, width, height, handle, srcx, srcy, srcwidth, srcheight, blend\n\/\/ blend is a color, use alpha component for blending\n\/\/ either an image handle or layer handle (if not in imagemap)\n\/* if height < 0 disable blending if width < 0 (font mode, composite with background and blend with given color) blend with full rgba color else blend with alpha only *\/\n\/\/ system.out.println(\"drawtextured: handle=\"+handle+\" dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") src=(\"+srcx+\",\"+srcy+\" \"+srcwidth+\"x\"+srcheight+\") blend=\"+integer.tohexstring(blend));\n\/\/ only use alpha\n\/\/ system.out.println(\" (drawing image) imageptr=\"+imageptr);\n\/\/ system.out.println(\" (compositing surface) layerptr=\"+long.tohexstring(imageptr.longvalue())+\" currentlayer=\"+currentlayer);\n\/\/ x1, y1, x2, y2, argb1, argb2\n\/\/ system.out.println(\"drawline: start=(\"+x1+\",\"+y1+\") end=(\"+x2+\",\"+y2+\") argb1=\"+integer.tohexstring(argb1)+\" argb2=\"+integer.tohexstring(argb2));\n\/\/ width, height\n\/\/ system.out.println(\"loadimage: size=(\"+width+\"x\"+height+\")\");\n\/\/ creating a new image from bitmap data being sent over myconn, create a new empty image\n\/\/ system.out.println(\" imghandle=\"+imghandle+\" imageptr=\"+imageptr);\n\/\/ actual value is filled in later when it's prepared\n\/\/ handle, width, height \/\/ not used unless we do uncompressed images\n\/\/ keep freeing the oldest image until we have enough memory to do this\n\/\/ system.out.println(\" imghandle=\"+imghandle+\" imageptr=\"+imageptr);\n\/\/ actual value is filled in later when it's prepared\n\/\/ width, height\n\/\/ width\/height is managed here\n\/\/ system.out.println(\"createsurface: (\"+width+\",\"+height+\") handle=\"+handle+\" layerptr=\"+layerptr);\n\/\/ width, height\n\/\/int imghandle = handlecount++;;\n\/\/ system.out.println(\"prepimage: size=(\"+width+\"x\"+height+\")\");\n\/\/ we've got enough room for it and there's a cache id, check if we've got it cached locally\n\/\/ system.out.println(\" rezname=\"+rezname);\n\/\/ we use this hashcode to match it up on the loadcompressedimage call so we know we're caching the right thing\n\/\/ we've got it locally in our cache! read it from there.\n\/\/ valid image in cache, use it\n\/\/ system.out.println(\" loaded from cache, imageptr=\"+imageptr+\" handle=\"+imghandle);\n\/\/imghandle=stbgfx.gfx_loadimage(width, height);\n\/\/ handle, width, height, [rezid]\n\/\/ keep freeing the oldest image until we have enough memory to do this\n\/\/ we will not have this cached locally...but setup our vars to track it\n\/\/ width, height\n\/\/ keep freeing the oldest image until we have enough memory to do this\n\/\/ we've got it locally in our cache! read it from there.\n\/\/ we've got it locally in our cache! read it from there.\n\/\/ valid image in cache, use it \/\/ system.out.println(\" loaded from cache, imageptr=\"+imageptr+\" handle=\"+imghandle);\n\/\/ it doesn't match the cache\n\/\/ this load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\n\/\/ this load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\n\/\/ this load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\n\/\/ handle\n\/\/ handle\n\/\/stbgfx.gfx_unloadimage(handle);\n\/\/ system.out.println(\"settargetsurface: handle=\"+handle+\" layerptr=\"+ (layerptr == null ? \"0\" : long.tohexstring(layerptr.longvalue())));\n\/\/ namelen, name, style, size\n\/\/ skip the terminating \\0 character\n\/\/ an extra 4 for the header\n\/\/ system.out.println(\"loadfont: handle=\"+fonthandle+\" name=\"+name.tostring()+\" style=\"+integer.tohexstring(style)+\" size=\"+size);\n\/\/ long fontptr = loadfont0(name.tostring(), style, size);\n\/\/ fixme: implement! \/\/ we don't have the font on this sytem (yet) see if it's cached and try to load it manually \/\/ string cachename = name.tostring() + \"-\" + style; \/\/ fontptr = loadcachedfont0(cachedir.getabsolutepath(), name.tostring() + \"-\" + myconn.getservername(), style, size); \/\/ if (fontptr == 0) { \/\/ return that we don't have this font so it'll load it into our cache\n\/\/ }\n\/\/ system.out.println(\" fontptr=\" + fontptr);\n\/\/ handle\n\/\/stbgfx.gfx_unloadfont(handle);\n\/\/ system.out.println(\"unloadfont: handle=\"+handle+\" fontptr=\"+fontptr);\n\/\/ namelen, name, len, data\n\/\/ skip the terminating \\0 character\n\/\/ an extra 4 for the header\n\/\/ system.out.println(\"saving font \" + name.tostring() + \" to cache\");\n\/\/ system.out.println(\"flipbuffer\");\n\/\/stbgfx.gfx_flipbuffer();\n\/\/ system.out.println(\"startframe\"); \/\/ prepare for a new frame to be rendered\n\/\/ this makes sure the drawing surface gets resized properly\n\/\/ handle, line, len, data\n\/\/unsigned char *data=&cmddata[12];\n\/\/ the last number is the offset into the data array to start reading from \/\/stbgfx.gfx_loadimageline(handle, line, len, data, 12); \/\/int datapos = 12;\n\/\/ system.out.println(\"loadimageline: handle=\"+handle+\" imageptr=\"+imageptr+\" line=\"+line+\" len2=\"+len2);\n\/*12*\/\n\/\/ handle, line, len, data\n\/\/ fixme: grab extension if possible\n\/\/ system.out.println(\"loadimagecompressed: handle=\"+handle+\" imageptr=\"+imageptr+\" len2=\"+len2);\n\/\/ srchandle, desthandle, destwidth, destheight, maskcornerarc\n\/\/ seems to be unused\n\/\/ scaled size (ignore?)\n\/\/ we cheat and apply the transforms to a metaimage object without actually creating a new image (saves oodles of memory)\n\/\/ system.out.println(\"xfmimage: srchandle=\"+srchandle+\" srcimg=\"+srcimg+\" desthandle=\"+desthandle+\" destwidth=\"+destwidth+\" destheight=\"+destheight+\" maskcornerarc=\"+maskcornerarc);\n\/\/ system.out.println(\" newimage=\"+newimage);","repo":"Narflex\/sagetv","code_context_2":"public int ExecuteGFXCommand(int cmd, int len, byte[] cmddata, int[] hasret)\n{\nlen -= 4; \/\/ for the 4 byte header\nhasret[0] = 0; \/\/ Nothing to return by default\n\/\/ System.out.println(\"GFXCMD=\" + cmd);\n\n{\nlen -= 4; \/\/ for the 4 byte header\nhasret[0] = 0; \/\/ Nothing to return by default\n\/\/ System.out.println(\"GFXCMD=\" + cmd);\n\/\/ make sure the frame is still valid or we could crash on fullscreen mode switches\n\nlen -= 4; \/\/ for the 4 byte header\nhasret[0] = 0; \/\/ Nothing to return by default\n\/\/ System.out.println(\"GFXCMD=\" + cmd);\n\/\/ make sure the frame is still valid or we could crash on fullscreen mode switches\nif((cmd != GFXCMD_INIT) && (cmd != GFXCMD_DEINIT))\n{\n\n{\nif((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\n\/\/ System.out.println(\"GFXCMD while frame not displayable\");\n\/\/ spin until the frame is valid and displayable, if we don't we'll lose parts of the UI or crash\nwhile((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\ntry {\n\ncase GFXCMD_INIT:\nhasret[0] = 1;\n\/\/ System.out.println(\"INIT\");\n\/\/ start up native renderer\ninit0();\nint windowTitleStyle = 0;\n\ncatch (NumberFormatException e){}\nif (!\"true\".equals(MiniClient.myProperties.getProperty(\"enable_custom_title_bar\", MiniClient.MAC_OS_X ? \"false\" : \"true\")))\nwindowTitleStyle = 10; \/\/ platform default\nf = new MiniClientWindow(myConn.getWindowTitle(), windowTitleStyle);\njava.awt.LayoutManager layer = new java.awt.LayoutManager()\n\nc.setBounds(parent.getInsets().left, parent.getInsets().top, parent.getWidth() - parent.getInsets().left - parent.getInsets().right,\nparent.getHeight() - parent.getInsets().top - parent.getInsets().bottom);\n\/\/System.out.println(\"LAYOUT frame bounds=\" + f.getBounds() + \" videoBounds=\" + videoBounds + \" parentBounds=\" + parent.getBounds());\n}\n};\n\n}\nf.setFocusTraversalKeysEnabled(false);\n\/*\nif not connecting to localhost:\n- draw background to bounds (scaled)\n- draw logo to {{2% from left, 15% from top}{20% view width, 7% view height}}, no clipping, alpha = 0.85, adjust size to keep aspect ratio\n- load Arial 32 bold\n- draw the following text, double spaced using Arial 32 bold, white with black shadow (offset by (+2,+2))\n\"SageTV Placeshifter is connecting to\"\n\"the server: \"+myConn.getServerName()\n\"Please Wait...\"\ntext is centered in the view on the middle line, use font metrics to determine proper location\ng.setFont(pleaseWaitFont);\ng.setColor(java.awt.Color.black);\ny += 2;\ng.drawString(str1, 2 + (getWidth()\/2) - (fm.stringWidth(str1)\/2), y + fm.getAscent());\ny += fm.getHeight();\ng.drawString(str2, 2 + (getWidth()\/2) - (fm.stringWidth(str2)\/2), y + fm.getAscent());\ny += 2*fm.getHeight();\ng.drawString(str3, 2 + (getWidth()\/2) - (fm.stringWidth(str3)\/2), y + fm.getAscent());\ng.setColor(java.awt.Color.white);\ny = (getHeight() \/ 2) - fh\/2;\ng.drawString(str1, (getWidth()\/2) - (fm.stringWidth(str1)\/2), y + fm.getAscent());\ny += fm.getHeight();\ng.drawString(str2, (getWidth()\/2) - (fm.stringWidth(str2)\/2), y + fm.getAscent());\ny += 2*fm.getHeight();\ng.drawString(str3, (getWidth()\/2) - (fm.stringWidth(str3)\/2), y + fm.getAscent());\n*\/\njava.awt.Dimension panelSize = f.getContentPane().getSize();\nc = new QuartzRendererView();\n\n}\nmyConn.close();\n\/* try\n{\nif (myConn.getMediaCmd().getPlaya() != null)\n{\nmyConn.getMediaCmd().getPlaya().stop();\nmyConn.getMediaCmd().getPlaya().free();\n}\n}catch (Exception e){}\nSystem.exit(0);*\/\nclose();\n\/\/ f.dispose();\n\nSystem.exit(0);*\/\nclose();\n\/\/ f.dispose();\n}\n});\n\nf.addKeyListener(this);\nc.addKeyListener(this);\n\/\/f.addMouseListener(this);\nf.addMouseWheelListener(this);\nc.addMouseListener(this);\n\nif (ENABLE_MOUSE_MOTION_EVENTS)\n{\n\/\/f.addMouseMotionListener(this);\nc.addMouseMotionListener(this);\n}\n\nf.setFullScreen(true);\nMiniClient.hideSplash();\n\/\/ f.setVisible(true);\nreturn 1;\ncase GFXCMD_DEINIT:\n\nreturn 1;\ncase GFXCMD_DEINIT:\n\/\/ System.out.println(\"DEINIT\");\nclose();\nbreak;\n\nargbBR=readInt(28, cmddata);\nargbBL=readInt(32, cmddata);\n\/\/ System.out.println(\"DRAWRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") thickness=\"+thickness+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\/\/ FIXME: no gradients on framed rects yet...\ndrawRect0(new java.awt.geom.Rectangle2D.Float(x, y, width, height), null,\n0,\n\nbreak;\ncase GFXCMD_FILLRECT:\n\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL\nif(len==32)\n{\n\nargbBR=readInt(24, cmddata);\nargbBL=readInt(28, cmddata);\n\/\/ System.out.println(\"FILLRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\ngp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\ngp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\/\/(float)((argbTL>>24)&0xff)\/255.0f);\n1.0f); \/\/ alpha already supplied\n} else {\n\ngp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\/\/(float)((argbTL>>24)&0xff)\/255.0f);\n1.0f); \/\/ alpha already supplied\n} else {\ndrawRect0(bounds, null,\n\nbreak;\ncase GFXCMD_FILLRECT:\n\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL\nif(len==32)\n{\n\nargbBR=readInt(24, cmddata);\nargbBL=readInt(28, cmddata);\n\/\/ System.out.println(\"CLEARRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.geom.Rectangle2D.Float destRect = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\nclearRect0(destRect);\n\nbreak;\ncase GFXCMD_DRAWOVAL:\n\/\/ x, y, width, height, thickness, argbTL, argbTR, argbBR, argbBL,\n\/\/ clipX, clipY, clipW, clipH\nif(len==52)\n{\n\nclipW=(float)readInt(44, cmddata);\nclipH=(float)readInt(48, cmddata);\n\/\/ System.out.println(\"DRAWOVAL: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") thickness=\"+thickness+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\/\/ FIXME: no gradient for framed ovals\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\njava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\n\nbreak;\ncase GFXCMD_FILLOVAL:\n\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL,\n\/\/ clipX, clipY, clipW, clipH\nif(len==48)\n{\n\nclipW=(float)readInt(40, cmddata);\nclipH=(float)readInt(44, cmddata);\n\/\/ System.out.println(\"FILLOVAL: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\nbreak;\ncase GFXCMD_DRAWROUNDRECT:\n\/\/ x, y, width, height, thickness, arcRadius, argbTL, argbTR, argbBR, argbBL,\n\/\/ clipX, clipY, clipW, clipH\nif(len==56)\n{\n\nclipW=(float)readInt(48, cmddata);\nclipH=(float)readInt(52, cmddata);\n\/\/ System.out.println(\"DRAWROUNDRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") thickness=\"+thickness+\" arcRadius=\"+arcRadius+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\/\/ FIXME: no gradients on stroked shapes\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\njava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\n\nbreak;\ncase GFXCMD_FILLROUNDRECT:\n\/\/ x, y, width, height, arcRadius, argbTL, argbTR, argbBR, argbBL,\n\/\/ clipX, clipY, clipW, clipH\nif(len==52)\n{\n\nclipW=(float)readInt(44, cmddata);\nclipH=(float)readInt(48, cmddata);\n\/\/ System.out.println(\"FILLROUNDRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") arcRadius=\"+arcRadius+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\ngp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\ngp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\/\/(float)((argbTL>>24)&0xff)\/255.0f);\n1.0f); \/\/ alpha already supplied\n} else {\n\nbreak;\ncase GFXCMD_DRAWTEXT:\n\/\/ x, y, len, text, handle, argb, clipX, clipY, clipW, clipH\nif(len>=36 && len>=(36+readInt(8, cmddata)*2))\n{\n\nclipW=(float)readInt(textlen*2+28, cmddata);\nclipH=(float)readInt(textlen*2+32, cmddata);\n\/\/ TODO: check if this is needed\n\/\/ if (System.getProperty(\"java.version\").startsWith(\"1.4\"))\n\/\/ clipW = clipW * 5 \/ 4;\n\/\/ System.out.println(\"DRAWTEXT: dest=(\"+x+\",\"+y+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") fontHandle=\"+fontHandle+\" argb=\"+Integer.toHexString(argb)+\" text=\"+text.toString());\nMcFont fontPtr = (McFont)fontMap.get(new Integer(fontHandle));\nif(fontPtr != null) {\n\nMcFont fontPtr = (McFont)fontMap.get(new Integer(fontHandle));\nif(fontPtr != null) {\n\/\/ use AWT string bounds or we'll clip on occasion\nString theString = text.toString();\n\/\/ java.awt.Dimension textSize = fontPtr.getStringSize(theString);\n\n\/\/ use AWT string bounds or we'll clip on occasion\nString theString = text.toString();\n\/\/ java.awt.Dimension textSize = fontPtr.getStringSize(theString);\nfloat[] positions = fontPtr.getGlyphPositions(theString);\n\/\/ System.out.println(\"drawText: \\\"\"+theString+\"\\\" loc=(\"+x+\",\"+y+\") num positions=\"+positions.length);\n\n\/\/ java.awt.Dimension textSize = fontPtr.getStringSize(theString);\nfloat[] positions = fontPtr.getGlyphPositions(theString);\n\/\/ System.out.println(\"drawText: \\\"\"+theString+\"\\\" loc=(\"+x+\",\"+y+\") num positions=\"+positions.length);\ndrawTextWithPositions0(theString, fontPtr.nativeFont,\nx, y, positions, new java.awt.geom.Rectangle2D.Float(clipX,clipY,clipW,clipH),\n\nbreak;\ncase GFXCMD_DRAWTEXTURED:\n\/\/ x, y, width, height, handle, srcx, srcy, srcwidth, srcheight, blend\nif(len==40)\n{\n\nfloat x, y, width, height,\nsrcx, srcy, srcwidth, srcheight;\nint handle, blend; \/\/ blend is a color, use alpha component for blending\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\n\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nhandle=readInt(16, cmddata); \/\/ either an image handle or layer handle (if not in imageMap)\nsrcx=(float)readInt(20, cmddata);\nsrcy=(float)readInt(24, cmddata);\n\n}\nf.setFocusTraversalKeysEnabled(false);\n\/*\nif not connecting to localhost:\n- draw background to bounds (scaled)\n- draw logo to {{2% from left, 15% from top}{20% view width, 7% view height}}, no clipping, alpha = 0.85, adjust size to keep aspect ratio\n- load Arial 32 bold\n- draw the following text, double spaced using Arial 32 bold, white with black shadow (offset by (+2,+2))\n\"SageTV Placeshifter is connecting to\"\n\"the server: \"+myConn.getServerName()\n\"Please Wait...\"\ntext is centered in the view on the middle line, use font metrics to determine proper location\n\nblend with alpha only\n*\/\n\/\/ System.out.println(\"DRAWTEXTURED: handle=\"+handle+\" dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") src=(\"+srcx+\",\"+srcy+\" \"+srcwidth+\"x\"+srcheight+\") blend=\"+Integer.toHexString(blend));\nboolean doBlend = true;\nif(height < 0) {\n\n} else {\nif(doBlend)\nblend |= 0x00ffffff; \/\/ only use alpha\n}\nLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\nif(imagePtr != null) {\nmyConn.registerImageAccess(handle);\n\/\/ System.out.println(\" (drawing image) imagePtr=\"+imagePtr);\ndrawImage1(imagePtr.longValue(),\ndestRect, srcRect,\n\nif(imagePtr != null) {\nmyConn.registerImageAccess(handle);\n\/\/ System.out.println(\" (compositing surface) layerPtr=\"+Long.toHexString(imagePtr.longValue())+\" currentLayer=\"+currentLayer);\nfloat alpha = (doBlend ? (float)(((blend >> 24)&0xff))\/255.0f : 1.0f);\ncomposite0(imagePtr.longValue(), currentLayer, srcRect, destRect, alpha, doBlend);\n\nbreak;\ncase GFXCMD_DRAWLINE:\n\/\/ x1, y1, x2, y2, argb1, argb2\nif(len==24)\n{\n\nargb1=readInt(16, cmddata);\nargb2=readInt(20, cmddata);\n\/\/ System.out.println(\"DRAWLINE: start=(\"+x1+\",\"+y1+\") end=(\"+x2+\",\"+y2+\") argb1=\"+Integer.toHexString(argb1)+\" argb2=\"+Integer.toHexString(argb2));\ndrawLine0(x1, y1, x2, y2, 1, new java.awt.Color(argb1, true));\n}\n\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\nif(len>=8)\n{\n\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ System.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\nelse\n{\n\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n}\n\nbreak;\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\n\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\/\/ Keep freeing the oldest image until we have enough memory to do this\nint oldestImage = myConn.getOldestImage();\nif (oldestImage != 0)\n\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n}\n\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\nif(len>=8)\n{\n\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ width\/height is managed here\nlong layerPtr = createLayer0(c.getSize());\nlayerMap.put(new Integer(handle), new Long(layerPtr));\n\nlong layerPtr = createLayer0(c.getSize());\nlayerMap.put(new Integer(handle), new Long(layerPtr));\n\/\/ System.out.println(\"CREATESURFACE: (\"+width+\",\"+height+\") handle=\"+handle+\" layerPtr=\"+layerPtr);\nhasret[0]=1;\nreturn handle;\n\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\nif(len>=8)\n{\n\n{\nint width, height;\n\/\/int imghandle = handleCount++;;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\nheight=readInt(4, cmddata);\nint imghandle = 1;\n\/\/ System.out.println(\"PREPIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\nimghandle = 0;\n\nelse if (len >= 12)\n{\n\/\/ We've got enough room for it and there's a cache ID, check if we've got it cached locally\nint strlen = readInt(8, cmddata);\nif (strlen > 1)\n\n{\nString rezName = new String(cmddata, 16, strlen - 1);\n\/\/ System.out.println(\" rezName=\"+rezName);\nlastImageResourceID = rezName;\n\/\/ We use this hashcode to match it up on the loadCompressedImage call so we know we're caching the right thing\n\n\/\/ System.out.println(\" rezName=\"+rezName);\nlastImageResourceID = rezName;\n\/\/ We use this hashcode to match it up on the loadCompressedImage call so we know we're caching the right thing\nlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\njava.io.File cachedFile = myConn.getCachedImageFile(rezName);\n\nif (cachedFile != null)\n{\n\/\/ We've got it locally in our cache! Read it from there.\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n\nif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\/\/ valid image in cache, use it\nimghandle = handleCount++;\n\/\/ System.out.println(\" loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\n\n\/\/ valid image in cache, use it\nimghandle = handleCount++;\n\/\/ System.out.println(\" loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\nimageMap.put(new Integer(imghandle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\n\n}\n}\n\/\/imghandle=STBGFX.GFX_loadImage(width, height);\nhasret[0]=1;\nreturn imghandle;\n\nbreak;\ncase GFXCMD_PREPIMAGETARGETED:\n\/\/ handle, width, height, [rezID]\nif(len>=12)\n{\n\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\/\/ Keep freeing the oldest image until we have enough memory to do this\nint oldestImage = myConn.getOldestImage();\nif (oldestImage != 0)\n\nif (len >= 16)\n{\n\/\/ We will not have this cached locally...but setup our vars to track it\nString rezName = new String(cmddata, 20, strlen - 1);\nlastImageResourceID = rezName;\n\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\nif(len>=8)\n{\n\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\/\/ Keep freeing the oldest image until we have enough memory to do this\nint oldestImage = myConn.getOldestImage();\nif (oldestImage != 0)\n\nif (cachedFile != null)\n{\n\/\/ We've got it locally in our cache! Read it from there.\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n\nif (cachedFile != null)\n{\n\/\/ We've got it locally in our cache! Read it from there.\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n\nif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\/\/ valid image in cache, use it\nimghandle = handleCount++;\n\/\/ System.out.println(\" loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\nimageMap.put(new Integer(imghandle), new Long(imagePtr));\n\nif (imgSize != null)\n{\n\/\/ It doesn't match the cache\nSystem.out.println(\"CACHE ID verification failed for rezName=\" + rezName + \" target=\" + width + \"x\" + height + \" actual=\" + imgSize.getWidth() + \"x\" + imgSize.getHeight());\n}\n\ncachedFile.delete();\nfreeNativeImage0(imagePtr);\n\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\nmyConn.postImageUnload(imghandle);\nmyConn.postOfflineCacheChange(false, rezName);\n\ncachedFile.delete();\nfreeNativeImage0(imagePtr);\n\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\nmyConn.postImageUnload(imghandle);\nmyConn.postOfflineCacheChange(false, rezName);\n\ncachedFile.delete();\nfreeNativeImage0(imagePtr);\n\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\nmyConn.postImageUnload(imghandle);\nmyConn.postOfflineCacheChange(false, rezName);\n\nbreak;\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\n\nbreak;\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\n\nint handle;\nhandle=readInt(0, cmddata);\n\/\/STBGFX.GFX_unloadImage(handle);\nLong layerPtr = (Long)layerMap.get(new Integer(handle));\n\/\/ System.out.println(\"SETTARGETSURFACE: handle=\"+handle+\" layerPtr=\"+ (layerPtr == null ? \"0\" : Long.toHexString(layerPtr.longValue())));\n\n\/\/STBGFX.GFX_unloadImage(handle);\nLong layerPtr = (Long)layerMap.get(new Integer(handle));\n\/\/ System.out.println(\"SETTARGETSURFACE: handle=\"+handle+\" layerPtr=\"+ (layerPtr == null ? \"0\" : Long.toHexString(layerPtr.longValue())));\ncurrentLayer = (layerPtr != null) ? layerPtr.longValue() : 0;\njava.awt.Rectangle clipRect = new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight());\n\nbreak;\ncase GFXCMD_LOADFONT:\n\/\/ namelen, name, style, size\nif(len>=12 && len>=(12+readInt(0, cmddata)))\n{\n\nint fonthandle = handleCount++;\nnamelen=readInt(0, cmddata);\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nstyle=readInt(namelen+4, cmddata);\n\nstyle=readInt(namelen+4, cmddata);\nsize=readInt(namelen+8, cmddata);\n\/\/ System.out.println(\"LOADFONT: handle=\"+fonthandle+\" name=\"+name.toString()+\" style=\"+Integer.toHexString(style)+\" size=\"+size);\nMcFont fontPtr = new McFont(name.toString(), style, size);\n\/\/ long fontPtr = loadFont0(name.toString(), style, size);\n\n\/\/ System.out.println(\"LOADFONT: handle=\"+fonthandle+\" name=\"+name.toString()+\" style=\"+Integer.toHexString(style)+\" size=\"+size);\nMcFont fontPtr = new McFont(name.toString(), style, size);\n\/\/ long fontPtr = loadFont0(name.toString(), style, size);\nif(fontPtr == null) {\n\/\/ FIXME: implement!\n\n\/\/ long fontPtr = loadFont0(name.toString(), style, size);\nif(fontPtr == null) {\n\/\/ FIXME: implement!\n\/\/ we don't have the font on this sytem (yet) see if it's cached and try to load it manually\n\/\/ String cacheName = name.toString() + \"-\" + style;\n\/\/ fontPtr = loadCachedFont0(cacheDir.getAbsolutePath(), name.toString() + \"-\" + myConn.getServerName(), style, size);\n\/\/ if (fontPtr == 0) {\n\/\/ Return that we don't have this font so it'll load it into our cache\nhasret[0] = 1;\nreturn 0;\n\nhasret[0] = 1;\nreturn 0;\n\/\/ }\n}\n\/\/ System.out.println(\" fontPtr=\" + fontPtr);\n\n\/\/ }\n}\n\/\/ System.out.println(\" fontPtr=\" + fontPtr);\nfontMap.put(new Integer(fonthandle), fontPtr);\nhasret[0] = 1;\n\nbreak;\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\n\nint handle;\nhandle=readInt(0, cmddata);\n\/\/STBGFX.GFX_unloadFont(handle);\nMcFont fontPtr = (McFont)fontMap.get(new Integer(handle));\n\/\/ System.out.println(\"UNLOADFONT: handle=\"+handle+\" fontPtr=\"+fontPtr);\n\n\/\/STBGFX.GFX_unloadFont(handle);\nMcFont fontPtr = (McFont)fontMap.get(new Integer(handle));\n\/\/ System.out.println(\"UNLOADFONT: handle=\"+handle+\" fontPtr=\"+fontPtr);\nif(fontPtr != null) fontPtr.unload();\nfontMap.remove(new Integer(handle));\n\nbreak;\ncase GFXCMD_LOADFONTSTREAM:\n\/\/ namelen, name, len, data\nif (len>=8)\n{\n\nint fonthandle = handleCount++;\nnamelen=readInt(0, cmddata);\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nstyle=readInt(namelen+4, cmddata);\n\nif (len >= datalen + 8 + namelen)\n{\n\/\/ System.out.println(\"Saving font \" + name.toString() + \" to cache\");\nmyConn.saveCacheData(name.toString() + \"-\" + myConn.getServerName(), cmddata, 12 + namelen, datalen);\n}\n\nbreak;\ncase GFXCMD_FLIPBUFFER:\n\/\/ System.out.println(\"FLIPBUFFER\");\nif (abortRenderCycle)\n{\n\n}\nhasret[0] = 1;\n\/\/STBGFX.GFX_flipBuffer();\nfirstFrameDone = true;\nreturn 0;\n\nreturn 0;\ncase GFXCMD_STARTFRAME:\n\/\/ System.out.println(\"STARTFRAME\");\n\/\/ prepare for a new frame to be rendered\nsetTargetView0(c.nativeView);\nsetLayer0(0, c.getSize(), null); \/\/ this makes sure the drawing surface gets resized properly\n\n\/\/ prepare for a new frame to be rendered\nsetTargetView0(c.nativeView);\nsetLayer0(0, c.getSize(), null); \/\/ this makes sure the drawing surface gets resized properly\nabortRenderCycle = false;\nbreak;\n\nbreak;\ncase GFXCMD_LOADIMAGELINE:\n\/\/ handle, line, len, data\nif(len>=12 && len>=(12+readInt(8, cmddata)))\n{\n\n{\nint handle, line, len2;\n\/\/unsigned char *data=&cmddata[12];\nhandle=readInt(0, cmddata);\nline=readInt(4, cmddata);\n\nline=readInt(4, cmddata);\nlen2=readInt(8, cmddata);\n\/\/ the last number is the offset into the data array to start reading from\n\/\/STBGFX.GFX_loadImageLine(handle, line, len, data, 12);\n\/\/int dataPos = 12;\nLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\/\/ System.out.println(\"LOADIMAGELINE: handle=\"+handle+\" imagePtr=\"+imagePtr+\" line=\"+line+\" len2=\"+len2);\n\n\/\/int dataPos = 12;\nLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\/\/ System.out.println(\"LOADIMAGELINE: handle=\"+handle+\" imagePtr=\"+imagePtr+\" line=\"+line+\" len2=\"+len2);\nif(imagePtr != null)\nloadImageLine0(imagePtr.longValue(), line, cmddata, 16\/*12*\/, len2);\n\n\/\/ System.out.println(\"LOADIMAGELINE: handle=\"+handle+\" imagePtr=\"+imagePtr+\" line=\"+line+\" len2=\"+len2);\nif(imagePtr != null)\nloadImageLine0(imagePtr.longValue(), line, cmddata, 16\/*12*\/, len2);\nmyConn.registerImageAccess(handle);\n}\n\nbreak;\ncase GFXCMD_LOADIMAGELINE:\n\/\/ handle, line, len, data\nif(len>=12 && len>=(12+readInt(8, cmddata)))\n{\n\nhasret[0] = 0;\nmyConn.registerImageAccess(handle);\nlong imagePtr = createImageFromBytes0(cmddata, 12, len2, null); \/\/ FIXME: grab extension if possible\n\/\/ System.out.println(\"LOADIMAGECOMPRESSED: handle=\"+handle+\" imagePtr=\"+imagePtr+\" len2=\"+len2);\nimageMap.put(new Integer(handle), new Long(imagePtr));\n\nmyConn.registerImageAccess(handle);\nlong imagePtr = createImageFromBytes0(cmddata, 12, len2, null); \/\/ FIXME: grab extension if possible\n\/\/ System.out.println(\"LOADIMAGECOMPRESSED: handle=\"+handle+\" imagePtr=\"+imagePtr+\" len2=\"+len2);\nimageMap.put(new Integer(handle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\n\nbreak;\ncase GFXCMD_XFMIMAGE:\n\/\/ srcHandle, destHandle, destWidth, destHeight, maskCornerArc\nif (len >= 20)\n{\n\nint srcHandle, destHandle, destWidth, destHeight, maskCornerArc;\nsrcHandle = readInt(0, cmddata);\ndestHandle = readInt(4, cmddata); \/\/ seems to be unused\ndestWidth = readInt(8, cmddata); \/\/ scaled size (ignore?)\ndestHeight = readInt(12, cmddata);\n\nsrcHandle = readInt(0, cmddata);\ndestHandle = readInt(4, cmddata); \/\/ seems to be unused\ndestWidth = readInt(8, cmddata); \/\/ scaled size (ignore?)\ndestHeight = readInt(12, cmddata);\nmaskCornerArc = readInt(16, cmddata);\n\nelse\nhasret[0] = 0;\n\/\/ we cheat and apply the transforms to a metaimage object without actually creating a new image (saves oodles of memory)\nLong srcImg = (Long)imageMap.get(new Integer(srcHandle));\n\/\/ System.out.println(\"XFMIMAGE: srcHandle=\"+srcHandle+\" srcImg=\"+srcImg+\" destHandle=\"+destHandle+\" destWidth=\"+destWidth+\" destHeight=\"+destHeight+\" maskCornerArc=\"+maskCornerArc);\n\n\/\/ we cheat and apply the transforms to a metaimage object without actually creating a new image (saves oodles of memory)\nLong srcImg = (Long)imageMap.get(new Integer(srcHandle));\n\/\/ System.out.println(\"XFMIMAGE: srcHandle=\"+srcHandle+\" srcImg=\"+srcImg+\" destHandle=\"+destHandle+\" destWidth=\"+destWidth+\" destHeight=\"+destHeight+\" maskCornerArc=\"+maskCornerArc);\nif(srcImg != null) {\nlong newImage = transformImage0(srcImg.longValue(), destWidth, destHeight, maskCornerArc);\n\nlong newImage = transformImage0(srcImg.longValue(), destWidth, destHeight, maskCornerArc);\nif(newImage != 0) {\n\/\/ System.out.println(\" newImage=\"+newImage);\nimageMap.put(new Integer(rvHandle), new Long(newImage));\n}","code_context_10":"public int ExecuteGFXCommand(int cmd, int len, byte[] cmddata, int[] hasret)\n{\nlen -= 4; \/\/ for the 4 byte header\nhasret[0] = 0; \/\/ Nothing to return by default\n\/\/ System.out.println(\"GFXCMD=\" + cmd);\n\/\/ make sure the frame is still valid or we could crash on fullscreen mode switches\nif((cmd != GFXCMD_INIT) && (cmd != GFXCMD_DEINIT))\n{\nif((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\n\/\/ System.out.println(\"GFXCMD while frame not displayable\");\n\/\/ spin until the frame is valid and displayable, if we don't we'll lose parts of the UI or crash\nwhile((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\ntry {\n\npublic int ExecuteGFXCommand(int cmd, int len, byte[] cmddata, int[] hasret)\n{\nlen -= 4; \/\/ for the 4 byte header\nhasret[0] = 0; \/\/ Nothing to return by default\n\/\/ System.out.println(\"GFXCMD=\" + cmd);\n\/\/ make sure the frame is still valid or we could crash on fullscreen mode switches\nif((cmd != GFXCMD_INIT) && (cmd != GFXCMD_DEINIT))\n{\nif((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\n\/\/ System.out.println(\"GFXCMD while frame not displayable\");\n\/\/ spin until the frame is valid and displayable, if we don't we'll lose parts of the UI or crash\nwhile((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\ntry {\nThread.sleep(10);\n\npublic int ExecuteGFXCommand(int cmd, int len, byte[] cmddata, int[] hasret)\n{\nlen -= 4; \/\/ for the 4 byte header\nhasret[0] = 0; \/\/ Nothing to return by default\n\/\/ System.out.println(\"GFXCMD=\" + cmd);\n\/\/ make sure the frame is still valid or we could crash on fullscreen mode switches\nif((cmd != GFXCMD_INIT) && (cmd != GFXCMD_DEINIT))\n{\nif((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\n\/\/ System.out.println(\"GFXCMD while frame not displayable\");\n\/\/ spin until the frame is valid and displayable, if we don't we'll lose parts of the UI or crash\nwhile((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\ntry {\nThread.sleep(10);\n} catch(InterruptedException ex) {}\n}\n\npublic int ExecuteGFXCommand(int cmd, int len, byte[] cmddata, int[] hasret)\n{\nlen -= 4; \/\/ for the 4 byte header\nhasret[0] = 0; \/\/ Nothing to return by default\n\/\/ System.out.println(\"GFXCMD=\" + cmd);\n\/\/ make sure the frame is still valid or we could crash on fullscreen mode switches\nif((cmd != GFXCMD_INIT) && (cmd != GFXCMD_DEINIT))\n{\nif((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\n\/\/ System.out.println(\"GFXCMD while frame not displayable\");\n\/\/ spin until the frame is valid and displayable, if we don't we'll lose parts of the UI or crash\nwhile((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\ntry {\nThread.sleep(10);\n} catch(InterruptedException ex) {}\n}\n}\n}\nif (c != null)\n{\nswitch(cmd)\n\ncase GFXCMD_PREPIMAGETARGETED:\nif (!cursorHidden)\nc.setCursor(java.awt.Cursor.getPredefinedCursor(java.awt.Cursor.WAIT_CURSOR));\nbreak;\n}\n}\nswitch(cmd)\n{\ncase GFXCMD_INIT:\nhasret[0] = 1;\n\/\/ System.out.println(\"INIT\");\n\/\/ start up native renderer\ninit0();\nint windowTitleStyle = 0;\ntry\n{\nwindowTitleStyle = Integer.parseInt(MiniClient.myProperties.getProperty(\"window_title_style\", \"0\"));\n}\ncatch (NumberFormatException e){}\nif (!\"true\".equals(MiniClient.myProperties.getProperty(\"enable_custom_title_bar\", MiniClient.MAC_OS_X ? \"false\" : \"true\")))\nwindowTitleStyle = 10; \/\/ platform default\nf = new MiniClientWindow(myConn.getWindowTitle(), windowTitleStyle);\n\n\/\/ System.out.println(\"INIT\");\n\/\/ start up native renderer\ninit0();\nint windowTitleStyle = 0;\ntry\n{\nwindowTitleStyle = Integer.parseInt(MiniClient.myProperties.getProperty(\"window_title_style\", \"0\"));\n}\ncatch (NumberFormatException e){}\nif (!\"true\".equals(MiniClient.myProperties.getProperty(\"enable_custom_title_bar\", MiniClient.MAC_OS_X ? \"false\" : \"true\")))\nwindowTitleStyle = 10; \/\/ platform default\nf = new MiniClientWindow(myConn.getWindowTitle(), windowTitleStyle);\njava.awt.LayoutManager layer = new java.awt.LayoutManager()\n{\npublic void addLayoutComponent(String name, java.awt.Component comp)\n{}\npublic java.awt.Dimension minimumLayoutSize(java.awt.Container parent)\n{\nreturn preferredLayoutSize(parent);\n}\npublic java.awt.Dimension preferredLayoutSize(java.awt.Container parent)\n\npublic java.awt.Dimension preferredLayoutSize(java.awt.Container parent)\n{\nreturn parent.getPreferredSize();\n}\npublic void removeLayoutComponent(java.awt.Component comp)\n{}\npublic void layoutContainer(java.awt.Container parent)\n{\nc.setBounds(parent.getInsets().left, parent.getInsets().top, parent.getWidth() - parent.getInsets().left - parent.getInsets().right,\nparent.getHeight() - parent.getInsets().top - parent.getInsets().bottom);\n\/\/System.out.println(\"LAYOUT frame bounds=\" + f.getBounds() + \" videoBounds=\" + videoBounds + \" parentBounds=\" + parent.getBounds());\n}\n};\nf.getContentPane().setLayout(layer);\ntry\n{\nbgImage = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/Background.jpg\"));\nensureImageIsLoaded(bgImage);\nlogoImage = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/SageLogo256.png\"));\nensureImageIsLoaded(logoImage);\n}\n\nensureImageIsLoaded(bgImage);\nlogoImage = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/SageLogo256.png\"));\nensureImageIsLoaded(logoImage);\n}\ncatch (Exception e)\n{\nSystem.out.println(\"ERROR:\" + e);\ne.printStackTrace();\n}\nf.setFocusTraversalKeysEnabled(false);\n\/*\nif not connecting to localhost:\n- draw background to bounds (scaled)\n- draw logo to {{2% from left, 15% from top}{20% view width, 7% view height}}, no clipping, alpha = 0.85, adjust size to keep aspect ratio\n- load Arial 32 bold\n- draw the following text, double spaced using Arial 32 bold, white with black shadow (offset by (+2,+2))\n\"SageTV Placeshifter is connecting to\"\n\"the server: \"+myConn.getServerName()\n\"Please Wait...\"\ntext is centered in the view on the middle line, use font metrics to determine proper location\ng.setFont(pleaseWaitFont);\ng.setColor(java.awt.Color.black);\ny += 2;\ng.drawString(str1, 2 + (getWidth()\/2) - (fm.stringWidth(str1)\/2), y + fm.getAscent());\ny += fm.getHeight();\ng.drawString(str2, 2 + (getWidth()\/2) - (fm.stringWidth(str2)\/2), y + fm.getAscent());\ny += 2*fm.getHeight();\ng.drawString(str3, 2 + (getWidth()\/2) - (fm.stringWidth(str3)\/2), y + fm.getAscent());\ng.setColor(java.awt.Color.white);\ny = (getHeight() \/ 2) - fh\/2;\ng.drawString(str1, (getWidth()\/2) - (fm.stringWidth(str1)\/2), y + fm.getAscent());\ny += fm.getHeight();\ng.drawString(str2, (getWidth()\/2) - (fm.stringWidth(str2)\/2), y + fm.getAscent());\ny += 2*fm.getHeight();\ng.drawString(str3, (getWidth()\/2) - (fm.stringWidth(str3)\/2), y + fm.getAscent());\n*\/\njava.awt.Dimension panelSize = f.getContentPane().getSize();\nc = new QuartzRendererView();\nc.setSize(panelSize);\nc.setFocusTraversalKeysEnabled(false);\nf.getContentPane().add(c);\ntry\n{\njava.awt.Image frameIcon = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/tvicon.gif\"));\nensureImageIsLoaded(frameIcon);\nf.setIconImage(frameIcon);\n\npublic void windowClosing(java.awt.event.WindowEvent evt)\n{\nif (!f.isFullScreen() || System.getProperty(\"os.name\").toLowerCase().indexOf(\"windows\") != -1)\n{\nMiniClient.myProperties.setProperty(\"main_window_width\", Integer.toString(f.getWidth()));\nMiniClient.myProperties.setProperty(\"main_window_height\", Integer.toString(f.getHeight()));\nMiniClient.myProperties.setProperty(\"main_window_x\", Integer.toString(f.getX()));\nMiniClient.myProperties.setProperty(\"main_window_y\", Integer.toString(f.getY()));\n}\nmyConn.close();\n\/* try\n{\nif (myConn.getMediaCmd().getPlaya() != null)\n{\nmyConn.getMediaCmd().getPlaya().stop();\nmyConn.getMediaCmd().getPlaya().free();\n}\n}catch (Exception e){}\nSystem.exit(0);*\/\nclose();\n\/\/ f.dispose();\n}\n});\nc.addComponentListener(new java.awt.event.ComponentAdapter()\n{\npublic void componentResized(java.awt.event.ComponentEvent evt)\n{\nmyConn.postResizeEvent(new java.awt.Dimension(c.getWidth(), c.getHeight()));\n}\n\n\/* try\n{\nif (myConn.getMediaCmd().getPlaya() != null)\n{\nmyConn.getMediaCmd().getPlaya().stop();\nmyConn.getMediaCmd().getPlaya().free();\n}\n}catch (Exception e){}\nSystem.exit(0);*\/\nclose();\n\/\/ f.dispose();\n}\n});\nc.addComponentListener(new java.awt.event.ComponentAdapter()\n{\npublic void componentResized(java.awt.event.ComponentEvent evt)\n{\nmyConn.postResizeEvent(new java.awt.Dimension(c.getWidth(), c.getHeight()));\n}\n});\nf.addKeyListener(this);\n\n});\nc.addComponentListener(new java.awt.event.ComponentAdapter()\n{\npublic void componentResized(java.awt.event.ComponentEvent evt)\n{\nmyConn.postResizeEvent(new java.awt.Dimension(c.getWidth(), c.getHeight()));\n}\n});\nf.addKeyListener(this);\nc.addKeyListener(this);\n\/\/f.addMouseListener(this);\nf.addMouseWheelListener(this);\nc.addMouseListener(this);\nif (ENABLE_MOUSE_MOTION_EVENTS)\n{\n\/\/f.addMouseMotionListener(this);\nc.addMouseMotionListener(this);\n}\nint frameX = 100;\nint frameY = 100;\nint frameW = 720;\n\nmyConn.postResizeEvent(new java.awt.Dimension(c.getWidth(), c.getHeight()));\n}\n});\nf.addKeyListener(this);\nc.addKeyListener(this);\n\/\/f.addMouseListener(this);\nf.addMouseWheelListener(this);\nc.addMouseListener(this);\nif (ENABLE_MOUSE_MOTION_EVENTS)\n{\n\/\/f.addMouseMotionListener(this);\nc.addMouseMotionListener(this);\n}\nint frameX = 100;\nint frameY = 100;\nint frameW = 720;\nint frameH = 480;\ntry\n{\nframeW = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_width\", \"720\"));\nframeH = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_height\", \"480\"));\n\nnewPos.x = 150;\nnewPos.y = 150;\n}\nf.setVisible(true);\nf.setSize(1,1);\nf.setSize(Math.max(frameW, 320), Math.max(frameH, 240));\nf.setLocation(newPos);\nif (MiniClient.fsStartup)\nf.setFullScreen(true);\nMiniClient.hideSplash();\n\/\/ f.setVisible(true);\nreturn 1;\ncase GFXCMD_DEINIT:\n\/\/ System.out.println(\"DEINIT\");\nclose();\nbreak;\ncase GFXCMD_DRAWRECT:\nif(len==36)\n{\nfloat x, y, width, height;\nint thickness, argbTL, argbTR, argbBR, argbBL;\n\nf.setVisible(true);\nf.setSize(1,1);\nf.setSize(Math.max(frameW, 320), Math.max(frameH, 240));\nf.setLocation(newPos);\nif (MiniClient.fsStartup)\nf.setFullScreen(true);\nMiniClient.hideSplash();\n\/\/ f.setVisible(true);\nreturn 1;\ncase GFXCMD_DEINIT:\n\/\/ System.out.println(\"DEINIT\");\nclose();\nbreak;\ncase GFXCMD_DRAWRECT:\nif(len==36)\n{\nfloat x, y, width, height;\nint thickness, argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\n\nint thickness, argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nthickness=readInt(16, cmddata);\nargbTL=readInt(20, cmddata);\nargbTR=readInt(24, cmddata);\nargbBR=readInt(28, cmddata);\nargbBL=readInt(32, cmddata);\n\/\/ System.out.println(\"DRAWRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") thickness=\"+thickness+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\/\/ FIXME: no gradients on framed rects yet...\ndrawRect0(new java.awt.geom.Rectangle2D.Float(x, y, width, height), null,\n0,\nnew java.awt.Color(argbTL, true), thickness,\nnull, 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWRECT : \" + len);\n\nnull, 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWRECT : \" + len);\n}\nbreak;\ncase GFXCMD_FILLRECT:\n\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL\nif(len==32)\n{\nfloat x, y, width, height;\nint argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nargbTL=readInt(16, cmddata);\nargbTR=readInt(20, cmddata);\n\nfloat x, y, width, height;\nint argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nargbTL=readInt(16, cmddata);\nargbTR=readInt(20, cmddata);\nargbBR=readInt(24, cmddata);\nargbBL=readInt(28, cmddata);\n\/\/ System.out.println(\"FILLRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\nif(gp != null) {\ndrawRect0(bounds, null,\n0,\nnull, 0,\ngp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\ngp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\/\/(float)((argbTL>>24)&0xff)\/255.0f);\n1.0f); \/\/ alpha already supplied\n\nargbBL=readInt(28, cmddata);\n\/\/ System.out.println(\"FILLRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\nif(gp != null) {\ndrawRect0(bounds, null,\n0,\nnull, 0,\ngp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\ngp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\/\/(float)((argbTL>>24)&0xff)\/255.0f);\n1.0f); \/\/ alpha already supplied\n} else {\ndrawRect0(bounds, null,\n0,\nnull, 0,\nnew java.awt.Color(argbTL, true), 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\n}\n\n\/\/ System.out.println(\"FILLRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\nif(gp != null) {\ndrawRect0(bounds, null,\n0,\nnull, 0,\ngp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\ngp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\/\/(float)((argbTL>>24)&0xff)\/255.0f);\n1.0f); \/\/ alpha already supplied\n} else {\ndrawRect0(bounds, null,\n0,\nnull, 0,\nnew java.awt.Color(argbTL, true), 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\n}\nelse\n\nnull, 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWRECT : \" + len);\n}\nbreak;\ncase GFXCMD_FILLRECT:\n\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL\nif(len==32)\n{\nfloat x, y, width, height;\nint argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nargbTL=readInt(16, cmddata);\nargbTR=readInt(20, cmddata);\n\nint x, y, width, height,\nargbTL, argbTR, argbBR, argbBL;\nx=readInt(0, cmddata);\ny=readInt(4, cmddata);\nwidth=readInt(8, cmddata);\nheight=readInt(12, cmddata);\nargbTL=readInt(16, cmddata);\nargbTR=readInt(20, cmddata);\nargbBR=readInt(24, cmddata);\nargbBL=readInt(28, cmddata);\n\/\/ System.out.println(\"CLEARRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.geom.Rectangle2D.Float destRect = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\nclearRect0(destRect);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_CLEARRECT : \" + len);\n}\nbreak;\ncase GFXCMD_DRAWOVAL:\n\/\/ x, y, width, height, thickness, argbTL, argbTR, argbBR, argbBL,\n\n\/\/ System.out.println(\"CLEARRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.geom.Rectangle2D.Float destRect = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\nclearRect0(destRect);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_CLEARRECT : \" + len);\n}\nbreak;\ncase GFXCMD_DRAWOVAL:\n\/\/ x, y, width, height, thickness, argbTL, argbTR, argbBR, argbBL,\n\/\/ clipX, clipY, clipW, clipH\nif(len==52)\n{\nfloat x, y, width, height, clipX, clipY, clipW, clipH;\nint thickness, argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nthickness=readInt(16, cmddata);\nargbTL=readInt(20, cmddata);\n\nheight=(float)readInt(12, cmddata);\nthickness=readInt(16, cmddata);\nargbTL=readInt(20, cmddata);\nargbTR=readInt(24, cmddata);\nargbBR=readInt(28, cmddata);\nargbBL=readInt(32, cmddata);\nclipX=(float)readInt(36, cmddata);\nclipY=(float)readInt(40, cmddata);\nclipW=(float)readInt(44, cmddata);\nclipH=(float)readInt(48, cmddata);\n\/\/ System.out.println(\"DRAWOVAL: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") thickness=\"+thickness+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\/\/ FIXME: no gradient for framed ovals\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\njava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\ndrawOval0(bounds, clipRect,\nnew java.awt.Color(argbTL, true), thickness,\nnull, 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\nelse\n{\n\nnull, 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWOVAL : \" + len);\n}\nbreak;\ncase GFXCMD_FILLOVAL:\n\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL,\n\/\/ clipX, clipY, clipW, clipH\nif(len==48)\n{\nfloat x, y, width, height,\nclipX, clipY, clipW, clipH;\nint argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nargbTL=readInt(16, cmddata);\n\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nargbTL=readInt(16, cmddata);\nargbTR=readInt(20, cmddata);\nargbBR=readInt(24, cmddata);\nargbBL=readInt(28, cmddata);\nclipX=(float)readInt(32, cmddata);\nclipY=(float)readInt(36, cmddata);\nclipW=(float)readInt(40, cmddata);\nclipH=(float)readInt(44, cmddata);\n\/\/ System.out.println(\"FILLOVAL: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\njava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\nif(gp != null) {\ndrawOval0(bounds, clipRect,\nnull, 0,\ngp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\ngp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n1.0f);\n} else {\n\nnull, 0.0f, 0.0f,\n1.0f);\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_FILLOVAL : \" + len);\n}\nbreak;\ncase GFXCMD_DRAWROUNDRECT:\n\/\/ x, y, width, height, thickness, arcRadius, argbTL, argbTR, argbBR, argbBL,\n\/\/ clipX, clipY, clipW, clipH\nif(len==56)\n{\nfloat x, y, width, height,\nclipX, clipY, clipW, clipH;\nint thickness, arcRadius,\nargbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\n\nthickness=readInt(16, cmddata);\narcRadius=readInt(20, cmddata);\nargbTL=readInt(24, cmddata);\nargbTR=readInt(28, cmddata);\nargbBR=readInt(32, cmddata);\nargbBL=readInt(36, cmddata);\nclipX=(float)readInt(40, cmddata);\nclipY=(float)readInt(44, cmddata);\nclipW=(float)readInt(48, cmddata);\nclipH=(float)readInt(52, cmddata);\n\/\/ System.out.println(\"DRAWROUNDRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") thickness=\"+thickness+\" arcRadius=\"+arcRadius+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\/\/ FIXME: no gradients on stroked shapes\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\njava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\ndrawRect0(bounds, clipRect,\narcRadius,\nnew java.awt.Color(argbTL, true), thickness,\nnull, 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\nelse\n\nnull, 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWROUNDRECT : \" + len);\n}\nbreak;\ncase GFXCMD_FILLROUNDRECT:\n\/\/ x, y, width, height, arcRadius, argbTL, argbTR, argbBR, argbBL,\n\/\/ clipX, clipY, clipW, clipH\nif(len==52)\n{\nfloat x, y, width, height,\nclipX, clipY, clipW, clipH;\nint arcRadius, argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\narcRadius=readInt(16, cmddata);\n\nheight=(float)readInt(12, cmddata);\narcRadius=readInt(16, cmddata);\nargbTL=readInt(20, cmddata);\nargbTR=readInt(24, cmddata);\nargbBR=readInt(28, cmddata);\nargbBL=readInt(32, cmddata);\nclipX=(float)readInt(36, cmddata);\nclipY=(float)readInt(40, cmddata);\nclipW=(float)readInt(44, cmddata);\nclipH=(float)readInt(48, cmddata);\n\/\/ System.out.println(\"FILLROUNDRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") arcRadius=\"+arcRadius+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\njava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\nif(gp != null) {\ndrawRect0(bounds, clipRect,\narcRadius,\nnull, 0,\ngp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\ngp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\/\/(float)((argbTL>>24)&0xff)\/255.0f);\n\nargbBL=readInt(28, cmddata);\n\/\/ System.out.println(\"FILLRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\nif(gp != null) {\ndrawRect0(bounds, null,\n0,\nnull, 0,\ngp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\ngp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\/\/(float)((argbTL>>24)&0xff)\/255.0f);\n1.0f); \/\/ alpha already supplied\n} else {\ndrawRect0(bounds, null,\n0,\nnull, 0,\nnew java.awt.Color(argbTL, true), 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\n}\n\nnull, 0.0f, 0.0f,\n1.0f);\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_FILLROUNDRECT : \" + len);\n}\nbreak;\ncase GFXCMD_DRAWTEXT:\n\/\/ x, y, len, text, handle, argb, clipX, clipY, clipW, clipH\nif(len>=36 && len>=(36+readInt(8, cmddata)*2))\n{\nfloat x, y, clipX, clipY, clipW, clipH;\nint textlen, fontHandle, argb;\nStringBuffer text = new StringBuffer();\nint i;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\ntextlen=readInt(8, cmddata);\nfor(i=0;i<textlen;i++)\n\nfor(i=0;i<textlen;i++)\n{\ntext.append((char)readShort(12+i*2, cmddata));\n}\nfontHandle=readInt(textlen*2+12, cmddata);\nargb=readInt(textlen*2+16, cmddata);\nclipX=(float)readInt(textlen*2+20, cmddata);\nclipY=(float)readInt(textlen*2+24, cmddata);\nclipW=(float)readInt(textlen*2+28, cmddata);\nclipH=(float)readInt(textlen*2+32, cmddata);\n\/\/ TODO: check if this is needed\n\/\/ if (System.getProperty(\"java.version\").startsWith(\"1.4\"))\n\/\/ clipW = clipW * 5 \/ 4;\n\/\/ System.out.println(\"DRAWTEXT: dest=(\"+x+\",\"+y+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") fontHandle=\"+fontHandle+\" argb=\"+Integer.toHexString(argb)+\" text=\"+text.toString());\nMcFont fontPtr = (McFont)fontMap.get(new Integer(fontHandle));\nif(fontPtr != null) {\n\/\/ use AWT string bounds or we'll clip on occasion\nString theString = text.toString();\n\/\/ java.awt.Dimension textSize = fontPtr.getStringSize(theString);\nfloat[] positions = fontPtr.getGlyphPositions(theString);\n\/\/ System.out.println(\"drawText: \\\"\"+theString+\"\\\" loc=(\"+x+\",\"+y+\") num positions=\"+positions.length);\ndrawTextWithPositions0(theString, fontPtr.nativeFont,\nx, y, positions, new java.awt.geom.Rectangle2D.Float(clipX,clipY,clipW,clipH),\nnew java.awt.Color(argb, true));\n\nclipX=(float)readInt(textlen*2+20, cmddata);\nclipY=(float)readInt(textlen*2+24, cmddata);\nclipW=(float)readInt(textlen*2+28, cmddata);\nclipH=(float)readInt(textlen*2+32, cmddata);\n\/\/ TODO: check if this is needed\n\/\/ if (System.getProperty(\"java.version\").startsWith(\"1.4\"))\n\/\/ clipW = clipW * 5 \/ 4;\n\/\/ System.out.println(\"DRAWTEXT: dest=(\"+x+\",\"+y+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") fontHandle=\"+fontHandle+\" argb=\"+Integer.toHexString(argb)+\" text=\"+text.toString());\nMcFont fontPtr = (McFont)fontMap.get(new Integer(fontHandle));\nif(fontPtr != null) {\n\/\/ use AWT string bounds or we'll clip on occasion\nString theString = text.toString();\n\/\/ java.awt.Dimension textSize = fontPtr.getStringSize(theString);\nfloat[] positions = fontPtr.getGlyphPositions(theString);\n\/\/ System.out.println(\"drawText: \\\"\"+theString+\"\\\" loc=(\"+x+\",\"+y+\") num positions=\"+positions.length);\ndrawTextWithPositions0(theString, fontPtr.nativeFont,\nx, y, positions, new java.awt.geom.Rectangle2D.Float(clipX,clipY,clipW,clipH),\nnew java.awt.Color(argb, true));\n}\n}\nelse\n\nclipW=(float)readInt(textlen*2+28, cmddata);\nclipH=(float)readInt(textlen*2+32, cmddata);\n\/\/ TODO: check if this is needed\n\/\/ if (System.getProperty(\"java.version\").startsWith(\"1.4\"))\n\/\/ clipW = clipW * 5 \/ 4;\n\/\/ System.out.println(\"DRAWTEXT: dest=(\"+x+\",\"+y+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") fontHandle=\"+fontHandle+\" argb=\"+Integer.toHexString(argb)+\" text=\"+text.toString());\nMcFont fontPtr = (McFont)fontMap.get(new Integer(fontHandle));\nif(fontPtr != null) {\n\/\/ use AWT string bounds or we'll clip on occasion\nString theString = text.toString();\n\/\/ java.awt.Dimension textSize = fontPtr.getStringSize(theString);\nfloat[] positions = fontPtr.getGlyphPositions(theString);\n\/\/ System.out.println(\"drawText: \\\"\"+theString+\"\\\" loc=(\"+x+\",\"+y+\") num positions=\"+positions.length);\ndrawTextWithPositions0(theString, fontPtr.nativeFont,\nx, y, positions, new java.awt.geom.Rectangle2D.Float(clipX,clipY,clipW,clipH),\nnew java.awt.Color(argb, true));\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXT : \" + len);\n\n\/\/ TODO: check if this is needed\n\/\/ if (System.getProperty(\"java.version\").startsWith(\"1.4\"))\n\/\/ clipW = clipW * 5 \/ 4;\n\/\/ System.out.println(\"DRAWTEXT: dest=(\"+x+\",\"+y+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") fontHandle=\"+fontHandle+\" argb=\"+Integer.toHexString(argb)+\" text=\"+text.toString());\nMcFont fontPtr = (McFont)fontMap.get(new Integer(fontHandle));\nif(fontPtr != null) {\n\/\/ use AWT string bounds or we'll clip on occasion\nString theString = text.toString();\n\/\/ java.awt.Dimension textSize = fontPtr.getStringSize(theString);\nfloat[] positions = fontPtr.getGlyphPositions(theString);\n\/\/ System.out.println(\"drawText: \\\"\"+theString+\"\\\" loc=(\"+x+\",\"+y+\") num positions=\"+positions.length);\ndrawTextWithPositions0(theString, fontPtr.nativeFont,\nx, y, positions, new java.awt.geom.Rectangle2D.Float(clipX,clipY,clipW,clipH),\nnew java.awt.Color(argb, true));\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXT : \" + len);\n}\nbreak;\n\nx, y, positions, new java.awt.geom.Rectangle2D.Float(clipX,clipY,clipW,clipH),\nnew java.awt.Color(argb, true));\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXT : \" + len);\n}\nbreak;\ncase GFXCMD_DRAWTEXTURED:\n\/\/ x, y, width, height, handle, srcx, srcy, srcwidth, srcheight, blend\nif(len==40)\n{\nfloat x, y, width, height,\nsrcx, srcy, srcwidth, srcheight;\nint handle, blend; \/\/ blend is a color, use alpha component for blending\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nhandle=readInt(16, cmddata); \/\/ either an image handle or layer handle (if not in imageMap)\n\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXT : \" + len);\n}\nbreak;\ncase GFXCMD_DRAWTEXTURED:\n\/\/ x, y, width, height, handle, srcx, srcy, srcwidth, srcheight, blend\nif(len==40)\n{\nfloat x, y, width, height,\nsrcx, srcy, srcwidth, srcheight;\nint handle, blend; \/\/ blend is a color, use alpha component for blending\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nhandle=readInt(16, cmddata); \/\/ either an image handle or layer handle (if not in imageMap)\nsrcx=(float)readInt(20, cmddata);\nsrcy=(float)readInt(24, cmddata);\nsrcwidth=(float)readInt(28, cmddata);\nsrcheight=(float)readInt(32, cmddata);\nblend=readInt(36, cmddata);\n\n\/\/ x, y, width, height, handle, srcx, srcy, srcwidth, srcheight, blend\nif(len==40)\n{\nfloat x, y, width, height,\nsrcx, srcy, srcwidth, srcheight;\nint handle, blend; \/\/ blend is a color, use alpha component for blending\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nhandle=readInt(16, cmddata); \/\/ either an image handle or layer handle (if not in imageMap)\nsrcx=(float)readInt(20, cmddata);\nsrcy=(float)readInt(24, cmddata);\nsrcwidth=(float)readInt(28, cmddata);\nsrcheight=(float)readInt(32, cmddata);\nblend=readInt(36, cmddata);\n\/*\nif height < 0\ndisable blending\nif width < 0 (font mode, composite with background and blend with given color)\nblend with full RGBA color\n\nensureImageIsLoaded(bgImage);\nlogoImage = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/SageLogo256.png\"));\nensureImageIsLoaded(logoImage);\n}\ncatch (Exception e)\n{\nSystem.out.println(\"ERROR:\" + e);\ne.printStackTrace();\n}\nf.setFocusTraversalKeysEnabled(false);\n\/*\nif not connecting to localhost:\n- draw background to bounds (scaled)\n- draw logo to {{2% from left, 15% from top}{20% view width, 7% view height}}, no clipping, alpha = 0.85, adjust size to keep aspect ratio\n- load Arial 32 bold\n- draw the following text, double spaced using Arial 32 bold, white with black shadow (offset by (+2,+2))\n\"SageTV Placeshifter is connecting to\"\n\"the server: \"+myConn.getServerName()\n\"Please Wait...\"\ntext is centered in the view on the middle line, use font metrics to determine proper location\ng.setFont(pleaseWaitFont);\ng.setColor(java.awt.Color.black);\ny += 2;\ng.drawString(str1, 2 + (getWidth()\/2) - (fm.stringWidth(str1)\/2), y + fm.getAscent());\ny += fm.getHeight();\ng.drawString(str2, 2 + (getWidth()\/2) - (fm.stringWidth(str2)\/2), y + fm.getAscent());\ny += 2*fm.getHeight();\ng.drawString(str3, 2 + (getWidth()\/2) - (fm.stringWidth(str3)\/2), y + fm.getAscent());\n\nsrcheight=(float)readInt(32, cmddata);\nblend=readInt(36, cmddata);\n\/*\nif height < 0\ndisable blending\nif width < 0 (font mode, composite with background and blend with given color)\nblend with full RGBA color\nelse\nblend with alpha only\n*\/\n\/\/ System.out.println(\"DRAWTEXTURED: handle=\"+handle+\" dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") src=(\"+srcx+\",\"+srcy+\" \"+srcwidth+\"x\"+srcheight+\") blend=\"+Integer.toHexString(blend));\nboolean doBlend = true;\nif(height < 0) {\ndoBlend = false;\nheight *= -1;\n}\nif(width < 0) {\nwidth *= -1;\n} else {\nif(doBlend)\nblend |= 0x00ffffff; \/\/ only use alpha\n\n\/\/ System.out.println(\"DRAWTEXTURED: handle=\"+handle+\" dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") src=(\"+srcx+\",\"+srcy+\" \"+srcwidth+\"x\"+srcheight+\") blend=\"+Integer.toHexString(blend));\nboolean doBlend = true;\nif(height < 0) {\ndoBlend = false;\nheight *= -1;\n}\nif(width < 0) {\nwidth *= -1;\n} else {\nif(doBlend)\nblend |= 0x00ffffff; \/\/ only use alpha\n}\nLong imagePtr = (Long)imageMap.get(new Integer(handle));\njava.awt.geom.Rectangle2D.Float destRect = new java.awt.geom.Rectangle2D.Float(x,y,width,height);\njava.awt.geom.Rectangle2D.Float srcRect = new java.awt.geom.Rectangle2D.Float(srcx,srcy,srcwidth,srcheight);\nif(imagePtr != null) {\nmyConn.registerImageAccess(handle);\n\/\/ System.out.println(\" (drawing image) imagePtr=\"+imagePtr);\ndrawImage1(imagePtr.longValue(),\ndestRect, srcRect,\n(doBlend) ? new java.awt.Color(blend, true) : null);\n\nwidth *= -1;\n} else {\nif(doBlend)\nblend |= 0x00ffffff; \/\/ only use alpha\n}\nLong imagePtr = (Long)imageMap.get(new Integer(handle));\njava.awt.geom.Rectangle2D.Float destRect = new java.awt.geom.Rectangle2D.Float(x,y,width,height);\njava.awt.geom.Rectangle2D.Float srcRect = new java.awt.geom.Rectangle2D.Float(srcx,srcy,srcwidth,srcheight);\nif(imagePtr != null) {\nmyConn.registerImageAccess(handle);\n\/\/ System.out.println(\" (drawing image) imagePtr=\"+imagePtr);\ndrawImage1(imagePtr.longValue(),\ndestRect, srcRect,\n(doBlend) ? new java.awt.Color(blend, true) : null);\n} else {\nimagePtr = (Long)layerMap.get(new Integer(handle));\nif(imagePtr != null) {\nmyConn.registerImageAccess(handle);\n\/\/ System.out.println(\" (compositing surface) layerPtr=\"+Long.toHexString(imagePtr.longValue())+\" currentLayer=\"+currentLayer);\nfloat alpha = (doBlend ? (float)(((blend >> 24)&0xff))\/255.0f : 1.0f);\ncomposite0(imagePtr.longValue(), currentLayer, srcRect, destRect, alpha, doBlend);\n\nif(imagePtr != null) {\nmyConn.registerImageAccess(handle);\n\/\/ System.out.println(\" (drawing image) imagePtr=\"+imagePtr);\ndrawImage1(imagePtr.longValue(),\ndestRect, srcRect,\n(doBlend) ? new java.awt.Color(blend, true) : null);\n} else {\nimagePtr = (Long)layerMap.get(new Integer(handle));\nif(imagePtr != null) {\nmyConn.registerImageAccess(handle);\n\/\/ System.out.println(\" (compositing surface) layerPtr=\"+Long.toHexString(imagePtr.longValue())+\" currentLayer=\"+currentLayer);\nfloat alpha = (doBlend ? (float)(((blend >> 24)&0xff))\/255.0f : 1.0f);\ncomposite0(imagePtr.longValue(), currentLayer, srcRect, destRect, alpha, doBlend);\n}\nelse\n{\nSystem.out.println(\"ERROR invalid handle passed for texture rendering of: \" + handle);\nabortRenderCycle = true;\n}\n}\n}\n\nabortRenderCycle = true;\n}\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXTURED : \" + len);\n}\nbreak;\ncase GFXCMD_DRAWLINE:\n\/\/ x1, y1, x2, y2, argb1, argb2\nif(len==24)\n{\nfloat x1, y1, x2, y2;\nint argb1, argb2;\nx1=readInt(0, cmddata);\ny1=readInt(4, cmddata);\nx2=readInt(8, cmddata);\ny2=readInt(12, cmddata);\nargb1=readInt(16, cmddata);\nargb2=readInt(20, cmddata);\n\nif(len==24)\n{\nfloat x1, y1, x2, y2;\nint argb1, argb2;\nx1=readInt(0, cmddata);\ny1=readInt(4, cmddata);\nx2=readInt(8, cmddata);\ny2=readInt(12, cmddata);\nargb1=readInt(16, cmddata);\nargb2=readInt(20, cmddata);\n\/\/ System.out.println(\"DRAWLINE: start=(\"+x1+\",\"+y1+\") end=(\"+x2+\",\"+y2+\") argb1=\"+Integer.toHexString(argb1)+\" argb2=\"+Integer.toHexString(argb2));\ndrawLine0(x1, y1, x2, y2, 1, new java.awt.Color(argb1, true));\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWLINE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\nif(len>=8)\n\nargb2=readInt(20, cmddata);\n\/\/ System.out.println(\"DRAWLINE: start=(\"+x1+\",\"+y1+\") end=(\"+x2+\",\"+y2+\") argb1=\"+Integer.toHexString(argb1)+\" argb2=\"+Integer.toHexString(argb2));\ndrawLine0(x1, y1, x2, y2, 1, new java.awt.Color(argb1, true));\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWLINE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\nint imghandle = 0;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ System.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\nimghandle = 0;\n\n}\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\nint imghandle = 0;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ System.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\nimghandle = 0;\n}\nelse\n{\n\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\n\nint imghandle = 0;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ System.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\nimghandle = 0;\n}\nelse\n{\n\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n\n\/\/ System.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\nimghandle = 0;\n}\nelse\n{\n\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n}\n\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\nimghandle = 0;\n}\nelse\n{\n\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n}\nbreak;\n\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\nint width, height;\nint imghandle = readInt(0, cmddata);\nwidth=readInt(4, cmddata);\nheight=readInt(8, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\/\/ Keep freeing the oldest image until we have enough memory to do this\nint oldestImage = myConn.getOldestImage();\n\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\nint width, height;\nint imghandle = readInt(0, cmddata);\nwidth=readInt(4, cmddata);\nheight=readInt(8, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\/\/ Keep freeing the oldest image until we have enough memory to do this\nint oldestImage = myConn.getOldestImage();\nif (oldestImage != 0)\n{\nSystem.out.println(\"Freeing image to make room in cache\");\nunloadImage(oldestImage);\nmyConn.postImageUnload(oldestImage);\n}\nelse\n{\nSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\n\n\/\/ System.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\nimghandle = 0;\n}\nelse\n{\n\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n}\n\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\nimghandle = 0;\n}\nelse\n{\n\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n}\nbreak;\n\nargb2=readInt(20, cmddata);\n\/\/ System.out.println(\"DRAWLINE: start=(\"+x1+\",\"+y1+\") end=(\"+x2+\",\"+y2+\") argb1=\"+Integer.toHexString(argb1)+\" argb2=\"+Integer.toHexString(argb2));\ndrawLine0(x1, y1, x2, y2, 1, new java.awt.Color(argb1, true));\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWLINE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\nint imghandle = 0;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ System.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\nimghandle = 0;\n\n}\nbreak;\ncase GFXCMD_CREATESURFACE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\nint handle = handleCount++;;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ width\/height is managed here\nlong layerPtr = createLayer0(c.getSize());\nlayerMap.put(new Integer(handle), new Long(layerPtr));\n\/\/ System.out.println(\"CREATESURFACE: (\"+width+\",\"+height+\") handle=\"+handle+\" layerPtr=\"+layerPtr);\nhasret[0]=1;\nreturn handle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_CREATESURFACE : \" + len);\n}\n\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\nint handle = handleCount++;;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ width\/height is managed here\nlong layerPtr = createLayer0(c.getSize());\nlayerMap.put(new Integer(handle), new Long(layerPtr));\n\/\/ System.out.println(\"CREATESURFACE: (\"+width+\",\"+height+\") handle=\"+handle+\" layerPtr=\"+layerPtr);\nhasret[0]=1;\nreturn handle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_CREATESURFACE : \" + len);\n}\nbreak;\ncase GFXCMD_PREPIMAGE:\n\/\/ width, height\n\nargb2=readInt(20, cmddata);\n\/\/ System.out.println(\"DRAWLINE: start=(\"+x1+\",\"+y1+\") end=(\"+x2+\",\"+y2+\") argb1=\"+Integer.toHexString(argb1)+\" argb2=\"+Integer.toHexString(argb2));\ndrawLine0(x1, y1, x2, y2, 1, new java.awt.Color(argb1, true));\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWLINE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\nint imghandle = 0;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ System.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\nimghandle = 0;\n\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_CREATESURFACE : \" + len);\n}\nbreak;\ncase GFXCMD_PREPIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\n\/\/int imghandle = handleCount++;;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\nint imghandle = 1;\n\/\/ System.out.println(\"PREPIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\nimghandle = 0;\nelse if (len >= 12)\n{\n\/\/ We've got enough room for it and there's a cache ID, check if we've got it cached locally\nint strlen = readInt(8, cmddata);\n\nbreak;\ncase GFXCMD_PREPIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\n\/\/int imghandle = handleCount++;;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\nint imghandle = 1;\n\/\/ System.out.println(\"PREPIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\nimghandle = 0;\nelse if (len >= 12)\n{\n\/\/ We've got enough room for it and there's a cache ID, check if we've got it cached locally\nint strlen = readInt(8, cmddata);\nif (strlen > 1)\n{\nString rezName = new String(cmddata, 16, strlen - 1);\n\/\/ System.out.println(\" rezName=\"+rezName);\n\nint width, height;\n\/\/int imghandle = handleCount++;;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\nint imghandle = 1;\n\/\/ System.out.println(\"PREPIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\nimghandle = 0;\nelse if (len >= 12)\n{\n\/\/ We've got enough room for it and there's a cache ID, check if we've got it cached locally\nint strlen = readInt(8, cmddata);\nif (strlen > 1)\n{\nString rezName = new String(cmddata, 16, strlen - 1);\n\/\/ System.out.println(\" rezName=\"+rezName);\nlastImageResourceID = rezName;\n\/\/ We use this hashcode to match it up on the loadCompressedImage call so we know we're caching the right thing\nlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\njava.io.File cachedFile = myConn.getCachedImageFile(rezName);\nif (cachedFile != null)\n\n\/\/ System.out.println(\"PREPIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\nimghandle = 0;\nelse if (len >= 12)\n{\n\/\/ We've got enough room for it and there's a cache ID, check if we've got it cached locally\nint strlen = readInt(8, cmddata);\nif (strlen > 1)\n{\nString rezName = new String(cmddata, 16, strlen - 1);\n\/\/ System.out.println(\" rezName=\"+rezName);\nlastImageResourceID = rezName;\n\/\/ We use this hashcode to match it up on the loadCompressedImage call so we know we're caching the right thing\nlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\njava.io.File cachedFile = myConn.getCachedImageFile(rezName);\nif (cachedFile != null)\n{\n\/\/ We've got it locally in our cache! Read it from there.\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n{\n\nimghandle = 0;\nelse if (len >= 12)\n{\n\/\/ We've got enough room for it and there's a cache ID, check if we've got it cached locally\nint strlen = readInt(8, cmddata);\nif (strlen > 1)\n{\nString rezName = new String(cmddata, 16, strlen - 1);\n\/\/ System.out.println(\" rezName=\"+rezName);\nlastImageResourceID = rezName;\n\/\/ We use this hashcode to match it up on the loadCompressedImage call so we know we're caching the right thing\nlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\njava.io.File cachedFile = myConn.getCachedImageFile(rezName);\nif (cachedFile != null)\n{\n\/\/ We've got it locally in our cache! Read it from there.\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n{\njava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\nif(imgSize != null)\n\nif (strlen > 1)\n{\nString rezName = new String(cmddata, 16, strlen - 1);\n\/\/ System.out.println(\" rezName=\"+rezName);\nlastImageResourceID = rezName;\n\/\/ We use this hashcode to match it up on the loadCompressedImage call so we know we're caching the right thing\nlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\njava.io.File cachedFile = myConn.getCachedImageFile(rezName);\nif (cachedFile != null)\n{\n\/\/ We've got it locally in our cache! Read it from there.\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n{\njava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\nif(imgSize != null)\n{\nif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\/\/ valid image in cache, use it\nimghandle = handleCount++;\n\n{\n\/\/ We've got it locally in our cache! Read it from there.\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n{\njava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\nif(imgSize != null)\n{\nif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\/\/ valid image in cache, use it\nimghandle = handleCount++;\n\/\/ System.out.println(\" loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\nimageMap.put(new Integer(imghandle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\nhasret[0] = 1;\nreturn -1 * imghandle;\n}\nelse\nfreeNativeImage0(imagePtr);\n}\n\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n{\njava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\nif(imgSize != null)\n{\nif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\/\/ valid image in cache, use it\nimghandle = handleCount++;\n\/\/ System.out.println(\" loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\nimageMap.put(new Integer(imghandle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\nhasret[0] = 1;\nreturn -1 * imghandle;\n}\nelse\nfreeNativeImage0(imagePtr);\n}\nelse\nfreeNativeImage0(imagePtr);\n\n}\nelse\nfreeNativeImage0(imagePtr);\n}\nelse\nfreeNativeImage0(imagePtr);\n}\n}\n}\n}\n\/\/imghandle=STBGFX.GFX_loadImage(width, height);\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_PREPIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_PREPIMAGETARGETED:\n\/\/ handle, width, height, [rezID]\n\n\/\/imghandle=STBGFX.GFX_loadImage(width, height);\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_PREPIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_PREPIMAGETARGETED:\n\/\/ handle, width, height, [rezID]\nif(len>=12)\n{\nint imghandle, width, height;\nimghandle = readInt(0, cmddata);\nwidth=readInt(4, cmddata);\nheight=readInt(8, cmddata);\nint strlen = readInt(12, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\/\/ Keep freeing the oldest image until we have enough memory to do this\n\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\nint width, height;\nint imghandle = readInt(0, cmddata);\nwidth=readInt(4, cmddata);\nheight=readInt(8, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\/\/ Keep freeing the oldest image until we have enough memory to do this\nint oldestImage = myConn.getOldestImage();\nif (oldestImage != 0)\n{\nSystem.out.println(\"Freeing image to make room in cache\");\nunloadImage(oldestImage);\nmyConn.postImageUnload(oldestImage);\n}\nelse\n{\nSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\n\nmyConn.postImageUnload(oldestImage);\n}\nelse\n{\nSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\nbreak;\n}\n}\nif (len >= 16)\n{\n\/\/ We will not have this cached locally...but setup our vars to track it\nString rezName = new String(cmddata, 20, strlen - 1);\nlastImageResourceID = rezName;\nlastImageResourceIDHandle = imghandle;\nSystem.out.println(\"Prepped targeted image with handle \" + imghandle + \" resource=\" + rezName);\n}\nmyConn.registerImageAccess(imghandle);\nhasret[0]=0;\n}\nelse\n{\n\nargb2=readInt(20, cmddata);\n\/\/ System.out.println(\"DRAWLINE: start=(\"+x1+\",\"+y1+\") end=(\"+x2+\",\"+y2+\") argb1=\"+Integer.toHexString(argb1)+\" argb2=\"+Integer.toHexString(argb2));\ndrawLine0(x1, y1, x2, y2, 1, new java.awt.Color(argb1, true));\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWLINE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\nint imghandle = 0;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ System.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\nimghandle = 0;\n\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\nint width, height;\nint imghandle = readInt(0, cmddata);\nwidth=readInt(4, cmddata);\nheight=readInt(8, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\/\/ Keep freeing the oldest image until we have enough memory to do this\nint oldestImage = myConn.getOldestImage();\nif (oldestImage != 0)\n{\nSystem.out.println(\"Freeing image to make room in cache\");\nunloadImage(oldestImage);\nmyConn.postImageUnload(oldestImage);\n}\nelse\n{\nSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\n\nif (strlen > 1)\n{\nString rezName = new String(cmddata, 16, strlen - 1);\n\/\/ System.out.println(\" rezName=\"+rezName);\nlastImageResourceID = rezName;\n\/\/ We use this hashcode to match it up on the loadCompressedImage call so we know we're caching the right thing\nlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\njava.io.File cachedFile = myConn.getCachedImageFile(rezName);\nif (cachedFile != null)\n{\n\/\/ We've got it locally in our cache! Read it from there.\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n{\njava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\nif(imgSize != null)\n{\nif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\/\/ valid image in cache, use it\nimghandle = handleCount++;\n\nif (strlen > 1)\n{\nString rezName = new String(cmddata, 16, strlen - 1);\n\/\/ System.out.println(\" rezName=\"+rezName);\nlastImageResourceID = rezName;\n\/\/ We use this hashcode to match it up on the loadCompressedImage call so we know we're caching the right thing\nlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\njava.io.File cachedFile = myConn.getCachedImageFile(rezName);\nif (cachedFile != null)\n{\n\/\/ We've got it locally in our cache! Read it from there.\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n{\njava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\nif(imgSize != null)\n{\nif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\/\/ valid image in cache, use it\nimghandle = handleCount++;\n\n{\n\/\/ We've got it locally in our cache! Read it from there.\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n{\njava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\nif(imgSize != null)\n{\nif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\/\/ valid image in cache, use it\nimghandle = handleCount++;\n\/\/ System.out.println(\" loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\nimageMap.put(new Integer(imghandle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\nhasret[0] = 1;\nreturn -1 * imghandle;\n}\nelse\nfreeNativeImage0(imagePtr);\n}\nelse\n\n{\n\/\/ valid image in cache, use it\n\/\/ System.out.println(\" loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\nimageMap.put(new Integer(imghandle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\n}\nelse\n{\nif (imgSize != null)\n{\n\/\/ It doesn't match the cache\nSystem.out.println(\"CACHE ID verification failed for rezName=\" + rezName + \" target=\" + width + \"x\" + height + \" actual=\" + imgSize.getWidth() + \"x\" + imgSize.getHeight());\n}\nelse\nSystem.out.println(\"CACHE Load failed for rezName=\" + rezName);\ncachedFile.delete();\nfreeNativeImage0(imagePtr);\n\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\nmyConn.postImageUnload(imghandle);\nmyConn.postOfflineCacheChange(false, rezName);\n}\n\n{\nif (imgSize != null)\n{\n\/\/ It doesn't match the cache\nSystem.out.println(\"CACHE ID verification failed for rezName=\" + rezName + \" target=\" + width + \"x\" + height + \" actual=\" + imgSize.getWidth() + \"x\" + imgSize.getHeight());\n}\nelse\nSystem.out.println(\"CACHE Load failed for rezName=\" + rezName);\ncachedFile.delete();\nfreeNativeImage0(imagePtr);\n\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\nmyConn.postImageUnload(imghandle);\nmyConn.postOfflineCacheChange(false, rezName);\n}\n}\nelse\n{\ncachedFile.delete();\n\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\nmyConn.postImageUnload(imghandle);\nmyConn.postOfflineCacheChange(false, rezName);\n\n{\nif (imgSize != null)\n{\n\/\/ It doesn't match the cache\nSystem.out.println(\"CACHE ID verification failed for rezName=\" + rezName + \" target=\" + width + \"x\" + height + \" actual=\" + imgSize.getWidth() + \"x\" + imgSize.getHeight());\n}\nelse\nSystem.out.println(\"CACHE Load failed for rezName=\" + rezName);\ncachedFile.delete();\nfreeNativeImage0(imagePtr);\n\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\nmyConn.postImageUnload(imghandle);\nmyConn.postOfflineCacheChange(false, rezName);\n}\n}\nelse\n{\ncachedFile.delete();\n\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\nmyConn.postImageUnload(imghandle);\nmyConn.postOfflineCacheChange(false, rezName);\n\n{\nif (imgSize != null)\n{\n\/\/ It doesn't match the cache\nSystem.out.println(\"CACHE ID verification failed for rezName=\" + rezName + \" target=\" + width + \"x\" + height + \" actual=\" + imgSize.getWidth() + \"x\" + imgSize.getHeight());\n}\nelse\nSystem.out.println(\"CACHE Load failed for rezName=\" + rezName);\ncachedFile.delete();\nfreeNativeImage0(imagePtr);\n\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\nmyConn.postImageUnload(imghandle);\nmyConn.postOfflineCacheChange(false, rezName);\n}\n}\nelse\n{\ncachedFile.delete();\n\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\nmyConn.postImageUnload(imghandle);\nmyConn.postOfflineCacheChange(false, rezName);\n\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\nint width, height;\nint imghandle = readInt(0, cmddata);\nwidth=readInt(4, cmddata);\nheight=readInt(8, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\/\/ Keep freeing the oldest image until we have enough memory to do this\nint oldestImage = myConn.getOldestImage();\n\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\nint width, height;\nint imghandle = readInt(0, cmddata);\nwidth=readInt(4, cmddata);\nheight=readInt(8, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\/\/ Keep freeing the oldest image until we have enough memory to do this\nint oldestImage = myConn.getOldestImage();\n\n{\nSystem.out.println(\"Invalid len for GFXCMD_UNLOADIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_SETTARGETSURFACE:\n\/\/ handle\nif(len==4)\n{\nint handle;\nhandle=readInt(0, cmddata);\n\/\/STBGFX.GFX_unloadImage(handle);\nLong layerPtr = (Long)layerMap.get(new Integer(handle));\n\/\/ System.out.println(\"SETTARGETSURFACE: handle=\"+handle+\" layerPtr=\"+ (layerPtr == null ? \"0\" : Long.toHexString(layerPtr.longValue())));\ncurrentLayer = (layerPtr != null) ? layerPtr.longValue() : 0;\njava.awt.Rectangle clipRect = new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight());\nsetLayer0(currentLayer, c.getSize(), clipRect);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_SETTARGETSURFACE : \" + len);\n}\n\n}\nbreak;\ncase GFXCMD_SETTARGETSURFACE:\n\/\/ handle\nif(len==4)\n{\nint handle;\nhandle=readInt(0, cmddata);\n\/\/STBGFX.GFX_unloadImage(handle);\nLong layerPtr = (Long)layerMap.get(new Integer(handle));\n\/\/ System.out.println(\"SETTARGETSURFACE: handle=\"+handle+\" layerPtr=\"+ (layerPtr == null ? \"0\" : Long.toHexString(layerPtr.longValue())));\ncurrentLayer = (layerPtr != null) ? layerPtr.longValue() : 0;\njava.awt.Rectangle clipRect = new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight());\nsetLayer0(currentLayer, c.getSize(), clipRect);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_SETTARGETSURFACE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADFONT:\n\ncurrentLayer = (layerPtr != null) ? layerPtr.longValue() : 0;\njava.awt.Rectangle clipRect = new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight());\nsetLayer0(currentLayer, c.getSize(), clipRect);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_SETTARGETSURFACE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADFONT:\n\/\/ namelen, name, style, size\nif(len>=12 && len>=(12+readInt(0, cmddata)))\n{\nint namelen, style, size;\nStringBuffer name = new StringBuffer();\nint i;\nint fonthandle = handleCount++;\nnamelen=readInt(0, cmddata);\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n\nbreak;\ncase GFXCMD_LOADFONT:\n\/\/ namelen, name, style, size\nif(len>=12 && len>=(12+readInt(0, cmddata)))\n{\nint namelen, style, size;\nStringBuffer name = new StringBuffer();\nint i;\nint fonthandle = handleCount++;\nnamelen=readInt(0, cmddata);\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nstyle=readInt(namelen+4, cmddata);\nsize=readInt(namelen+8, cmddata);\n\/\/ System.out.println(\"LOADFONT: handle=\"+fonthandle+\" name=\"+name.toString()+\" style=\"+Integer.toHexString(style)+\" size=\"+size);\nMcFont fontPtr = new McFont(name.toString(), style, size);\n\/\/ long fontPtr = loadFont0(name.toString(), style, size);\nif(fontPtr == null) {\n\/\/ FIXME: implement!\n\n\/\/ namelen, name, style, size\nif(len>=12 && len>=(12+readInt(0, cmddata)))\n{\nint namelen, style, size;\nStringBuffer name = new StringBuffer();\nint i;\nint fonthandle = handleCount++;\nnamelen=readInt(0, cmddata);\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nstyle=readInt(namelen+4, cmddata);\nsize=readInt(namelen+8, cmddata);\n\/\/ System.out.println(\"LOADFONT: handle=\"+fonthandle+\" name=\"+name.toString()+\" style=\"+Integer.toHexString(style)+\" size=\"+size);\nMcFont fontPtr = new McFont(name.toString(), style, size);\n\/\/ long fontPtr = loadFont0(name.toString(), style, size);\nif(fontPtr == null) {\n\/\/ FIXME: implement!\n\/\/ we don't have the font on this sytem (yet) see if it's cached and try to load it manually\n\/\/ String cacheName = name.toString() + \"-\" + style;\n\nStringBuffer name = new StringBuffer();\nint i;\nint fonthandle = handleCount++;\nnamelen=readInt(0, cmddata);\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nstyle=readInt(namelen+4, cmddata);\nsize=readInt(namelen+8, cmddata);\n\/\/ System.out.println(\"LOADFONT: handle=\"+fonthandle+\" name=\"+name.toString()+\" style=\"+Integer.toHexString(style)+\" size=\"+size);\nMcFont fontPtr = new McFont(name.toString(), style, size);\n\/\/ long fontPtr = loadFont0(name.toString(), style, size);\nif(fontPtr == null) {\n\/\/ FIXME: implement!\n\/\/ we don't have the font on this sytem (yet) see if it's cached and try to load it manually\n\/\/ String cacheName = name.toString() + \"-\" + style;\n\/\/ fontPtr = loadCachedFont0(cacheDir.getAbsolutePath(), name.toString() + \"-\" + myConn.getServerName(), style, size);\n\/\/ if (fontPtr == 0) {\n\/\/ Return that we don't have this font so it'll load it into our cache\nhasret[0] = 1;\n\nint fonthandle = handleCount++;\nnamelen=readInt(0, cmddata);\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nstyle=readInt(namelen+4, cmddata);\nsize=readInt(namelen+8, cmddata);\n\/\/ System.out.println(\"LOADFONT: handle=\"+fonthandle+\" name=\"+name.toString()+\" style=\"+Integer.toHexString(style)+\" size=\"+size);\nMcFont fontPtr = new McFont(name.toString(), style, size);\n\/\/ long fontPtr = loadFont0(name.toString(), style, size);\nif(fontPtr == null) {\n\/\/ FIXME: implement!\n\/\/ we don't have the font on this sytem (yet) see if it's cached and try to load it manually\n\/\/ String cacheName = name.toString() + \"-\" + style;\n\/\/ fontPtr = loadCachedFont0(cacheDir.getAbsolutePath(), name.toString() + \"-\" + myConn.getServerName(), style, size);\n\/\/ if (fontPtr == 0) {\n\/\/ Return that we don't have this font so it'll load it into our cache\nhasret[0] = 1;\nreturn 0;\n\/\/ }\n\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nstyle=readInt(namelen+4, cmddata);\nsize=readInt(namelen+8, cmddata);\n\/\/ System.out.println(\"LOADFONT: handle=\"+fonthandle+\" name=\"+name.toString()+\" style=\"+Integer.toHexString(style)+\" size=\"+size);\nMcFont fontPtr = new McFont(name.toString(), style, size);\n\/\/ long fontPtr = loadFont0(name.toString(), style, size);\nif(fontPtr == null) {\n\/\/ FIXME: implement!\n\/\/ we don't have the font on this sytem (yet) see if it's cached and try to load it manually\n\/\/ String cacheName = name.toString() + \"-\" + style;\n\/\/ fontPtr = loadCachedFont0(cacheDir.getAbsolutePath(), name.toString() + \"-\" + myConn.getServerName(), style, size);\n\/\/ if (fontPtr == 0) {\n\/\/ Return that we don't have this font so it'll load it into our cache\nhasret[0] = 1;\nreturn 0;\n\/\/ }\n}\n\/\/ System.out.println(\" fontPtr=\" + fontPtr);\nfontMap.put(new Integer(fonthandle), fontPtr);\nhasret[0] = 1;\nreturn fonthandle;\n}\nelse\n\n\/\/ long fontPtr = loadFont0(name.toString(), style, size);\nif(fontPtr == null) {\n\/\/ FIXME: implement!\n\/\/ we don't have the font on this sytem (yet) see if it's cached and try to load it manually\n\/\/ String cacheName = name.toString() + \"-\" + style;\n\/\/ fontPtr = loadCachedFont0(cacheDir.getAbsolutePath(), name.toString() + \"-\" + myConn.getServerName(), style, size);\n\/\/ if (fontPtr == 0) {\n\/\/ Return that we don't have this font so it'll load it into our cache\nhasret[0] = 1;\nreturn 0;\n\/\/ }\n}\n\/\/ System.out.println(\" fontPtr=\" + fontPtr);\nfontMap.put(new Integer(fonthandle), fontPtr);\nhasret[0] = 1;\nreturn fonthandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADFONT : \" + len);\n}\n\n\/\/ FIXME: implement!\n\/\/ we don't have the font on this sytem (yet) see if it's cached and try to load it manually\n\/\/ String cacheName = name.toString() + \"-\" + style;\n\/\/ fontPtr = loadCachedFont0(cacheDir.getAbsolutePath(), name.toString() + \"-\" + myConn.getServerName(), style, size);\n\/\/ if (fontPtr == 0) {\n\/\/ Return that we don't have this font so it'll load it into our cache\nhasret[0] = 1;\nreturn 0;\n\/\/ }\n}\n\/\/ System.out.println(\" fontPtr=\" + fontPtr);\nfontMap.put(new Integer(fonthandle), fontPtr);\nhasret[0] = 1;\nreturn fonthandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADFONT : \" + len);\n}\nbreak;\ncase GFXCMD_UNLOADFONT:\n\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\nint width, height;\nint imghandle = readInt(0, cmddata);\nwidth=readInt(4, cmddata);\nheight=readInt(8, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\/\/ Keep freeing the oldest image until we have enough memory to do this\nint oldestImage = myConn.getOldestImage();\n\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADFONT : \" + len);\n}\nbreak;\ncase GFXCMD_UNLOADFONT:\n\/\/ handle\nif(len==4)\n{\nint handle;\nhandle=readInt(0, cmddata);\n\/\/STBGFX.GFX_unloadFont(handle);\nMcFont fontPtr = (McFont)fontMap.get(new Integer(handle));\n\/\/ System.out.println(\"UNLOADFONT: handle=\"+handle+\" fontPtr=\"+fontPtr);\nif(fontPtr != null) fontPtr.unload();\nfontMap.remove(new Integer(handle));\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_UNLOADFONT : \" + len);\n}\nbreak;\n\n}\nbreak;\ncase GFXCMD_UNLOADFONT:\n\/\/ handle\nif(len==4)\n{\nint handle;\nhandle=readInt(0, cmddata);\n\/\/STBGFX.GFX_unloadFont(handle);\nMcFont fontPtr = (McFont)fontMap.get(new Integer(handle));\n\/\/ System.out.println(\"UNLOADFONT: handle=\"+handle+\" fontPtr=\"+fontPtr);\nif(fontPtr != null) fontPtr.unload();\nfontMap.remove(new Integer(handle));\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_UNLOADFONT : \" + len);\n}\nbreak;\ncase GFXCMD_LOADFONTSTREAM:\n\/\/ namelen, name, len, data\n\n\/\/ System.out.println(\"UNLOADFONT: handle=\"+handle+\" fontPtr=\"+fontPtr);\nif(fontPtr != null) fontPtr.unload();\nfontMap.remove(new Integer(handle));\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_UNLOADFONT : \" + len);\n}\nbreak;\ncase GFXCMD_LOADFONTSTREAM:\n\/\/ namelen, name, len, data\nif (len>=8)\n{\nStringBuffer name = new StringBuffer();\nint namelen = readInt(0, cmddata);\nfor(int i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nint datalen = readInt(4 + namelen, cmddata);\nif (len >= datalen + 8 + namelen)\n\nbreak;\ncase GFXCMD_LOADFONT:\n\/\/ namelen, name, style, size\nif(len>=12 && len>=(12+readInt(0, cmddata)))\n{\nint namelen, style, size;\nStringBuffer name = new StringBuffer();\nint i;\nint fonthandle = handleCount++;\nnamelen=readInt(0, cmddata);\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nstyle=readInt(namelen+4, cmddata);\nsize=readInt(namelen+8, cmddata);\n\/\/ System.out.println(\"LOADFONT: handle=\"+fonthandle+\" name=\"+name.toString()+\" style=\"+Integer.toHexString(style)+\" size=\"+size);\nMcFont fontPtr = new McFont(name.toString(), style, size);\n\/\/ long fontPtr = loadFont0(name.toString(), style, size);\nif(fontPtr == null) {\n\/\/ FIXME: implement!\n\n\/\/ namelen, name, style, size\nif(len>=12 && len>=(12+readInt(0, cmddata)))\n{\nint namelen, style, size;\nStringBuffer name = new StringBuffer();\nint i;\nint fonthandle = handleCount++;\nnamelen=readInt(0, cmddata);\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nstyle=readInt(namelen+4, cmddata);\nsize=readInt(namelen+8, cmddata);\n\/\/ System.out.println(\"LOADFONT: handle=\"+fonthandle+\" name=\"+name.toString()+\" style=\"+Integer.toHexString(style)+\" size=\"+size);\nMcFont fontPtr = new McFont(name.toString(), style, size);\n\/\/ long fontPtr = loadFont0(name.toString(), style, size);\nif(fontPtr == null) {\n\/\/ FIXME: implement!\n\/\/ we don't have the font on this sytem (yet) see if it's cached and try to load it manually\n\/\/ String cacheName = name.toString() + \"-\" + style;\n\n{\nStringBuffer name = new StringBuffer();\nint namelen = readInt(0, cmddata);\nfor(int i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nint datalen = readInt(4 + namelen, cmddata);\nif (len >= datalen + 8 + namelen)\n{\n\/\/ System.out.println(\"Saving font \" + name.toString() + \" to cache\");\nmyConn.saveCacheData(name.toString() + \"-\" + myConn.getServerName(), cmddata, 12 + namelen, datalen);\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADFONTSTREAM : \" + len);\n}\nbreak;\ncase GFXCMD_FLIPBUFFER:\n\/\/ System.out.println(\"FLIPBUFFER\");\n\n\/\/ System.out.println(\"Saving font \" + name.toString() + \" to cache\");\nmyConn.saveCacheData(name.toString() + \"-\" + myConn.getServerName(), cmddata, 12 + namelen, datalen);\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADFONTSTREAM : \" + len);\n}\nbreak;\ncase GFXCMD_FLIPBUFFER:\n\/\/ System.out.println(\"FLIPBUFFER\");\nif (abortRenderCycle)\n{\nSystem.out.println(\"ERROR in painting cycle, ABORT was set...send full repaint command\");\nmyConn.postRepaintEvent(0, 0, c.getWidth(), c.getHeight());\n}\nelse\n{\npresent0(c.nativeView, new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight()));\n}\nhasret[0] = 1;\n\nif (abortRenderCycle)\n{\nSystem.out.println(\"ERROR in painting cycle, ABORT was set...send full repaint command\");\nmyConn.postRepaintEvent(0, 0, c.getWidth(), c.getHeight());\n}\nelse\n{\npresent0(c.nativeView, new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight()));\n}\nhasret[0] = 1;\n\/\/STBGFX.GFX_flipBuffer();\nfirstFrameDone = true;\nreturn 0;\ncase GFXCMD_STARTFRAME:\n\/\/ System.out.println(\"STARTFRAME\");\n\/\/ prepare for a new frame to be rendered\nsetTargetView0(c.nativeView);\nsetLayer0(0, c.getSize(), null); \/\/ this makes sure the drawing surface gets resized properly\nabortRenderCycle = false;\nbreak;\ncase GFXCMD_LOADIMAGELINE:\n\n}\nelse\n{\npresent0(c.nativeView, new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight()));\n}\nhasret[0] = 1;\n\/\/STBGFX.GFX_flipBuffer();\nfirstFrameDone = true;\nreturn 0;\ncase GFXCMD_STARTFRAME:\n\/\/ System.out.println(\"STARTFRAME\");\n\/\/ prepare for a new frame to be rendered\nsetTargetView0(c.nativeView);\nsetLayer0(0, c.getSize(), null); \/\/ this makes sure the drawing surface gets resized properly\nabortRenderCycle = false;\nbreak;\ncase GFXCMD_LOADIMAGELINE:\n\/\/ handle, line, len, data\nif(len>=12 && len>=(12+readInt(8, cmddata)))\n{\nint handle, line, len2;\n\/\/unsigned char *data=&cmddata[12];\n\npresent0(c.nativeView, new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight()));\n}\nhasret[0] = 1;\n\/\/STBGFX.GFX_flipBuffer();\nfirstFrameDone = true;\nreturn 0;\ncase GFXCMD_STARTFRAME:\n\/\/ System.out.println(\"STARTFRAME\");\n\/\/ prepare for a new frame to be rendered\nsetTargetView0(c.nativeView);\nsetLayer0(0, c.getSize(), null); \/\/ this makes sure the drawing surface gets resized properly\nabortRenderCycle = false;\nbreak;\ncase GFXCMD_LOADIMAGELINE:\n\/\/ handle, line, len, data\nif(len>=12 && len>=(12+readInt(8, cmddata)))\n{\nint handle, line, len2;\n\/\/unsigned char *data=&cmddata[12];\nhandle=readInt(0, cmddata);\nline=readInt(4, cmddata);\n\nfirstFrameDone = true;\nreturn 0;\ncase GFXCMD_STARTFRAME:\n\/\/ System.out.println(\"STARTFRAME\");\n\/\/ prepare for a new frame to be rendered\nsetTargetView0(c.nativeView);\nsetLayer0(0, c.getSize(), null); \/\/ this makes sure the drawing surface gets resized properly\nabortRenderCycle = false;\nbreak;\ncase GFXCMD_LOADIMAGELINE:\n\/\/ handle, line, len, data\nif(len>=12 && len>=(12+readInt(8, cmddata)))\n{\nint handle, line, len2;\n\/\/unsigned char *data=&cmddata[12];\nhandle=readInt(0, cmddata);\nline=readInt(4, cmddata);\nlen2=readInt(8, cmddata);\n\/\/ the last number is the offset into the data array to start reading from\n\/\/STBGFX.GFX_loadImageLine(handle, line, len, data, 12);\n\/\/int dataPos = 12;\n\n\/\/ prepare for a new frame to be rendered\nsetTargetView0(c.nativeView);\nsetLayer0(0, c.getSize(), null); \/\/ this makes sure the drawing surface gets resized properly\nabortRenderCycle = false;\nbreak;\ncase GFXCMD_LOADIMAGELINE:\n\/\/ handle, line, len, data\nif(len>=12 && len>=(12+readInt(8, cmddata)))\n{\nint handle, line, len2;\n\/\/unsigned char *data=&cmddata[12];\nhandle=readInt(0, cmddata);\nline=readInt(4, cmddata);\nlen2=readInt(8, cmddata);\n\/\/ the last number is the offset into the data array to start reading from\n\/\/STBGFX.GFX_loadImageLine(handle, line, len, data, 12);\n\/\/int dataPos = 12;\nLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\/\/ System.out.println(\"LOADIMAGELINE: handle=\"+handle+\" imagePtr=\"+imagePtr+\" line=\"+line+\" len2=\"+len2);\nif(imagePtr != null)\nloadImageLine0(imagePtr.longValue(), line, cmddata, 16\/*12*\/, len2);\n\nbreak;\ncase GFXCMD_LOADIMAGELINE:\n\/\/ handle, line, len, data\nif(len>=12 && len>=(12+readInt(8, cmddata)))\n{\nint handle, line, len2;\n\/\/unsigned char *data=&cmddata[12];\nhandle=readInt(0, cmddata);\nline=readInt(4, cmddata);\nlen2=readInt(8, cmddata);\n\/\/ the last number is the offset into the data array to start reading from\n\/\/STBGFX.GFX_loadImageLine(handle, line, len, data, 12);\n\/\/int dataPos = 12;\nLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\/\/ System.out.println(\"LOADIMAGELINE: handle=\"+handle+\" imagePtr=\"+imagePtr+\" line=\"+line+\" len2=\"+len2);\nif(imagePtr != null)\nloadImageLine0(imagePtr.longValue(), line, cmddata, 16\/*12*\/, len2);\nmyConn.registerImageAccess(handle);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGELINE : \" + len);\n}\n\n{\nint handle, line, len2;\n\/\/unsigned char *data=&cmddata[12];\nhandle=readInt(0, cmddata);\nline=readInt(4, cmddata);\nlen2=readInt(8, cmddata);\n\/\/ the last number is the offset into the data array to start reading from\n\/\/STBGFX.GFX_loadImageLine(handle, line, len, data, 12);\n\/\/int dataPos = 12;\nLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\/\/ System.out.println(\"LOADIMAGELINE: handle=\"+handle+\" imagePtr=\"+imagePtr+\" line=\"+line+\" len2=\"+len2);\nif(imagePtr != null)\nloadImageLine0(imagePtr.longValue(), line, cmddata, 16\/*12*\/, len2);\nmyConn.registerImageAccess(handle);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGELINE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGECOMPRESSED:\n\n\/\/unsigned char *data=&cmddata[12];\nhandle=readInt(0, cmddata);\nline=readInt(4, cmddata);\nlen2=readInt(8, cmddata);\n\/\/ the last number is the offset into the data array to start reading from\n\/\/STBGFX.GFX_loadImageLine(handle, line, len, data, 12);\n\/\/int dataPos = 12;\nLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\/\/ System.out.println(\"LOADIMAGELINE: handle=\"+handle+\" imagePtr=\"+imagePtr+\" line=\"+line+\" len2=\"+len2);\nif(imagePtr != null)\nloadImageLine0(imagePtr.longValue(), line, cmddata, 16\/*12*\/, len2);\nmyConn.registerImageAccess(handle);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGELINE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGECOMPRESSED:\n\/\/ handle, line, len, data\nif(len>=8 && len>=(8+readInt(4, cmddata)))\n\nfirstFrameDone = true;\nreturn 0;\ncase GFXCMD_STARTFRAME:\n\/\/ System.out.println(\"STARTFRAME\");\n\/\/ prepare for a new frame to be rendered\nsetTargetView0(c.nativeView);\nsetLayer0(0, c.getSize(), null); \/\/ this makes sure the drawing surface gets resized properly\nabortRenderCycle = false;\nbreak;\ncase GFXCMD_LOADIMAGELINE:\n\/\/ handle, line, len, data\nif(len>=12 && len>=(12+readInt(8, cmddata)))\n{\nint handle, line, len2;\n\/\/unsigned char *data=&cmddata[12];\nhandle=readInt(0, cmddata);\nline=readInt(4, cmddata);\nlen2=readInt(8, cmddata);\n\/\/ the last number is the offset into the data array to start reading from\n\/\/STBGFX.GFX_loadImageLine(handle, line, len, data, 12);\n\/\/int dataPos = 12;\n\nmyConn.postOfflineCacheChange(true, lastImageResourceID);\n}\nif (!myConn.doesUseAdvancedImageCaching())\n{\nhandle = handleCount++;\nhasret[0] = 1;\n}\nelse\nhasret[0] = 0;\nmyConn.registerImageAccess(handle);\nlong imagePtr = createImageFromBytes0(cmddata, 12, len2, null); \/\/ FIXME: grab extension if possible\n\/\/ System.out.println(\"LOADIMAGECOMPRESSED: handle=\"+handle+\" imagePtr=\"+imagePtr+\" len2=\"+len2);\nimageMap.put(new Integer(handle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\nreturn handle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGECOMPRESSED : \" + len);\n}\nbreak;\n\n}\nif (!myConn.doesUseAdvancedImageCaching())\n{\nhandle = handleCount++;\nhasret[0] = 1;\n}\nelse\nhasret[0] = 0;\nmyConn.registerImageAccess(handle);\nlong imagePtr = createImageFromBytes0(cmddata, 12, len2, null); \/\/ FIXME: grab extension if possible\n\/\/ System.out.println(\"LOADIMAGECOMPRESSED: handle=\"+handle+\" imagePtr=\"+imagePtr+\" len2=\"+len2);\nimageMap.put(new Integer(handle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\nreturn handle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGECOMPRESSED : \" + len);\n}\nbreak;\ncase GFXCMD_XFMIMAGE:\n\nimageMap.put(new Integer(handle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\nreturn handle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGECOMPRESSED : \" + len);\n}\nbreak;\ncase GFXCMD_XFMIMAGE:\n\/\/ srcHandle, destHandle, destWidth, destHeight, maskCornerArc\nif (len >= 20)\n{\nint srcHandle, destHandle, destWidth, destHeight, maskCornerArc;\nsrcHandle = readInt(0, cmddata);\ndestHandle = readInt(4, cmddata); \/\/ seems to be unused\ndestWidth = readInt(8, cmddata); \/\/ scaled size (ignore?)\ndestHeight = readInt(12, cmddata);\nmaskCornerArc = readInt(16, cmddata);\nint rvHandle = destHandle;\nif (!myConn.doesUseAdvancedImageCaching())\n\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGECOMPRESSED : \" + len);\n}\nbreak;\ncase GFXCMD_XFMIMAGE:\n\/\/ srcHandle, destHandle, destWidth, destHeight, maskCornerArc\nif (len >= 20)\n{\nint srcHandle, destHandle, destWidth, destHeight, maskCornerArc;\nsrcHandle = readInt(0, cmddata);\ndestHandle = readInt(4, cmddata); \/\/ seems to be unused\ndestWidth = readInt(8, cmddata); \/\/ scaled size (ignore?)\ndestHeight = readInt(12, cmddata);\nmaskCornerArc = readInt(16, cmddata);\nint rvHandle = destHandle;\nif (!myConn.doesUseAdvancedImageCaching())\n{\nrvHandle = handleCount++;\nhasret[0] = 1;\n}\nelse\n\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGECOMPRESSED : \" + len);\n}\nbreak;\ncase GFXCMD_XFMIMAGE:\n\/\/ srcHandle, destHandle, destWidth, destHeight, maskCornerArc\nif (len >= 20)\n{\nint srcHandle, destHandle, destWidth, destHeight, maskCornerArc;\nsrcHandle = readInt(0, cmddata);\ndestHandle = readInt(4, cmddata); \/\/ seems to be unused\ndestWidth = readInt(8, cmddata); \/\/ scaled size (ignore?)\ndestHeight = readInt(12, cmddata);\nmaskCornerArc = readInt(16, cmddata);\nint rvHandle = destHandle;\nif (!myConn.doesUseAdvancedImageCaching())\n{\nrvHandle = handleCount++;\nhasret[0] = 1;\n}\nelse\nhasret[0] = 0;\n\ndestHeight = readInt(12, cmddata);\nmaskCornerArc = readInt(16, cmddata);\nint rvHandle = destHandle;\nif (!myConn.doesUseAdvancedImageCaching())\n{\nrvHandle = handleCount++;\nhasret[0] = 1;\n}\nelse\nhasret[0] = 0;\n\/\/ we cheat and apply the transforms to a metaimage object without actually creating a new image (saves oodles of memory)\nLong srcImg = (Long)imageMap.get(new Integer(srcHandle));\n\/\/ System.out.println(\"XFMIMAGE: srcHandle=\"+srcHandle+\" srcImg=\"+srcImg+\" destHandle=\"+destHandle+\" destWidth=\"+destWidth+\" destHeight=\"+destHeight+\" maskCornerArc=\"+maskCornerArc);\nif(srcImg != null) {\nlong newImage = transformImage0(srcImg.longValue(), destWidth, destHeight, maskCornerArc);\nif(newImage != 0) {\n\/\/ System.out.println(\" newImage=\"+newImage);\nimageMap.put(new Integer(rvHandle), new Long(newImage));\n}\n}\nreturn rvHandle;\n\nint rvHandle = destHandle;\nif (!myConn.doesUseAdvancedImageCaching())\n{\nrvHandle = handleCount++;\nhasret[0] = 1;\n}\nelse\nhasret[0] = 0;\n\/\/ we cheat and apply the transforms to a metaimage object without actually creating a new image (saves oodles of memory)\nLong srcImg = (Long)imageMap.get(new Integer(srcHandle));\n\/\/ System.out.println(\"XFMIMAGE: srcHandle=\"+srcHandle+\" srcImg=\"+srcImg+\" destHandle=\"+destHandle+\" destWidth=\"+destWidth+\" destHeight=\"+destHeight+\" maskCornerArc=\"+maskCornerArc);\nif(srcImg != null) {\nlong newImage = transformImage0(srcImg.longValue(), destWidth, destHeight, maskCornerArc);\nif(newImage != 0) {\n\/\/ System.out.println(\" newImage=\"+newImage);\nimageMap.put(new Integer(rvHandle), new Long(newImage));\n}\n}\nreturn rvHandle;\n}\nelse\n\nhasret[0] = 1;\n}\nelse\nhasret[0] = 0;\n\/\/ we cheat and apply the transforms to a metaimage object without actually creating a new image (saves oodles of memory)\nLong srcImg = (Long)imageMap.get(new Integer(srcHandle));\n\/\/ System.out.println(\"XFMIMAGE: srcHandle=\"+srcHandle+\" srcImg=\"+srcImg+\" destHandle=\"+destHandle+\" destWidth=\"+destWidth+\" destHeight=\"+destHeight+\" maskCornerArc=\"+maskCornerArc);\nif(srcImg != null) {\nlong newImage = transformImage0(srcImg.longValue(), destWidth, destHeight, maskCornerArc);\nif(newImage != 0) {\n\/\/ System.out.println(\" newImage=\"+newImage);\nimageMap.put(new Integer(rvHandle), new Long(newImage));\n}\n}\nreturn rvHandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_XFMIMAGE : \" + len);\n}\nbreak;","code_context_20":"public int ExecuteGFXCommand(int cmd, int len, byte[] cmddata, int[] hasret)\n{\nlen -= 4; \/\/ for the 4 byte header\nhasret[0] = 0; \/\/ Nothing to return by default\n\/\/ System.out.println(\"GFXCMD=\" + cmd);\n\/\/ make sure the frame is still valid or we could crash on fullscreen mode switches\nif((cmd != GFXCMD_INIT) && (cmd != GFXCMD_DEINIT))\n{\nif((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\n\/\/ System.out.println(\"GFXCMD while frame not displayable\");\n\/\/ spin until the frame is valid and displayable, if we don't we'll lose parts of the UI or crash\nwhile((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\ntry {\nThread.sleep(10);\n} catch(InterruptedException ex) {}\n}\n}\n}\nif (c != null)\n{\nswitch(cmd)\n{\ncase GFXCMD_INIT:\n\npublic int ExecuteGFXCommand(int cmd, int len, byte[] cmddata, int[] hasret)\n{\nlen -= 4; \/\/ for the 4 byte header\nhasret[0] = 0; \/\/ Nothing to return by default\n\/\/ System.out.println(\"GFXCMD=\" + cmd);\n\/\/ make sure the frame is still valid or we could crash on fullscreen mode switches\nif((cmd != GFXCMD_INIT) && (cmd != GFXCMD_DEINIT))\n{\nif((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\n\/\/ System.out.println(\"GFXCMD while frame not displayable\");\n\/\/ spin until the frame is valid and displayable, if we don't we'll lose parts of the UI or crash\nwhile((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\ntry {\nThread.sleep(10);\n} catch(InterruptedException ex) {}\n}\n}\n}\nif (c != null)\n{\nswitch(cmd)\n{\ncase GFXCMD_INIT:\ncase GFXCMD_DEINIT:\n\npublic int ExecuteGFXCommand(int cmd, int len, byte[] cmddata, int[] hasret)\n{\nlen -= 4; \/\/ for the 4 byte header\nhasret[0] = 0; \/\/ Nothing to return by default\n\/\/ System.out.println(\"GFXCMD=\" + cmd);\n\/\/ make sure the frame is still valid or we could crash on fullscreen mode switches\nif((cmd != GFXCMD_INIT) && (cmd != GFXCMD_DEINIT))\n{\nif((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\n\/\/ System.out.println(\"GFXCMD while frame not displayable\");\n\/\/ spin until the frame is valid and displayable, if we don't we'll lose parts of the UI or crash\nwhile((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\ntry {\nThread.sleep(10);\n} catch(InterruptedException ex) {}\n}\n}\n}\nif (c != null)\n{\nswitch(cmd)\n{\ncase GFXCMD_INIT:\ncase GFXCMD_DEINIT:\ncase GFXCMD_STARTFRAME:\ncase GFXCMD_FLIPBUFFER:\n\npublic int ExecuteGFXCommand(int cmd, int len, byte[] cmddata, int[] hasret)\n{\nlen -= 4; \/\/ for the 4 byte header\nhasret[0] = 0; \/\/ Nothing to return by default\n\/\/ System.out.println(\"GFXCMD=\" + cmd);\n\/\/ make sure the frame is still valid or we could crash on fullscreen mode switches\nif((cmd != GFXCMD_INIT) && (cmd != GFXCMD_DEINIT))\n{\nif((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\n\/\/ System.out.println(\"GFXCMD while frame not displayable\");\n\/\/ spin until the frame is valid and displayable, if we don't we'll lose parts of the UI or crash\nwhile((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\ntry {\nThread.sleep(10);\n} catch(InterruptedException ex) {}\n}\n}\n}\nif (c != null)\n{\nswitch(cmd)\n{\ncase GFXCMD_INIT:\ncase GFXCMD_DEINIT:\ncase GFXCMD_STARTFRAME:\ncase GFXCMD_FLIPBUFFER:\nc.setCursor(null);\nbreak;\ncase GFXCMD_DRAWRECT:\ncase GFXCMD_FILLRECT:\ncase GFXCMD_CLEARRECT:\n\ncase GFXCMD_LOADFONT:\ncase GFXCMD_UNLOADFONT:\ncase GFXCMD_SETTARGETSURFACE:\ncase GFXCMD_CREATESURFACE:\nbreak;\ncase GFXCMD_PREPIMAGE:\ncase GFXCMD_LOADIMAGELINE:\ncase GFXCMD_LOADIMAGECOMPRESSED:\ncase GFXCMD_XFMIMAGE:\ncase GFXCMD_LOADCACHEDIMAGE:\ncase GFXCMD_PREPIMAGETARGETED:\nif (!cursorHidden)\nc.setCursor(java.awt.Cursor.getPredefinedCursor(java.awt.Cursor.WAIT_CURSOR));\nbreak;\n}\n}\nswitch(cmd)\n{\ncase GFXCMD_INIT:\nhasret[0] = 1;\n\/\/ System.out.println(\"INIT\");\n\/\/ start up native renderer\ninit0();\nint windowTitleStyle = 0;\ntry\n{\nwindowTitleStyle = Integer.parseInt(MiniClient.myProperties.getProperty(\"window_title_style\", \"0\"));\n}\ncatch (NumberFormatException e){}\nif (!\"true\".equals(MiniClient.myProperties.getProperty(\"enable_custom_title_bar\", MiniClient.MAC_OS_X ? \"false\" : \"true\")))\nwindowTitleStyle = 10; \/\/ platform default\nf = new MiniClientWindow(myConn.getWindowTitle(), windowTitleStyle);\njava.awt.LayoutManager layer = new java.awt.LayoutManager()\n{\npublic void addLayoutComponent(String name, java.awt.Component comp)\n{}\npublic java.awt.Dimension minimumLayoutSize(java.awt.Container parent)\n{\nreturn preferredLayoutSize(parent);\n}\npublic java.awt.Dimension preferredLayoutSize(java.awt.Container parent)\n{\n\ncase GFXCMD_PREPIMAGETARGETED:\nif (!cursorHidden)\nc.setCursor(java.awt.Cursor.getPredefinedCursor(java.awt.Cursor.WAIT_CURSOR));\nbreak;\n}\n}\nswitch(cmd)\n{\ncase GFXCMD_INIT:\nhasret[0] = 1;\n\/\/ System.out.println(\"INIT\");\n\/\/ start up native renderer\ninit0();\nint windowTitleStyle = 0;\ntry\n{\nwindowTitleStyle = Integer.parseInt(MiniClient.myProperties.getProperty(\"window_title_style\", \"0\"));\n}\ncatch (NumberFormatException e){}\nif (!\"true\".equals(MiniClient.myProperties.getProperty(\"enable_custom_title_bar\", MiniClient.MAC_OS_X ? \"false\" : \"true\")))\nwindowTitleStyle = 10; \/\/ platform default\nf = new MiniClientWindow(myConn.getWindowTitle(), windowTitleStyle);\njava.awt.LayoutManager layer = new java.awt.LayoutManager()\n{\npublic void addLayoutComponent(String name, java.awt.Component comp)\n{}\npublic java.awt.Dimension minimumLayoutSize(java.awt.Container parent)\n{\nreturn preferredLayoutSize(parent);\n}\npublic java.awt.Dimension preferredLayoutSize(java.awt.Container parent)\n{\nreturn parent.getPreferredSize();\n}\npublic void removeLayoutComponent(java.awt.Component comp)\n{}\npublic void layoutContainer(java.awt.Container parent)\n{\nc.setBounds(parent.getInsets().left, parent.getInsets().top, parent.getWidth() - parent.getInsets().left - parent.getInsets().right,\nparent.getHeight() - parent.getInsets().top - parent.getInsets().bottom);\n\/\/System.out.println(\"LAYOUT frame bounds=\" + f.getBounds() + \" videoBounds=\" + videoBounds + \" parentBounds=\" + parent.getBounds());\n\nwindowTitleStyle = 10; \/\/ platform default\nf = new MiniClientWindow(myConn.getWindowTitle(), windowTitleStyle);\njava.awt.LayoutManager layer = new java.awt.LayoutManager()\n{\npublic void addLayoutComponent(String name, java.awt.Component comp)\n{}\npublic java.awt.Dimension minimumLayoutSize(java.awt.Container parent)\n{\nreturn preferredLayoutSize(parent);\n}\npublic java.awt.Dimension preferredLayoutSize(java.awt.Container parent)\n{\nreturn parent.getPreferredSize();\n}\npublic void removeLayoutComponent(java.awt.Component comp)\n{}\npublic void layoutContainer(java.awt.Container parent)\n{\nc.setBounds(parent.getInsets().left, parent.getInsets().top, parent.getWidth() - parent.getInsets().left - parent.getInsets().right,\nparent.getHeight() - parent.getInsets().top - parent.getInsets().bottom);\n\/\/System.out.println(\"LAYOUT frame bounds=\" + f.getBounds() + \" videoBounds=\" + videoBounds + \" parentBounds=\" + parent.getBounds());\n}\n};\nf.getContentPane().setLayout(layer);\ntry\n{\nbgImage = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/Background.jpg\"));\nensureImageIsLoaded(bgImage);\nlogoImage = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/SageLogo256.png\"));\nensureImageIsLoaded(logoImage);\n}\ncatch (Exception e)\n{\nSystem.out.println(\"ERROR:\" + e);\ne.printStackTrace();\n}\nf.setFocusTraversalKeysEnabled(false);\n\/*\nif not connecting to localhost:\n- draw background to bounds (scaled)\n- draw logo to {{2% from left, 15% from top}{20% view width, 7% view height}}, no clipping, alpha = 0.85, adjust size to keep aspect ratio\n\n{\nc.setBounds(parent.getInsets().left, parent.getInsets().top, parent.getWidth() - parent.getInsets().left - parent.getInsets().right,\nparent.getHeight() - parent.getInsets().top - parent.getInsets().bottom);\n\/\/System.out.println(\"LAYOUT frame bounds=\" + f.getBounds() + \" videoBounds=\" + videoBounds + \" parentBounds=\" + parent.getBounds());\n}\n};\nf.getContentPane().setLayout(layer);\ntry\n{\nbgImage = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/Background.jpg\"));\nensureImageIsLoaded(bgImage);\nlogoImage = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/SageLogo256.png\"));\nensureImageIsLoaded(logoImage);\n}\ncatch (Exception e)\n{\nSystem.out.println(\"ERROR:\" + e);\ne.printStackTrace();\n}\nf.setFocusTraversalKeysEnabled(false);\n\/*\nif not connecting to localhost:\n- draw background to bounds (scaled)\n- draw logo to {{2% from left, 15% from top}{20% view width, 7% view height}}, no clipping, alpha = 0.85, adjust size to keep aspect ratio\n- load Arial 32 bold\n- draw the following text, double spaced using Arial 32 bold, white with black shadow (offset by (+2,+2))\n\"SageTV Placeshifter is connecting to\"\n\"the server: \"+myConn.getServerName()\n\"Please Wait...\"\ntext is centered in the view on the middle line, use font metrics to determine proper location\ng.setFont(pleaseWaitFont);\ng.setColor(java.awt.Color.black);\ny += 2;\ng.drawString(str1, 2 + (getWidth()\/2) - (fm.stringWidth(str1)\/2), y + fm.getAscent());\ny += fm.getHeight();\ng.drawString(str2, 2 + (getWidth()\/2) - (fm.stringWidth(str2)\/2), y + fm.getAscent());\ny += 2*fm.getHeight();\ng.drawString(str3, 2 + (getWidth()\/2) - (fm.stringWidth(str3)\/2), y + fm.getAscent());\ng.setColor(java.awt.Color.white);\ny = (getHeight() \/ 2) - fh\/2;\ng.drawString(str1, (getWidth()\/2) - (fm.stringWidth(str1)\/2), y + fm.getAscent());\ny += fm.getHeight();\ng.drawString(str2, (getWidth()\/2) - (fm.stringWidth(str2)\/2), y + fm.getAscent());\ny += 2*fm.getHeight();\ng.drawString(str3, (getWidth()\/2) - (fm.stringWidth(str3)\/2), y + fm.getAscent());\n*\/\njava.awt.Dimension panelSize = f.getContentPane().getSize();\nc = new QuartzRendererView();\nc.setSize(panelSize);\nc.setFocusTraversalKeysEnabled(false);\nf.getContentPane().add(c);\ntry\n{\njava.awt.Image frameIcon = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/tvicon.gif\"));\nensureImageIsLoaded(frameIcon);\nf.setIconImage(frameIcon);\n}\ncatch (Exception e)\n{\nSystem.out.println(\"ERROR:\" + e);\ne.printStackTrace();\n}\nf.addWindowListener(new java.awt.event.WindowAdapter()\n{\npublic void windowClosing(java.awt.event.WindowEvent evt)\n{\n\nensureImageIsLoaded(frameIcon);\nf.setIconImage(frameIcon);\n}\ncatch (Exception e)\n{\nSystem.out.println(\"ERROR:\" + e);\ne.printStackTrace();\n}\nf.addWindowListener(new java.awt.event.WindowAdapter()\n{\npublic void windowClosing(java.awt.event.WindowEvent evt)\n{\nif (!f.isFullScreen() || System.getProperty(\"os.name\").toLowerCase().indexOf(\"windows\") != -1)\n{\nMiniClient.myProperties.setProperty(\"main_window_width\", Integer.toString(f.getWidth()));\nMiniClient.myProperties.setProperty(\"main_window_height\", Integer.toString(f.getHeight()));\nMiniClient.myProperties.setProperty(\"main_window_x\", Integer.toString(f.getX()));\nMiniClient.myProperties.setProperty(\"main_window_y\", Integer.toString(f.getY()));\n}\nmyConn.close();\n\/* try\n{\nif (myConn.getMediaCmd().getPlaya() != null)\n{\nmyConn.getMediaCmd().getPlaya().stop();\nmyConn.getMediaCmd().getPlaya().free();\n}\n}catch (Exception e){}\nSystem.exit(0);*\/\nclose();\n\/\/ f.dispose();\n}\n});\nc.addComponentListener(new java.awt.event.ComponentAdapter()\n{\npublic void componentResized(java.awt.event.ComponentEvent evt)\n{\nmyConn.postResizeEvent(new java.awt.Dimension(c.getWidth(), c.getHeight()));\n}\n});\nf.addKeyListener(this);\nc.addKeyListener(this);\n\/\/f.addMouseListener(this);\nf.addMouseWheelListener(this);\nc.addMouseListener(this);\nif (ENABLE_MOUSE_MOTION_EVENTS)\n{\n\/\/f.addMouseMotionListener(this);\nc.addMouseMotionListener(this);\n\npublic void windowClosing(java.awt.event.WindowEvent evt)\n{\nif (!f.isFullScreen() || System.getProperty(\"os.name\").toLowerCase().indexOf(\"windows\") != -1)\n{\nMiniClient.myProperties.setProperty(\"main_window_width\", Integer.toString(f.getWidth()));\nMiniClient.myProperties.setProperty(\"main_window_height\", Integer.toString(f.getHeight()));\nMiniClient.myProperties.setProperty(\"main_window_x\", Integer.toString(f.getX()));\nMiniClient.myProperties.setProperty(\"main_window_y\", Integer.toString(f.getY()));\n}\nmyConn.close();\n\/* try\n{\nif (myConn.getMediaCmd().getPlaya() != null)\n{\nmyConn.getMediaCmd().getPlaya().stop();\nmyConn.getMediaCmd().getPlaya().free();\n}\n}catch (Exception e){}\nSystem.exit(0);*\/\nclose();\n\/\/ f.dispose();\n}\n});\nc.addComponentListener(new java.awt.event.ComponentAdapter()\n{\npublic void componentResized(java.awt.event.ComponentEvent evt)\n{\nmyConn.postResizeEvent(new java.awt.Dimension(c.getWidth(), c.getHeight()));\n}\n});\nf.addKeyListener(this);\nc.addKeyListener(this);\n\/\/f.addMouseListener(this);\nf.addMouseWheelListener(this);\nc.addMouseListener(this);\nif (ENABLE_MOUSE_MOTION_EVENTS)\n{\n\/\/f.addMouseMotionListener(this);\nc.addMouseMotionListener(this);\n}\nint frameX = 100;\n\nif (myConn.getMediaCmd().getPlaya() != null)\n{\nmyConn.getMediaCmd().getPlaya().stop();\nmyConn.getMediaCmd().getPlaya().free();\n}\n}catch (Exception e){}\nSystem.exit(0);*\/\nclose();\n\/\/ f.dispose();\n}\n});\nc.addComponentListener(new java.awt.event.ComponentAdapter()\n{\npublic void componentResized(java.awt.event.ComponentEvent evt)\n{\nmyConn.postResizeEvent(new java.awt.Dimension(c.getWidth(), c.getHeight()));\n}\n});\nf.addKeyListener(this);\nc.addKeyListener(this);\n\/\/f.addMouseListener(this);\nf.addMouseWheelListener(this);\nc.addMouseListener(this);\nif (ENABLE_MOUSE_MOTION_EVENTS)\n{\n\/\/f.addMouseMotionListener(this);\nc.addMouseMotionListener(this);\n}\nint frameX = 100;\nint frameY = 100;\nint frameW = 720;\nint frameH = 480;\ntry\n{\nframeW = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_width\", \"720\"));\nframeH = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_height\", \"480\"));\nframeX = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_x\", \"100\"));\nframeY = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_y\", \"100\"));\n}\ncatch (NumberFormatException e){}\njava.awt.Point newPos = new java.awt.Point(frameX, frameY);\n\n}catch (Exception e){}\nSystem.exit(0);*\/\nclose();\n\/\/ f.dispose();\n}\n});\nc.addComponentListener(new java.awt.event.ComponentAdapter()\n{\npublic void componentResized(java.awt.event.ComponentEvent evt)\n{\nmyConn.postResizeEvent(new java.awt.Dimension(c.getWidth(), c.getHeight()));\n}\n});\nf.addKeyListener(this);\nc.addKeyListener(this);\n\/\/f.addMouseListener(this);\nf.addMouseWheelListener(this);\nc.addMouseListener(this);\nif (ENABLE_MOUSE_MOTION_EVENTS)\n{\n\/\/f.addMouseMotionListener(this);\nc.addMouseMotionListener(this);\n}\nint frameX = 100;\nint frameY = 100;\nint frameW = 720;\nint frameH = 480;\ntry\n{\nframeW = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_width\", \"720\"));\nframeH = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_height\", \"480\"));\nframeX = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_x\", \"100\"));\nframeY = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_y\", \"100\"));\n}\ncatch (NumberFormatException e){}\njava.awt.Point newPos = new java.awt.Point(frameX, frameY);\nboolean foundScreen = sage.UIUtils.isPointOnAScreen(newPos);\nif (!foundScreen)\n{\nnewPos.x = 150;\nnewPos.y = 150;\n\nframeW = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_width\", \"720\"));\nframeH = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_height\", \"480\"));\nframeX = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_x\", \"100\"));\nframeY = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_y\", \"100\"));\n}\ncatch (NumberFormatException e){}\njava.awt.Point newPos = new java.awt.Point(frameX, frameY);\nboolean foundScreen = sage.UIUtils.isPointOnAScreen(newPos);\nif (!foundScreen)\n{\nnewPos.x = 150;\nnewPos.y = 150;\n}\nf.setVisible(true);\nf.setSize(1,1);\nf.setSize(Math.max(frameW, 320), Math.max(frameH, 240));\nf.setLocation(newPos);\nif (MiniClient.fsStartup)\nf.setFullScreen(true);\nMiniClient.hideSplash();\n\/\/ f.setVisible(true);\nreturn 1;\ncase GFXCMD_DEINIT:\n\/\/ System.out.println(\"DEINIT\");\nclose();\nbreak;\ncase GFXCMD_DRAWRECT:\nif(len==36)\n{\nfloat x, y, width, height;\nint thickness, argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nthickness=readInt(16, cmddata);\nargbTL=readInt(20, cmddata);\nargbTR=readInt(24, cmddata);\nargbBR=readInt(28, cmddata);\nargbBL=readInt(32, cmddata);\n\/\/ System.out.println(\"DRAWRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") thickness=\"+thickness+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\nframeY = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_y\", \"100\"));\n}\ncatch (NumberFormatException e){}\njava.awt.Point newPos = new java.awt.Point(frameX, frameY);\nboolean foundScreen = sage.UIUtils.isPointOnAScreen(newPos);\nif (!foundScreen)\n{\nnewPos.x = 150;\nnewPos.y = 150;\n}\nf.setVisible(true);\nf.setSize(1,1);\nf.setSize(Math.max(frameW, 320), Math.max(frameH, 240));\nf.setLocation(newPos);\nif (MiniClient.fsStartup)\nf.setFullScreen(true);\nMiniClient.hideSplash();\n\/\/ f.setVisible(true);\nreturn 1;\ncase GFXCMD_DEINIT:\n\/\/ System.out.println(\"DEINIT\");\nclose();\nbreak;\ncase GFXCMD_DRAWRECT:\nif(len==36)\n{\nfloat x, y, width, height;\nint thickness, argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nthickness=readInt(16, cmddata);\nargbTL=readInt(20, cmddata);\nargbTR=readInt(24, cmddata);\nargbBR=readInt(28, cmddata);\nargbBL=readInt(32, cmddata);\n\/\/ System.out.println(\"DRAWRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") thickness=\"+thickness+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\/\/ FIXME: no gradients on framed rects yet...\ndrawRect0(new java.awt.geom.Rectangle2D.Float(x, y, width, height), null,\n0,\n\n\/\/ f.setVisible(true);\nreturn 1;\ncase GFXCMD_DEINIT:\n\/\/ System.out.println(\"DEINIT\");\nclose();\nbreak;\ncase GFXCMD_DRAWRECT:\nif(len==36)\n{\nfloat x, y, width, height;\nint thickness, argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nthickness=readInt(16, cmddata);\nargbTL=readInt(20, cmddata);\nargbTR=readInt(24, cmddata);\nargbBR=readInt(28, cmddata);\nargbBL=readInt(32, cmddata);\n\/\/ System.out.println(\"DRAWRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") thickness=\"+thickness+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\/\/ FIXME: no gradients on framed rects yet...\ndrawRect0(new java.awt.geom.Rectangle2D.Float(x, y, width, height), null,\n0,\nnew java.awt.Color(argbTL, true), thickness,\nnull, 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWRECT : \" + len);\n}\nbreak;\ncase GFXCMD_FILLRECT:\n\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL\nif(len==32)\n{\nfloat x, y, width, height;\nint argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\n\nthickness=readInt(16, cmddata);\nargbTL=readInt(20, cmddata);\nargbTR=readInt(24, cmddata);\nargbBR=readInt(28, cmddata);\nargbBL=readInt(32, cmddata);\n\/\/ System.out.println(\"DRAWRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") thickness=\"+thickness+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\/\/ FIXME: no gradients on framed rects yet...\ndrawRect0(new java.awt.geom.Rectangle2D.Float(x, y, width, height), null,\n0,\nnew java.awt.Color(argbTL, true), thickness,\nnull, 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWRECT : \" + len);\n}\nbreak;\ncase GFXCMD_FILLRECT:\n\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL\nif(len==32)\n{\nfloat x, y, width, height;\nint argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nargbTL=readInt(16, cmddata);\nargbTR=readInt(20, cmddata);\nargbBR=readInt(24, cmddata);\nargbBL=readInt(28, cmddata);\n\/\/ System.out.println(\"FILLRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\nif(gp != null) {\ndrawRect0(bounds, null,\n0,\nnull, 0,\ngp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\n\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWRECT : \" + len);\n}\nbreak;\ncase GFXCMD_FILLRECT:\n\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL\nif(len==32)\n{\nfloat x, y, width, height;\nint argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nargbTL=readInt(16, cmddata);\nargbTR=readInt(20, cmddata);\nargbBR=readInt(24, cmddata);\nargbBL=readInt(28, cmddata);\n\/\/ System.out.println(\"FILLRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\nif(gp != null) {\ndrawRect0(bounds, null,\n0,\nnull, 0,\ngp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\ngp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\/\/(float)((argbTL>>24)&0xff)\/255.0f);\n1.0f); \/\/ alpha already supplied\n} else {\ndrawRect0(bounds, null,\n0,\nnull, 0,\nnew java.awt.Color(argbTL, true), 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\n}\nelse\n\n{\nfloat x, y, width, height;\nint argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nargbTL=readInt(16, cmddata);\nargbTR=readInt(20, cmddata);\nargbBR=readInt(24, cmddata);\nargbBL=readInt(28, cmddata);\n\/\/ System.out.println(\"FILLRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\nif(gp != null) {\ndrawRect0(bounds, null,\n0,\nnull, 0,\ngp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\ngp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\/\/(float)((argbTL>>24)&0xff)\/255.0f);\n1.0f); \/\/ alpha already supplied\n} else {\ndrawRect0(bounds, null,\n0,\nnull, 0,\nnew java.awt.Color(argbTL, true), 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_FILLRECT : \" + len);\n}\nbreak;\ncase GFXCMD_CLEARRECT:\n\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL\nif(len==32)\n{\nint x, y, width, height,\n\nfloat x, y, width, height;\nint argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nargbTL=readInt(16, cmddata);\nargbTR=readInt(20, cmddata);\nargbBR=readInt(24, cmddata);\nargbBL=readInt(28, cmddata);\n\/\/ System.out.println(\"FILLRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\nif(gp != null) {\ndrawRect0(bounds, null,\n0,\nnull, 0,\ngp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\ngp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\/\/(float)((argbTL>>24)&0xff)\/255.0f);\n1.0f); \/\/ alpha already supplied\n} else {\ndrawRect0(bounds, null,\n0,\nnull, 0,\nnew java.awt.Color(argbTL, true), 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_FILLRECT : \" + len);\n}\nbreak;\ncase GFXCMD_CLEARRECT:\n\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL\nif(len==32)\n{\nint x, y, width, height,\nargbTL, argbTR, argbBR, argbBL;\n\nthickness=readInt(16, cmddata);\nargbTL=readInt(20, cmddata);\nargbTR=readInt(24, cmddata);\nargbBR=readInt(28, cmddata);\nargbBL=readInt(32, cmddata);\n\/\/ System.out.println(\"DRAWRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") thickness=\"+thickness+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\/\/ FIXME: no gradients on framed rects yet...\ndrawRect0(new java.awt.geom.Rectangle2D.Float(x, y, width, height), null,\n0,\nnew java.awt.Color(argbTL, true), thickness,\nnull, 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWRECT : \" + len);\n}\nbreak;\ncase GFXCMD_FILLRECT:\n\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL\nif(len==32)\n{\nfloat x, y, width, height;\nint argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nargbTL=readInt(16, cmddata);\nargbTR=readInt(20, cmddata);\nargbBR=readInt(24, cmddata);\nargbBL=readInt(28, cmddata);\n\/\/ System.out.println(\"FILLRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\nif(gp != null) {\ndrawRect0(bounds, null,\n0,\nnull, 0,\ngp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\n\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_FILLRECT : \" + len);\n}\nbreak;\ncase GFXCMD_CLEARRECT:\n\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL\nif(len==32)\n{\nint x, y, width, height,\nargbTL, argbTR, argbBR, argbBL;\nx=readInt(0, cmddata);\ny=readInt(4, cmddata);\nwidth=readInt(8, cmddata);\nheight=readInt(12, cmddata);\nargbTL=readInt(16, cmddata);\nargbTR=readInt(20, cmddata);\nargbBR=readInt(24, cmddata);\nargbBL=readInt(28, cmddata);\n\/\/ System.out.println(\"CLEARRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.geom.Rectangle2D.Float destRect = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\nclearRect0(destRect);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_CLEARRECT : \" + len);\n}\nbreak;\ncase GFXCMD_DRAWOVAL:\n\/\/ x, y, width, height, thickness, argbTL, argbTR, argbBR, argbBL,\n\/\/ clipX, clipY, clipW, clipH\nif(len==52)\n{\nfloat x, y, width, height, clipX, clipY, clipW, clipH;\nint thickness, argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nthickness=readInt(16, cmddata);\n\nint x, y, width, height,\nargbTL, argbTR, argbBR, argbBL;\nx=readInt(0, cmddata);\ny=readInt(4, cmddata);\nwidth=readInt(8, cmddata);\nheight=readInt(12, cmddata);\nargbTL=readInt(16, cmddata);\nargbTR=readInt(20, cmddata);\nargbBR=readInt(24, cmddata);\nargbBL=readInt(28, cmddata);\n\/\/ System.out.println(\"CLEARRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.geom.Rectangle2D.Float destRect = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\nclearRect0(destRect);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_CLEARRECT : \" + len);\n}\nbreak;\ncase GFXCMD_DRAWOVAL:\n\/\/ x, y, width, height, thickness, argbTL, argbTR, argbBR, argbBL,\n\/\/ clipX, clipY, clipW, clipH\nif(len==52)\n{\nfloat x, y, width, height, clipX, clipY, clipW, clipH;\nint thickness, argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nthickness=readInt(16, cmddata);\nargbTL=readInt(20, cmddata);\nargbTR=readInt(24, cmddata);\nargbBR=readInt(28, cmddata);\nargbBL=readInt(32, cmddata);\nclipX=(float)readInt(36, cmddata);\nclipY=(float)readInt(40, cmddata);\nclipW=(float)readInt(44, cmddata);\nclipH=(float)readInt(48, cmddata);\n\/\/ System.out.println(\"DRAWOVAL: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") thickness=\"+thickness+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\/\/ FIXME: no gradient for framed ovals\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\ncase GFXCMD_DRAWOVAL:\n\/\/ x, y, width, height, thickness, argbTL, argbTR, argbBR, argbBL,\n\/\/ clipX, clipY, clipW, clipH\nif(len==52)\n{\nfloat x, y, width, height, clipX, clipY, clipW, clipH;\nint thickness, argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nthickness=readInt(16, cmddata);\nargbTL=readInt(20, cmddata);\nargbTR=readInt(24, cmddata);\nargbBR=readInt(28, cmddata);\nargbBL=readInt(32, cmddata);\nclipX=(float)readInt(36, cmddata);\nclipY=(float)readInt(40, cmddata);\nclipW=(float)readInt(44, cmddata);\nclipH=(float)readInt(48, cmddata);\n\/\/ System.out.println(\"DRAWOVAL: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") thickness=\"+thickness+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\/\/ FIXME: no gradient for framed ovals\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\njava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\ndrawOval0(bounds, clipRect,\nnew java.awt.Color(argbTL, true), thickness,\nnull, 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWOVAL : \" + len);\n}\nbreak;\ncase GFXCMD_FILLOVAL:\n\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL,\n\/\/ clipX, clipY, clipW, clipH\nif(len==48)\n{\nfloat x, y, width, height,\nclipX, clipY, clipW, clipH;\n\nclipX=(float)readInt(36, cmddata);\nclipY=(float)readInt(40, cmddata);\nclipW=(float)readInt(44, cmddata);\nclipH=(float)readInt(48, cmddata);\n\/\/ System.out.println(\"DRAWOVAL: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") thickness=\"+thickness+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\/\/ FIXME: no gradient for framed ovals\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\njava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\ndrawOval0(bounds, clipRect,\nnew java.awt.Color(argbTL, true), thickness,\nnull, 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWOVAL : \" + len);\n}\nbreak;\ncase GFXCMD_FILLOVAL:\n\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL,\n\/\/ clipX, clipY, clipW, clipH\nif(len==48)\n{\nfloat x, y, width, height,\nclipX, clipY, clipW, clipH;\nint argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nargbTL=readInt(16, cmddata);\nargbTR=readInt(20, cmddata);\nargbBR=readInt(24, cmddata);\nargbBL=readInt(28, cmddata);\nclipX=(float)readInt(32, cmddata);\nclipY=(float)readInt(36, cmddata);\nclipW=(float)readInt(40, cmddata);\nclipH=(float)readInt(44, cmddata);\n\/\/ System.out.println(\"FILLOVAL: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\ncase GFXCMD_FILLOVAL:\n\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL,\n\/\/ clipX, clipY, clipW, clipH\nif(len==48)\n{\nfloat x, y, width, height,\nclipX, clipY, clipW, clipH;\nint argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nargbTL=readInt(16, cmddata);\nargbTR=readInt(20, cmddata);\nargbBR=readInt(24, cmddata);\nargbBL=readInt(28, cmddata);\nclipX=(float)readInt(32, cmddata);\nclipY=(float)readInt(36, cmddata);\nclipW=(float)readInt(40, cmddata);\nclipH=(float)readInt(44, cmddata);\n\/\/ System.out.println(\"FILLOVAL: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\njava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\nif(gp != null) {\ndrawOval0(bounds, clipRect,\nnull, 0,\ngp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\ngp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n1.0f);\n} else {\ndrawOval0(bounds, clipRect,\nnull, 0,\nnew java.awt.Color(argbTL, true), 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_FILLOVAL : \" + len);\n\nif(gp != null) {\ndrawOval0(bounds, clipRect,\nnull, 0,\ngp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\ngp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n1.0f);\n} else {\ndrawOval0(bounds, clipRect,\nnull, 0,\nnew java.awt.Color(argbTL, true), 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_FILLOVAL : \" + len);\n}\nbreak;\ncase GFXCMD_DRAWROUNDRECT:\n\/\/ x, y, width, height, thickness, arcRadius, argbTL, argbTR, argbBR, argbBL,\n\/\/ clipX, clipY, clipW, clipH\nif(len==56)\n{\nfloat x, y, width, height,\nclipX, clipY, clipW, clipH;\nint thickness, arcRadius,\nargbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nthickness=readInt(16, cmddata);\narcRadius=readInt(20, cmddata);\nargbTL=readInt(24, cmddata);\nargbTR=readInt(28, cmddata);\nargbBR=readInt(32, cmddata);\nargbBL=readInt(36, cmddata);\nclipX=(float)readInt(40, cmddata);\nclipY=(float)readInt(44, cmddata);\nclipW=(float)readInt(48, cmddata);\nclipH=(float)readInt(52, cmddata);\n\nif(len==56)\n{\nfloat x, y, width, height,\nclipX, clipY, clipW, clipH;\nint thickness, arcRadius,\nargbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nthickness=readInt(16, cmddata);\narcRadius=readInt(20, cmddata);\nargbTL=readInt(24, cmddata);\nargbTR=readInt(28, cmddata);\nargbBR=readInt(32, cmddata);\nargbBL=readInt(36, cmddata);\nclipX=(float)readInt(40, cmddata);\nclipY=(float)readInt(44, cmddata);\nclipW=(float)readInt(48, cmddata);\nclipH=(float)readInt(52, cmddata);\n\/\/ System.out.println(\"DRAWROUNDRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") thickness=\"+thickness+\" arcRadius=\"+arcRadius+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\/\/ FIXME: no gradients on stroked shapes\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\njava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\ndrawRect0(bounds, clipRect,\narcRadius,\nnew java.awt.Color(argbTL, true), thickness,\nnull, 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWROUNDRECT : \" + len);\n}\nbreak;\ncase GFXCMD_FILLROUNDRECT:\n\/\/ x, y, width, height, arcRadius, argbTL, argbTR, argbBR, argbBL,\n\/\/ clipX, clipY, clipW, clipH\nif(len==52)\n{\nfloat x, y, width, height,\n\nclipY=(float)readInt(44, cmddata);\nclipW=(float)readInt(48, cmddata);\nclipH=(float)readInt(52, cmddata);\n\/\/ System.out.println(\"DRAWROUNDRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") thickness=\"+thickness+\" arcRadius=\"+arcRadius+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\/\/ FIXME: no gradients on stroked shapes\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\njava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\ndrawRect0(bounds, clipRect,\narcRadius,\nnew java.awt.Color(argbTL, true), thickness,\nnull, 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWROUNDRECT : \" + len);\n}\nbreak;\ncase GFXCMD_FILLROUNDRECT:\n\/\/ x, y, width, height, arcRadius, argbTL, argbTR, argbBR, argbBL,\n\/\/ clipX, clipY, clipW, clipH\nif(len==52)\n{\nfloat x, y, width, height,\nclipX, clipY, clipW, clipH;\nint arcRadius, argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\narcRadius=readInt(16, cmddata);\nargbTL=readInt(20, cmddata);\nargbTR=readInt(24, cmddata);\nargbBR=readInt(28, cmddata);\nargbBL=readInt(32, cmddata);\nclipX=(float)readInt(36, cmddata);\nclipY=(float)readInt(40, cmddata);\nclipW=(float)readInt(44, cmddata);\nclipH=(float)readInt(48, cmddata);\n\/\/ System.out.println(\"FILLROUNDRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") arcRadius=\"+arcRadius+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\n\n\/\/ x, y, width, height, arcRadius, argbTL, argbTR, argbBR, argbBL,\n\/\/ clipX, clipY, clipW, clipH\nif(len==52)\n{\nfloat x, y, width, height,\nclipX, clipY, clipW, clipH;\nint arcRadius, argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\narcRadius=readInt(16, cmddata);\nargbTL=readInt(20, cmddata);\nargbTR=readInt(24, cmddata);\nargbBR=readInt(28, cmddata);\nargbBL=readInt(32, cmddata);\nclipX=(float)readInt(36, cmddata);\nclipY=(float)readInt(40, cmddata);\nclipW=(float)readInt(44, cmddata);\nclipH=(float)readInt(48, cmddata);\n\/\/ System.out.println(\"FILLROUNDRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") arcRadius=\"+arcRadius+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\njava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\nif(gp != null) {\ndrawRect0(bounds, clipRect,\narcRadius,\nnull, 0,\ngp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\ngp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\/\/(float)((argbTL>>24)&0xff)\/255.0f);\n1.0f);\n} else {\ndrawRect0(bounds, clipRect,\narcRadius,\nnull, 0,\nnew java.awt.Color(argbTL, true), 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\n}\n\n{\nfloat x, y, width, height;\nint argbTL, argbTR, argbBR, argbBL;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nargbTL=readInt(16, cmddata);\nargbTR=readInt(20, cmddata);\nargbBR=readInt(24, cmddata);\nargbBL=readInt(28, cmddata);\n\/\/ System.out.println(\"FILLRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\njava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\njava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\nif(gp != null) {\ndrawRect0(bounds, null,\n0,\nnull, 0,\ngp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\ngp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\/\/(float)((argbTL>>24)&0xff)\/255.0f);\n1.0f); \/\/ alpha already supplied\n} else {\ndrawRect0(bounds, null,\n0,\nnull, 0,\nnew java.awt.Color(argbTL, true), 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_FILLRECT : \" + len);\n}\nbreak;\ncase GFXCMD_CLEARRECT:\n\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL\nif(len==32)\n{\nint x, y, width, height,\n\nnull, 0,\ngp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\ngp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\/\/(float)((argbTL>>24)&0xff)\/255.0f);\n1.0f);\n} else {\ndrawRect0(bounds, clipRect,\narcRadius,\nnull, 0,\nnew java.awt.Color(argbTL, true), 0.0f, 0.0f,\nnull, 0.0f, 0.0f,\n1.0f);\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_FILLROUNDRECT : \" + len);\n}\nbreak;\ncase GFXCMD_DRAWTEXT:\n\/\/ x, y, len, text, handle, argb, clipX, clipY, clipW, clipH\nif(len>=36 && len>=(36+readInt(8, cmddata)*2))\n{\nfloat x, y, clipX, clipY, clipW, clipH;\nint textlen, fontHandle, argb;\nStringBuffer text = new StringBuffer();\nint i;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\ntextlen=readInt(8, cmddata);\nfor(i=0;i<textlen;i++)\n{\ntext.append((char)readShort(12+i*2, cmddata));\n}\nfontHandle=readInt(textlen*2+12, cmddata);\nargb=readInt(textlen*2+16, cmddata);\nclipX=(float)readInt(textlen*2+20, cmddata);\nclipY=(float)readInt(textlen*2+24, cmddata);\nclipW=(float)readInt(textlen*2+28, cmddata);\nclipH=(float)readInt(textlen*2+32, cmddata);\n\/\/ TODO: check if this is needed\n\n\/\/ x, y, len, text, handle, argb, clipX, clipY, clipW, clipH\nif(len>=36 && len>=(36+readInt(8, cmddata)*2))\n{\nfloat x, y, clipX, clipY, clipW, clipH;\nint textlen, fontHandle, argb;\nStringBuffer text = new StringBuffer();\nint i;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\ntextlen=readInt(8, cmddata);\nfor(i=0;i<textlen;i++)\n{\ntext.append((char)readShort(12+i*2, cmddata));\n}\nfontHandle=readInt(textlen*2+12, cmddata);\nargb=readInt(textlen*2+16, cmddata);\nclipX=(float)readInt(textlen*2+20, cmddata);\nclipY=(float)readInt(textlen*2+24, cmddata);\nclipW=(float)readInt(textlen*2+28, cmddata);\nclipH=(float)readInt(textlen*2+32, cmddata);\n\/\/ TODO: check if this is needed\n\/\/ if (System.getProperty(\"java.version\").startsWith(\"1.4\"))\n\/\/ clipW = clipW * 5 \/ 4;\n\/\/ System.out.println(\"DRAWTEXT: dest=(\"+x+\",\"+y+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") fontHandle=\"+fontHandle+\" argb=\"+Integer.toHexString(argb)+\" text=\"+text.toString());\nMcFont fontPtr = (McFont)fontMap.get(new Integer(fontHandle));\nif(fontPtr != null) {\n\/\/ use AWT string bounds or we'll clip on occasion\nString theString = text.toString();\n\/\/ java.awt.Dimension textSize = fontPtr.getStringSize(theString);\nfloat[] positions = fontPtr.getGlyphPositions(theString);\n\/\/ System.out.println(\"drawText: \\\"\"+theString+\"\\\" loc=(\"+x+\",\"+y+\") num positions=\"+positions.length);\ndrawTextWithPositions0(theString, fontPtr.nativeFont,\nx, y, positions, new java.awt.geom.Rectangle2D.Float(clipX,clipY,clipW,clipH),\nnew java.awt.Color(argb, true));\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXT : \" + len);\n}\nbreak;\ncase GFXCMD_DRAWTEXTURED:\n\/\/ x, y, width, height, handle, srcx, srcy, srcwidth, srcheight, blend\nif(len==40)\n\nint i;\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\ntextlen=readInt(8, cmddata);\nfor(i=0;i<textlen;i++)\n{\ntext.append((char)readShort(12+i*2, cmddata));\n}\nfontHandle=readInt(textlen*2+12, cmddata);\nargb=readInt(textlen*2+16, cmddata);\nclipX=(float)readInt(textlen*2+20, cmddata);\nclipY=(float)readInt(textlen*2+24, cmddata);\nclipW=(float)readInt(textlen*2+28, cmddata);\nclipH=(float)readInt(textlen*2+32, cmddata);\n\/\/ TODO: check if this is needed\n\/\/ if (System.getProperty(\"java.version\").startsWith(\"1.4\"))\n\/\/ clipW = clipW * 5 \/ 4;\n\/\/ System.out.println(\"DRAWTEXT: dest=(\"+x+\",\"+y+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") fontHandle=\"+fontHandle+\" argb=\"+Integer.toHexString(argb)+\" text=\"+text.toString());\nMcFont fontPtr = (McFont)fontMap.get(new Integer(fontHandle));\nif(fontPtr != null) {\n\/\/ use AWT string bounds or we'll clip on occasion\nString theString = text.toString();\n\/\/ java.awt.Dimension textSize = fontPtr.getStringSize(theString);\nfloat[] positions = fontPtr.getGlyphPositions(theString);\n\/\/ System.out.println(\"drawText: \\\"\"+theString+\"\\\" loc=(\"+x+\",\"+y+\") num positions=\"+positions.length);\ndrawTextWithPositions0(theString, fontPtr.nativeFont,\nx, y, positions, new java.awt.geom.Rectangle2D.Float(clipX,clipY,clipW,clipH),\nnew java.awt.Color(argb, true));\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXT : \" + len);\n}\nbreak;\ncase GFXCMD_DRAWTEXTURED:\n\/\/ x, y, width, height, handle, srcx, srcy, srcwidth, srcheight, blend\nif(len==40)\n{\nfloat x, y, width, height,\nsrcx, srcy, srcwidth, srcheight;\n\ny=(float)readInt(4, cmddata);\ntextlen=readInt(8, cmddata);\nfor(i=0;i<textlen;i++)\n{\ntext.append((char)readShort(12+i*2, cmddata));\n}\nfontHandle=readInt(textlen*2+12, cmddata);\nargb=readInt(textlen*2+16, cmddata);\nclipX=(float)readInt(textlen*2+20, cmddata);\nclipY=(float)readInt(textlen*2+24, cmddata);\nclipW=(float)readInt(textlen*2+28, cmddata);\nclipH=(float)readInt(textlen*2+32, cmddata);\n\/\/ TODO: check if this is needed\n\/\/ if (System.getProperty(\"java.version\").startsWith(\"1.4\"))\n\/\/ clipW = clipW * 5 \/ 4;\n\/\/ System.out.println(\"DRAWTEXT: dest=(\"+x+\",\"+y+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") fontHandle=\"+fontHandle+\" argb=\"+Integer.toHexString(argb)+\" text=\"+text.toString());\nMcFont fontPtr = (McFont)fontMap.get(new Integer(fontHandle));\nif(fontPtr != null) {\n\/\/ use AWT string bounds or we'll clip on occasion\nString theString = text.toString();\n\/\/ java.awt.Dimension textSize = fontPtr.getStringSize(theString);\nfloat[] positions = fontPtr.getGlyphPositions(theString);\n\/\/ System.out.println(\"drawText: \\\"\"+theString+\"\\\" loc=(\"+x+\",\"+y+\") num positions=\"+positions.length);\ndrawTextWithPositions0(theString, fontPtr.nativeFont,\nx, y, positions, new java.awt.geom.Rectangle2D.Float(clipX,clipY,clipW,clipH),\nnew java.awt.Color(argb, true));\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXT : \" + len);\n}\nbreak;\ncase GFXCMD_DRAWTEXTURED:\n\/\/ x, y, width, height, handle, srcx, srcy, srcwidth, srcheight, blend\nif(len==40)\n{\nfloat x, y, width, height,\nsrcx, srcy, srcwidth, srcheight;\nint handle, blend; \/\/ blend is a color, use alpha component for blending\nx=(float)readInt(0, cmddata);\n\nfor(i=0;i<textlen;i++)\n{\ntext.append((char)readShort(12+i*2, cmddata));\n}\nfontHandle=readInt(textlen*2+12, cmddata);\nargb=readInt(textlen*2+16, cmddata);\nclipX=(float)readInt(textlen*2+20, cmddata);\nclipY=(float)readInt(textlen*2+24, cmddata);\nclipW=(float)readInt(textlen*2+28, cmddata);\nclipH=(float)readInt(textlen*2+32, cmddata);\n\/\/ TODO: check if this is needed\n\/\/ if (System.getProperty(\"java.version\").startsWith(\"1.4\"))\n\/\/ clipW = clipW * 5 \/ 4;\n\/\/ System.out.println(\"DRAWTEXT: dest=(\"+x+\",\"+y+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") fontHandle=\"+fontHandle+\" argb=\"+Integer.toHexString(argb)+\" text=\"+text.toString());\nMcFont fontPtr = (McFont)fontMap.get(new Integer(fontHandle));\nif(fontPtr != null) {\n\/\/ use AWT string bounds or we'll clip on occasion\nString theString = text.toString();\n\/\/ java.awt.Dimension textSize = fontPtr.getStringSize(theString);\nfloat[] positions = fontPtr.getGlyphPositions(theString);\n\/\/ System.out.println(\"drawText: \\\"\"+theString+\"\\\" loc=(\"+x+\",\"+y+\") num positions=\"+positions.length);\ndrawTextWithPositions0(theString, fontPtr.nativeFont,\nx, y, positions, new java.awt.geom.Rectangle2D.Float(clipX,clipY,clipW,clipH),\nnew java.awt.Color(argb, true));\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXT : \" + len);\n}\nbreak;\ncase GFXCMD_DRAWTEXTURED:\n\/\/ x, y, width, height, handle, srcx, srcy, srcwidth, srcheight, blend\nif(len==40)\n{\nfloat x, y, width, height,\nsrcx, srcy, srcwidth, srcheight;\nint handle, blend; \/\/ blend is a color, use alpha component for blending\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\n\n\/\/ clipW = clipW * 5 \/ 4;\n\/\/ System.out.println(\"DRAWTEXT: dest=(\"+x+\",\"+y+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") fontHandle=\"+fontHandle+\" argb=\"+Integer.toHexString(argb)+\" text=\"+text.toString());\nMcFont fontPtr = (McFont)fontMap.get(new Integer(fontHandle));\nif(fontPtr != null) {\n\/\/ use AWT string bounds or we'll clip on occasion\nString theString = text.toString();\n\/\/ java.awt.Dimension textSize = fontPtr.getStringSize(theString);\nfloat[] positions = fontPtr.getGlyphPositions(theString);\n\/\/ System.out.println(\"drawText: \\\"\"+theString+\"\\\" loc=(\"+x+\",\"+y+\") num positions=\"+positions.length);\ndrawTextWithPositions0(theString, fontPtr.nativeFont,\nx, y, positions, new java.awt.geom.Rectangle2D.Float(clipX,clipY,clipW,clipH),\nnew java.awt.Color(argb, true));\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXT : \" + len);\n}\nbreak;\ncase GFXCMD_DRAWTEXTURED:\n\/\/ x, y, width, height, handle, srcx, srcy, srcwidth, srcheight, blend\nif(len==40)\n{\nfloat x, y, width, height,\nsrcx, srcy, srcwidth, srcheight;\nint handle, blend; \/\/ blend is a color, use alpha component for blending\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nhandle=readInt(16, cmddata); \/\/ either an image handle or layer handle (if not in imageMap)\nsrcx=(float)readInt(20, cmddata);\nsrcy=(float)readInt(24, cmddata);\nsrcwidth=(float)readInt(28, cmddata);\nsrcheight=(float)readInt(32, cmddata);\nblend=readInt(36, cmddata);\n\/*\nif height < 0\ndisable blending\nif width < 0 (font mode, composite with background and blend with given color)\nblend with full RGBA color\n\nString theString = text.toString();\n\/\/ java.awt.Dimension textSize = fontPtr.getStringSize(theString);\nfloat[] positions = fontPtr.getGlyphPositions(theString);\n\/\/ System.out.println(\"drawText: \\\"\"+theString+\"\\\" loc=(\"+x+\",\"+y+\") num positions=\"+positions.length);\ndrawTextWithPositions0(theString, fontPtr.nativeFont,\nx, y, positions, new java.awt.geom.Rectangle2D.Float(clipX,clipY,clipW,clipH),\nnew java.awt.Color(argb, true));\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXT : \" + len);\n}\nbreak;\ncase GFXCMD_DRAWTEXTURED:\n\/\/ x, y, width, height, handle, srcx, srcy, srcwidth, srcheight, blend\nif(len==40)\n{\nfloat x, y, width, height,\nsrcx, srcy, srcwidth, srcheight;\nint handle, blend; \/\/ blend is a color, use alpha component for blending\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nhandle=readInt(16, cmddata); \/\/ either an image handle or layer handle (if not in imageMap)\nsrcx=(float)readInt(20, cmddata);\nsrcy=(float)readInt(24, cmddata);\nsrcwidth=(float)readInt(28, cmddata);\nsrcheight=(float)readInt(32, cmddata);\nblend=readInt(36, cmddata);\n\/*\nif height < 0\ndisable blending\nif width < 0 (font mode, composite with background and blend with given color)\nblend with full RGBA color\nelse\nblend with alpha only\n*\/\n\/\/ System.out.println(\"DRAWTEXTURED: handle=\"+handle+\" dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") src=(\"+srcx+\",\"+srcy+\" \"+srcwidth+\"x\"+srcheight+\") blend=\"+Integer.toHexString(blend));\nboolean doBlend = true;\n\nx, y, positions, new java.awt.geom.Rectangle2D.Float(clipX,clipY,clipW,clipH),\nnew java.awt.Color(argb, true));\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXT : \" + len);\n}\nbreak;\ncase GFXCMD_DRAWTEXTURED:\n\/\/ x, y, width, height, handle, srcx, srcy, srcwidth, srcheight, blend\nif(len==40)\n{\nfloat x, y, width, height,\nsrcx, srcy, srcwidth, srcheight;\nint handle, blend; \/\/ blend is a color, use alpha component for blending\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nhandle=readInt(16, cmddata); \/\/ either an image handle or layer handle (if not in imageMap)\nsrcx=(float)readInt(20, cmddata);\nsrcy=(float)readInt(24, cmddata);\nsrcwidth=(float)readInt(28, cmddata);\nsrcheight=(float)readInt(32, cmddata);\nblend=readInt(36, cmddata);\n\/*\nif height < 0\ndisable blending\nif width < 0 (font mode, composite with background and blend with given color)\nblend with full RGBA color\nelse\nblend with alpha only\n*\/\n\/\/ System.out.println(\"DRAWTEXTURED: handle=\"+handle+\" dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") src=(\"+srcx+\",\"+srcy+\" \"+srcwidth+\"x\"+srcheight+\") blend=\"+Integer.toHexString(blend));\nboolean doBlend = true;\nif(height < 0) {\ndoBlend = false;\nheight *= -1;\n}\nif(width < 0) {\n\n{\nc.setBounds(parent.getInsets().left, parent.getInsets().top, parent.getWidth() - parent.getInsets().left - parent.getInsets().right,\nparent.getHeight() - parent.getInsets().top - parent.getInsets().bottom);\n\/\/System.out.println(\"LAYOUT frame bounds=\" + f.getBounds() + \" videoBounds=\" + videoBounds + \" parentBounds=\" + parent.getBounds());\n}\n};\nf.getContentPane().setLayout(layer);\ntry\n{\nbgImage = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/Background.jpg\"));\nensureImageIsLoaded(bgImage);\nlogoImage = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/SageLogo256.png\"));\nensureImageIsLoaded(logoImage);\n}\ncatch (Exception e)\n{\nSystem.out.println(\"ERROR:\" + e);\ne.printStackTrace();\n}\nf.setFocusTraversalKeysEnabled(false);\n\/*\nif not connecting to localhost:\n- draw background to bounds (scaled)\n- draw logo to {{2% from left, 15% from top}{20% view width, 7% view height}}, no clipping, alpha = 0.85, adjust size to keep aspect ratio\n- load Arial 32 bold\n- draw the following text, double spaced using Arial 32 bold, white with black shadow (offset by (+2,+2))\n\"SageTV Placeshifter is connecting to\"\n\"the server: \"+myConn.getServerName()\n\"Please Wait...\"\ntext is centered in the view on the middle line, use font metrics to determine proper location\ng.setFont(pleaseWaitFont);\ng.setColor(java.awt.Color.black);\ny += 2;\ng.drawString(str1, 2 + (getWidth()\/2) - (fm.stringWidth(str1)\/2), y + fm.getAscent());\ny += fm.getHeight();\ng.drawString(str2, 2 + (getWidth()\/2) - (fm.stringWidth(str2)\/2), y + fm.getAscent());\ny += 2*fm.getHeight();\ng.drawString(str3, 2 + (getWidth()\/2) - (fm.stringWidth(str3)\/2), y + fm.getAscent());\ng.setColor(java.awt.Color.white);\ny = (getHeight() \/ 2) - fh\/2;\ng.drawString(str1, (getWidth()\/2) - (fm.stringWidth(str1)\/2), y + fm.getAscent());\ny += fm.getHeight();\ng.drawString(str2, (getWidth()\/2) - (fm.stringWidth(str2)\/2), y + fm.getAscent());\ny += 2*fm.getHeight();\ng.drawString(str3, (getWidth()\/2) - (fm.stringWidth(str3)\/2), y + fm.getAscent());\n*\/\njava.awt.Dimension panelSize = f.getContentPane().getSize();\nc = new QuartzRendererView();\n\nsrcx, srcy, srcwidth, srcheight;\nint handle, blend; \/\/ blend is a color, use alpha component for blending\nx=(float)readInt(0, cmddata);\ny=(float)readInt(4, cmddata);\nwidth=(float)readInt(8, cmddata);\nheight=(float)readInt(12, cmddata);\nhandle=readInt(16, cmddata); \/\/ either an image handle or layer handle (if not in imageMap)\nsrcx=(float)readInt(20, cmddata);\nsrcy=(float)readInt(24, cmddata);\nsrcwidth=(float)readInt(28, cmddata);\nsrcheight=(float)readInt(32, cmddata);\nblend=readInt(36, cmddata);\n\/*\nif height < 0\ndisable blending\nif width < 0 (font mode, composite with background and blend with given color)\nblend with full RGBA color\nelse\nblend with alpha only\n*\/\n\/\/ System.out.println(\"DRAWTEXTURED: handle=\"+handle+\" dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") src=(\"+srcx+\",\"+srcy+\" \"+srcwidth+\"x\"+srcheight+\") blend=\"+Integer.toHexString(blend));\nboolean doBlend = true;\nif(height < 0) {\ndoBlend = false;\nheight *= -1;\n}\nif(width < 0) {\nwidth *= -1;\n} else {\nif(doBlend)\nblend |= 0x00ffffff; \/\/ only use alpha\n}\nLong imagePtr = (Long)imageMap.get(new Integer(handle));\njava.awt.geom.Rectangle2D.Float destRect = new java.awt.geom.Rectangle2D.Float(x,y,width,height);\njava.awt.geom.Rectangle2D.Float srcRect = new java.awt.geom.Rectangle2D.Float(srcx,srcy,srcwidth,srcheight);\nif(imagePtr != null) {\nmyConn.registerImageAccess(handle);\n\/\/ System.out.println(\" (drawing image) imagePtr=\"+imagePtr);\ndrawImage1(imagePtr.longValue(),\ndestRect, srcRect,\n(doBlend) ? new java.awt.Color(blend, true) : null);\n\nsrcheight=(float)readInt(32, cmddata);\nblend=readInt(36, cmddata);\n\/*\nif height < 0\ndisable blending\nif width < 0 (font mode, composite with background and blend with given color)\nblend with full RGBA color\nelse\nblend with alpha only\n*\/\n\/\/ System.out.println(\"DRAWTEXTURED: handle=\"+handle+\" dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") src=(\"+srcx+\",\"+srcy+\" \"+srcwidth+\"x\"+srcheight+\") blend=\"+Integer.toHexString(blend));\nboolean doBlend = true;\nif(height < 0) {\ndoBlend = false;\nheight *= -1;\n}\nif(width < 0) {\nwidth *= -1;\n} else {\nif(doBlend)\nblend |= 0x00ffffff; \/\/ only use alpha\n}\nLong imagePtr = (Long)imageMap.get(new Integer(handle));\njava.awt.geom.Rectangle2D.Float destRect = new java.awt.geom.Rectangle2D.Float(x,y,width,height);\njava.awt.geom.Rectangle2D.Float srcRect = new java.awt.geom.Rectangle2D.Float(srcx,srcy,srcwidth,srcheight);\nif(imagePtr != null) {\nmyConn.registerImageAccess(handle);\n\/\/ System.out.println(\" (drawing image) imagePtr=\"+imagePtr);\ndrawImage1(imagePtr.longValue(),\ndestRect, srcRect,\n(doBlend) ? new java.awt.Color(blend, true) : null);\n} else {\nimagePtr = (Long)layerMap.get(new Integer(handle));\nif(imagePtr != null) {\nmyConn.registerImageAccess(handle);\n\/\/ System.out.println(\" (compositing surface) layerPtr=\"+Long.toHexString(imagePtr.longValue())+\" currentLayer=\"+currentLayer);\nfloat alpha = (doBlend ? (float)(((blend >> 24)&0xff))\/255.0f : 1.0f);\ncomposite0(imagePtr.longValue(), currentLayer, srcRect, destRect, alpha, doBlend);\n}\nelse\n{\n\nelse\nblend with alpha only\n*\/\n\/\/ System.out.println(\"DRAWTEXTURED: handle=\"+handle+\" dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") src=(\"+srcx+\",\"+srcy+\" \"+srcwidth+\"x\"+srcheight+\") blend=\"+Integer.toHexString(blend));\nboolean doBlend = true;\nif(height < 0) {\ndoBlend = false;\nheight *= -1;\n}\nif(width < 0) {\nwidth *= -1;\n} else {\nif(doBlend)\nblend |= 0x00ffffff; \/\/ only use alpha\n}\nLong imagePtr = (Long)imageMap.get(new Integer(handle));\njava.awt.geom.Rectangle2D.Float destRect = new java.awt.geom.Rectangle2D.Float(x,y,width,height);\njava.awt.geom.Rectangle2D.Float srcRect = new java.awt.geom.Rectangle2D.Float(srcx,srcy,srcwidth,srcheight);\nif(imagePtr != null) {\nmyConn.registerImageAccess(handle);\n\/\/ System.out.println(\" (drawing image) imagePtr=\"+imagePtr);\ndrawImage1(imagePtr.longValue(),\ndestRect, srcRect,\n(doBlend) ? new java.awt.Color(blend, true) : null);\n} else {\nimagePtr = (Long)layerMap.get(new Integer(handle));\nif(imagePtr != null) {\nmyConn.registerImageAccess(handle);\n\/\/ System.out.println(\" (compositing surface) layerPtr=\"+Long.toHexString(imagePtr.longValue())+\" currentLayer=\"+currentLayer);\nfloat alpha = (doBlend ? (float)(((blend >> 24)&0xff))\/255.0f : 1.0f);\ncomposite0(imagePtr.longValue(), currentLayer, srcRect, destRect, alpha, doBlend);\n}\nelse\n{\nSystem.out.println(\"ERROR invalid handle passed for texture rendering of: \" + handle);\nabortRenderCycle = true;\n}\n}\n}\nelse\n{\n\n}\nif(width < 0) {\nwidth *= -1;\n} else {\nif(doBlend)\nblend |= 0x00ffffff; \/\/ only use alpha\n}\nLong imagePtr = (Long)imageMap.get(new Integer(handle));\njava.awt.geom.Rectangle2D.Float destRect = new java.awt.geom.Rectangle2D.Float(x,y,width,height);\njava.awt.geom.Rectangle2D.Float srcRect = new java.awt.geom.Rectangle2D.Float(srcx,srcy,srcwidth,srcheight);\nif(imagePtr != null) {\nmyConn.registerImageAccess(handle);\n\/\/ System.out.println(\" (drawing image) imagePtr=\"+imagePtr);\ndrawImage1(imagePtr.longValue(),\ndestRect, srcRect,\n(doBlend) ? new java.awt.Color(blend, true) : null);\n} else {\nimagePtr = (Long)layerMap.get(new Integer(handle));\nif(imagePtr != null) {\nmyConn.registerImageAccess(handle);\n\/\/ System.out.println(\" (compositing surface) layerPtr=\"+Long.toHexString(imagePtr.longValue())+\" currentLayer=\"+currentLayer);\nfloat alpha = (doBlend ? (float)(((blend >> 24)&0xff))\/255.0f : 1.0f);\ncomposite0(imagePtr.longValue(), currentLayer, srcRect, destRect, alpha, doBlend);\n}\nelse\n{\nSystem.out.println(\"ERROR invalid handle passed for texture rendering of: \" + handle);\nabortRenderCycle = true;\n}\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXTURED : \" + len);\n}\nbreak;\ncase GFXCMD_DRAWLINE:\n\/\/ x1, y1, x2, y2, argb1, argb2\nif(len==24)\n{\nfloat x1, y1, x2, y2;\n\nimagePtr = (Long)layerMap.get(new Integer(handle));\nif(imagePtr != null) {\nmyConn.registerImageAccess(handle);\n\/\/ System.out.println(\" (compositing surface) layerPtr=\"+Long.toHexString(imagePtr.longValue())+\" currentLayer=\"+currentLayer);\nfloat alpha = (doBlend ? (float)(((blend >> 24)&0xff))\/255.0f : 1.0f);\ncomposite0(imagePtr.longValue(), currentLayer, srcRect, destRect, alpha, doBlend);\n}\nelse\n{\nSystem.out.println(\"ERROR invalid handle passed for texture rendering of: \" + handle);\nabortRenderCycle = true;\n}\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXTURED : \" + len);\n}\nbreak;\ncase GFXCMD_DRAWLINE:\n\/\/ x1, y1, x2, y2, argb1, argb2\nif(len==24)\n{\nfloat x1, y1, x2, y2;\nint argb1, argb2;\nx1=readInt(0, cmddata);\ny1=readInt(4, cmddata);\nx2=readInt(8, cmddata);\ny2=readInt(12, cmddata);\nargb1=readInt(16, cmddata);\nargb2=readInt(20, cmddata);\n\/\/ System.out.println(\"DRAWLINE: start=(\"+x1+\",\"+y1+\") end=(\"+x2+\",\"+y2+\") argb1=\"+Integer.toHexString(argb1)+\" argb2=\"+Integer.toHexString(argb2));\ndrawLine0(x1, y1, x2, y2, 1, new java.awt.Color(argb1, true));\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWLINE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\n\n}\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXTURED : \" + len);\n}\nbreak;\ncase GFXCMD_DRAWLINE:\n\/\/ x1, y1, x2, y2, argb1, argb2\nif(len==24)\n{\nfloat x1, y1, x2, y2;\nint argb1, argb2;\nx1=readInt(0, cmddata);\ny1=readInt(4, cmddata);\nx2=readInt(8, cmddata);\ny2=readInt(12, cmddata);\nargb1=readInt(16, cmddata);\nargb2=readInt(20, cmddata);\n\/\/ System.out.println(\"DRAWLINE: start=(\"+x1+\",\"+y1+\") end=(\"+x2+\",\"+y2+\") argb1=\"+Integer.toHexString(argb1)+\" argb2=\"+Integer.toHexString(argb2));\ndrawLine0(x1, y1, x2, y2, 1, new java.awt.Color(argb1, true));\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWLINE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\nint imghandle = 0;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ System.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\nimghandle = 0;\n}\n\n\/\/ x1, y1, x2, y2, argb1, argb2\nif(len==24)\n{\nfloat x1, y1, x2, y2;\nint argb1, argb2;\nx1=readInt(0, cmddata);\ny1=readInt(4, cmddata);\nx2=readInt(8, cmddata);\ny2=readInt(12, cmddata);\nargb1=readInt(16, cmddata);\nargb2=readInt(20, cmddata);\n\/\/ System.out.println(\"DRAWLINE: start=(\"+x1+\",\"+y1+\") end=(\"+x2+\",\"+y2+\") argb1=\"+Integer.toHexString(argb1)+\" argb2=\"+Integer.toHexString(argb2));\ndrawLine0(x1, y1, x2, y2, 1, new java.awt.Color(argb1, true));\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWLINE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\nint imghandle = 0;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ System.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\nimghandle = 0;\n}\nelse\n{\n\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n}\n\nx2=readInt(8, cmddata);\ny2=readInt(12, cmddata);\nargb1=readInt(16, cmddata);\nargb2=readInt(20, cmddata);\n\/\/ System.out.println(\"DRAWLINE: start=(\"+x1+\",\"+y1+\") end=(\"+x2+\",\"+y2+\") argb1=\"+Integer.toHexString(argb1)+\" argb2=\"+Integer.toHexString(argb2));\ndrawLine0(x1, y1, x2, y2, 1, new java.awt.Color(argb1, true));\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWLINE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\nint imghandle = 0;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ System.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\nimghandle = 0;\n}\nelse\n{\n\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n}\n\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWLINE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\nint imghandle = 0;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ System.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\nimghandle = 0;\n}\nelse\n{\n\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\nint width, height;\nint imghandle = readInt(0, cmddata);\n\n}\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\nint imghandle = 0;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ System.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\nimghandle = 0;\n}\nelse\n{\n\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\nint width, height;\nint imghandle = readInt(0, cmddata);\nwidth=readInt(4, cmddata);\nheight=readInt(8, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\nint imghandle = 0;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ System.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\nimghandle = 0;\n}\nelse\n{\n\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\nint width, height;\nint imghandle = readInt(0, cmddata);\nwidth=readInt(4, cmddata);\nheight=readInt(8, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\nimghandle = 0;\n}\nelse\n{\n\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\nint width, height;\nint imghandle = readInt(0, cmddata);\nwidth=readInt(4, cmddata);\nheight=readInt(8, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\/\/ Keep freeing the oldest image until we have enough memory to do this\nint oldestImage = myConn.getOldestImage();\nif (oldestImage != 0)\n{\nSystem.out.println(\"Freeing image to make room in cache\");\nunloadImage(oldestImage);\nmyConn.postImageUnload(oldestImage);\n}\nelse\n{\nSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\nbreak;\n\nimageCacheSize += width * height * 4;\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\nint width, height;\nint imghandle = readInt(0, cmddata);\nwidth=readInt(4, cmddata);\nheight=readInt(8, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\/\/ Keep freeing the oldest image until we have enough memory to do this\nint oldestImage = myConn.getOldestImage();\nif (oldestImage != 0)\n{\nSystem.out.println(\"Freeing image to make room in cache\");\nunloadImage(oldestImage);\nmyConn.postImageUnload(oldestImage);\n}\nelse\n{\nSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\nbreak;\n}\n}\nlong imagePtr = createNewImage0(width, height);\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\nmyConn.registerImageAccess(imghandle);\nhasret[0]=0;\n}\n\n}\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\nint imghandle = 0;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ System.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\nimghandle = 0;\n}\nelse\n{\n\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\nint width, height;\nint imghandle = readInt(0, cmddata);\nwidth=readInt(4, cmddata);\nheight=readInt(8, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\nint imghandle = 0;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ System.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\nimghandle = 0;\n}\nelse\n{\n\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\nint width, height;\nint imghandle = readInt(0, cmddata);\nwidth=readInt(4, cmddata);\nheight=readInt(8, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\n\/\/ x1, y1, x2, y2, argb1, argb2\nif(len==24)\n{\nfloat x1, y1, x2, y2;\nint argb1, argb2;\nx1=readInt(0, cmddata);\ny1=readInt(4, cmddata);\nx2=readInt(8, cmddata);\ny2=readInt(12, cmddata);\nargb1=readInt(16, cmddata);\nargb2=readInt(20, cmddata);\n\/\/ System.out.println(\"DRAWLINE: start=(\"+x1+\",\"+y1+\") end=(\"+x2+\",\"+y2+\") argb1=\"+Integer.toHexString(argb1)+\" argb2=\"+Integer.toHexString(argb2));\ndrawLine0(x1, y1, x2, y2, 1, new java.awt.Color(argb1, true));\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWLINE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\nint imghandle = 0;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ System.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\nimghandle = 0;\n}\nelse\n{\n\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n}\n\nlong imagePtr = createNewImage0(width, height);\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\nmyConn.registerImageAccess(imghandle);\nhasret[0]=0;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGETARGETED : \" + len);\n}\nbreak;\ncase GFXCMD_CREATESURFACE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\nint handle = handleCount++;;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ width\/height is managed here\nlong layerPtr = createLayer0(c.getSize());\nlayerMap.put(new Integer(handle), new Long(layerPtr));\n\/\/ System.out.println(\"CREATESURFACE: (\"+width+\",\"+height+\") handle=\"+handle+\" layerPtr=\"+layerPtr);\nhasret[0]=1;\nreturn handle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_CREATESURFACE : \" + len);\n}\nbreak;\ncase GFXCMD_PREPIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\n\/\/int imghandle = handleCount++;;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\nint imghandle = 1;\n\nimageCacheSize += width * height * 4;\nmyConn.registerImageAccess(imghandle);\nhasret[0]=0;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGETARGETED : \" + len);\n}\nbreak;\ncase GFXCMD_CREATESURFACE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\nint handle = handleCount++;;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ width\/height is managed here\nlong layerPtr = createLayer0(c.getSize());\nlayerMap.put(new Integer(handle), new Long(layerPtr));\n\/\/ System.out.println(\"CREATESURFACE: (\"+width+\",\"+height+\") handle=\"+handle+\" layerPtr=\"+layerPtr);\nhasret[0]=1;\nreturn handle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_CREATESURFACE : \" + len);\n}\nbreak;\ncase GFXCMD_PREPIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\n\/\/int imghandle = handleCount++;;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\nint imghandle = 1;\n\/\/ System.out.println(\"PREPIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\nimghandle = 0;\n\n\/\/ x1, y1, x2, y2, argb1, argb2\nif(len==24)\n{\nfloat x1, y1, x2, y2;\nint argb1, argb2;\nx1=readInt(0, cmddata);\ny1=readInt(4, cmddata);\nx2=readInt(8, cmddata);\ny2=readInt(12, cmddata);\nargb1=readInt(16, cmddata);\nargb2=readInt(20, cmddata);\n\/\/ System.out.println(\"DRAWLINE: start=(\"+x1+\",\"+y1+\") end=(\"+x2+\",\"+y2+\") argb1=\"+Integer.toHexString(argb1)+\" argb2=\"+Integer.toHexString(argb2));\ndrawLine0(x1, y1, x2, y2, 1, new java.awt.Color(argb1, true));\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWLINE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\nint imghandle = 0;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ System.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\nimghandle = 0;\n}\nelse\n{\n\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n}\n\nint handle = handleCount++;;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ width\/height is managed here\nlong layerPtr = createLayer0(c.getSize());\nlayerMap.put(new Integer(handle), new Long(layerPtr));\n\/\/ System.out.println(\"CREATESURFACE: (\"+width+\",\"+height+\") handle=\"+handle+\" layerPtr=\"+layerPtr);\nhasret[0]=1;\nreturn handle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_CREATESURFACE : \" + len);\n}\nbreak;\ncase GFXCMD_PREPIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\n\/\/int imghandle = handleCount++;;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\nint imghandle = 1;\n\/\/ System.out.println(\"PREPIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\nimghandle = 0;\nelse if (len >= 12)\n{\n\/\/ We've got enough room for it and there's a cache ID, check if we've got it cached locally\nint strlen = readInt(8, cmddata);\nif (strlen > 1)\n{\nString rezName = new String(cmddata, 16, strlen - 1);\n\/\/ System.out.println(\" rezName=\"+rezName);\nlastImageResourceID = rezName;\n\/\/ We use this hashcode to match it up on the loadCompressedImage call so we know we're caching the right thing\nlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\njava.io.File cachedFile = myConn.getCachedImageFile(rezName);\nif (cachedFile != null)\n{\n\nlong layerPtr = createLayer0(c.getSize());\nlayerMap.put(new Integer(handle), new Long(layerPtr));\n\/\/ System.out.println(\"CREATESURFACE: (\"+width+\",\"+height+\") handle=\"+handle+\" layerPtr=\"+layerPtr);\nhasret[0]=1;\nreturn handle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_CREATESURFACE : \" + len);\n}\nbreak;\ncase GFXCMD_PREPIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\n\/\/int imghandle = handleCount++;;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\nint imghandle = 1;\n\/\/ System.out.println(\"PREPIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\nimghandle = 0;\nelse if (len >= 12)\n{\n\/\/ We've got enough room for it and there's a cache ID, check if we've got it cached locally\nint strlen = readInt(8, cmddata);\nif (strlen > 1)\n{\nString rezName = new String(cmddata, 16, strlen - 1);\n\/\/ System.out.println(\" rezName=\"+rezName);\nlastImageResourceID = rezName;\n\/\/ We use this hashcode to match it up on the loadCompressedImage call so we know we're caching the right thing\nlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\njava.io.File cachedFile = myConn.getCachedImageFile(rezName);\nif (cachedFile != null)\n{\n\/\/ We've got it locally in our cache! Read it from there.\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n{\n\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_CREATESURFACE : \" + len);\n}\nbreak;\ncase GFXCMD_PREPIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\n\/\/int imghandle = handleCount++;;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\nint imghandle = 1;\n\/\/ System.out.println(\"PREPIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\nimghandle = 0;\nelse if (len >= 12)\n{\n\/\/ We've got enough room for it and there's a cache ID, check if we've got it cached locally\nint strlen = readInt(8, cmddata);\nif (strlen > 1)\n{\nString rezName = new String(cmddata, 16, strlen - 1);\n\/\/ System.out.println(\" rezName=\"+rezName);\nlastImageResourceID = rezName;\n\/\/ We use this hashcode to match it up on the loadCompressedImage call so we know we're caching the right thing\nlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\njava.io.File cachedFile = myConn.getCachedImageFile(rezName);\nif (cachedFile != null)\n{\n\/\/ We've got it locally in our cache! Read it from there.\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n{\njava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\nif(imgSize != null)\n{\nif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\nbreak;\ncase GFXCMD_PREPIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\n\/\/int imghandle = handleCount++;;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\nint imghandle = 1;\n\/\/ System.out.println(\"PREPIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\nimghandle = 0;\nelse if (len >= 12)\n{\n\/\/ We've got enough room for it and there's a cache ID, check if we've got it cached locally\nint strlen = readInt(8, cmddata);\nif (strlen > 1)\n{\nString rezName = new String(cmddata, 16, strlen - 1);\n\/\/ System.out.println(\" rezName=\"+rezName);\nlastImageResourceID = rezName;\n\/\/ We use this hashcode to match it up on the loadCompressedImage call so we know we're caching the right thing\nlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\njava.io.File cachedFile = myConn.getCachedImageFile(rezName);\nif (cachedFile != null)\n{\n\/\/ We've got it locally in our cache! Read it from there.\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n{\njava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\nif(imgSize != null)\n{\nif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\/\/ valid image in cache, use it\nimghandle = handleCount++;\n\/\/ System.out.println(\" loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\nimageMap.put(new Integer(imghandle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\n\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\n\/\/int imghandle = handleCount++;;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\nint imghandle = 1;\n\/\/ System.out.println(\"PREPIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\nimghandle = 0;\nelse if (len >= 12)\n{\n\/\/ We've got enough room for it and there's a cache ID, check if we've got it cached locally\nint strlen = readInt(8, cmddata);\nif (strlen > 1)\n{\nString rezName = new String(cmddata, 16, strlen - 1);\n\/\/ System.out.println(\" rezName=\"+rezName);\nlastImageResourceID = rezName;\n\/\/ We use this hashcode to match it up on the loadCompressedImage call so we know we're caching the right thing\nlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\njava.io.File cachedFile = myConn.getCachedImageFile(rezName);\nif (cachedFile != null)\n{\n\/\/ We've got it locally in our cache! Read it from there.\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n{\njava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\nif(imgSize != null)\n{\nif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\/\/ valid image in cache, use it\nimghandle = handleCount++;\n\/\/ System.out.println(\" loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\nimageMap.put(new Integer(imghandle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\nhasret[0] = 1;\nreturn -1 * imghandle;\n\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\nint imghandle = 1;\n\/\/ System.out.println(\"PREPIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\nimghandle = 0;\nelse if (len >= 12)\n{\n\/\/ We've got enough room for it and there's a cache ID, check if we've got it cached locally\nint strlen = readInt(8, cmddata);\nif (strlen > 1)\n{\nString rezName = new String(cmddata, 16, strlen - 1);\n\/\/ System.out.println(\" rezName=\"+rezName);\nlastImageResourceID = rezName;\n\/\/ We use this hashcode to match it up on the loadCompressedImage call so we know we're caching the right thing\nlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\njava.io.File cachedFile = myConn.getCachedImageFile(rezName);\nif (cachedFile != null)\n{\n\/\/ We've got it locally in our cache! Read it from there.\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n{\njava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\nif(imgSize != null)\n{\nif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\/\/ valid image in cache, use it\nimghandle = handleCount++;\n\/\/ System.out.println(\" loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\nimageMap.put(new Integer(imghandle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\nhasret[0] = 1;\nreturn -1 * imghandle;\n}\nelse\nfreeNativeImage0(imagePtr);\n}\nelse\n\nint strlen = readInt(8, cmddata);\nif (strlen > 1)\n{\nString rezName = new String(cmddata, 16, strlen - 1);\n\/\/ System.out.println(\" rezName=\"+rezName);\nlastImageResourceID = rezName;\n\/\/ We use this hashcode to match it up on the loadCompressedImage call so we know we're caching the right thing\nlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\njava.io.File cachedFile = myConn.getCachedImageFile(rezName);\nif (cachedFile != null)\n{\n\/\/ We've got it locally in our cache! Read it from there.\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n{\njava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\nif(imgSize != null)\n{\nif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\/\/ valid image in cache, use it\nimghandle = handleCount++;\n\/\/ System.out.println(\" loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\nimageMap.put(new Integer(imghandle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\nhasret[0] = 1;\nreturn -1 * imghandle;\n}\nelse\nfreeNativeImage0(imagePtr);\n}\nelse\nfreeNativeImage0(imagePtr);\n}\n}\n}\n}\n\/\/imghandle=STBGFX.GFX_loadImage(width, height);\nhasret[0]=1;\nreturn imghandle;\n}\n\n{\nString rezName = new String(cmddata, 16, strlen - 1);\n\/\/ System.out.println(\" rezName=\"+rezName);\nlastImageResourceID = rezName;\n\/\/ We use this hashcode to match it up on the loadCompressedImage call so we know we're caching the right thing\nlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\njava.io.File cachedFile = myConn.getCachedImageFile(rezName);\nif (cachedFile != null)\n{\n\/\/ We've got it locally in our cache! Read it from there.\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n{\njava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\nif(imgSize != null)\n{\nif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\/\/ valid image in cache, use it\nimghandle = handleCount++;\n\/\/ System.out.println(\" loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\nimageMap.put(new Integer(imghandle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\nhasret[0] = 1;\nreturn -1 * imghandle;\n}\nelse\nfreeNativeImage0(imagePtr);\n}\nelse\nfreeNativeImage0(imagePtr);\n}\n}\n}\n}\n\/\/imghandle=STBGFX.GFX_loadImage(width, height);\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\n\n{\nif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\/\/ valid image in cache, use it\nimghandle = handleCount++;\n\/\/ System.out.println(\" loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\nimageMap.put(new Integer(imghandle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\nhasret[0] = 1;\nreturn -1 * imghandle;\n}\nelse\nfreeNativeImage0(imagePtr);\n}\nelse\nfreeNativeImage0(imagePtr);\n}\n}\n}\n}\n\/\/imghandle=STBGFX.GFX_loadImage(width, height);\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_PREPIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_PREPIMAGETARGETED:\n\/\/ handle, width, height, [rezID]\nif(len>=12)\n{\nint imghandle, width, height;\nimghandle = readInt(0, cmddata);\nwidth=readInt(4, cmddata);\nheight=readInt(8, cmddata);\nint strlen = readInt(12, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\/\/ Keep freeing the oldest image until we have enough memory to do this\n\n}\nelse\nfreeNativeImage0(imagePtr);\n}\nelse\nfreeNativeImage0(imagePtr);\n}\n}\n}\n}\n\/\/imghandle=STBGFX.GFX_loadImage(width, height);\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_PREPIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_PREPIMAGETARGETED:\n\/\/ handle, width, height, [rezID]\nif(len>=12)\n{\nint imghandle, width, height;\nimghandle = readInt(0, cmddata);\nwidth=readInt(4, cmddata);\nheight=readInt(8, cmddata);\nint strlen = readInt(12, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\/\/ Keep freeing the oldest image until we have enough memory to do this\nint oldestImage = myConn.getOldestImage();\nif (oldestImage != 0)\n{\nSystem.out.println(\"Freeing image to make room in cache\");\nunloadImage(oldestImage);\nmyConn.postImageUnload(oldestImage);\n}\nelse\n{\nSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\n\nimageCacheSize += width * height * 4;\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\nint width, height;\nint imghandle = readInt(0, cmddata);\nwidth=readInt(4, cmddata);\nheight=readInt(8, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\/\/ Keep freeing the oldest image until we have enough memory to do this\nint oldestImage = myConn.getOldestImage();\nif (oldestImage != 0)\n{\nSystem.out.println(\"Freeing image to make room in cache\");\nunloadImage(oldestImage);\nmyConn.postImageUnload(oldestImage);\n}\nelse\n{\nSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\nbreak;\n}\n}\nlong imagePtr = createNewImage0(width, height);\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\nmyConn.registerImageAccess(imghandle);\nhasret[0]=0;\n}\n\nheight=readInt(8, cmddata);\nint strlen = readInt(12, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\/\/ Keep freeing the oldest image until we have enough memory to do this\nint oldestImage = myConn.getOldestImage();\nif (oldestImage != 0)\n{\nSystem.out.println(\"Freeing image to make room in cache\");\nunloadImage(oldestImage);\nmyConn.postImageUnload(oldestImage);\n}\nelse\n{\nSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\nbreak;\n}\n}\nif (len >= 16)\n{\n\/\/ We will not have this cached locally...but setup our vars to track it\nString rezName = new String(cmddata, 20, strlen - 1);\nlastImageResourceID = rezName;\nlastImageResourceIDHandle = imghandle;\nSystem.out.println(\"Prepped targeted image with handle \" + imghandle + \" resource=\" + rezName);\n}\nmyConn.registerImageAccess(imghandle);\nhasret[0]=0;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_PREPIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADCACHEDIMAGE:\n\/\/ width, height\nif(len>=18)\n{\nint width, height, imghandle;\nimghandle = readInt(0, cmddata);\nwidth = readInt(4, cmddata);\n\n\/\/ x1, y1, x2, y2, argb1, argb2\nif(len==24)\n{\nfloat x1, y1, x2, y2;\nint argb1, argb2;\nx1=readInt(0, cmddata);\ny1=readInt(4, cmddata);\nx2=readInt(8, cmddata);\ny2=readInt(12, cmddata);\nargb1=readInt(16, cmddata);\nargb2=readInt(20, cmddata);\n\/\/ System.out.println(\"DRAWLINE: start=(\"+x1+\",\"+y1+\") end=(\"+x2+\",\"+y2+\") argb1=\"+Integer.toHexString(argb1)+\" argb2=\"+Integer.toHexString(argb2));\ndrawLine0(x1, y1, x2, y2, 1, new java.awt.Color(argb1, true));\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_DRAWLINE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGE:\n\/\/ width, height\nif(len>=8)\n{\nint width, height;\nint imghandle = 0;\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\n\/\/ System.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\nimghandle = 0;\n}\nelse\n{\n\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n}\n\nimageCacheSize += width * height * 4;\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\nint width, height;\nint imghandle = readInt(0, cmddata);\nwidth=readInt(4, cmddata);\nheight=readInt(8, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\/\/ Keep freeing the oldest image until we have enough memory to do this\nint oldestImage = myConn.getOldestImage();\nif (oldestImage != 0)\n{\nSystem.out.println(\"Freeing image to make room in cache\");\nunloadImage(oldestImage);\nmyConn.postImageUnload(oldestImage);\n}\nelse\n{\nSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\nbreak;\n}\n}\nlong imagePtr = createNewImage0(width, height);\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\nmyConn.registerImageAccess(imghandle);\nhasret[0]=0;\n}\n\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\nint imghandle = 1;\n\/\/ System.out.println(\"PREPIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\nimghandle = 0;\nelse if (len >= 12)\n{\n\/\/ We've got enough room for it and there's a cache ID, check if we've got it cached locally\nint strlen = readInt(8, cmddata);\nif (strlen > 1)\n{\nString rezName = new String(cmddata, 16, strlen - 1);\n\/\/ System.out.println(\" rezName=\"+rezName);\nlastImageResourceID = rezName;\n\/\/ We use this hashcode to match it up on the loadCompressedImage call so we know we're caching the right thing\nlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\njava.io.File cachedFile = myConn.getCachedImageFile(rezName);\nif (cachedFile != null)\n{\n\/\/ We've got it locally in our cache! Read it from there.\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n{\njava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\nif(imgSize != null)\n{\nif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\/\/ valid image in cache, use it\nimghandle = handleCount++;\n\/\/ System.out.println(\" loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\nimageMap.put(new Integer(imghandle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\nhasret[0] = 1;\nreturn -1 * imghandle;\n}\nelse\nfreeNativeImage0(imagePtr);\n}\nelse\n\nwidth=readInt(0, cmddata);\nheight=readInt(4, cmddata);\nint imghandle = 1;\n\/\/ System.out.println(\"PREPIMAGE: size=(\"+width+\"x\"+height+\")\");\nif (width * height * 4 + imageCacheSize > imageCacheLimit)\nimghandle = 0;\nelse if (len >= 12)\n{\n\/\/ We've got enough room for it and there's a cache ID, check if we've got it cached locally\nint strlen = readInt(8, cmddata);\nif (strlen > 1)\n{\nString rezName = new String(cmddata, 16, strlen - 1);\n\/\/ System.out.println(\" rezName=\"+rezName);\nlastImageResourceID = rezName;\n\/\/ We use this hashcode to match it up on the loadCompressedImage call so we know we're caching the right thing\nlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\njava.io.File cachedFile = myConn.getCachedImageFile(rezName);\nif (cachedFile != null)\n{\n\/\/ We've got it locally in our cache! Read it from there.\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n{\njava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\nif(imgSize != null)\n{\nif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\/\/ valid image in cache, use it\nimghandle = handleCount++;\n\/\/ System.out.println(\" loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\nimageMap.put(new Integer(imghandle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\nhasret[0] = 1;\nreturn -1 * imghandle;\n}\nelse\nfreeNativeImage0(imagePtr);\n}\nelse\n\nint strlen = readInt(8, cmddata);\nif (strlen > 1)\n{\nString rezName = new String(cmddata, 16, strlen - 1);\n\/\/ System.out.println(\" rezName=\"+rezName);\nlastImageResourceID = rezName;\n\/\/ We use this hashcode to match it up on the loadCompressedImage call so we know we're caching the right thing\nlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\njava.io.File cachedFile = myConn.getCachedImageFile(rezName);\nif (cachedFile != null)\n{\n\/\/ We've got it locally in our cache! Read it from there.\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n{\njava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\nif(imgSize != null)\n{\nif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\/\/ valid image in cache, use it\nimghandle = handleCount++;\n\/\/ System.out.println(\" loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\nimageMap.put(new Integer(imghandle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\nhasret[0] = 1;\nreturn -1 * imghandle;\n}\nelse\nfreeNativeImage0(imagePtr);\n}\nelse\nfreeNativeImage0(imagePtr);\n}\n}\n}\n}\n\/\/imghandle=STBGFX.GFX_loadImage(width, height);\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n\nif (cachedFile != null)\n{\n\/\/ We've got it locally in our cache! Read it from there.\nSystem.out.println(\"Image found in cache!\");\n\/\/ We've got it locally in our cache! Read it from there.\nlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\nif(imagePtr != 0)\n{\njava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\nif(imgSize != null && imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\/\/ valid image in cache, use it\n\/\/ System.out.println(\" loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\nimageMap.put(new Integer(imghandle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\n}\nelse\n{\nif (imgSize != null)\n{\n\/\/ It doesn't match the cache\nSystem.out.println(\"CACHE ID verification failed for rezName=\" + rezName + \" target=\" + width + \"x\" + height + \" actual=\" + imgSize.getWidth() + \"x\" + imgSize.getHeight());\n}\nelse\nSystem.out.println(\"CACHE Load failed for rezName=\" + rezName);\ncachedFile.delete();\nfreeNativeImage0(imagePtr);\n\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\nmyConn.postImageUnload(imghandle);\nmyConn.postOfflineCacheChange(false, rezName);\n}\n}\nelse\n{\ncachedFile.delete();\n\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\nmyConn.postImageUnload(imghandle);\nmyConn.postOfflineCacheChange(false, rezName);\n}\n}\nelse\n\n{\njava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\nif(imgSize != null && imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\/\/ valid image in cache, use it\n\/\/ System.out.println(\" loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\nimageMap.put(new Integer(imghandle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\n}\nelse\n{\nif (imgSize != null)\n{\n\/\/ It doesn't match the cache\nSystem.out.println(\"CACHE ID verification failed for rezName=\" + rezName + \" target=\" + width + \"x\" + height + \" actual=\" + imgSize.getWidth() + \"x\" + imgSize.getHeight());\n}\nelse\nSystem.out.println(\"CACHE Load failed for rezName=\" + rezName);\ncachedFile.delete();\nfreeNativeImage0(imagePtr);\n\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\nmyConn.postImageUnload(imghandle);\nmyConn.postOfflineCacheChange(false, rezName);\n}\n}\nelse\n{\ncachedFile.delete();\n\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\nmyConn.postImageUnload(imghandle);\nmyConn.postOfflineCacheChange(false, rezName);\n}\n}\nelse\n{\nSystem.out.println(\"ERROR Image not found in cache that should be there! rezName=\" + rezName);\n\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\nmyConn.postImageUnload(imghandle);\nmyConn.postOfflineCacheChange(false, rezName);\n}\n}\n\n{\njava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\nif(imgSize != null && imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\/\/ valid image in cache, use it\n\/\/ System.out.println(\" loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\nimageMap.put(new Integer(imghandle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\n}\nelse\n{\nif (imgSize != null)\n{\n\/\/ It doesn't match the cache\nSystem.out.println(\"CACHE ID verification failed for rezName=\" + rezName + \" target=\" + width + \"x\" + height + \" actual=\" + imgSize.getWidth() + \"x\" + imgSize.getHeight());\n}\nelse\nSystem.out.println(\"CACHE Load failed for rezName=\" + rezName);\ncachedFile.delete();\nfreeNativeImage0(imagePtr);\n\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\nmyConn.postImageUnload(imghandle);\nmyConn.postOfflineCacheChange(false, rezName);\n}\n}\nelse\n{\ncachedFile.delete();\n\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\nmyConn.postImageUnload(imghandle);\nmyConn.postOfflineCacheChange(false, rezName);\n}\n}\nelse\n{\nSystem.out.println(\"ERROR Image not found in cache that should be there! rezName=\" + rezName);\n\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\nmyConn.postImageUnload(imghandle);\nmyConn.postOfflineCacheChange(false, rezName);\n}\n}\n\n{\njava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\nif(imgSize != null && imgSize.getWidth() == width && imgSize.getHeight() == height)\n{\n\/\/ valid image in cache, use it\n\/\/ System.out.println(\" loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\nimageMap.put(new Integer(imghandle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\n}\nelse\n{\nif (imgSize != null)\n{\n\/\/ It doesn't match the cache\nSystem.out.println(\"CACHE ID verification failed for rezName=\" + rezName + \" target=\" + width + \"x\" + height + \" actual=\" + imgSize.getWidth() + \"x\" + imgSize.getHeight());\n}\nelse\nSystem.out.println(\"CACHE Load failed for rezName=\" + rezName);\ncachedFile.delete();\nfreeNativeImage0(imagePtr);\n\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\nmyConn.postImageUnload(imghandle);\nmyConn.postOfflineCacheChange(false, rezName);\n}\n}\nelse\n{\ncachedFile.delete();\n\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\nmyConn.postImageUnload(imghandle);\nmyConn.postOfflineCacheChange(false, rezName);\n}\n}\nelse\n{\nSystem.out.println(\"ERROR Image not found in cache that should be there! rezName=\" + rezName);\n\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\nmyConn.postImageUnload(imghandle);\nmyConn.postOfflineCacheChange(false, rezName);\n}\n}\n\nimghandle = 0;\n}\nelse\n{\n\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\nint width, height;\nint imghandle = readInt(0, cmddata);\nwidth=readInt(4, cmddata);\nheight=readInt(8, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\/\/ Keep freeing the oldest image until we have enough memory to do this\nint oldestImage = myConn.getOldestImage();\nif (oldestImage != 0)\n{\nSystem.out.println(\"Freeing image to make room in cache\");\nunloadImage(oldestImage);\nmyConn.postImageUnload(oldestImage);\n}\nelse\n{\nSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\nbreak;\n\nimghandle = 0;\n}\nelse\n{\n\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\nint width, height;\nint imghandle = readInt(0, cmddata);\nwidth=readInt(4, cmddata);\nheight=readInt(8, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\/\/ Keep freeing the oldest image until we have enough memory to do this\nint oldestImage = myConn.getOldestImage();\nif (oldestImage != 0)\n{\nSystem.out.println(\"Freeing image to make room in cache\");\nunloadImage(oldestImage);\nmyConn.postImageUnload(oldestImage);\n}\nelse\n{\nSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\nbreak;\n\ncase GFXCMD_UNLOADIMAGE:\n\/\/ handle\nif(len==4)\n{\nint handle;\nhandle=readInt(0, cmddata);\nunloadImage(handle);\nmyConn.clearImageAccess(handle);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_UNLOADIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_SETTARGETSURFACE:\n\/\/ handle\nif(len==4)\n{\nint handle;\nhandle=readInt(0, cmddata);\n\/\/STBGFX.GFX_unloadImage(handle);\nLong layerPtr = (Long)layerMap.get(new Integer(handle));\n\/\/ System.out.println(\"SETTARGETSURFACE: handle=\"+handle+\" layerPtr=\"+ (layerPtr == null ? \"0\" : Long.toHexString(layerPtr.longValue())));\ncurrentLayer = (layerPtr != null) ? layerPtr.longValue() : 0;\njava.awt.Rectangle clipRect = new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight());\nsetLayer0(currentLayer, c.getSize(), clipRect);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_SETTARGETSURFACE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADFONT:\n\/\/ namelen, name, style, size\nif(len>=12 && len>=(12+readInt(0, cmddata)))\n{\nint namelen, style, size;\nStringBuffer name = new StringBuffer();\nint i;\nint fonthandle = handleCount++;\nnamelen=readInt(0, cmddata);\n\nif(len==4)\n{\nint handle;\nhandle=readInt(0, cmddata);\nunloadImage(handle);\nmyConn.clearImageAccess(handle);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_UNLOADIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_SETTARGETSURFACE:\n\/\/ handle\nif(len==4)\n{\nint handle;\nhandle=readInt(0, cmddata);\n\/\/STBGFX.GFX_unloadImage(handle);\nLong layerPtr = (Long)layerMap.get(new Integer(handle));\n\/\/ System.out.println(\"SETTARGETSURFACE: handle=\"+handle+\" layerPtr=\"+ (layerPtr == null ? \"0\" : Long.toHexString(layerPtr.longValue())));\ncurrentLayer = (layerPtr != null) ? layerPtr.longValue() : 0;\njava.awt.Rectangle clipRect = new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight());\nsetLayer0(currentLayer, c.getSize(), clipRect);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_SETTARGETSURFACE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADFONT:\n\/\/ namelen, name, style, size\nif(len>=12 && len>=(12+readInt(0, cmddata)))\n{\nint namelen, style, size;\nStringBuffer name = new StringBuffer();\nint i;\nint fonthandle = handleCount++;\nnamelen=readInt(0, cmddata);\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\n\nbreak;\ncase GFXCMD_SETTARGETSURFACE:\n\/\/ handle\nif(len==4)\n{\nint handle;\nhandle=readInt(0, cmddata);\n\/\/STBGFX.GFX_unloadImage(handle);\nLong layerPtr = (Long)layerMap.get(new Integer(handle));\n\/\/ System.out.println(\"SETTARGETSURFACE: handle=\"+handle+\" layerPtr=\"+ (layerPtr == null ? \"0\" : Long.toHexString(layerPtr.longValue())));\ncurrentLayer = (layerPtr != null) ? layerPtr.longValue() : 0;\njava.awt.Rectangle clipRect = new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight());\nsetLayer0(currentLayer, c.getSize(), clipRect);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_SETTARGETSURFACE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADFONT:\n\/\/ namelen, name, style, size\nif(len>=12 && len>=(12+readInt(0, cmddata)))\n{\nint namelen, style, size;\nStringBuffer name = new StringBuffer();\nint i;\nint fonthandle = handleCount++;\nnamelen=readInt(0, cmddata);\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nstyle=readInt(namelen+4, cmddata);\nsize=readInt(namelen+8, cmddata);\n\/\/ System.out.println(\"LOADFONT: handle=\"+fonthandle+\" name=\"+name.toString()+\" style=\"+Integer.toHexString(style)+\" size=\"+size);\nMcFont fontPtr = new McFont(name.toString(), style, size);\n\/\/ long fontPtr = loadFont0(name.toString(), style, size);\nif(fontPtr == null) {\n\/\/ FIXME: implement!\n\/\/ we don't have the font on this sytem (yet) see if it's cached and try to load it manually\n\/\/ String cacheName = name.toString() + \"-\" + style;\n\nLong layerPtr = (Long)layerMap.get(new Integer(handle));\n\/\/ System.out.println(\"SETTARGETSURFACE: handle=\"+handle+\" layerPtr=\"+ (layerPtr == null ? \"0\" : Long.toHexString(layerPtr.longValue())));\ncurrentLayer = (layerPtr != null) ? layerPtr.longValue() : 0;\njava.awt.Rectangle clipRect = new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight());\nsetLayer0(currentLayer, c.getSize(), clipRect);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_SETTARGETSURFACE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADFONT:\n\/\/ namelen, name, style, size\nif(len>=12 && len>=(12+readInt(0, cmddata)))\n{\nint namelen, style, size;\nStringBuffer name = new StringBuffer();\nint i;\nint fonthandle = handleCount++;\nnamelen=readInt(0, cmddata);\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nstyle=readInt(namelen+4, cmddata);\nsize=readInt(namelen+8, cmddata);\n\/\/ System.out.println(\"LOADFONT: handle=\"+fonthandle+\" name=\"+name.toString()+\" style=\"+Integer.toHexString(style)+\" size=\"+size);\nMcFont fontPtr = new McFont(name.toString(), style, size);\n\/\/ long fontPtr = loadFont0(name.toString(), style, size);\nif(fontPtr == null) {\n\/\/ FIXME: implement!\n\/\/ we don't have the font on this sytem (yet) see if it's cached and try to load it manually\n\/\/ String cacheName = name.toString() + \"-\" + style;\n\/\/ fontPtr = loadCachedFont0(cacheDir.getAbsolutePath(), name.toString() + \"-\" + myConn.getServerName(), style, size);\n\/\/ if (fontPtr == 0) {\n\/\/ Return that we don't have this font so it'll load it into our cache\nhasret[0] = 1;\nreturn 0;\n\/\/ }\n}\n\/\/ System.out.println(\" fontPtr=\" + fontPtr);\n\ncurrentLayer = (layerPtr != null) ? layerPtr.longValue() : 0;\njava.awt.Rectangle clipRect = new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight());\nsetLayer0(currentLayer, c.getSize(), clipRect);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_SETTARGETSURFACE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADFONT:\n\/\/ namelen, name, style, size\nif(len>=12 && len>=(12+readInt(0, cmddata)))\n{\nint namelen, style, size;\nStringBuffer name = new StringBuffer();\nint i;\nint fonthandle = handleCount++;\nnamelen=readInt(0, cmddata);\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nstyle=readInt(namelen+4, cmddata);\nsize=readInt(namelen+8, cmddata);\n\/\/ System.out.println(\"LOADFONT: handle=\"+fonthandle+\" name=\"+name.toString()+\" style=\"+Integer.toHexString(style)+\" size=\"+size);\nMcFont fontPtr = new McFont(name.toString(), style, size);\n\/\/ long fontPtr = loadFont0(name.toString(), style, size);\nif(fontPtr == null) {\n\/\/ FIXME: implement!\n\/\/ we don't have the font on this sytem (yet) see if it's cached and try to load it manually\n\/\/ String cacheName = name.toString() + \"-\" + style;\n\/\/ fontPtr = loadCachedFont0(cacheDir.getAbsolutePath(), name.toString() + \"-\" + myConn.getServerName(), style, size);\n\/\/ if (fontPtr == 0) {\n\/\/ Return that we don't have this font so it'll load it into our cache\nhasret[0] = 1;\nreturn 0;\n\/\/ }\n}\n\/\/ System.out.println(\" fontPtr=\" + fontPtr);\nfontMap.put(new Integer(fonthandle), fontPtr);\nhasret[0] = 1;\n\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_SETTARGETSURFACE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADFONT:\n\/\/ namelen, name, style, size\nif(len>=12 && len>=(12+readInt(0, cmddata)))\n{\nint namelen, style, size;\nStringBuffer name = new StringBuffer();\nint i;\nint fonthandle = handleCount++;\nnamelen=readInt(0, cmddata);\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nstyle=readInt(namelen+4, cmddata);\nsize=readInt(namelen+8, cmddata);\n\/\/ System.out.println(\"LOADFONT: handle=\"+fonthandle+\" name=\"+name.toString()+\" style=\"+Integer.toHexString(style)+\" size=\"+size);\nMcFont fontPtr = new McFont(name.toString(), style, size);\n\/\/ long fontPtr = loadFont0(name.toString(), style, size);\nif(fontPtr == null) {\n\/\/ FIXME: implement!\n\/\/ we don't have the font on this sytem (yet) see if it's cached and try to load it manually\n\/\/ String cacheName = name.toString() + \"-\" + style;\n\/\/ fontPtr = loadCachedFont0(cacheDir.getAbsolutePath(), name.toString() + \"-\" + myConn.getServerName(), style, size);\n\/\/ if (fontPtr == 0) {\n\/\/ Return that we don't have this font so it'll load it into our cache\nhasret[0] = 1;\nreturn 0;\n\/\/ }\n}\n\/\/ System.out.println(\" fontPtr=\" + fontPtr);\nfontMap.put(new Integer(fonthandle), fontPtr);\nhasret[0] = 1;\nreturn fonthandle;\n}\nelse\n{\n\nSystem.out.println(\"Invalid len for GFXCMD_SETTARGETSURFACE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADFONT:\n\/\/ namelen, name, style, size\nif(len>=12 && len>=(12+readInt(0, cmddata)))\n{\nint namelen, style, size;\nStringBuffer name = new StringBuffer();\nint i;\nint fonthandle = handleCount++;\nnamelen=readInt(0, cmddata);\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nstyle=readInt(namelen+4, cmddata);\nsize=readInt(namelen+8, cmddata);\n\/\/ System.out.println(\"LOADFONT: handle=\"+fonthandle+\" name=\"+name.toString()+\" style=\"+Integer.toHexString(style)+\" size=\"+size);\nMcFont fontPtr = new McFont(name.toString(), style, size);\n\/\/ long fontPtr = loadFont0(name.toString(), style, size);\nif(fontPtr == null) {\n\/\/ FIXME: implement!\n\/\/ we don't have the font on this sytem (yet) see if it's cached and try to load it manually\n\/\/ String cacheName = name.toString() + \"-\" + style;\n\/\/ fontPtr = loadCachedFont0(cacheDir.getAbsolutePath(), name.toString() + \"-\" + myConn.getServerName(), style, size);\n\/\/ if (fontPtr == 0) {\n\/\/ Return that we don't have this font so it'll load it into our cache\nhasret[0] = 1;\nreturn 0;\n\/\/ }\n}\n\/\/ System.out.println(\" fontPtr=\" + fontPtr);\nfontMap.put(new Integer(fonthandle), fontPtr);\nhasret[0] = 1;\nreturn fonthandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADFONT : \" + len);\n}\n\nbreak;\ncase GFXCMD_LOADFONT:\n\/\/ namelen, name, style, size\nif(len>=12 && len>=(12+readInt(0, cmddata)))\n{\nint namelen, style, size;\nStringBuffer name = new StringBuffer();\nint i;\nint fonthandle = handleCount++;\nnamelen=readInt(0, cmddata);\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nstyle=readInt(namelen+4, cmddata);\nsize=readInt(namelen+8, cmddata);\n\/\/ System.out.println(\"LOADFONT: handle=\"+fonthandle+\" name=\"+name.toString()+\" style=\"+Integer.toHexString(style)+\" size=\"+size);\nMcFont fontPtr = new McFont(name.toString(), style, size);\n\/\/ long fontPtr = loadFont0(name.toString(), style, size);\nif(fontPtr == null) {\n\/\/ FIXME: implement!\n\/\/ we don't have the font on this sytem (yet) see if it's cached and try to load it manually\n\/\/ String cacheName = name.toString() + \"-\" + style;\n\/\/ fontPtr = loadCachedFont0(cacheDir.getAbsolutePath(), name.toString() + \"-\" + myConn.getServerName(), style, size);\n\/\/ if (fontPtr == 0) {\n\/\/ Return that we don't have this font so it'll load it into our cache\nhasret[0] = 1;\nreturn 0;\n\/\/ }\n}\n\/\/ System.out.println(\" fontPtr=\" + fontPtr);\nfontMap.put(new Integer(fonthandle), fontPtr);\nhasret[0] = 1;\nreturn fonthandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADFONT : \" + len);\n}\nbreak;\ncase GFXCMD_UNLOADFONT:\n\/\/ handle\nif(len==4)\n{\nint handle;\nhandle=readInt(0, cmddata);\n\nint fonthandle = handleCount++;\nnamelen=readInt(0, cmddata);\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nstyle=readInt(namelen+4, cmddata);\nsize=readInt(namelen+8, cmddata);\n\/\/ System.out.println(\"LOADFONT: handle=\"+fonthandle+\" name=\"+name.toString()+\" style=\"+Integer.toHexString(style)+\" size=\"+size);\nMcFont fontPtr = new McFont(name.toString(), style, size);\n\/\/ long fontPtr = loadFont0(name.toString(), style, size);\nif(fontPtr == null) {\n\/\/ FIXME: implement!\n\/\/ we don't have the font on this sytem (yet) see if it's cached and try to load it manually\n\/\/ String cacheName = name.toString() + \"-\" + style;\n\/\/ fontPtr = loadCachedFont0(cacheDir.getAbsolutePath(), name.toString() + \"-\" + myConn.getServerName(), style, size);\n\/\/ if (fontPtr == 0) {\n\/\/ Return that we don't have this font so it'll load it into our cache\nhasret[0] = 1;\nreturn 0;\n\/\/ }\n}\n\/\/ System.out.println(\" fontPtr=\" + fontPtr);\nfontMap.put(new Integer(fonthandle), fontPtr);\nhasret[0] = 1;\nreturn fonthandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADFONT : \" + len);\n}\nbreak;\ncase GFXCMD_UNLOADFONT:\n\/\/ handle\nif(len==4)\n{\nint handle;\nhandle=readInt(0, cmddata);\n\/\/STBGFX.GFX_unloadFont(handle);\nMcFont fontPtr = (McFont)fontMap.get(new Integer(handle));\n\/\/ System.out.println(\"UNLOADFONT: handle=\"+handle+\" fontPtr=\"+fontPtr);\n\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nstyle=readInt(namelen+4, cmddata);\nsize=readInt(namelen+8, cmddata);\n\/\/ System.out.println(\"LOADFONT: handle=\"+fonthandle+\" name=\"+name.toString()+\" style=\"+Integer.toHexString(style)+\" size=\"+size);\nMcFont fontPtr = new McFont(name.toString(), style, size);\n\/\/ long fontPtr = loadFont0(name.toString(), style, size);\nif(fontPtr == null) {\n\/\/ FIXME: implement!\n\/\/ we don't have the font on this sytem (yet) see if it's cached and try to load it manually\n\/\/ String cacheName = name.toString() + \"-\" + style;\n\/\/ fontPtr = loadCachedFont0(cacheDir.getAbsolutePath(), name.toString() + \"-\" + myConn.getServerName(), style, size);\n\/\/ if (fontPtr == 0) {\n\/\/ Return that we don't have this font so it'll load it into our cache\nhasret[0] = 1;\nreturn 0;\n\/\/ }\n}\n\/\/ System.out.println(\" fontPtr=\" + fontPtr);\nfontMap.put(new Integer(fonthandle), fontPtr);\nhasret[0] = 1;\nreturn fonthandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADFONT : \" + len);\n}\nbreak;\ncase GFXCMD_UNLOADFONT:\n\/\/ handle\nif(len==4)\n{\nint handle;\nhandle=readInt(0, cmddata);\n\/\/STBGFX.GFX_unloadFont(handle);\nMcFont fontPtr = (McFont)fontMap.get(new Integer(handle));\n\/\/ System.out.println(\"UNLOADFONT: handle=\"+handle+\" fontPtr=\"+fontPtr);\nif(fontPtr != null) fontPtr.unload();\nfontMap.remove(new Integer(handle));\n\nimghandle = 0;\n}\nelse\n{\n\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\nlong imagePtr = createNewImage0(width, height);\nimghandle = handleCount++;\n\/\/ System.out.println(\" imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\nimageMap.put(new Integer(imghandle), new Long(imagePtr)); \/\/ actual value is filled in later when it's prepared\nimageCacheSize += width * height * 4;\n}\nhasret[0]=1;\nreturn imghandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGETARGETED:\n\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\nif(len>=12)\n{\nint width, height;\nint imghandle = readInt(0, cmddata);\nwidth=readInt(4, cmddata);\nheight=readInt(8, cmddata);\nwhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n{\n\/\/ Keep freeing the oldest image until we have enough memory to do this\nint oldestImage = myConn.getOldestImage();\nif (oldestImage != 0)\n{\nSystem.out.println(\"Freeing image to make room in cache\");\nunloadImage(oldestImage);\nmyConn.postImageUnload(oldestImage);\n}\nelse\n{\nSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\nbreak;\n\nhasret[0] = 1;\nreturn 0;\n\/\/ }\n}\n\/\/ System.out.println(\" fontPtr=\" + fontPtr);\nfontMap.put(new Integer(fonthandle), fontPtr);\nhasret[0] = 1;\nreturn fonthandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADFONT : \" + len);\n}\nbreak;\ncase GFXCMD_UNLOADFONT:\n\/\/ handle\nif(len==4)\n{\nint handle;\nhandle=readInt(0, cmddata);\n\/\/STBGFX.GFX_unloadFont(handle);\nMcFont fontPtr = (McFont)fontMap.get(new Integer(handle));\n\/\/ System.out.println(\"UNLOADFONT: handle=\"+handle+\" fontPtr=\"+fontPtr);\nif(fontPtr != null) fontPtr.unload();\nfontMap.remove(new Integer(handle));\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_UNLOADFONT : \" + len);\n}\nbreak;\ncase GFXCMD_LOADFONTSTREAM:\n\/\/ namelen, name, len, data\nif (len>=8)\n{\nStringBuffer name = new StringBuffer();\nint namelen = readInt(0, cmddata);\nfor(int i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\n\n\/\/ }\n}\n\/\/ System.out.println(\" fontPtr=\" + fontPtr);\nfontMap.put(new Integer(fonthandle), fontPtr);\nhasret[0] = 1;\nreturn fonthandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADFONT : \" + len);\n}\nbreak;\ncase GFXCMD_UNLOADFONT:\n\/\/ handle\nif(len==4)\n{\nint handle;\nhandle=readInt(0, cmddata);\n\/\/STBGFX.GFX_unloadFont(handle);\nMcFont fontPtr = (McFont)fontMap.get(new Integer(handle));\n\/\/ System.out.println(\"UNLOADFONT: handle=\"+handle+\" fontPtr=\"+fontPtr);\nif(fontPtr != null) fontPtr.unload();\nfontMap.remove(new Integer(handle));\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_UNLOADFONT : \" + len);\n}\nbreak;\ncase GFXCMD_LOADFONTSTREAM:\n\/\/ namelen, name, len, data\nif (len>=8)\n{\nStringBuffer name = new StringBuffer();\nint namelen = readInt(0, cmddata);\nfor(int i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nint datalen = readInt(4 + namelen, cmddata);\nif (len >= datalen + 8 + namelen)\n\n}\nbreak;\ncase GFXCMD_UNLOADFONT:\n\/\/ handle\nif(len==4)\n{\nint handle;\nhandle=readInt(0, cmddata);\n\/\/STBGFX.GFX_unloadFont(handle);\nMcFont fontPtr = (McFont)fontMap.get(new Integer(handle));\n\/\/ System.out.println(\"UNLOADFONT: handle=\"+handle+\" fontPtr=\"+fontPtr);\nif(fontPtr != null) fontPtr.unload();\nfontMap.remove(new Integer(handle));\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_UNLOADFONT : \" + len);\n}\nbreak;\ncase GFXCMD_LOADFONTSTREAM:\n\/\/ namelen, name, len, data\nif (len>=8)\n{\nStringBuffer name = new StringBuffer();\nint namelen = readInt(0, cmddata);\nfor(int i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nint datalen = readInt(4 + namelen, cmddata);\nif (len >= datalen + 8 + namelen)\n{\n\/\/ System.out.println(\"Saving font \" + name.toString() + \" to cache\");\nmyConn.saveCacheData(name.toString() + \"-\" + myConn.getServerName(), cmddata, 12 + namelen, datalen);\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADFONTSTREAM : \" + len);\n}\nbreak;\n\nLong layerPtr = (Long)layerMap.get(new Integer(handle));\n\/\/ System.out.println(\"SETTARGETSURFACE: handle=\"+handle+\" layerPtr=\"+ (layerPtr == null ? \"0\" : Long.toHexString(layerPtr.longValue())));\ncurrentLayer = (layerPtr != null) ? layerPtr.longValue() : 0;\njava.awt.Rectangle clipRect = new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight());\nsetLayer0(currentLayer, c.getSize(), clipRect);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_SETTARGETSURFACE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADFONT:\n\/\/ namelen, name, style, size\nif(len>=12 && len>=(12+readInt(0, cmddata)))\n{\nint namelen, style, size;\nStringBuffer name = new StringBuffer();\nint i;\nint fonthandle = handleCount++;\nnamelen=readInt(0, cmddata);\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nstyle=readInt(namelen+4, cmddata);\nsize=readInt(namelen+8, cmddata);\n\/\/ System.out.println(\"LOADFONT: handle=\"+fonthandle+\" name=\"+name.toString()+\" style=\"+Integer.toHexString(style)+\" size=\"+size);\nMcFont fontPtr = new McFont(name.toString(), style, size);\n\/\/ long fontPtr = loadFont0(name.toString(), style, size);\nif(fontPtr == null) {\n\/\/ FIXME: implement!\n\/\/ we don't have the font on this sytem (yet) see if it's cached and try to load it manually\n\/\/ String cacheName = name.toString() + \"-\" + style;\n\/\/ fontPtr = loadCachedFont0(cacheDir.getAbsolutePath(), name.toString() + \"-\" + myConn.getServerName(), style, size);\n\/\/ if (fontPtr == 0) {\n\/\/ Return that we don't have this font so it'll load it into our cache\nhasret[0] = 1;\nreturn 0;\n\/\/ }\n}\n\/\/ System.out.println(\" fontPtr=\" + fontPtr);\n\ncurrentLayer = (layerPtr != null) ? layerPtr.longValue() : 0;\njava.awt.Rectangle clipRect = new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight());\nsetLayer0(currentLayer, c.getSize(), clipRect);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_SETTARGETSURFACE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADFONT:\n\/\/ namelen, name, style, size\nif(len>=12 && len>=(12+readInt(0, cmddata)))\n{\nint namelen, style, size;\nStringBuffer name = new StringBuffer();\nint i;\nint fonthandle = handleCount++;\nnamelen=readInt(0, cmddata);\nfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nstyle=readInt(namelen+4, cmddata);\nsize=readInt(namelen+8, cmddata);\n\/\/ System.out.println(\"LOADFONT: handle=\"+fonthandle+\" name=\"+name.toString()+\" style=\"+Integer.toHexString(style)+\" size=\"+size);\nMcFont fontPtr = new McFont(name.toString(), style, size);\n\/\/ long fontPtr = loadFont0(name.toString(), style, size);\nif(fontPtr == null) {\n\/\/ FIXME: implement!\n\/\/ we don't have the font on this sytem (yet) see if it's cached and try to load it manually\n\/\/ String cacheName = name.toString() + \"-\" + style;\n\/\/ fontPtr = loadCachedFont0(cacheDir.getAbsolutePath(), name.toString() + \"-\" + myConn.getServerName(), style, size);\n\/\/ if (fontPtr == 0) {\n\/\/ Return that we don't have this font so it'll load it into our cache\nhasret[0] = 1;\nreturn 0;\n\/\/ }\n}\n\/\/ System.out.println(\" fontPtr=\" + fontPtr);\nfontMap.put(new Integer(fonthandle), fontPtr);\nhasret[0] = 1;\n\nfontMap.remove(new Integer(handle));\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_UNLOADFONT : \" + len);\n}\nbreak;\ncase GFXCMD_LOADFONTSTREAM:\n\/\/ namelen, name, len, data\nif (len>=8)\n{\nStringBuffer name = new StringBuffer();\nint namelen = readInt(0, cmddata);\nfor(int i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nint datalen = readInt(4 + namelen, cmddata);\nif (len >= datalen + 8 + namelen)\n{\n\/\/ System.out.println(\"Saving font \" + name.toString() + \" to cache\");\nmyConn.saveCacheData(name.toString() + \"-\" + myConn.getServerName(), cmddata, 12 + namelen, datalen);\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADFONTSTREAM : \" + len);\n}\nbreak;\ncase GFXCMD_FLIPBUFFER:\n\/\/ System.out.println(\"FLIPBUFFER\");\nif (abortRenderCycle)\n{\nSystem.out.println(\"ERROR in painting cycle, ABORT was set...send full repaint command\");\nmyConn.postRepaintEvent(0, 0, c.getWidth(), c.getHeight());\n}\nelse\n{\npresent0(c.nativeView, new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight()));\n}\nhasret[0] = 1;\n\n{\nStringBuffer name = new StringBuffer();\nint namelen = readInt(0, cmddata);\nfor(int i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n{\nname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n}\nint datalen = readInt(4 + namelen, cmddata);\nif (len >= datalen + 8 + namelen)\n{\n\/\/ System.out.println(\"Saving font \" + name.toString() + \" to cache\");\nmyConn.saveCacheData(name.toString() + \"-\" + myConn.getServerName(), cmddata, 12 + namelen, datalen);\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADFONTSTREAM : \" + len);\n}\nbreak;\ncase GFXCMD_FLIPBUFFER:\n\/\/ System.out.println(\"FLIPBUFFER\");\nif (abortRenderCycle)\n{\nSystem.out.println(\"ERROR in painting cycle, ABORT was set...send full repaint command\");\nmyConn.postRepaintEvent(0, 0, c.getWidth(), c.getHeight());\n}\nelse\n{\npresent0(c.nativeView, new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight()));\n}\nhasret[0] = 1;\n\/\/STBGFX.GFX_flipBuffer();\nfirstFrameDone = true;\nreturn 0;\ncase GFXCMD_STARTFRAME:\n\/\/ System.out.println(\"STARTFRAME\");\n\/\/ prepare for a new frame to be rendered\nsetTargetView0(c.nativeView);\nsetLayer0(0, c.getSize(), null); \/\/ this makes sure the drawing surface gets resized properly\nabortRenderCycle = false;\nbreak;\n\nmyConn.saveCacheData(name.toString() + \"-\" + myConn.getServerName(), cmddata, 12 + namelen, datalen);\n}\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADFONTSTREAM : \" + len);\n}\nbreak;\ncase GFXCMD_FLIPBUFFER:\n\/\/ System.out.println(\"FLIPBUFFER\");\nif (abortRenderCycle)\n{\nSystem.out.println(\"ERROR in painting cycle, ABORT was set...send full repaint command\");\nmyConn.postRepaintEvent(0, 0, c.getWidth(), c.getHeight());\n}\nelse\n{\npresent0(c.nativeView, new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight()));\n}\nhasret[0] = 1;\n\/\/STBGFX.GFX_flipBuffer();\nfirstFrameDone = true;\nreturn 0;\ncase GFXCMD_STARTFRAME:\n\/\/ System.out.println(\"STARTFRAME\");\n\/\/ prepare for a new frame to be rendered\nsetTargetView0(c.nativeView);\nsetLayer0(0, c.getSize(), null); \/\/ this makes sure the drawing surface gets resized properly\nabortRenderCycle = false;\nbreak;\ncase GFXCMD_LOADIMAGELINE:\n\/\/ handle, line, len, data\nif(len>=12 && len>=(12+readInt(8, cmddata)))\n{\nint handle, line, len2;\n\/\/unsigned char *data=&cmddata[12];\nhandle=readInt(0, cmddata);\nline=readInt(4, cmddata);\nlen2=readInt(8, cmddata);\n\/\/ the last number is the offset into the data array to start reading from\n\/\/STBGFX.GFX_loadImageLine(handle, line, len, data, 12);\n\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADFONTSTREAM : \" + len);\n}\nbreak;\ncase GFXCMD_FLIPBUFFER:\n\/\/ System.out.println(\"FLIPBUFFER\");\nif (abortRenderCycle)\n{\nSystem.out.println(\"ERROR in painting cycle, ABORT was set...send full repaint command\");\nmyConn.postRepaintEvent(0, 0, c.getWidth(), c.getHeight());\n}\nelse\n{\npresent0(c.nativeView, new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight()));\n}\nhasret[0] = 1;\n\/\/STBGFX.GFX_flipBuffer();\nfirstFrameDone = true;\nreturn 0;\ncase GFXCMD_STARTFRAME:\n\/\/ System.out.println(\"STARTFRAME\");\n\/\/ prepare for a new frame to be rendered\nsetTargetView0(c.nativeView);\nsetLayer0(0, c.getSize(), null); \/\/ this makes sure the drawing surface gets resized properly\nabortRenderCycle = false;\nbreak;\ncase GFXCMD_LOADIMAGELINE:\n\/\/ handle, line, len, data\nif(len>=12 && len>=(12+readInt(8, cmddata)))\n{\nint handle, line, len2;\n\/\/unsigned char *data=&cmddata[12];\nhandle=readInt(0, cmddata);\nline=readInt(4, cmddata);\nlen2=readInt(8, cmddata);\n\/\/ the last number is the offset into the data array to start reading from\n\/\/STBGFX.GFX_loadImageLine(handle, line, len, data, 12);\n\/\/int dataPos = 12;\nLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\/\/ System.out.println(\"LOADIMAGELINE: handle=\"+handle+\" imagePtr=\"+imagePtr+\" line=\"+line+\" len2=\"+len2);\nif(imagePtr != null)\nloadImageLine0(imagePtr.longValue(), line, cmddata, 16\/*12*\/, len2);\n\nbreak;\ncase GFXCMD_FLIPBUFFER:\n\/\/ System.out.println(\"FLIPBUFFER\");\nif (abortRenderCycle)\n{\nSystem.out.println(\"ERROR in painting cycle, ABORT was set...send full repaint command\");\nmyConn.postRepaintEvent(0, 0, c.getWidth(), c.getHeight());\n}\nelse\n{\npresent0(c.nativeView, new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight()));\n}\nhasret[0] = 1;\n\/\/STBGFX.GFX_flipBuffer();\nfirstFrameDone = true;\nreturn 0;\ncase GFXCMD_STARTFRAME:\n\/\/ System.out.println(\"STARTFRAME\");\n\/\/ prepare for a new frame to be rendered\nsetTargetView0(c.nativeView);\nsetLayer0(0, c.getSize(), null); \/\/ this makes sure the drawing surface gets resized properly\nabortRenderCycle = false;\nbreak;\ncase GFXCMD_LOADIMAGELINE:\n\/\/ handle, line, len, data\nif(len>=12 && len>=(12+readInt(8, cmddata)))\n{\nint handle, line, len2;\n\/\/unsigned char *data=&cmddata[12];\nhandle=readInt(0, cmddata);\nline=readInt(4, cmddata);\nlen2=readInt(8, cmddata);\n\/\/ the last number is the offset into the data array to start reading from\n\/\/STBGFX.GFX_loadImageLine(handle, line, len, data, 12);\n\/\/int dataPos = 12;\nLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\/\/ System.out.println(\"LOADIMAGELINE: handle=\"+handle+\" imagePtr=\"+imagePtr+\" line=\"+line+\" len2=\"+len2);\nif(imagePtr != null)\nloadImageLine0(imagePtr.longValue(), line, cmddata, 16\/*12*\/, len2);\nmyConn.registerImageAccess(handle);\n}\n\n{\nSystem.out.println(\"ERROR in painting cycle, ABORT was set...send full repaint command\");\nmyConn.postRepaintEvent(0, 0, c.getWidth(), c.getHeight());\n}\nelse\n{\npresent0(c.nativeView, new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight()));\n}\nhasret[0] = 1;\n\/\/STBGFX.GFX_flipBuffer();\nfirstFrameDone = true;\nreturn 0;\ncase GFXCMD_STARTFRAME:\n\/\/ System.out.println(\"STARTFRAME\");\n\/\/ prepare for a new frame to be rendered\nsetTargetView0(c.nativeView);\nsetLayer0(0, c.getSize(), null); \/\/ this makes sure the drawing surface gets resized properly\nabortRenderCycle = false;\nbreak;\ncase GFXCMD_LOADIMAGELINE:\n\/\/ handle, line, len, data\nif(len>=12 && len>=(12+readInt(8, cmddata)))\n{\nint handle, line, len2;\n\/\/unsigned char *data=&cmddata[12];\nhandle=readInt(0, cmddata);\nline=readInt(4, cmddata);\nlen2=readInt(8, cmddata);\n\/\/ the last number is the offset into the data array to start reading from\n\/\/STBGFX.GFX_loadImageLine(handle, line, len, data, 12);\n\/\/int dataPos = 12;\nLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\/\/ System.out.println(\"LOADIMAGELINE: handle=\"+handle+\" imagePtr=\"+imagePtr+\" line=\"+line+\" len2=\"+len2);\nif(imagePtr != null)\nloadImageLine0(imagePtr.longValue(), line, cmddata, 16\/*12*\/, len2);\nmyConn.registerImageAccess(handle);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGELINE : \" + len);\n}\n\nelse\n{\npresent0(c.nativeView, new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight()));\n}\nhasret[0] = 1;\n\/\/STBGFX.GFX_flipBuffer();\nfirstFrameDone = true;\nreturn 0;\ncase GFXCMD_STARTFRAME:\n\/\/ System.out.println(\"STARTFRAME\");\n\/\/ prepare for a new frame to be rendered\nsetTargetView0(c.nativeView);\nsetLayer0(0, c.getSize(), null); \/\/ this makes sure the drawing surface gets resized properly\nabortRenderCycle = false;\nbreak;\ncase GFXCMD_LOADIMAGELINE:\n\/\/ handle, line, len, data\nif(len>=12 && len>=(12+readInt(8, cmddata)))\n{\nint handle, line, len2;\n\/\/unsigned char *data=&cmddata[12];\nhandle=readInt(0, cmddata);\nline=readInt(4, cmddata);\nlen2=readInt(8, cmddata);\n\/\/ the last number is the offset into the data array to start reading from\n\/\/STBGFX.GFX_loadImageLine(handle, line, len, data, 12);\n\/\/int dataPos = 12;\nLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\/\/ System.out.println(\"LOADIMAGELINE: handle=\"+handle+\" imagePtr=\"+imagePtr+\" line=\"+line+\" len2=\"+len2);\nif(imagePtr != null)\nloadImageLine0(imagePtr.longValue(), line, cmddata, 16\/*12*\/, len2);\nmyConn.registerImageAccess(handle);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGELINE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGECOMPRESSED:\n\/\/ handle, line, len, data\nif(len>=8 && len>=(8+readInt(4, cmddata)))\n\nhasret[0] = 1;\n\/\/STBGFX.GFX_flipBuffer();\nfirstFrameDone = true;\nreturn 0;\ncase GFXCMD_STARTFRAME:\n\/\/ System.out.println(\"STARTFRAME\");\n\/\/ prepare for a new frame to be rendered\nsetTargetView0(c.nativeView);\nsetLayer0(0, c.getSize(), null); \/\/ this makes sure the drawing surface gets resized properly\nabortRenderCycle = false;\nbreak;\ncase GFXCMD_LOADIMAGELINE:\n\/\/ handle, line, len, data\nif(len>=12 && len>=(12+readInt(8, cmddata)))\n{\nint handle, line, len2;\n\/\/unsigned char *data=&cmddata[12];\nhandle=readInt(0, cmddata);\nline=readInt(4, cmddata);\nlen2=readInt(8, cmddata);\n\/\/ the last number is the offset into the data array to start reading from\n\/\/STBGFX.GFX_loadImageLine(handle, line, len, data, 12);\n\/\/int dataPos = 12;\nLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\/\/ System.out.println(\"LOADIMAGELINE: handle=\"+handle+\" imagePtr=\"+imagePtr+\" line=\"+line+\" len2=\"+len2);\nif(imagePtr != null)\nloadImageLine0(imagePtr.longValue(), line, cmddata, 16\/*12*\/, len2);\nmyConn.registerImageAccess(handle);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGELINE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGECOMPRESSED:\n\/\/ handle, line, len, data\nif(len>=8 && len>=(8+readInt(4, cmddata)))\n{\nint handle, len2;\nhandle=readInt(0, cmddata);\nlen2=readInt(4, cmddata);\nif (lastImageResourceID != null && lastImageResourceIDHandle == handle)\n{\n\ncase GFXCMD_STARTFRAME:\n\/\/ System.out.println(\"STARTFRAME\");\n\/\/ prepare for a new frame to be rendered\nsetTargetView0(c.nativeView);\nsetLayer0(0, c.getSize(), null); \/\/ this makes sure the drawing surface gets resized properly\nabortRenderCycle = false;\nbreak;\ncase GFXCMD_LOADIMAGELINE:\n\/\/ handle, line, len, data\nif(len>=12 && len>=(12+readInt(8, cmddata)))\n{\nint handle, line, len2;\n\/\/unsigned char *data=&cmddata[12];\nhandle=readInt(0, cmddata);\nline=readInt(4, cmddata);\nlen2=readInt(8, cmddata);\n\/\/ the last number is the offset into the data array to start reading from\n\/\/STBGFX.GFX_loadImageLine(handle, line, len, data, 12);\n\/\/int dataPos = 12;\nLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\/\/ System.out.println(\"LOADIMAGELINE: handle=\"+handle+\" imagePtr=\"+imagePtr+\" line=\"+line+\" len2=\"+len2);\nif(imagePtr != null)\nloadImageLine0(imagePtr.longValue(), line, cmddata, 16\/*12*\/, len2);\nmyConn.registerImageAccess(handle);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGELINE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGECOMPRESSED:\n\/\/ handle, line, len, data\nif(len>=8 && len>=(8+readInt(4, cmddata)))\n{\nint handle, len2;\nhandle=readInt(0, cmddata);\nlen2=readInt(4, cmddata);\nif (lastImageResourceID != null && lastImageResourceIDHandle == handle)\n{\nmyConn.saveCacheData(lastImageResourceID, cmddata, 12, len2);\nmyConn.postOfflineCacheChange(true, lastImageResourceID);\n\n\/\/ prepare for a new frame to be rendered\nsetTargetView0(c.nativeView);\nsetLayer0(0, c.getSize(), null); \/\/ this makes sure the drawing surface gets resized properly\nabortRenderCycle = false;\nbreak;\ncase GFXCMD_LOADIMAGELINE:\n\/\/ handle, line, len, data\nif(len>=12 && len>=(12+readInt(8, cmddata)))\n{\nint handle, line, len2;\n\/\/unsigned char *data=&cmddata[12];\nhandle=readInt(0, cmddata);\nline=readInt(4, cmddata);\nlen2=readInt(8, cmddata);\n\/\/ the last number is the offset into the data array to start reading from\n\/\/STBGFX.GFX_loadImageLine(handle, line, len, data, 12);\n\/\/int dataPos = 12;\nLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\/\/ System.out.println(\"LOADIMAGELINE: handle=\"+handle+\" imagePtr=\"+imagePtr+\" line=\"+line+\" len2=\"+len2);\nif(imagePtr != null)\nloadImageLine0(imagePtr.longValue(), line, cmddata, 16\/*12*\/, len2);\nmyConn.registerImageAccess(handle);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGELINE : \" + len);\n}\nbreak;\ncase GFXCMD_LOADIMAGECOMPRESSED:\n\/\/ handle, line, len, data\nif(len>=8 && len>=(8+readInt(4, cmddata)))\n{\nint handle, len2;\nhandle=readInt(0, cmddata);\nlen2=readInt(4, cmddata);\nif (lastImageResourceID != null && lastImageResourceIDHandle == handle)\n{\nmyConn.saveCacheData(lastImageResourceID, cmddata, 12, len2);\nmyConn.postOfflineCacheChange(true, lastImageResourceID);\n}\nif (!myConn.doesUseAdvancedImageCaching())\n\n{\nSystem.out.println(\"ERROR in painting cycle, ABORT was set...send full repaint command\");\nmyConn.postRepaintEvent(0, 0, c.getWidth(), c.getHeight());\n}\nelse\n{\npresent0(c.nativeView, new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight()));\n}\nhasret[0] = 1;\n\/\/STBGFX.GFX_flipBuffer();\nfirstFrameDone = true;\nreturn 0;\ncase GFXCMD_STARTFRAME:\n\/\/ System.out.println(\"STARTFRAME\");\n\/\/ prepare for a new frame to be rendered\nsetTargetView0(c.nativeView);\nsetLayer0(0, c.getSize(), null); \/\/ this makes sure the drawing surface gets resized properly\nabortRenderCycle = false;\nbreak;\ncase GFXCMD_LOADIMAGELINE:\n\/\/ handle, line, len, data\nif(len>=12 && len>=(12+readInt(8, cmddata)))\n{\nint handle, line, len2;\n\/\/unsigned char *data=&cmddata[12];\nhandle=readInt(0, cmddata);\nline=readInt(4, cmddata);\nlen2=readInt(8, cmddata);\n\/\/ the last number is the offset into the data array to start reading from\n\/\/STBGFX.GFX_loadImageLine(handle, line, len, data, 12);\n\/\/int dataPos = 12;\nLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\/\/ System.out.println(\"LOADIMAGELINE: handle=\"+handle+\" imagePtr=\"+imagePtr+\" line=\"+line+\" len2=\"+len2);\nif(imagePtr != null)\nloadImageLine0(imagePtr.longValue(), line, cmddata, 16\/*12*\/, len2);\nmyConn.registerImageAccess(handle);\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGELINE : \" + len);\n}\n\ncase GFXCMD_LOADIMAGECOMPRESSED:\n\/\/ handle, line, len, data\nif(len>=8 && len>=(8+readInt(4, cmddata)))\n{\nint handle, len2;\nhandle=readInt(0, cmddata);\nlen2=readInt(4, cmddata);\nif (lastImageResourceID != null && lastImageResourceIDHandle == handle)\n{\nmyConn.saveCacheData(lastImageResourceID, cmddata, 12, len2);\nmyConn.postOfflineCacheChange(true, lastImageResourceID);\n}\nif (!myConn.doesUseAdvancedImageCaching())\n{\nhandle = handleCount++;\nhasret[0] = 1;\n}\nelse\nhasret[0] = 0;\nmyConn.registerImageAccess(handle);\nlong imagePtr = createImageFromBytes0(cmddata, 12, len2, null); \/\/ FIXME: grab extension if possible\n\/\/ System.out.println(\"LOADIMAGECOMPRESSED: handle=\"+handle+\" imagePtr=\"+imagePtr+\" len2=\"+len2);\nimageMap.put(new Integer(handle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\nreturn handle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGECOMPRESSED : \" + len);\n}\nbreak;\ncase GFXCMD_XFMIMAGE:\n\/\/ srcHandle, destHandle, destWidth, destHeight, maskCornerArc\nif (len >= 20)\n{\nint srcHandle, destHandle, destWidth, destHeight, maskCornerArc;\nsrcHandle = readInt(0, cmddata);\ndestHandle = readInt(4, cmddata); \/\/ seems to be unused\ndestWidth = readInt(8, cmddata); \/\/ scaled size (ignore?)\ndestHeight = readInt(12, cmddata);\nmaskCornerArc = readInt(16, cmddata);\n\n\/\/ handle, line, len, data\nif(len>=8 && len>=(8+readInt(4, cmddata)))\n{\nint handle, len2;\nhandle=readInt(0, cmddata);\nlen2=readInt(4, cmddata);\nif (lastImageResourceID != null && lastImageResourceIDHandle == handle)\n{\nmyConn.saveCacheData(lastImageResourceID, cmddata, 12, len2);\nmyConn.postOfflineCacheChange(true, lastImageResourceID);\n}\nif (!myConn.doesUseAdvancedImageCaching())\n{\nhandle = handleCount++;\nhasret[0] = 1;\n}\nelse\nhasret[0] = 0;\nmyConn.registerImageAccess(handle);\nlong imagePtr = createImageFromBytes0(cmddata, 12, len2, null); \/\/ FIXME: grab extension if possible\n\/\/ System.out.println(\"LOADIMAGECOMPRESSED: handle=\"+handle+\" imagePtr=\"+imagePtr+\" len2=\"+len2);\nimageMap.put(new Integer(handle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\nreturn handle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGECOMPRESSED : \" + len);\n}\nbreak;\ncase GFXCMD_XFMIMAGE:\n\/\/ srcHandle, destHandle, destWidth, destHeight, maskCornerArc\nif (len >= 20)\n{\nint srcHandle, destHandle, destWidth, destHeight, maskCornerArc;\nsrcHandle = readInt(0, cmddata);\ndestHandle = readInt(4, cmddata); \/\/ seems to be unused\ndestWidth = readInt(8, cmddata); \/\/ scaled size (ignore?)\ndestHeight = readInt(12, cmddata);\nmaskCornerArc = readInt(16, cmddata);\nint rvHandle = destHandle;\n\nif (!myConn.doesUseAdvancedImageCaching())\n{\nhandle = handleCount++;\nhasret[0] = 1;\n}\nelse\nhasret[0] = 0;\nmyConn.registerImageAccess(handle);\nlong imagePtr = createImageFromBytes0(cmddata, 12, len2, null); \/\/ FIXME: grab extension if possible\n\/\/ System.out.println(\"LOADIMAGECOMPRESSED: handle=\"+handle+\" imagePtr=\"+imagePtr+\" len2=\"+len2);\nimageMap.put(new Integer(handle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\nreturn handle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGECOMPRESSED : \" + len);\n}\nbreak;\ncase GFXCMD_XFMIMAGE:\n\/\/ srcHandle, destHandle, destWidth, destHeight, maskCornerArc\nif (len >= 20)\n{\nint srcHandle, destHandle, destWidth, destHeight, maskCornerArc;\nsrcHandle = readInt(0, cmddata);\ndestHandle = readInt(4, cmddata); \/\/ seems to be unused\ndestWidth = readInt(8, cmddata); \/\/ scaled size (ignore?)\ndestHeight = readInt(12, cmddata);\nmaskCornerArc = readInt(16, cmddata);\nint rvHandle = destHandle;\nif (!myConn.doesUseAdvancedImageCaching())\n{\nrvHandle = handleCount++;\nhasret[0] = 1;\n}\nelse\nhasret[0] = 0;\n\/\/ we cheat and apply the transforms to a metaimage object without actually creating a new image (saves oodles of memory)\nLong srcImg = (Long)imageMap.get(new Integer(srcHandle));\n\/\/ System.out.println(\"XFMIMAGE: srcHandle=\"+srcHandle+\" srcImg=\"+srcImg+\" destHandle=\"+destHandle+\" destWidth=\"+destWidth+\" destHeight=\"+destHeight+\" maskCornerArc=\"+maskCornerArc);\nif(srcImg != null) {\n\nelse\nhasret[0] = 0;\nmyConn.registerImageAccess(handle);\nlong imagePtr = createImageFromBytes0(cmddata, 12, len2, null); \/\/ FIXME: grab extension if possible\n\/\/ System.out.println(\"LOADIMAGECOMPRESSED: handle=\"+handle+\" imagePtr=\"+imagePtr+\" len2=\"+len2);\nimageMap.put(new Integer(handle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\nreturn handle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGECOMPRESSED : \" + len);\n}\nbreak;\ncase GFXCMD_XFMIMAGE:\n\/\/ srcHandle, destHandle, destWidth, destHeight, maskCornerArc\nif (len >= 20)\n{\nint srcHandle, destHandle, destWidth, destHeight, maskCornerArc;\nsrcHandle = readInt(0, cmddata);\ndestHandle = readInt(4, cmddata); \/\/ seems to be unused\ndestWidth = readInt(8, cmddata); \/\/ scaled size (ignore?)\ndestHeight = readInt(12, cmddata);\nmaskCornerArc = readInt(16, cmddata);\nint rvHandle = destHandle;\nif (!myConn.doesUseAdvancedImageCaching())\n{\nrvHandle = handleCount++;\nhasret[0] = 1;\n}\nelse\nhasret[0] = 0;\n\/\/ we cheat and apply the transforms to a metaimage object without actually creating a new image (saves oodles of memory)\nLong srcImg = (Long)imageMap.get(new Integer(srcHandle));\n\/\/ System.out.println(\"XFMIMAGE: srcHandle=\"+srcHandle+\" srcImg=\"+srcImg+\" destHandle=\"+destHandle+\" destWidth=\"+destWidth+\" destHeight=\"+destHeight+\" maskCornerArc=\"+maskCornerArc);\nif(srcImg != null) {\nlong newImage = transformImage0(srcImg.longValue(), destWidth, destHeight, maskCornerArc);\nif(newImage != 0) {\n\/\/ System.out.println(\" newImage=\"+newImage);\nimageMap.put(new Integer(rvHandle), new Long(newImage));\n}\n\nhasret[0] = 0;\nmyConn.registerImageAccess(handle);\nlong imagePtr = createImageFromBytes0(cmddata, 12, len2, null); \/\/ FIXME: grab extension if possible\n\/\/ System.out.println(\"LOADIMAGECOMPRESSED: handle=\"+handle+\" imagePtr=\"+imagePtr+\" len2=\"+len2);\nimageMap.put(new Integer(handle), new Long(imagePtr));\nimageCacheSize += getImageSize0(imagePtr);\nreturn handle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGECOMPRESSED : \" + len);\n}\nbreak;\ncase GFXCMD_XFMIMAGE:\n\/\/ srcHandle, destHandle, destWidth, destHeight, maskCornerArc\nif (len >= 20)\n{\nint srcHandle, destHandle, destWidth, destHeight, maskCornerArc;\nsrcHandle = readInt(0, cmddata);\ndestHandle = readInt(4, cmddata); \/\/ seems to be unused\ndestWidth = readInt(8, cmddata); \/\/ scaled size (ignore?)\ndestHeight = readInt(12, cmddata);\nmaskCornerArc = readInt(16, cmddata);\nint rvHandle = destHandle;\nif (!myConn.doesUseAdvancedImageCaching())\n{\nrvHandle = handleCount++;\nhasret[0] = 1;\n}\nelse\nhasret[0] = 0;\n\/\/ we cheat and apply the transforms to a metaimage object without actually creating a new image (saves oodles of memory)\nLong srcImg = (Long)imageMap.get(new Integer(srcHandle));\n\/\/ System.out.println(\"XFMIMAGE: srcHandle=\"+srcHandle+\" srcImg=\"+srcImg+\" destHandle=\"+destHandle+\" destWidth=\"+destWidth+\" destHeight=\"+destHeight+\" maskCornerArc=\"+maskCornerArc);\nif(srcImg != null) {\nlong newImage = transformImage0(srcImg.longValue(), destWidth, destHeight, maskCornerArc);\nif(newImage != 0) {\n\/\/ System.out.println(\" newImage=\"+newImage);\nimageMap.put(new Integer(rvHandle), new Long(newImage));\n}\n}\n\n}\nbreak;\ncase GFXCMD_XFMIMAGE:\n\/\/ srcHandle, destHandle, destWidth, destHeight, maskCornerArc\nif (len >= 20)\n{\nint srcHandle, destHandle, destWidth, destHeight, maskCornerArc;\nsrcHandle = readInt(0, cmddata);\ndestHandle = readInt(4, cmddata); \/\/ seems to be unused\ndestWidth = readInt(8, cmddata); \/\/ scaled size (ignore?)\ndestHeight = readInt(12, cmddata);\nmaskCornerArc = readInt(16, cmddata);\nint rvHandle = destHandle;\nif (!myConn.doesUseAdvancedImageCaching())\n{\nrvHandle = handleCount++;\nhasret[0] = 1;\n}\nelse\nhasret[0] = 0;\n\/\/ we cheat and apply the transforms to a metaimage object without actually creating a new image (saves oodles of memory)\nLong srcImg = (Long)imageMap.get(new Integer(srcHandle));\n\/\/ System.out.println(\"XFMIMAGE: srcHandle=\"+srcHandle+\" srcImg=\"+srcImg+\" destHandle=\"+destHandle+\" destWidth=\"+destWidth+\" destHeight=\"+destHeight+\" maskCornerArc=\"+maskCornerArc);\nif(srcImg != null) {\nlong newImage = transformImage0(srcImg.longValue(), destWidth, destHeight, maskCornerArc);\nif(newImage != 0) {\n\/\/ System.out.println(\" newImage=\"+newImage);\nimageMap.put(new Integer(rvHandle), new Long(newImage));\n}\n}\nreturn rvHandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_XFMIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_SETVIDEOPROP:\nif (len >= 40)\n{\njava.awt.Rectangle srcRect = new java.awt.Rectangle(readInt(4, cmddata), readInt(8, cmddata),\n\ncase GFXCMD_XFMIMAGE:\n\/\/ srcHandle, destHandle, destWidth, destHeight, maskCornerArc\nif (len >= 20)\n{\nint srcHandle, destHandle, destWidth, destHeight, maskCornerArc;\nsrcHandle = readInt(0, cmddata);\ndestHandle = readInt(4, cmddata); \/\/ seems to be unused\ndestWidth = readInt(8, cmddata); \/\/ scaled size (ignore?)\ndestHeight = readInt(12, cmddata);\nmaskCornerArc = readInt(16, cmddata);\nint rvHandle = destHandle;\nif (!myConn.doesUseAdvancedImageCaching())\n{\nrvHandle = handleCount++;\nhasret[0] = 1;\n}\nelse\nhasret[0] = 0;\n\/\/ we cheat and apply the transforms to a metaimage object without actually creating a new image (saves oodles of memory)\nLong srcImg = (Long)imageMap.get(new Integer(srcHandle));\n\/\/ System.out.println(\"XFMIMAGE: srcHandle=\"+srcHandle+\" srcImg=\"+srcImg+\" destHandle=\"+destHandle+\" destWidth=\"+destWidth+\" destHeight=\"+destHeight+\" maskCornerArc=\"+maskCornerArc);\nif(srcImg != null) {\nlong newImage = transformImage0(srcImg.longValue(), destWidth, destHeight, maskCornerArc);\nif(newImage != 0) {\n\/\/ System.out.println(\" newImage=\"+newImage);\nimageMap.put(new Integer(rvHandle), new Long(newImage));\n}\n}\nreturn rvHandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_XFMIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_SETVIDEOPROP:\nif (len >= 40)\n{\njava.awt.Rectangle srcRect = new java.awt.Rectangle(readInt(4, cmddata), readInt(8, cmddata),\nreadInt(12, cmddata), readInt(16, cmddata));\njava.awt.Rectangle destRect = new java.awt.Rectangle(readInt(20, cmddata), readInt(24, cmddata),\n\nint srcHandle, destHandle, destWidth, destHeight, maskCornerArc;\nsrcHandle = readInt(0, cmddata);\ndestHandle = readInt(4, cmddata); \/\/ seems to be unused\ndestWidth = readInt(8, cmddata); \/\/ scaled size (ignore?)\ndestHeight = readInt(12, cmddata);\nmaskCornerArc = readInt(16, cmddata);\nint rvHandle = destHandle;\nif (!myConn.doesUseAdvancedImageCaching())\n{\nrvHandle = handleCount++;\nhasret[0] = 1;\n}\nelse\nhasret[0] = 0;\n\/\/ we cheat and apply the transforms to a metaimage object without actually creating a new image (saves oodles of memory)\nLong srcImg = (Long)imageMap.get(new Integer(srcHandle));\n\/\/ System.out.println(\"XFMIMAGE: srcHandle=\"+srcHandle+\" srcImg=\"+srcImg+\" destHandle=\"+destHandle+\" destWidth=\"+destWidth+\" destHeight=\"+destHeight+\" maskCornerArc=\"+maskCornerArc);\nif(srcImg != null) {\nlong newImage = transformImage0(srcImg.longValue(), destWidth, destHeight, maskCornerArc);\nif(newImage != 0) {\n\/\/ System.out.println(\" newImage=\"+newImage);\nimageMap.put(new Integer(rvHandle), new Long(newImage));\n}\n}\nreturn rvHandle;\n}\nelse\n{\nSystem.out.println(\"Invalid len for GFXCMD_XFMIMAGE : \" + len);\n}\nbreak;\ncase GFXCMD_SETVIDEOPROP:\nif (len >= 40)\n{\njava.awt.Rectangle srcRect = new java.awt.Rectangle(readInt(4, cmddata), readInt(8, cmddata),\nreadInt(12, cmddata), readInt(16, cmddata));\njava.awt.Rectangle destRect = new java.awt.Rectangle(readInt(20, cmddata), readInt(24, cmddata),\nreadInt(28, cmddata), readInt(32, cmddata));\nSystem.out.println(\"SETVIDEOPROP: srcRect=\"+srcRect+\" dstRect=\"+destRect);\nsetVideoBounds(srcRect, destRect);\n}","label":[1,0,1,0]}
{"id":7810,"original_code":"public boolean isOvertaking() {\n\t\tif (overtakeStage != OvertakeStage.NOT_OVERTAKING) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}","code":"public boolean isOvertaking() {\n\t\tif (overtakeStage != OvertakeStage.NOT_OVERTAKING) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}","cleancode":"public boolean isovertaking() { if (overtakestage != overtakestage.not_overtaking) { return true; } else { return false; } }","comment":"\/** * returns true if ugv currently engaged in overtaking manoeuvre. * todo - may want to do some testing to make sure that the ugv start mode * is initialised to overtakestage.not_overtaking in the constructor, and * reset at appropriate points through the simulation. * @return boolean (return true if ugv is overtaking, else false) *\/","repo":"RobAlexander\/SCovSGen","code_context_2":"public boolean isOvertaking() {\nif (overtakeStage != OvertakeStage.NOT_OVERTAKING) {\nreturn true;\n} else {\nreturn false;\n}\n}","code_context_10":"public boolean isOvertaking() {\nif (overtakeStage != OvertakeStage.NOT_OVERTAKING) {\nreturn true;\n} else {\nreturn false;\n}\n}","code_context_20":"public boolean isOvertaking() {\nif (overtakeStage != OvertakeStage.NOT_OVERTAKING) {\nreturn true;\n} else {\nreturn false;\n}\n}","label":[0,1,0,0]}
{"id":16039,"original_code":"public static List<String> generateParenthesis1(int n) {\n        Set<String>[] dp = new Set[n + 1];\n        Set<String> first = new HashSet<>();\n        first.add(\"\");\n        dp[0] = first;\n        for (int i = 1; i <= n; i++) {\n            Set<String> set = new HashSet<>();\n            for (String pre : dp[i - 1]) {\n                set.add(\"(\" + pre + \")\");\n            }\n            for (int m = 1; m < i; m++) {\n                for (String p1 : dp[m]) {\n                    for (String p2 : dp[i - m]) {\n                        set.add(p1 + p2);\n                        set.add(p2 + p1);\n                    }\n                }\n            }\n            dp[i] = set;\n        }\n        return new ArrayList<>(dp[n]);\n    }","code":"public static List<String> generateParenthesis1(int n) {\n        Set<String>[] dp = new Set[n + 1];\n        Set<String> first = new HashSet<>();\n        first.add(\"\");\n        dp[0] = first;\n        for (int i = 1; i <= n; i++) {\n            Set<String> set = new HashSet<>();\n            for (String pre : dp[i - 1]) {\n                set.add(\"(\" + pre + \")\");\n            }\n            for (int m = 1; m < i; m++) {\n                for (String p1 : dp[m]) {\n                    for (String p2 : dp[i - m]) {\n                        set.add(p1 + p2);\n                        set.add(p2 + p1);\n                    }\n                }\n            }\n            dp[i] = set;\n        }\n        return new ArrayList<>(dp[n]);\n    }","cleancode":"public static list<string> generateparenthesis1(int n) { set<string>[] dp = new set[n + 1]; set<string> first = new hashset<>(); first.add(\"\"); dp[0] = first; for (int i = 1; i <= n; i++) { set<string> set = new hashset<>(); for (string pre : dp[i - 1]) { set.add(\"(\" + pre + \")\"); } for (int m = 1; m < i; m++) { for (string p1 : dp[m]) { for (string p2 : dp[i - m]) { set.add(p1 + p2); set.add(p2 + p1); } } } dp[i] = set; } return new arraylist<>(dp[n]); }","comment":"\/** * ugly dp * * @param n * @return *\/","repo":"Joybeanx\/leetcode","code_context_2":"public static List<String> generateParenthesis1(int n) {\nSet<String>[] dp = new Set[n + 1];\nSet<String> first = new HashSet<>();\nfirst.add(\"\");\ndp[0] = first;\nfor (int i = 1; i <= n; i++) {\nSet<String> set = new HashSet<>();\nfor (String pre : dp[i - 1]) {\nset.add(\"(\" + pre + \")\");\n}\nfor (int m = 1; m < i; m++) {\nfor (String p1 : dp[m]) {\nfor (String p2 : dp[i - m]) {\nset.add(p1 + p2);\nset.add(p2 + p1);\n}\n}\n}\ndp[i] = set;\n}\nreturn new ArrayList<>(dp[n]);\n}","code_context_10":"public static List<String> generateParenthesis1(int n) {\nSet<String>[] dp = new Set[n + 1];\nSet<String> first = new HashSet<>();\nfirst.add(\"\");\ndp[0] = first;\nfor (int i = 1; i <= n; i++) {\nSet<String> set = new HashSet<>();\nfor (String pre : dp[i - 1]) {\nset.add(\"(\" + pre + \")\");\n}\nfor (int m = 1; m < i; m++) {\nfor (String p1 : dp[m]) {\nfor (String p2 : dp[i - m]) {\nset.add(p1 + p2);\nset.add(p2 + p1);\n}\n}\n}\ndp[i] = set;\n}\nreturn new ArrayList<>(dp[n]);\n}","code_context_20":"public static List<String> generateParenthesis1(int n) {\nSet<String>[] dp = new Set[n + 1];\nSet<String> first = new HashSet<>();\nfirst.add(\"\");\ndp[0] = first;\nfor (int i = 1; i <= n; i++) {\nSet<String> set = new HashSet<>();\nfor (String pre : dp[i - 1]) {\nset.add(\"(\" + pre + \")\");\n}\nfor (int m = 1; m < i; m++) {\nfor (String p1 : dp[m]) {\nfor (String p2 : dp[i - m]) {\nset.add(p1 + p2);\nset.add(p2 + p1);\n}\n}\n}\ndp[i] = set;\n}\nreturn new ArrayList<>(dp[n]);\n}","label":[1,0,0,0]}

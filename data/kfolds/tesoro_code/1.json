{"id":24703,"original_code":"@Override\n        public boolean onStartNode(ProjectPath path) {\n            JpaEntityMap entityMap = (JpaEntityMap) path.getObject();\n            \/\/ TODO: andrus, 4\/28\/2006 - actually we need to analyze preloaded classes and\n            \/\/ see how they were annotated to choose the right access type...\n            entityMap.setAccess(AccessType.FIELD);\n            return true;\n        }","code_wo_comment":"@Override\n        public boolean onStartNode(ProjectPath path) {\n            JpaEntityMap entityMap = (JpaEntityMap) path.getObject();\n           \n           \n            entityMap.setAccess(AccessType.FIELD);\n            return true;\n        }","cleancode":"@override public boolean onstartnode(projectpath path) { jpaentitymap entitymap = (jpaentitymap) path.getobject(); entitymap.setaccess(accesstype.field); return true; }","repo":"JavaQualitasCorpus\/cayenne-3.0.1","label":[1,0,0,0]}
{"id":24704,"original_code":"@Override\n        public boolean onStartNode(ProjectPath path) {\n            JpaRelationship relationship = (JpaRelationship) path.getObjectParent();\n            JpaJoinColumn column = (JpaJoinColumn) path.getObject();\n            if (column.getTable() == null) {\n                JpaEntity entity = path.firstInstanceOf(JpaEntity.class);\n                column.setTable(entity.getTable().getName());\n            }\n            \/\/ JPA Spec, 2.1.8.2 (same for all relationship owners):\n            \/\/ The following mapping defaults apply: [...]\n            \/\/ Table A contains a foreign key to table B. The foreign key column\n            \/\/ name is formed as the concatenation of the following: the name of\n            \/\/ the relationship property or field of entityA; \"_\" ; the name of\n            \/\/ the primary key column in table B. The foreign key column has the\n            \/\/ same type as the primary key of table B.\n            JpaEntityMap map = path.firstInstanceOf(JpaEntityMap.class);\n            JpaEntity target = map.entityForClass(relationship.getTargetEntityName());\n            if (target == null) {\n                context.recordConflict(new SimpleValidationFailure(\n                        relationship,\n                        \"Invalid relationship target \"\n                                + relationship.getTargetEntityName()));\n            }\n            else if (target.getAttributes() == null\n                    || target.getAttributes().getIds().isEmpty()) {\n                context.recordConflict(new SimpleValidationFailure(\n                        target,\n                        \"Relationship target has no PK defined: \"\n                                + relationship.getTargetEntityName()));\n            }\n            else if (target.getAttributes().getIds().size() > 1) {\n                \/\/ TODO: andrus, 4\/30\/2006 implement this; note that instead of\n                \/\/ checking for \"attribute.getJoinColumns().isEmpty()\" above,\n                \/\/ we'll have to match individual columns\n                context.recordConflict(new SimpleValidationFailure(\n                        relationship,\n                        \"Defaults for compound FK are not implemented.\"));\n            }\n            else {\n                JpaId id = target.getAttributes().getIds().iterator().next();\n                String pkName = id.getColumn() != null ? id.getColumn().getName() : id\n                        .getName();\n                column.setName(relationship.getName() + '_' + pkName);\n                column.setReferencedColumnName(id.getColumn() != null ? id\n                        .getColumn()\n                        .getName() : id.getName());\n            }\n            return true;\n        }","code_wo_comment":"@Override\n        public boolean onStartNode(ProjectPath path) {\n            JpaRelationship relationship = (JpaRelationship) path.getObjectParent();\n            JpaJoinColumn column = (JpaJoinColumn) path.getObject();\n            if (column.getTable() == null) {\n                JpaEntity entity = path.firstInstanceOf(JpaEntity.class);\n                column.setTable(entity.getTable().getName());\n            }\n           \n           \n           \n           \n           \n           \n           \n            JpaEntityMap map = path.firstInstanceOf(JpaEntityMap.class);\n            JpaEntity target = map.entityForClass(relationship.getTargetEntityName());\n            if (target == null) {\n                context.recordConflict(new SimpleValidationFailure(\n                        relationship,\n                        \"Invalid relationship target \"\n                                + relationship.getTargetEntityName()));\n            }\n            else if (target.getAttributes() == null\n                    || target.getAttributes().getIds().isEmpty()) {\n                context.recordConflict(new SimpleValidationFailure(\n                        target,\n                        \"Relationship target has no PK defined: \"\n                                + relationship.getTargetEntityName()));\n            }\n            else if (target.getAttributes().getIds().size() > 1) {\n               \n               \n               \n                context.recordConflict(new SimpleValidationFailure(\n                        relationship,\n                        \"Defaults for compound FK are not implemented.\"));\n            }\n            else {\n                JpaId id = target.getAttributes().getIds().iterator().next();\n                String pkName = id.getColumn() != null ? id.getColumn().getName() : id\n                        .getName();\n                column.setName(relationship.getName() + '_' + pkName);\n                column.setReferencedColumnName(id.getColumn() != null ? id\n                        .getColumn()\n                        .getName() : id.getName());\n            }\n            return true;\n        }","cleancode":"@override public boolean onstartnode(projectpath path) { jparelationship relationship = (jparelationship) path.getobjectparent(); jpajoincolumn column = (jpajoincolumn) path.getobject(); if (column.gettable() == null) { jpaentity entity = path.firstinstanceof(jpaentity.class); column.settable(entity.gettable().getname()); } jpaentitymap map = path.firstinstanceof(jpaentitymap.class); jpaentity target = map.entityforclass(relationship.gettargetentityname()); if (target == null) { context.recordconflict(new simplevalidationfailure( relationship, \"invalid relationship target \" + relationship.gettargetentityname())); } else if (target.getattributes() == null || target.getattributes().getids().isempty()) { context.recordconflict(new simplevalidationfailure( target, \"relationship target has no pk defined: \" + relationship.gettargetentityname())); } else if (target.getattributes().getids().size() > 1) { context.recordconflict(new simplevalidationfailure( relationship, \"defaults for compound fk are not implemented.\")); } else { jpaid id = target.getattributes().getids().iterator().next(); string pkname = id.getcolumn() != null ? id.getcolumn().getname() : id .getname(); column.setname(relationship.getname() + '_' + pkname); column.setreferencedcolumnname(id.getcolumn() != null ? id .getcolumn() .getname() : id.getname()); } return true; }","repo":"JavaQualitasCorpus\/cayenne-3.0.1","label":[0,1,0,0]}
{"id":16569,"original_code":"private Result executeTest(Path.ID id, QCInterpreter interpreter, Decl.FunctionOrMethod dec, TestType testType, int numTest, BigInteger lowerLimit, BigInteger upperLimit) {\n\t\t\/\/ Get the method for generating test values\n\t\tGenerateTest testGen;\n\t\ttry {\n\t\t\tif(testType == TestType.EXHAUSTIVE) {\n\t\t\t\ttestGen = new ExhaustiveGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n\t\t\t}\n\t\t\telse {\n\t            testGen = new RandomGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n\t\t\t}\n\t\t} catch (IntegerRangeException e) {\n\t\t\tSystem.out.println(\"Integer range was invalid for the limits given.\");\n\t\t\treturn Result.ERRORS;\n\t\t}\n\t\t\/\/ Get the function's relevant header information\n\t\tNameID name = new NameID(id, dec.getName().get());\n\t\tType.Callable type = dec.getType();\n\t\tTuple<Expr> preconditions = dec.getRequires();\n\t\tTuple<Expr> postconditions = dec.getEnsures();\n\t\tTuple<Decl.Variable> inputParameters = dec.getParameters();\n\t\tTuple<Decl.Variable> outputParameters = dec.getReturns();\n\t\tSystem.out.println(\"Name of the function\/method: \" + name.name());\n\/\/\t\tSystem.out.println(\"FUNCTION PARAM TYPES \"+ inputParameters);\n\/\/\t\tSystem.out.println(\"PRECONDITION \"+ preconditions);\n\/\/\t\tSystem.out.println(\"POSTCONDITION \"+ postconditions);\n\/\/\t\t\/\/ Have to remove the pre and post conditions out of the \n\/\/\t\t\/\/ function so the function is executed without validation\n\/\/\t\t\/\/ Validation will be conducted manually inside the function.\n\/\/\t\tTuple<Expr> empty = new Tuple<Expr>();\t\t\n\/\/\t\tdec.setOperand(4, empty); \/\/ Remove precondition\n\/\/\t\tdec.setOperand(5, empty); \/\/ Remove postcondition\n\t\tboolean completedAll = false;\n\t\tint numSkipped = 0;\n\t\tint numPassed = 0;\n\t\tint numFailed = 0;\n\t\tfor(int i=0; i < numTest; i++) {\n\t\t\trecursiveType.clear();\n\t\t\t\/\/ Stop execution if all possible combinations have been generated \n\t\t\t\/\/ Can do this for methods as well as a new call stack is created each time\n\t\t\tif(testGen.exceedSize() && i != 0) {\n\t\t\t\tcompletedAll = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRValue[] paramValues = null;\n\t\t\tCallStack frame = interpreter.new CallStack();\n\t\t\t\/\/ Check the precondition\n\t\t\ttry {\n\t\t\t\tparamValues = testGen.generateParameters();\n\t\t\t\tfor(int j=0; j < inputParameters.size(); j++) {\n\t\t\t\t\tDecl.Variable parameter = inputParameters.get(j);\n\t\t\t\t\tframe.putLocal(parameter.getName(), paramValues[j]);\n\t\t\t\t}\n\t\t\t\tinterpreter.checkInvariants(frame, preconditions);\n\t\t\t}\n\t\t\tcatch(CannotGenerateException e) {\n\t\t\t\tSystem.out.println(e);\n\t\t\t\treturn Result.ERRORS;\n\t\t\t}\n\t\t\tcatch(AssertionError e){\n\t\t\t\tSystem.out.println(\"Pre-condition failed on input: \" + Arrays.toString(paramValues));\n\t\t\t\tnumSkipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcatch(RuntimeException e) {\n\t\t\t\tSystem.out.println(\"Error occurred when generating input \" + e + \": \" + e.getMessage());\n\t\t\t\treturn Result.ERRORS;\n\t\t\t}\n\t\t\tSystem.out.println(\"INPUT: \" + Arrays.toString(paramValues));\n\t\t\t\/\/ Checks the postcondition when it is executed\n\t\t\tRValue[] returns = null;\n\t\t\ttry {\n\t\t\t\treturns = interpreter.execute(name, type, frame, false, false, paramValues);\n\t\t\t\trecursiveType.clear();\n\t\t\t}\n\t\t\tcatch(AssertionError e) {\n\t\t\t\tSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\n\t\t\t\tnumFailed++;\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\tcatch(RuntimeException e) {\n\t\t\t\tSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\n\t\t\t\treturn Result.ERRORS;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\t\/\/ Add the return values into the frame for validation\n\t\t\t\tfor(int j=0; j < outputParameters.size(); j++) {\n\t\t\t\t\tDecl.Variable parameter = outputParameters.get(j);\n\t\t\t\t\tType paramType = parameter.getType();\n\t\t\t\t\tboolean valid = checkInvariant(interpreter, paramType, returns[j]);\n\t\t\t\t\tif(!valid) {\n\t\t\t\t\t\tthrow new AssertionError(\"Type constraints for \" + parameter  + \" failed\");\n\t\t\t\t\t}\n\t\t\t\t\tframe.putLocal(parameter.getName(), returns[j]);\n\t\t\t\t}\t\n\t\t\t\ttry {\n\t\t\t\t\tinterpreter.checkInvariants(frame, postconditions);\n\t\t\t\t\tnumPassed++;\n\/\/\t\t\t\t\t\/\/ Print out any return values produced\n\t\t\t\t\tif (returns != null) {\n\t\t\t\t\t\tSystem.out.println(\"OUTPUT: \" + Arrays.toString(returns));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch(AssertionError e) {\n\t\t\t\t\tSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\n\t\t\t\t\tSystem.out.println(\"Postcondition failed \" + e);\n\t\t\t\t\tnumFailed++;\n\t\t\t\t} \n\t\t\t\tcatch(RuntimeException e) {\n\t\t\t\t\tSystem.out.println(\"Error when checking invariants of return values \" + e + \": \" + e.getMessage());\n\t\t\t\t\treturn Result.ERRORS;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(AssertionError e) {\n\t\t\t\tSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\n\t\t\t\tSystem.out.println(\"Due to error \" + e);\n\t\t\t\tnumFailed++;\n\t\t\t} \n\t\t\tcatch(RuntimeException e) {\n\t\t\t\tSystem.out.println(\"Error when checking type invariants of return values \" + e + \": \" + e.getMessage());\n\t\t\t\treturn Result.ERRORS;\n\t\t\t}\n\t\t\tcatch (ResolutionError e) {\n\t\t\t\t\/\/ FIXME resolution error\n\t\t\t\te.printStackTrace();\n\t\t\t\tassert false;\n\t\t\t} \n\t\t}\n\t\t\/\/ Overall test statistics\n\t\tif(completedAll) {\n\t\t\tSystem.out.println(\"Tested all possible combinations\");\n\t\t\tint numActualTest = numPassed + numFailed + numSkipped;\n\t\t\tif(numFailed == 0) {\n\t\t\t\tif(numPassed > 0) {\n\t\t\t\t\tSystem.out.printf(\"Ok: %d passed  (%.2f %%), %d skipped (%.2f %%), ran %d tests %n\",\n\t\t\t\t\t\t\tnumPassed, (double) 100 * numPassed\/numActualTest, numSkipped, (double) 100 * numSkipped\/numActualTest, numActualTest);\n\t\t\t\t\treturn Result.PASSED;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.println(\"All tests skipped!\");\n\t\t\t\t\treturn Result.SKIPPED;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"Failed: %d passed (%.2f %%), %d failed (%.2f %%), %d skipped (%.2f %%), ran %d tests%n\",\n\t\t\t\t\tnumPassed, (double) 100 * numPassed\/numActualTest, numFailed, (double) 100 * numFailed\/numActualTest, numSkipped, (double) 100 * numSkipped\/numActualTest, numActualTest);\n\t\t\treturn Result.FAILED;\n\t\t}\n\t\telse if(numPassed + numSkipped == numTest) {\n\t\t\tassert numFailed == 0;\n\t\t\tSystem.out.printf(\"Ok: %d passed  (%.2f %%), %d skipped (%.2f %%), ran %d tests %n\",\n\t\t\t\t\tnumPassed, (double) 100 * numPassed\/numTest, numSkipped, (double) 100 * numSkipped\/numTest, numTest);\n\t\t\treturn Result.PASSED;\n\t\t}\n\t\telse if(numSkipped == numTest) {\n\t\t\tSystem.out.println(\"All tests skipped!\");\n\t\t\treturn Result.SKIPPED;\n\t\t}\n\t\telse {\n\t\t\tSystem.out.printf(\"Failed: %d passed (%.2f %%), %d failed (%.2f %%), %d skipped (%.2f %%), ran %d tests%n\",\n\t\t\t\t\tnumPassed, (double) 100 * numPassed\/numTest, numFailed, (double) 100 * numFailed\/numTest, numSkipped, (double) 100 * numSkipped\/numTest, numTest);\n\t\t\treturn Result.FAILED;\n\t\t}\n\t}","code_wo_comment":"private Result executeTest(Path.ID id, QCInterpreter interpreter, Decl.FunctionOrMethod dec, TestType testType, int numTest, BigInteger lowerLimit, BigInteger upperLimit) {\n\t\n\t\tGenerateTest testGen;\n\t\ttry {\n\t\t\tif(testType == TestType.EXHAUSTIVE) {\n\t\t\t\ttestGen = new ExhaustiveGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n\t\t\t}\n\t\t\telse {\n\t            testGen = new RandomGenerateTest(dec.getParameters(), interpreter, numTest, lowerLimit, upperLimit);\n\t\t\t}\n\t\t} catch (IntegerRangeException e) {\n\t\t\tSystem.out.println(\"Integer range was invalid for the limits given.\");\n\t\t\treturn Result.ERRORS;\n\t\t}\n\t\n\t\tNameID name = new NameID(id, dec.getName().get());\n\t\tType.Callable type = dec.getType();\n\t\tTuple<Expr> preconditions = dec.getRequires();\n\t\tTuple<Expr> postconditions = dec.getEnsures();\n\t\tTuple<Decl.Variable> inputParameters = dec.getParameters();\n\t\tTuple<Decl.Variable> outputParameters = dec.getReturns();\n\t\tSystem.out.println(\"Name of the function\/method: \" + name.name());\n\t\tboolean completedAll = false;\n\t\tint numSkipped = 0;\n\t\tint numPassed = 0;\n\t\tint numFailed = 0;\n\t\tfor(int i=0; i < numTest; i++) {\n\t\t\trecursiveType.clear();\n\t\t\n\t\t\n\t\t\tif(testGen.exceedSize() && i != 0) {\n\t\t\t\tcompletedAll = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRValue[] paramValues = null;\n\t\t\tCallStack frame = interpreter.new CallStack();\n\t\t\n\t\t\ttry {\n\t\t\t\tparamValues = testGen.generateParameters();\n\t\t\t\tfor(int j=0; j < inputParameters.size(); j++) {\n\t\t\t\t\tDecl.Variable parameter = inputParameters.get(j);\n\t\t\t\t\tframe.putLocal(parameter.getName(), paramValues[j]);\n\t\t\t\t}\n\t\t\t\tinterpreter.checkInvariants(frame, preconditions);\n\t\t\t}\n\t\t\tcatch(CannotGenerateException e) {\n\t\t\t\tSystem.out.println(e);\n\t\t\t\treturn Result.ERRORS;\n\t\t\t}\n\t\t\tcatch(AssertionError e){\n\t\t\t\tSystem.out.println(\"Pre-condition failed on input: \" + Arrays.toString(paramValues));\n\t\t\t\tnumSkipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcatch(RuntimeException e) {\n\t\t\t\tSystem.out.println(\"Error occurred when generating input \" + e + \": \" + e.getMessage());\n\t\t\t\treturn Result.ERRORS;\n\t\t\t}\n\t\t\tSystem.out.println(\"INPUT: \" + Arrays.toString(paramValues));\n\t\t\n\t\t\tRValue[] returns = null;\n\t\t\ttry {\n\t\t\t\treturns = interpreter.execute(name, type, frame, false, false, paramValues);\n\t\t\t\trecursiveType.clear();\n\t\t\t}\n\t\t\tcatch(AssertionError e) {\n\t\t\t\tSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\n\t\t\t\tnumFailed++;\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\tcatch(RuntimeException e) {\n\t\t\t\tSystem.out.println(\"Error occurred during execution \" + e + \": \" + e.getMessage());\n\t\t\t\treturn Result.ERRORS;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\n\t\t\t\tfor(int j=0; j < outputParameters.size(); j++) {\n\t\t\t\t\tDecl.Variable parameter = outputParameters.get(j);\n\t\t\t\t\tType paramType = parameter.getType();\n\t\t\t\t\tboolean valid = checkInvariant(interpreter, paramType, returns[j]);\n\t\t\t\t\tif(!valid) {\n\t\t\t\t\t\tthrow new AssertionError(\"Type constraints for \" + parameter  + \" failed\");\n\t\t\t\t\t}\n\t\t\t\t\tframe.putLocal(parameter.getName(), returns[j]);\n\t\t\t\t}\t\n\t\t\t\ttry {\n\t\t\t\t\tinterpreter.checkInvariants(frame, postconditions);\n\t\t\t\t\tnumPassed++;\n\t\t\t\t\tif (returns != null) {\n\t\t\t\t\t\tSystem.out.println(\"OUTPUT: \" + Arrays.toString(returns));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch(AssertionError e) {\n\t\t\t\t\tSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\n\t\t\t\t\tSystem.out.println(\"Postcondition failed \" + e);\n\t\t\t\t\tnumFailed++;\n\t\t\t\t} \n\t\t\t\tcatch(RuntimeException e) {\n\t\t\t\t\tSystem.out.println(\"Error when checking invariants of return values \" + e + \": \" + e.getMessage());\n\t\t\t\t\treturn Result.ERRORS;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(AssertionError e) {\n\t\t\t\tSystem.out.printf(\"Failed Input: %s%nFailed Output: %s%n\", Arrays.toString(paramValues), Arrays.toString(returns));\n\t\t\t\tSystem.out.println(\"Due to error \" + e);\n\t\t\t\tnumFailed++;\n\t\t\t} \n\t\t\tcatch(RuntimeException e) {\n\t\t\t\tSystem.out.println(\"Error when checking type invariants of return values \" + e + \": \" + e.getMessage());\n\t\t\t\treturn Result.ERRORS;\n\t\t\t}\n\t\t\tcatch (ResolutionError e) {\n\t\t\t\n\t\t\t\te.printStackTrace();\n\t\t\t\tassert false;\n\t\t\t} \n\t\t}\n\t\n\t\tif(completedAll) {\n\t\t\tSystem.out.println(\"Tested all possible combinations\");\n\t\t\tint numActualTest = numPassed + numFailed + numSkipped;\n\t\t\tif(numFailed == 0) {\n\t\t\t\tif(numPassed > 0) {\n\t\t\t\t\tSystem.out.printf(\"Ok: %d passed  (%.2f %%), %d skipped (%.2f %%), ran %d tests %n\",\n\t\t\t\t\t\t\tnumPassed, (double) 100 * numPassed\/numActualTest, numSkipped, (double) 100 * numSkipped\/numActualTest, numActualTest);\n\t\t\t\t\treturn Result.PASSED;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.println(\"All tests skipped!\");\n\t\t\t\t\treturn Result.SKIPPED;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"Failed: %d passed (%.2f %%), %d failed (%.2f %%), %d skipped (%.2f %%), ran %d tests%n\",\n\t\t\t\t\tnumPassed, (double) 100 * numPassed\/numActualTest, numFailed, (double) 100 * numFailed\/numActualTest, numSkipped, (double) 100 * numSkipped\/numActualTest, numActualTest);\n\t\t\treturn Result.FAILED;\n\t\t}\n\t\telse if(numPassed + numSkipped == numTest) {\n\t\t\tassert numFailed == 0;\n\t\t\tSystem.out.printf(\"Ok: %d passed  (%.2f %%), %d skipped (%.2f %%), ran %d tests %n\",\n\t\t\t\t\tnumPassed, (double) 100 * numPassed\/numTest, numSkipped, (double) 100 * numSkipped\/numTest, numTest);\n\t\t\treturn Result.PASSED;\n\t\t}\n\t\telse if(numSkipped == numTest) {\n\t\t\tSystem.out.println(\"All tests skipped!\");\n\t\t\treturn Result.SKIPPED;\n\t\t}\n\t\telse {\n\t\t\tSystem.out.printf(\"Failed: %d passed (%.2f %%), %d failed (%.2f %%), %d skipped (%.2f %%), ran %d tests%n\",\n\t\t\t\t\tnumPassed, (double) 100 * numPassed\/numTest, numFailed, (double) 100 * numFailed\/numTest, numSkipped, (double) 100 * numSkipped\/numTest, numTest);\n\t\t\treturn Result.FAILED;\n\t\t}\n\t}","cleancode":"private result executetest(path.id id, qcinterpreter interpreter, decl.functionormethod dec, testtype testtype, int numtest, biginteger lowerlimit, biginteger upperlimit) { generatetest testgen; try { if(testtype == testtype.exhaustive) { testgen = new exhaustivegeneratetest(dec.getparameters(), interpreter, numtest, lowerlimit, upperlimit); } else { testgen = new randomgeneratetest(dec.getparameters(), interpreter, numtest, lowerlimit, upperlimit); } } catch (integerrangeexception e) { system.out.println(\"integer range was invalid for the limits given.\"); return result.errors; } nameid name = new nameid(id, dec.getname().get()); type.callable type = dec.gettype(); tuple<expr> preconditions = dec.getrequires(); tuple<expr> postconditions = dec.getensures(); tuple<decl.variable> inputparameters = dec.getparameters(); tuple<decl.variable> outputparameters = dec.getreturns(); system.out.println(\"name of the function\/method: \" + name.name()); boolean completedall = false; int numskipped = 0; int numpassed = 0; int numfailed = 0; for(int i=0; i < numtest; i++) { recursivetype.clear(); if(testgen.exceedsize() && i != 0) { completedall = true; break; } rvalue[] paramvalues = null; callstack frame = interpreter.new callstack(); try { paramvalues = testgen.generateparameters(); for(int j=0; j < inputparameters.size(); j++) { decl.variable parameter = inputparameters.get(j); frame.putlocal(parameter.getname(), paramvalues[j]); } interpreter.checkinvariants(frame, preconditions); } catch(cannotgenerateexception e) { system.out.println(e); return result.errors; } catch(assertionerror e){ system.out.println(\"pre-condition failed on input: \" + arrays.tostring(paramvalues)); numskipped++; continue; } catch(runtimeexception e) { system.out.println(\"error occurred when generating input \" + e + \": \" + e.getmessage()); return result.errors; } system.out.println(\"input: \" + arrays.tostring(paramvalues)); rvalue[] returns = null; try { returns = interpreter.execute(name, type, frame, false, false, paramvalues); recursivetype.clear(); } catch(assertionerror e) { system.out.println(\"error occurred during execution \" + e + \": \" + e.getmessage()); numfailed++; continue; } catch(runtimeexception e) { system.out.println(\"error occurred during execution \" + e + \": \" + e.getmessage()); return result.errors; } try { for(int j=0; j < outputparameters.size(); j++) { decl.variable parameter = outputparameters.get(j); type paramtype = parameter.gettype(); boolean valid = checkinvariant(interpreter, paramtype, returns[j]); if(!valid) { throw new assertionerror(\"type constraints for \" + parameter + \" failed\"); } frame.putlocal(parameter.getname(), returns[j]); } try { interpreter.checkinvariants(frame, postconditions); numpassed++; if (returns != null) { system.out.println(\"output: \" + arrays.tostring(returns)); } } catch(assertionerror e) { system.out.printf(\"failed input: %s%nfailed output: %s%n\", arrays.tostring(paramvalues), arrays.tostring(returns)); system.out.println(\"postcondition failed \" + e); numfailed++; } catch(runtimeexception e) { system.out.println(\"error when checking invariants of return values \" + e + \": \" + e.getmessage()); return result.errors; } } catch(assertionerror e) { system.out.printf(\"failed input: %s%nfailed output: %s%n\", arrays.tostring(paramvalues), arrays.tostring(returns)); system.out.println(\"due to error \" + e); numfailed++; } catch(runtimeexception e) { system.out.println(\"error when checking type invariants of return values \" + e + \": \" + e.getmessage()); return result.errors; } catch (resolutionerror e) { e.printstacktrace(); assert false; } } if(completedall) { system.out.println(\"tested all possible combinations\"); int numactualtest = numpassed + numfailed + numskipped; if(numfailed == 0) { if(numpassed > 0) { system.out.printf(\"ok: %d passed (%.2f %%), %d skipped (%.2f %%), ran %d tests %n\", numpassed, (double) 100 * numpassed\/numactualtest, numskipped, (double) 100 * numskipped\/numactualtest, numactualtest); return result.passed; } else { system.out.println(\"all tests skipped!\"); return result.skipped; } } system.out.printf(\"failed: %d passed (%.2f %%), %d failed (%.2f %%), %d skipped (%.2f %%), ran %d tests%n\", numpassed, (double) 100 * numpassed\/numactualtest, numfailed, (double) 100 * numfailed\/numactualtest, numskipped, (double) 100 * numskipped\/numactualtest, numactualtest); return result.failed; } else if(numpassed + numskipped == numtest) { assert numfailed == 0; system.out.printf(\"ok: %d passed (%.2f %%), %d skipped (%.2f %%), ran %d tests %n\", numpassed, (double) 100 * numpassed\/numtest, numskipped, (double) 100 * numskipped\/numtest, numtest); return result.passed; } else if(numskipped == numtest) { system.out.println(\"all tests skipped!\"); return result.skipped; } else { system.out.printf(\"failed: %d passed (%.2f %%), %d failed (%.2f %%), %d skipped (%.2f %%), ran %d tests%n\", numpassed, (double) 100 * numpassed\/numtest, numfailed, (double) 100 * numfailed\/numtest, numskipped, (double) 100 * numskipped\/numtest, numtest); return result.failed; } }","repo":"JC626\/quickcheck-for-whiley","label":[0,0,1,0]}
{"id":8419,"original_code":"@GET\n  @Path(\"getDefaultNotebook\")\n  @Produces(MediaType.TEXT_PLAIN)\n  public String getDefaultNotebook() {\n    final String defaultNotebookUrl = this.bkConfig.getDefaultNotebookUrl();\n    \/\/ TODO, assume the url is a file path for now.\n    java.nio.file.Path defaultNotebookFile = Paths.get(defaultNotebookUrl);\n    String content = this.utils.readFile(defaultNotebookFile);\n    if (content == null) {\n      System.out.println(\"Warning, default notebook is empty\");\n      return \"\";\n    }\n    return clean(content);\n  }","code_wo_comment":"@GET\n  @Path(\"getDefaultNotebook\")\n  @Produces(MediaType.TEXT_PLAIN)\n  public String getDefaultNotebook() {\n    final String defaultNotebookUrl = this.bkConfig.getDefaultNotebookUrl();\n   \n    java.nio.file.Path defaultNotebookFile = Paths.get(defaultNotebookUrl);\n    String content = this.utils.readFile(defaultNotebookFile);\n    if (content == null) {\n      System.out.println(\"Warning, default notebook is empty\");\n      return \"\";\n    }\n    return clean(content);\n  }","cleancode":"@get @path(\"getdefaultnotebook\") @produces(mediatype.text_plain) public string getdefaultnotebook() { final string defaultnotebookurl = this.bkconfig.getdefaultnotebookurl(); java.nio.file.path defaultnotebookfile = paths.get(defaultnotebookurl); string content = this.utils.readfile(defaultnotebookfile); if (content == null) { system.out.println(\"warning, default notebook is empty\"); return \"\"; } return clean(content); }","repo":"NunoEdgarGFlowHub\/beaker-notebook","label":[1,0,0,0]}
{"id":8421,"original_code":"@POST\n  @Path(\"setPreference\")\n  public synchronized void setPreference(\n    @FormParam(\"preferencename\") String preferenceName,\n    @FormParam(\"preferencevalue\") String preferenceValue) {\n    if ((preferenceName == null) || (preferenceValue == null))\n      return;\n    Object newValue = null;\n    \/\/ Validate boolean preferences\n    String[] booleanPrefs = {\"advanced-mode\", \"allow-anonymous-usage-tracking\", \"fs-reverse\"};\n    if (Arrays.asList(booleanPrefs).contains(preferenceName)){\n      switch (preferenceValue){\n        case \"true\":\n          newValue = Boolean.TRUE;\n          break;\n        case \"false\":\n          newValue = Boolean.FALSE;\n          break;\n        default:\n          return;\n      }\n      if (preferenceName.equals(\"advanced-mode\"))\n        this.isUseAdvancedMode = (Boolean) newValue;\n      else if (preferenceName == \"allow\")\n        this.isAllowAnonymousTracking = (Boolean) newValue;\n    }\n    \/\/ Validate edit mode\n    else if (preferenceName.equals(\"edit-mode\")){\n      String[] validModes = {\"vim\", \"emacs\", \"default\"};\n      if (Arrays.asList(validModes).contains(preferenceValue)){\n        newValue = preferenceValue;\n        this.editMode = preferenceValue;\n      }\n    }\n    \/\/ Validate edit mode\n    else if (preferenceName.equals(\"fs-order-by\")){\n      String[] validModes = {\"uri\", \"modified\"};\n      if (Arrays.asList(validModes).contains(preferenceValue)){\n        newValue = preferenceValue;\n      }\n    }\n    final String preferenceFileUrl = this.bkConfig.getPreferenceFileUrl();\n    \/\/ TODO, assume the url is a file path for now.\n    \/\/ System.out.println(preferenceFileUrl + \" url!!!!\\n\");\n    \/\/ Use a temporary for atomic writing\n    java.nio.file.Path preferenceFileTmp = Paths.get(preferenceFileUrl + \".tmp\");\n    java.nio.file.Path preferenceFile = Paths.get(preferenceFileUrl);\n    try {\n      ObjectMapper om = new ObjectMapper();\n      TypeReference readType = new TypeReference<HashMap<String, Object>>() {\n      };\n      Map<String, Object> prefs = om.readValue(preferenceFile.toFile(), readType);\n      Object oldValue = (Object) prefs.get(preferenceName);\n      \/\/ If value changed, write it to the file too\n      if (!Objects.equals(newValue, oldValue)) {\n        Files.deleteIfExists(preferenceFileTmp);\n        prefs.put(preferenceName, newValue);\n        om.writerWithDefaultPrettyPrinter().writeValue(preferenceFileTmp.toFile(), prefs);\n        \/\/ Move tmp to normal\n        Files.move(preferenceFileTmp, preferenceFile, REPLACE_EXISTING);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }","code_wo_comment":"@POST\n  @Path(\"setPreference\")\n  public synchronized void setPreference(\n    @FormParam(\"preferencename\") String preferenceName,\n    @FormParam(\"preferencevalue\") String preferenceValue) {\n    if ((preferenceName == null) || (preferenceValue == null))\n      return;\n    Object newValue = null;\n   \n    String[] booleanPrefs = {\"advanced-mode\", \"allow-anonymous-usage-tracking\", \"fs-reverse\"};\n    if (Arrays.asList(booleanPrefs).contains(preferenceName)){\n      switch (preferenceValue){\n        case \"true\":\n          newValue = Boolean.TRUE;\n          break;\n        case \"false\":\n          newValue = Boolean.FALSE;\n          break;\n        default:\n          return;\n      }\n      if (preferenceName.equals(\"advanced-mode\"))\n        this.isUseAdvancedMode = (Boolean) newValue;\n      else if (preferenceName == \"allow\")\n        this.isAllowAnonymousTracking = (Boolean) newValue;\n    }\n   \n    else if (preferenceName.equals(\"edit-mode\")){\n      String[] validModes = {\"vim\", \"emacs\", \"default\"};\n      if (Arrays.asList(validModes).contains(preferenceValue)){\n        newValue = preferenceValue;\n        this.editMode = preferenceValue;\n      }\n    }\n   \n    else if (preferenceName.equals(\"fs-order-by\")){\n      String[] validModes = {\"uri\", \"modified\"};\n      if (Arrays.asList(validModes).contains(preferenceValue)){\n        newValue = preferenceValue;\n      }\n    }\n    final String preferenceFileUrl = this.bkConfig.getPreferenceFileUrl();\n   \n   \n   \n    java.nio.file.Path preferenceFileTmp = Paths.get(preferenceFileUrl + \".tmp\");\n    java.nio.file.Path preferenceFile = Paths.get(preferenceFileUrl);\n    try {\n      ObjectMapper om = new ObjectMapper();\n      TypeReference readType = new TypeReference<HashMap<String, Object>>() {\n      };\n      Map<String, Object> prefs = om.readValue(preferenceFile.toFile(), readType);\n      Object oldValue = (Object) prefs.get(preferenceName);\n     \n      if (!Objects.equals(newValue, oldValue)) {\n        Files.deleteIfExists(preferenceFileTmp);\n        prefs.put(preferenceName, newValue);\n        om.writerWithDefaultPrettyPrinter().writeValue(preferenceFileTmp.toFile(), prefs);\n       \n        Files.move(preferenceFileTmp, preferenceFile, REPLACE_EXISTING);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }","cleancode":"@post @path(\"setpreference\") public synchronized void setpreference( @formparam(\"preferencename\") string preferencename, @formparam(\"preferencevalue\") string preferencevalue) { if ((preferencename == null) || (preferencevalue == null)) return; object newvalue = null; string[] booleanprefs = {\"advanced-mode\", \"allow-anonymous-usage-tracking\", \"fs-reverse\"}; if (arrays.aslist(booleanprefs).contains(preferencename)){ switch (preferencevalue){ case \"true\": newvalue = boolean.true; break; case \"false\": newvalue = boolean.false; break; default: return; } if (preferencename.equals(\"advanced-mode\")) this.isuseadvancedmode = (boolean) newvalue; else if (preferencename == \"allow\") this.isallowanonymoustracking = (boolean) newvalue; } else if (preferencename.equals(\"edit-mode\")){ string[] validmodes = {\"vim\", \"emacs\", \"default\"}; if (arrays.aslist(validmodes).contains(preferencevalue)){ newvalue = preferencevalue; this.editmode = preferencevalue; } } else if (preferencename.equals(\"fs-order-by\")){ string[] validmodes = {\"uri\", \"modified\"}; if (arrays.aslist(validmodes).contains(preferencevalue)){ newvalue = preferencevalue; } } final string preferencefileurl = this.bkconfig.getpreferencefileurl(); java.nio.file.path preferencefiletmp = paths.get(preferencefileurl + \".tmp\"); java.nio.file.path preferencefile = paths.get(preferencefileurl); try { objectmapper om = new objectmapper(); typereference readtype = new typereference<hashmap<string, object>>() { }; map<string, object> prefs = om.readvalue(preferencefile.tofile(), readtype); object oldvalue = (object) prefs.get(preferencename); if (!objects.equals(newvalue, oldvalue)) { files.deleteifexists(preferencefiletmp); prefs.put(preferencename, newvalue); om.writerwithdefaultprettyprinter().writevalue(preferencefiletmp.tofile(), prefs); files.move(preferencefiletmp, preferencefile, replace_existing); } } catch (ioexception e) { e.printstacktrace(); } }","repo":"NunoEdgarGFlowHub\/beaker-notebook","label":[1,0,0,0]}
{"id":8420,"original_code":"private void resetConfig() {\n    final String configFileUrl = this.bkConfig.getConfigFileUrl();\n    final String preferenceFileUrl = this.bkConfig.getPreferenceFileUrl();\n    \/\/ TODO, assume the url is a file path for now.\n    java.nio.file.Path configFile = Paths.get(configFileUrl);\n    java.nio.file.Path preferenceFile = Paths.get(preferenceFileUrl);\n    try {\n      JSONParser parser = new JSONParser();\n      JSONObject configJsonObject =\n          (JSONObject) parser.parse(this.utils.readFile(configFile));\n      JSONObject preferenceJsonObject =\n          (JSONObject) parser.parse(this.utils.readFile(preferenceFile));\n      String isAllowTracking = mergeBooleanSetting(\n          \"allow-anonymous-usage-tracking\",\n          configJsonObject,\n          preferenceJsonObject);\n      setPreference(\"allow-anonymous-usage-tracking\", isAllowTracking);\n      String isUseAdvancedMode = mergeBooleanSetting(\n          \"advanced-mode\",\n          configJsonObject,\n          preferenceJsonObject);\n      setPreference(\"advanced-mode\", isUseAdvancedMode);\n      String mergedEditMode = mergeStringSetting(\n          \"edit-mode\",\n          configJsonObject,\n          preferenceJsonObject);\n      setPreference(\"edit-mode\", mergedEditMode);\n      this.initPlugins.addAll(\n          mergeListSetting(\"init\", configJsonObject, preferenceJsonObject));\n      this.controlPanelMenuPlugins.addAll(\n          mergeListSetting(\"control-panel-menu-plugins\", configJsonObject, preferenceJsonObject));\n      this.menuPlugins.addAll(\n          mergeListSetting(\"notebook-app-menu-plugins\", configJsonObject, preferenceJsonObject));\n      this.cellMenuPlugins.addAll(\n          mergeListSetting(\"notebook-cell-menu-plugins\", configJsonObject, preferenceJsonObject));\n    } catch (ParseException e) {\n      throw new RuntimeException(\"failed getting beaker configurations from config file\", e);\n    }\n  }","code_wo_comment":"private void resetConfig() {\n    final String configFileUrl = this.bkConfig.getConfigFileUrl();\n    final String preferenceFileUrl = this.bkConfig.getPreferenceFileUrl();\n   \n    java.nio.file.Path configFile = Paths.get(configFileUrl);\n    java.nio.file.Path preferenceFile = Paths.get(preferenceFileUrl);\n    try {\n      JSONParser parser = new JSONParser();\n      JSONObject configJsonObject =\n          (JSONObject) parser.parse(this.utils.readFile(configFile));\n      JSONObject preferenceJsonObject =\n          (JSONObject) parser.parse(this.utils.readFile(preferenceFile));\n      String isAllowTracking = mergeBooleanSetting(\n          \"allow-anonymous-usage-tracking\",\n          configJsonObject,\n          preferenceJsonObject);\n      setPreference(\"allow-anonymous-usage-tracking\", isAllowTracking);\n      String isUseAdvancedMode = mergeBooleanSetting(\n          \"advanced-mode\",\n          configJsonObject,\n          preferenceJsonObject);\n      setPreference(\"advanced-mode\", isUseAdvancedMode);\n      String mergedEditMode = mergeStringSetting(\n          \"edit-mode\",\n          configJsonObject,\n          preferenceJsonObject);\n      setPreference(\"edit-mode\", mergedEditMode);\n      this.initPlugins.addAll(\n          mergeListSetting(\"init\", configJsonObject, preferenceJsonObject));\n      this.controlPanelMenuPlugins.addAll(\n          mergeListSetting(\"control-panel-menu-plugins\", configJsonObject, preferenceJsonObject));\n      this.menuPlugins.addAll(\n          mergeListSetting(\"notebook-app-menu-plugins\", configJsonObject, preferenceJsonObject));\n      this.cellMenuPlugins.addAll(\n          mergeListSetting(\"notebook-cell-menu-plugins\", configJsonObject, preferenceJsonObject));\n    } catch (ParseException e) {\n      throw new RuntimeException(\"failed getting beaker configurations from config file\", e);\n    }\n  }","cleancode":"private void resetconfig() { final string configfileurl = this.bkconfig.getconfigfileurl(); final string preferencefileurl = this.bkconfig.getpreferencefileurl(); java.nio.file.path configfile = paths.get(configfileurl); java.nio.file.path preferencefile = paths.get(preferencefileurl); try { jsonparser parser = new jsonparser(); jsonobject configjsonobject = (jsonobject) parser.parse(this.utils.readfile(configfile)); jsonobject preferencejsonobject = (jsonobject) parser.parse(this.utils.readfile(preferencefile)); string isallowtracking = mergebooleansetting( \"allow-anonymous-usage-tracking\", configjsonobject, preferencejsonobject); setpreference(\"allow-anonymous-usage-tracking\", isallowtracking); string isuseadvancedmode = mergebooleansetting( \"advanced-mode\", configjsonobject, preferencejsonobject); setpreference(\"advanced-mode\", isuseadvancedmode); string mergededitmode = mergestringsetting( \"edit-mode\", configjsonobject, preferencejsonobject); setpreference(\"edit-mode\", mergededitmode); this.initplugins.addall( mergelistsetting(\"init\", configjsonobject, preferencejsonobject)); this.controlpanelmenuplugins.addall( mergelistsetting(\"control-panel-menu-plugins\", configjsonobject, preferencejsonobject)); this.menuplugins.addall( mergelistsetting(\"notebook-app-menu-plugins\", configjsonobject, preferencejsonobject)); this.cellmenuplugins.addall( mergelistsetting(\"notebook-cell-menu-plugins\", configjsonobject, preferencejsonobject)); } catch (parseexception e) { throw new runtimeexception(\"failed getting beaker configurations from config file\", e); } }","repo":"NunoEdgarGFlowHub\/beaker-notebook","label":[1,0,0,0]}
{"id":8457,"original_code":"@Override\n    @StartHandler(phase = Phase.INBOUND_EVENT_CONNECTORS)\n    public void start() {\n        if (activeProcessorThreads() > 0 || workLauncherRunning.get()) {\n            if (state.get().isRunning()) {\n                \/\/ then it's ok. It's already running\n                return;\n            } else {\n                \/\/ this is problematic. There are still active threads pending a shutdown.\n                throw new IllegalStateException(\"Cannot start this processor. It is pending shutdown...\");\n            }\n        }\n        State previousState = state.getAndSet(State.STARTED);\n        if (!previousState.isRunning()) {\n            startSegmentWorkers();\n        }\n    }","code_wo_comment":"@Override\n    @StartHandler(phase = Phase.INBOUND_EVENT_CONNECTORS)\n    public void start() {\n        if (activeProcessorThreads() > 0 || workLauncherRunning.get()) {\n            if (state.get().isRunning()) {\n               \n                return;\n            } else {\n               \n                throw new IllegalStateException(\"Cannot start this processor. It is pending shutdown...\");\n            }\n        }\n        State previousState = state.getAndSet(State.STARTED);\n        if (!previousState.isRunning()) {\n            startSegmentWorkers();\n        }\n    }","cleancode":"@override @starthandler(phase = phase.inbound_event_connectors) public void start() { if (activeprocessorthreads() > 0 || worklauncherrunning.get()) { if (state.get().isrunning()) { return; } else { throw new illegalstateexception(\"cannot start this processor. it is pending shutdown...\"); } } state previousstate = state.getandset(state.started); if (!previousstate.isrunning()) { startsegmentworkers(); } }","repo":"Mu-L\/AxonFramework","label":[0,0,1,0]}
{"id":275,"original_code":"public void update(Observable arg0, Object arg) {\n\t\t\/\/ arg is Event\n\t\tif (!(arg instanceof Event))\n\t\t\treturn;\n\t\tEvent event = (Event) arg;\n\t\t\/\/ check the event function against the functions we have notifications watching for\n\t\tString function = event.getEvent();\n\t\t\/\/we err on the side of caution here in checking all events that might invalidate the data in the cache -DH\n\t\tif (UserDirectoryService.SECURE_ADD_USER.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN_PASSWORD.equals(function)\n\t\t\t\t|| UserDirectoryService.SECURE_UPDATE_USER_ANY.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN.equals(function)) {\n\t\t\t\/\/we need the userId\n\t\t\tReference ref = entityManager.newReference(event.getResource());\n\t\t\t\/\/ look for group reference. Need to replace it with parent site reference\n\t\t\tString refId = ref.getId();\n\t\t\ttry {\n\t\t\t\tString eid = userDirectoryService.getUserEid(refId);\n\t\t\t\tlog.debug(\"removing \" + eid + \" from cache\");\n\t\t\t\tauthenticationCache.removeAuthentification(eid);\n\t\t\t\tuserCache.remove(UserDirectoryService.IDCACHE + eid);\n\t\t\t\tuserCache.remove(UserDirectoryService.EIDCACHE + refId);\n\t\t\t} catch (UserNotDefinedException e) {\n\t\t\t\t\/\/not sure how we'd end up here\n\t\t\t\tlog.warn(e.getMessage(), e);\n\t\t\t}\n\t\t} \n\t}","code_wo_comment":"public void update(Observable arg0, Object arg) {\n\t\n\t\tif (!(arg instanceof Event))\n\t\t\treturn;\n\t\tEvent event = (Event) arg;\n\t\n\t\tString function = event.getEvent();\n\t\n\t\tif (UserDirectoryService.SECURE_ADD_USER.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN_PASSWORD.equals(function)\n\t\t\t\t|| UserDirectoryService.SECURE_UPDATE_USER_ANY.equals(function) || UserDirectoryService.SECURE_UPDATE_USER_OWN.equals(function)) {\n\t\t\n\t\t\tReference ref = entityManager.newReference(event.getResource());\n\t\t\n\t\t\tString refId = ref.getId();\n\t\t\ttry {\n\t\t\t\tString eid = userDirectoryService.getUserEid(refId);\n\t\t\t\tlog.debug(\"removing \" + eid + \" from cache\");\n\t\t\t\tauthenticationCache.removeAuthentification(eid);\n\t\t\t\tuserCache.remove(UserDirectoryService.IDCACHE + eid);\n\t\t\t\tuserCache.remove(UserDirectoryService.EIDCACHE + refId);\n\t\t\t} catch (UserNotDefinedException e) {\n\t\t\t\n\t\t\t\tlog.warn(e.getMessage(), e);\n\t\t\t}\n\t\t} \n\t}","cleancode":"public void update(observable arg0, object arg) { if (!(arg instanceof event)) return; event event = (event) arg; string function = event.getevent(); if (userdirectoryservice.secure_add_user.equals(function) || userdirectoryservice.secure_update_user_own_password.equals(function) || userdirectoryservice.secure_update_user_any.equals(function) || userdirectoryservice.secure_update_user_own.equals(function)) { reference ref = entitymanager.newreference(event.getresource()); string refid = ref.getid(); try { string eid = userdirectoryservice.getusereid(refid); log.debug(\"removing \" + eid + \" from cache\"); authenticationcache.removeauthentification(eid); usercache.remove(userdirectoryservice.idcache + eid); usercache.remove(userdirectoryservice.eidcache + refid); } catch (usernotdefinedexception e) { log.warn(e.getmessage(), e); } } }","repo":"RyanAFinney\/sakai","label":[1,0,0,0]}
{"id":286,"original_code":"public static String getAppProcess32Bit() {\n        return getAppProcess32Bit(true);\n    }","code_wo_comment":"public static String getAppProcess32Bit() {\n        return getAppProcess32Bit(true);\n    }","cleancode":"public static string getappprocess32bit() { return getappprocess32bit(true); }","repo":"Lobesitdoll\/librootjava","label":[0,0,0,0]}
{"id":8492,"original_code":"@Pure\n    @Override\n    public boolean equals(@Nullable Object o) {\n      if (o == null) return false; \/\/ never happens\n      if (this == o) return true;\n      \/\/ This test is illegal because WeakKey is a generic type,\n      \/\/ so use the getClass hack below instead.\n      \/\/ if (!(o instanceof WeakKey)) return false;\n      if (!(o.getClass().equals(WeakKey.class))) return false;\n      Object t = this.get();\n      @SuppressWarnings(\"unchecked\")\n      Object u = ((WeakKey) o).get();\n      if ((t == null) || (u == null)) return false;\n      if (t == u) return true;\n      return keyEquals(t, u);\n    }","code_wo_comment":"@Pure\n    @Override\n    public boolean equals(@Nullable Object o) {\n      if (o == null) return false;\n      if (this == o) return true;\n     \n     \n     \n      if (!(o.getClass().equals(WeakKey.class))) return false;\n      Object t = this.get();\n      @SuppressWarnings(\"unchecked\")\n      Object u = ((WeakKey) o).get();\n      if ((t == null) || (u == null)) return false;\n      if (t == u) return true;\n      return keyEquals(t, u);\n    }","cleancode":"@pure @override public boolean equals(@nullable object o) { if (o == null) return false; if (this == o) return true; if (!(o.getclass().equals(weakkey.class))) return false; object t = this.get(); @suppresswarnings(\"unchecked\") object u = ((weakkey) o).get(); if ((t == null) || (u == null)) return false; if (t == u) return true; return keyequals(t, u); }","repo":"Nargeshdb\/plume-util","label":[1,0,0,0]}
{"id":16687,"original_code":"public void applyGPSSetting() {\n        \/\/ verify if GPS enable on device\n        if(GPSService.isGPSProviderEnable(context) || GPSService.isNetworkProviderEnable(context)) {\n            GPSSettingController gpsSettingController = new GPSSettingController(mMapView.getContext());\n            Boolean showGPSLocation = gpsSettingController.getGPSLocationState();\n            Boolean showGPSLocationOnCenter = gpsSettingController.getGPSCenterState();\n            if (showGPSLocation != null)\n                if (showGPSLocation) {\n                    MainActivity mainActivity = (MainActivity) context;\n                    GPSOverlayController gpsOverlayController = mainActivity.getMainController().getGpsOverlayController();\n                    gpsOverlayController.addGPSTrackerLayer();\n                    gpsOverlayController.setKeepOnCenter( ((showGPSLocationOnCenter != null)?(showGPSLocationOnCenter):(false)) );\n                }\n        }else {\n            \/\/ TODO: notify user when the state of the GPS resource is disabled. use one icon on action bar?\n        }\n    }","code_wo_comment":"public void applyGPSSetting() {\n       \n        if(GPSService.isGPSProviderEnable(context) || GPSService.isNetworkProviderEnable(context)) {\n            GPSSettingController gpsSettingController = new GPSSettingController(mMapView.getContext());\n            Boolean showGPSLocation = gpsSettingController.getGPSLocationState();\n            Boolean showGPSLocationOnCenter = gpsSettingController.getGPSCenterState();\n            if (showGPSLocation != null)\n                if (showGPSLocation) {\n                    MainActivity mainActivity = (MainActivity) context;\n                    GPSOverlayController gpsOverlayController = mainActivity.getMainController().getGpsOverlayController();\n                    gpsOverlayController.addGPSTrackerLayer();\n                    gpsOverlayController.setKeepOnCenter( ((showGPSLocationOnCenter != null)?(showGPSLocationOnCenter):(false)) );\n                }\n        }else {\n           \n        }\n    }","cleancode":"public void applygpssetting() { if(gpsservice.isgpsproviderenable(context) || gpsservice.isnetworkproviderenable(context)) { gpssettingcontroller gpssettingcontroller = new gpssettingcontroller(mmapview.getcontext()); boolean showgpslocation = gpssettingcontroller.getgpslocationstate(); boolean showgpslocationoncenter = gpssettingcontroller.getgpscenterstate(); if (showgpslocation != null) if (showgpslocation) { mainactivity mainactivity = (mainactivity) context; gpsoverlaycontroller gpsoverlaycontroller = mainactivity.getmaincontroller().getgpsoverlaycontroller(); gpsoverlaycontroller.addgpstrackerlayer(); gpsoverlaycontroller.setkeeponcenter( ((showgpslocationoncenter != null)?(showgpslocationoncenter):(false)) ); } }else { } }","repo":"MalteBerlin\/TerraMobile","label":[0,1,0,0]}
{"id":325,"original_code":"void tracksDropped(Point startPoint, Point dropPoint, List<Track> tracks) {\n            \/\/ This cast is horrid but we can't fix everything at once.\n            TrackPanel panel = ((TrackPanel) getParent());\n            List<MouseableRegion> regions = getMouseRegions();\n            if (regions.isEmpty()) {\n                \/\/ empty panel,  just add the tracks\n                panel.addTracks(tracks);\n            } else {\n                \/\/ Find the regions containing the startPoint and point\n                boolean before = true;\n                MouseableRegion dropRegion = null;\n                MouseableRegion startRegion = null;\n                for (MouseableRegion region : regions) {\n                    if (region.containsPoint(dropPoint.x, dropPoint.y)) {\n                        dropRegion = region;\n                        Rectangle bnds = dropRegion.getBounds();\n                        int dy1 = (dropPoint.y - bnds.y);\n                        int dy2 = bnds.height - dy1;\n                        before = dy1 < dy2;\n                    }\n                    if (region.containsPoint(startPoint.x, startPoint.y)) {\n                        startRegion = region;\n                    }\n                    if (dropRegion != null && startRegion != null) {\n                        break;\n                    }\n                }\n                Track dropTrack = null;\n                if (dropRegion != null) {\n                    Iterator<Track> tmp = dropRegion.getTracks().iterator();\n                    if (tmp.hasNext()) {\n                        dropTrack = tmp.next();\n                    }\n                }\n                panel.moveSelectedTracksTo(tracks, dropTrack, before);\n            }\n        }","code_wo_comment":"void tracksDropped(Point startPoint, Point dropPoint, List<Track> tracks) {\n           \n            TrackPanel panel = ((TrackPanel) getParent());\n            List<MouseableRegion> regions = getMouseRegions();\n            if (regions.isEmpty()) {\n               \n                panel.addTracks(tracks);\n            } else {\n               \n                boolean before = true;\n                MouseableRegion dropRegion = null;\n                MouseableRegion startRegion = null;\n                for (MouseableRegion region : regions) {\n                    if (region.containsPoint(dropPoint.x, dropPoint.y)) {\n                        dropRegion = region;\n                        Rectangle bnds = dropRegion.getBounds();\n                        int dy1 = (dropPoint.y - bnds.y);\n                        int dy2 = bnds.height - dy1;\n                        before = dy1 < dy2;\n                    }\n                    if (region.containsPoint(startPoint.x, startPoint.y)) {\n                        startRegion = region;\n                    }\n                    if (dropRegion != null && startRegion != null) {\n                        break;\n                    }\n                }\n                Track dropTrack = null;\n                if (dropRegion != null) {\n                    Iterator<Track> tmp = dropRegion.getTracks().iterator();\n                    if (tmp.hasNext()) {\n                        dropTrack = tmp.next();\n                    }\n                }\n                panel.moveSelectedTracksTo(tracks, dropTrack, before);\n            }\n        }","cleancode":"void tracksdropped(point startpoint, point droppoint, list<track> tracks) { trackpanel panel = ((trackpanel) getparent()); list<mouseableregion> regions = getmouseregions(); if (regions.isempty()) { panel.addtracks(tracks); } else { boolean before = true; mouseableregion dropregion = null; mouseableregion startregion = null; for (mouseableregion region : regions) { if (region.containspoint(droppoint.x, droppoint.y)) { dropregion = region; rectangle bnds = dropregion.getbounds(); int dy1 = (droppoint.y - bnds.y); int dy2 = bnds.height - dy1; before = dy1 < dy2; } if (region.containspoint(startpoint.x, startpoint.y)) { startregion = region; } if (dropregion != null && startregion != null) { break; } } track droptrack = null; if (dropregion != null) { iterator<track> tmp = dropregion.gettracks().iterator(); if (tmp.hasnext()) { droptrack = tmp.next(); } } panel.moveselectedtracksto(tracks, droptrack, before); } }","repo":"Karimi-Lab\/ALEA","label":[1,0,0,0]}
{"id":343,"original_code":"@AfterMethod\n    public void cleanupResources() throws SQLException {\n        TEST_NUMBER++;\n        \/\/todo issue #232 fix increment topic partition name for tests on multi jvm\n        ALL_RESOURCES.cleanUpClusters();\n        DB_RESOURCE.executeResource(JDBCUtil.DROP_TABLE_SQL_RESOURCE);\n    }","code_wo_comment":"@AfterMethod\n    public void cleanupResources() throws SQLException {\n        TEST_NUMBER++;\n       \n        ALL_RESOURCES.cleanUpClusters();\n        DB_RESOURCE.executeResource(JDBCUtil.DROP_TABLE_SQL_RESOURCE);\n    }","cleancode":"@aftermethod public void cleanupresources() throws sqlexception { test_number++; all_resources.cleanupclusters(); db_resource.executeresource(jdbcutil.drop_table_sql_resource); }","repo":"MayerRoman\/Lagerta","label":[0,0,1,0]}
{"id":24925,"original_code":"private void scheduleCleanup() {\n        if (cleanupRegistration != null) {\n            \/\/ Already scheduled\n            return;\n        }\n        cleanupRegistration = ui.beforeClientResponse(ui, ignore -> {\n            cleanupRegistration = null;\n            pendingCleanup = false;\n            \/\/ TODO Avoid copying by using Iterator.remove()\n            properties.keySet().stream().filter(property -> !lastUsed.contains(property)).collect(Collectors.toList())\n                    .forEach(unused -> properties.remove(unused).unregister());\n        });\n    }","code_wo_comment":"private void scheduleCleanup() {\n        if (cleanupRegistration != null) {\n           \n            return;\n        }\n        cleanupRegistration = ui.beforeClientResponse(ui, ignore -> {\n            cleanupRegistration = null;\n            pendingCleanup = false;\n           \n            properties.keySet().stream().filter(property -> !lastUsed.contains(property)).collect(Collectors.toList())\n                    .forEach(unused -> properties.remove(unused).unregister());\n        });\n    }","cleancode":"private void schedulecleanup() { if (cleanupregistration != null) { return; } cleanupregistration = ui.beforeclientresponse(ui, ignore -> { cleanupregistration = null; pendingcleanup = false; properties.keyset().stream().filter(property -> !lastused.contains(property)).collect(collectors.tolist()) .foreach(unused -> properties.remove(unused).unregister()); }); }","repo":"Legioth\/reactivevaadin","label":[0,1,0,0]}
{"id":24936,"original_code":"@Override\n    protected Path getPath(Canvas canvas, Paint paint) {\n        Path path = new Path();\n        String text = formatText();\n        if (text == null) {\n            return path;\n        }\n        \/\/ TODO: get path while TextPath is set.\n        if (setupFillPaint(paint, 1.0f, getBox(paint, text))) {\n            applyTextPropertiesToPaint(paint);\n            paint.getTextPath(text, 0, text.length(), 0, -paint.ascent(), path);\n            path.transform(mMatrix);\n        }\n        return path;\n    }","code_wo_comment":"@Override\n    protected Path getPath(Canvas canvas, Paint paint) {\n        Path path = new Path();\n        String text = formatText();\n        if (text == null) {\n            return path;\n        }\n       \n        if (setupFillPaint(paint, 1.0f, getBox(paint, text))) {\n            applyTextPropertiesToPaint(paint);\n            paint.getTextPath(text, 0, text.length(), 0, -paint.ascent(), path);\n            path.transform(mMatrix);\n        }\n        return path;\n    }","cleancode":"@override protected path getpath(canvas canvas, paint paint) { path path = new path(); string text = formattext(); if (text == null) { return path; } if (setupfillpaint(paint, 1.0f, getbox(paint, text))) { applytextpropertiestopaint(paint); paint.gettextpath(text, 0, text.length(), 0, -paint.ascent(), path); path.transform(mmatrix); } return path; }","repo":"L8RMedia\/exponent","label":[0,1,0,0]}
{"id":8573,"original_code":"public void translate() {\n        \/\/TODO: translate code\n    }","code_wo_comment":"public void translate() {\n       \n    }","cleancode":"public void translate() { }","repo":"JC-Bodoque\/geometric-transformer","label":[0,1,0,0]}
{"id":636,"original_code":"@Override\n    public <Q extends Facet> Q getFacet(final Class<Q> facetType) {\n        final Q facet = super.getFacet(facetType);\n        Q noopFacet = null;\n        if (isNotANoopFacet(facet)) {\n            return facet;\n        } else {\n            noopFacet = facet;\n        }\n        if (interfaces() != null) {\n            final List<ObjectSpecification> interfaces = interfaces();\n            for (int i = 0; i < interfaces.size(); i++) {\n                final ObjectSpecification interfaceSpec = interfaces.get(i);\n                if (interfaceSpec == null) {\n                    \/\/ HACK: shouldn't happen, but occurring on occasion when\n                    \/\/ running\n                    \/\/ XATs under JUnit4. Some sort of race condition?\n                    continue;\n                }\n                final Q interfaceFacet = interfaceSpec.getFacet(facetType);\n                if (isNotANoopFacet(interfaceFacet)) {\n                    return interfaceFacet;\n                } else {\n                    if (noopFacet == null) {\n                        noopFacet = interfaceFacet;\n                    }\n                }\n            }\n        }\n        \/\/ search up the inheritance hierarchy\n        final ObjectSpecification superSpec = superclass();\n        if (superSpec != null) {\n            final Q superClassFacet = superSpec.getFacet(facetType);\n            if (isNotANoopFacet(superClassFacet)) {\n                return superClassFacet;\n            }\n        }\n        return noopFacet;\n    }","code_wo_comment":"@Override\n    public <Q extends Facet> Q getFacet(final Class<Q> facetType) {\n        final Q facet = super.getFacet(facetType);\n        Q noopFacet = null;\n        if (isNotANoopFacet(facet)) {\n            return facet;\n        } else {\n            noopFacet = facet;\n        }\n        if (interfaces() != null) {\n            final List<ObjectSpecification> interfaces = interfaces();\n            for (int i = 0; i < interfaces.size(); i++) {\n                final ObjectSpecification interfaceSpec = interfaces.get(i);\n                if (interfaceSpec == null) {\n                   \n                   \n                   \n                    continue;\n                }\n                final Q interfaceFacet = interfaceSpec.getFacet(facetType);\n                if (isNotANoopFacet(interfaceFacet)) {\n                    return interfaceFacet;\n                } else {\n                    if (noopFacet == null) {\n                        noopFacet = interfaceFacet;\n                    }\n                }\n            }\n        }\n       \n        final ObjectSpecification superSpec = superclass();\n        if (superSpec != null) {\n            final Q superClassFacet = superSpec.getFacet(facetType);\n            if (isNotANoopFacet(superClassFacet)) {\n                return superClassFacet;\n            }\n        }\n        return noopFacet;\n    }","cleancode":"@override public <q extends facet> q getfacet(final class<q> facettype) { final q facet = super.getfacet(facettype); q noopfacet = null; if (isnotanoopfacet(facet)) { return facet; } else { noopfacet = facet; } if (interfaces() != null) { final list<objectspecification> interfaces = interfaces(); for (int i = 0; i < interfaces.size(); i++) { final objectspecification interfacespec = interfaces.get(i); if (interfacespec == null) { continue; } final q interfacefacet = interfacespec.getfacet(facettype); if (isnotanoopfacet(interfacefacet)) { return interfacefacet; } else { if (noopfacet == null) { noopfacet = interfacefacet; } } } } final objectspecification superspec = superclass(); if (superspec != null) { final q superclassfacet = superspec.getfacet(facettype); if (isnotanoopfacet(superclassfacet)) { return superclassfacet; } } return noopfacet; }","repo":"K-Rhen\/isis","label":[1,0,0,0]}
{"id":643,"original_code":"protected void blast(T message) {\n\t\tlogger.debug(\"blast called for message: \" + message);\n\t\tMap<String,Object> filter = KStringUtil.toMap(message.getFilter());\n\t\tLong affinityAppId = null;\n\t\tMap<String, Object> data = createPayLoadData(message);\n\t\tList<D> deviceList = getDeviceList(filter, affinityAppId, message.isSandbox());\n\t\tint sendCount = 0;\n\t\tList<String> blastErrors = new ArrayList<String>();\n\t\tList<String> deviceIdList = new ArrayList<String>();\n\t\tfor (D device : deviceList) {\n\t\t\tlogger.debug(\"blast push device: \" + device);\n\t\t\tKPushService.Platform platform = getPushService().getPushPlatform(device.getPlatformName(), device.isSandbox());\n\t\t\tString endpoint = device.getPushEndpoint();\n\t\t\tif (platform == null || endpoint == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tgetPushService().publish(platform, endpoint, message.getMessage(), data);\n\t\t\t\tlogger.debug(\"\\n--------------------------\\n\"\n\t\t\t\t\t\t+ \"\\npush message:\"\n\t\t\t\t\t\t+ \"\\nplatform: \" + platform\n\t\t\t\t\t\t+ \"\\nendpoint: \" + endpoint\n\t\t\t\t\t\t+ \"\\nmessage: \" + message\n\t\t\t\t\t\t+ \"\\ndata: \" + data \n\t\t\t\t\t\t+ \"\\n--------------------------\\n\"\n\t\t\t\t);\n\t\t\t\tsendCount += 1;\n\t\t\t\tdeviceIdList.add(device.getId().toString());\n\t\t\t} catch (Exception e) {\n\t\t\t\tblastErrors.add(e.getMessage());\n\t\t\t}\n\t\t}\n\t\tlogger.debug(\"blast: updating sendCount: \" + sendCount); \n\t\tif (blastErrors.size() > 0) {\n\t\t\tlogger.warn(\"Broadcast blast errors\" + KStringUtil.join(blastErrors, \"\\n\\n\"));\n\t\t}\n\t\tmessage.setDeviceCount(sendCount);\n\t\t\/\/ FIXME: this won't save since it's a blob type and underlying framework needs to support it\n\t\tmessage.setDevices(KStringUtil.join(deviceIdList,\",\").getBytes());\n\t\tupdate(message);\n\t}","code_wo_comment":"protected void blast(T message) {\n\t\tlogger.debug(\"blast called for message: \" + message);\n\t\tMap<String,Object> filter = KStringUtil.toMap(message.getFilter());\n\t\tLong affinityAppId = null;\n\t\tMap<String, Object> data = createPayLoadData(message);\n\t\tList<D> deviceList = getDeviceList(filter, affinityAppId, message.isSandbox());\n\t\tint sendCount = 0;\n\t\tList<String> blastErrors = new ArrayList<String>();\n\t\tList<String> deviceIdList = new ArrayList<String>();\n\t\tfor (D device : deviceList) {\n\t\t\tlogger.debug(\"blast push device: \" + device);\n\t\t\tKPushService.Platform platform = getPushService().getPushPlatform(device.getPlatformName(), device.isSandbox());\n\t\t\tString endpoint = device.getPushEndpoint();\n\t\t\tif (platform == null || endpoint == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tgetPushService().publish(platform, endpoint, message.getMessage(), data);\n\t\t\t\tlogger.debug(\"\\n--------------------------\\n\"\n\t\t\t\t\t\t+ \"\\npush message:\"\n\t\t\t\t\t\t+ \"\\nplatform: \" + platform\n\t\t\t\t\t\t+ \"\\nendpoint: \" + endpoint\n\t\t\t\t\t\t+ \"\\nmessage: \" + message\n\t\t\t\t\t\t+ \"\\ndata: \" + data \n\t\t\t\t\t\t+ \"\\n--------------------------\\n\"\n\t\t\t\t);\n\t\t\t\tsendCount += 1;\n\t\t\t\tdeviceIdList.add(device.getId().toString());\n\t\t\t} catch (Exception e) {\n\t\t\t\tblastErrors.add(e.getMessage());\n\t\t\t}\n\t\t}\n\t\tlogger.debug(\"blast: updating sendCount: \" + sendCount); \n\t\tif (blastErrors.size() > 0) {\n\t\t\tlogger.warn(\"Broadcast blast errors\" + KStringUtil.join(blastErrors, \"\\n\\n\"));\n\t\t}\n\t\tmessage.setDeviceCount(sendCount);\n\t\n\t\tmessage.setDevices(KStringUtil.join(deviceIdList,\",\").getBytes());\n\t\tupdate(message);\n\t}","cleancode":"protected void blast(t message) { logger.debug(\"blast called for message: \" + message); map<string,object> filter = kstringutil.tomap(message.getfilter()); long affinityappid = null; map<string, object> data = createpayloaddata(message); list<d> devicelist = getdevicelist(filter, affinityappid, message.issandbox()); int sendcount = 0; list<string> blasterrors = new arraylist<string>(); list<string> deviceidlist = new arraylist<string>(); for (d device : devicelist) { logger.debug(\"blast push device: \" + device); kpushservice.platform platform = getpushservice().getpushplatform(device.getplatformname(), device.issandbox()); string endpoint = device.getpushendpoint(); if (platform == null || endpoint == null) { continue; } try { getpushservice().publish(platform, endpoint, message.getmessage(), data); logger.debug(\"\\n--------------------------\\n\" + \"\\npush message:\" + \"\\nplatform: \" + platform + \"\\nendpoint: \" + endpoint + \"\\nmessage: \" + message + \"\\ndata: \" + data + \"\\n--------------------------\\n\" ); sendcount += 1; deviceidlist.add(device.getid().tostring()); } catch (exception e) { blasterrors.add(e.getmessage()); } } logger.debug(\"blast: updating sendcount: \" + sendcount); if (blasterrors.size() > 0) { logger.warn(\"broadcast blast errors\" + kstringutil.join(blasterrors, \"\\n\\n\")); } message.setdevicecount(sendcount); message.setdevices(kstringutil.join(deviceidlist,\",\").getbytes()); update(message); }","repo":"LinuxTek\/kona-app-model","label":[0,0,1,0]}
{"id":17067,"original_code":"protected void closeLayout( )\n\t{\n\t\t\/\/TODO support specified height\/width\/alignment\n\t\tif ( root != null )\n\t\t{\n\t\t\troot.setContentHeight( childHeight );\n\t\t\tIStyle areaStyle = root.getStyle( );\n\t\t\tint width = getCurrentIP( )\n\t\t\t\t\t+ getOffsetX( )\n\t\t\t\t\t+ getDimensionValue( areaStyle\n\t\t\t\t\t\t\t.getProperty( StyleConstants.STYLE_PADDING_RIGHT ) )\n\t\t\t\t\t+ getDimensionValue( areaStyle\n\t\t\t\t\t\t\t.getProperty( StyleConstants.STYLE_BORDER_RIGHT_WIDTH ) );\n\t\t\troot.setWidth( width );\n\t\t\tint height = 0;\n\t\t\tIterator iter = root.getChildren( );\n\t\t\twhile(iter.hasNext())\n\t\t\t{\n\t\t\t\tAbstractArea child = (AbstractArea)iter.next( );\n\t\t\t\theight = Math.max( height, child.getAllocatedHeight( ));\n\t\t\t}\n\t\t\troot.setContentHeight( height );\n\t\t}\n\t\t\/\/FIXME verticalAlign may effect the root height.\n\t\tverticalAlign();\n\t}","code_wo_comment":"protected void closeLayout( )\n\t{\n\t\n\t\tif ( root != null )\n\t\t{\n\t\t\troot.setContentHeight( childHeight );\n\t\t\tIStyle areaStyle = root.getStyle( );\n\t\t\tint width = getCurrentIP( )\n\t\t\t\t\t+ getOffsetX( )\n\t\t\t\t\t+ getDimensionValue( areaStyle\n\t\t\t\t\t\t\t.getProperty( StyleConstants.STYLE_PADDING_RIGHT ) )\n\t\t\t\t\t+ getDimensionValue( areaStyle\n\t\t\t\t\t\t\t.getProperty( StyleConstants.STYLE_BORDER_RIGHT_WIDTH ) );\n\t\t\troot.setWidth( width );\n\t\t\tint height = 0;\n\t\t\tIterator iter = root.getChildren( );\n\t\t\twhile(iter.hasNext())\n\t\t\t{\n\t\t\t\tAbstractArea child = (AbstractArea)iter.next( );\n\t\t\t\theight = Math.max( height, child.getAllocatedHeight( ));\n\t\t\t}\n\t\t\troot.setContentHeight( height );\n\t\t}\n\t\n\t\tverticalAlign();\n\t}","cleancode":"protected void closelayout( ) { if ( root != null ) { root.setcontentheight( childheight ); istyle areastyle = root.getstyle( ); int width = getcurrentip( ) + getoffsetx( ) + getdimensionvalue( areastyle .getproperty( styleconstants.style_padding_right ) ) + getdimensionvalue( areastyle .getproperty( styleconstants.style_border_right_width ) ); root.setwidth( width ); int height = 0; iterator iter = root.getchildren( ); while(iter.hasnext()) { abstractarea child = (abstractarea)iter.next( ); height = math.max( height, child.getallocatedheight( )); } root.setcontentheight( height ); } verticalalign(); }","repo":"JamesCao2048\/BlizzardData","label":[0,1,1,0]}
{"id":8889,"original_code":"private void performEnableScreen() {\n        synchronized (mGlobalLock) {\n            if (DEBUG_BOOT) Slog.i(TAG_WM, \"performEnableScreen: mDisplayEnabled=\" + mDisplayEnabled\n                    + \" mForceDisplayEnabled=\" + mForceDisplayEnabled\n                    + \" mShowingBootMessages=\" + mShowingBootMessages\n                    + \" mSystemBooted=\" + mSystemBooted\n                    + \" mOnlyCore=\" + mOnlyCore,\n                    new RuntimeException(\"here\").fillInStackTrace());\n            if (mDisplayEnabled) {\n                return;\n            }\n            if (!mSystemBooted && !mShowingBootMessages) {\n                return;\n            }\n            if (!mShowingBootMessages && !mPolicy.canDismissBootAnimation()) {\n                return;\n            }\n            \/\/ Don't enable the screen until all existing windows have been drawn.\n            if (!mForceDisplayEnabled\n                    \/\/ TODO(multidisplay): Expand to all displays?\n                    && getDefaultDisplayContentLocked().checkWaitingForWindows()) {\n                return;\n            }\n            if (!mBootAnimationStopped) {\n                Trace.asyncTraceBegin(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0);\n                \/\/ stop boot animation\n                \/\/ formerly we would just kill the process, but we now ask it to exit so it\n                \/\/ can choose where to stop the animation.\n                SystemProperties.set(\"service.bootanim.exit\", \"1\");\n                mBootAnimationStopped = true;\n            }\n            if (!mForceDisplayEnabled && !checkBootAnimationCompleteLocked()) {\n                if (DEBUG_BOOT) Slog.i(TAG_WM, \"performEnableScreen: Waiting for anim complete\");\n                return;\n            }\n            try {\n                IBinder surfaceFlinger = ServiceManager.getService(\"SurfaceFlinger\");\n                if (surfaceFlinger != null) {\n                    Slog.i(TAG_WM, \"******* TELLING SURFACE FLINGER WE ARE BOOTED!\");\n                    Parcel data = Parcel.obtain();\n                    data.writeInterfaceToken(\"android.ui.ISurfaceComposer\");\n                    surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, \/\/ BOOT_FINISHED\n                            data, null, 0);\n                    data.recycle();\n                }\n            } catch (RemoteException ex) {\n                Slog.e(TAG_WM, \"Boot completed: SurfaceFlinger is dead!\");\n            }\n            EventLog.writeEvent(EventLogTags.WM_BOOT_ANIMATION_DONE, SystemClock.uptimeMillis());\n            Trace.asyncTraceEnd(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0);\n            mDisplayEnabled = true;\n            if (DEBUG_SCREEN_ON || DEBUG_BOOT) Slog.i(TAG_WM, \"******************** ENABLING SCREEN!\");\n            \/\/ Enable input dispatch.\n            mInputManagerCallback.setEventDispatchingLw(mEventDispatchingEnabled);\n        }\n        try {\n            mActivityManager.bootAnimationComplete();\n        } catch (RemoteException e) {\n        }\n        mPolicy.enableScreenAfterBoot();\n        \/\/ Make sure the last requested orientation has been applied.\n        updateRotationUnchecked(false, false);\n    }","code_wo_comment":"private void performEnableScreen() {\n        synchronized (mGlobalLock) {\n            if (DEBUG_BOOT) Slog.i(TAG_WM, \"performEnableScreen: mDisplayEnabled=\" + mDisplayEnabled\n                    + \" mForceDisplayEnabled=\" + mForceDisplayEnabled\n                    + \" mShowingBootMessages=\" + mShowingBootMessages\n                    + \" mSystemBooted=\" + mSystemBooted\n                    + \" mOnlyCore=\" + mOnlyCore,\n                    new RuntimeException(\"here\").fillInStackTrace());\n            if (mDisplayEnabled) {\n                return;\n            }\n            if (!mSystemBooted && !mShowingBootMessages) {\n                return;\n            }\n            if (!mShowingBootMessages && !mPolicy.canDismissBootAnimation()) {\n                return;\n            }\n           \n            if (!mForceDisplayEnabled\n                   \n                    && getDefaultDisplayContentLocked().checkWaitingForWindows()) {\n                return;\n            }\n            if (!mBootAnimationStopped) {\n                Trace.asyncTraceBegin(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0);\n               \n               \n               \n                SystemProperties.set(\"service.bootanim.exit\", \"1\");\n                mBootAnimationStopped = true;\n            }\n            if (!mForceDisplayEnabled && !checkBootAnimationCompleteLocked()) {\n                if (DEBUG_BOOT) Slog.i(TAG_WM, \"performEnableScreen: Waiting for anim complete\");\n                return;\n            }\n            try {\n                IBinder surfaceFlinger = ServiceManager.getService(\"SurfaceFlinger\");\n                if (surfaceFlinger != null) {\n                    Slog.i(TAG_WM, \"******* TELLING SURFACE FLINGER WE ARE BOOTED!\");\n                    Parcel data = Parcel.obtain();\n                    data.writeInterfaceToken(\"android.ui.ISurfaceComposer\");\n                    surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,\n                            data, null, 0);\n                    data.recycle();\n                }\n            } catch (RemoteException ex) {\n                Slog.e(TAG_WM, \"Boot completed: SurfaceFlinger is dead!\");\n            }\n            EventLog.writeEvent(EventLogTags.WM_BOOT_ANIMATION_DONE, SystemClock.uptimeMillis());\n            Trace.asyncTraceEnd(TRACE_TAG_WINDOW_MANAGER, \"Stop bootanim\", 0);\n            mDisplayEnabled = true;\n            if (DEBUG_SCREEN_ON || DEBUG_BOOT) Slog.i(TAG_WM, \"******************** ENABLING SCREEN!\");\n           \n            mInputManagerCallback.setEventDispatchingLw(mEventDispatchingEnabled);\n        }\n        try {\n            mActivityManager.bootAnimationComplete();\n        } catch (RemoteException e) {\n        }\n        mPolicy.enableScreenAfterBoot();\n       \n        updateRotationUnchecked(false, false);\n    }","cleancode":"private void performenablescreen() { synchronized (mgloballock) { if (debug_boot) slog.i(tag_wm, \"performenablescreen: mdisplayenabled=\" + mdisplayenabled + \" mforcedisplayenabled=\" + mforcedisplayenabled + \" mshowingbootmessages=\" + mshowingbootmessages + \" msystembooted=\" + msystembooted + \" monlycore=\" + monlycore, new runtimeexception(\"here\").fillinstacktrace()); if (mdisplayenabled) { return; } if (!msystembooted && !mshowingbootmessages) { return; } if (!mshowingbootmessages && !mpolicy.candismissbootanimation()) { return; } if (!mforcedisplayenabled && getdefaultdisplaycontentlocked().checkwaitingforwindows()) { return; } if (!mbootanimationstopped) { trace.asynctracebegin(trace_tag_window_manager, \"stop bootanim\", 0); systemproperties.set(\"service.bootanim.exit\", \"1\"); mbootanimationstopped = true; } if (!mforcedisplayenabled && !checkbootanimationcompletelocked()) { if (debug_boot) slog.i(tag_wm, \"performenablescreen: waiting for anim complete\"); return; } try { ibinder surfaceflinger = servicemanager.getservice(\"surfaceflinger\"); if (surfaceflinger != null) { slog.i(tag_wm, \"******* telling surface flinger we are booted!\"); parcel data = parcel.obtain(); data.writeinterfacetoken(\"android.ui.isurfacecomposer\"); surfaceflinger.transact(ibinder.first_call_transaction, data, null, 0); data.recycle(); } } catch (remoteexception ex) { slog.e(tag_wm, \"boot completed: surfaceflinger is dead!\"); } eventlog.writeevent(eventlogtags.wm_boot_animation_done, systemclock.uptimemillis()); trace.asynctraceend(trace_tag_window_manager, \"stop bootanim\", 0); mdisplayenabled = true; if (debug_screen_on || debug_boot) slog.i(tag_wm, \"******************** enabling screen!\"); minputmanagercallback.seteventdispatchinglw(meventdispatchingenabled); } try { mactivitymanager.bootanimationcomplete(); } catch (remoteexception e) { } mpolicy.enablescreenafterboot(); updaterotationunchecked(false, false); }","repo":"LynzhX\/android_frameworks_base-1","label":[1,0,0,0]}
{"id":8894,"original_code":"boolean viewServerGetFocusedWindow(Socket client) {\n        if (isSystemSecure()) {\n            return false;\n        }\n        boolean result = true;\n        WindowState focusedWindow = getFocusedWindow();\n        BufferedWriter out = null;\n        \/\/ Any uncaught exception will crash the system process\n        try {\n            OutputStream clientStream = client.getOutputStream();\n            out = new BufferedWriter(new OutputStreamWriter(clientStream), 8 * 1024);\n            if(focusedWindow != null) {\n                out.write(Integer.toHexString(System.identityHashCode(focusedWindow)));\n                out.write(' ');\n                out.append(focusedWindow.mAttrs.getTitle());\n            }\n            out.write('\\n');\n            out.flush();\n        } catch (Exception e) {\n            result = false;\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) {\n                    result = false;\n                }\n            }\n        }\n        return result;\n    }","code_wo_comment":"boolean viewServerGetFocusedWindow(Socket client) {\n        if (isSystemSecure()) {\n            return false;\n        }\n        boolean result = true;\n        WindowState focusedWindow = getFocusedWindow();\n        BufferedWriter out = null;\n       \n        try {\n            OutputStream clientStream = client.getOutputStream();\n            out = new BufferedWriter(new OutputStreamWriter(clientStream), 8 * 1024);\n            if(focusedWindow != null) {\n                out.write(Integer.toHexString(System.identityHashCode(focusedWindow)));\n                out.write(' ');\n                out.append(focusedWindow.mAttrs.getTitle());\n            }\n            out.write('\\n');\n            out.flush();\n        } catch (Exception e) {\n            result = false;\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) {\n                    result = false;\n                }\n            }\n        }\n        return result;\n    }","cleancode":"boolean viewservergetfocusedwindow(socket client) { if (issystemsecure()) { return false; } boolean result = true; windowstate focusedwindow = getfocusedwindow(); bufferedwriter out = null; try { outputstream clientstream = client.getoutputstream(); out = new bufferedwriter(new outputstreamwriter(clientstream), 8 * 1024); if(focusedwindow != null) { out.write(integer.tohexstring(system.identityhashcode(focusedwindow))); out.write(' '); out.append(focusedwindow.mattrs.gettitle()); } out.write('\\n'); out.flush(); } catch (exception e) { result = false; } finally { if (out != null) { try { out.close(); } catch (ioexception e) { result = false; } } } return result; }","repo":"LynzhX\/android_frameworks_base-1","label":[0,1,0,0]}
{"id":17124,"original_code":"@Test\n    public void simpleEndpointReturnsPostsWithoutTransformation() {\n        \/\/This unit-test class is the wrong place to test that behaviour, unless it becomes an integration test\n        \/\/Given\n        ForumPosts posts = generateTestPosts();\n        when(exampleApiService.getPosts()).thenReturn(posts);\n        \/\/When\n        ForumPosts controllerOutput = exerciseController.posts();\n        \/\/Then\n        assertEquals(controllerOutput.size(), 2);\n        assertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));\n    }","code_wo_comment":"@Test\n    public void simpleEndpointReturnsPostsWithoutTransformation() {\n       \n       \n        ForumPosts posts = generateTestPosts();\n        when(exampleApiService.getPosts()).thenReturn(posts);\n       \n        ForumPosts controllerOutput = exerciseController.posts();\n       \n        assertEquals(controllerOutput.size(), 2);\n        assertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));\n    }","cleancode":"@test public void simpleendpointreturnspostswithouttransformation() { forumposts posts = generatetestposts(); when(exampleapiservice.getposts()).thenreturn(posts); forumposts controlleroutput = exercisecontroller.posts(); assertequals(controlleroutput.size(), 2); asserttrue(controlleroutput.get(0).gettitle().contains(\"test\")); }","repo":"JoseAlban\/etc","label":[0,0,0,1]}
{"id":17125,"original_code":"@Test\n    public void transformedEndpointReturnsPostsWithCurrentDate() {\n        \/\/This unit-test class is the wrong place to test that behaviour, unless it becomes an integration test\n        \/\/Given\n        TransformedForumPosts transformed = generateTransformedTestPosts();\n        when(exampleApiService.getTransformedPosts()).thenReturn(transformed);\n        \/\/When\n        TransformedForumPosts controllerOutput = exerciseController.transformed();\n        \/\/Then\n        assertEquals(controllerOutput.size(), 2);\n        assertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));\n        assertTrue(controllerOutput.get(0).getUppercaseTitle().contains(\"TEST\"));\n        assertTrue(controllerOutput.get(0).getPostDate().matches(\"\\\\d{4}-[01]\\\\d-[0-3]\\\\d\"));\n    }","code_wo_comment":"@Test\n    public void transformedEndpointReturnsPostsWithCurrentDate() {\n       \n       \n        TransformedForumPosts transformed = generateTransformedTestPosts();\n        when(exampleApiService.getTransformedPosts()).thenReturn(transformed);\n       \n        TransformedForumPosts controllerOutput = exerciseController.transformed();\n       \n        assertEquals(controllerOutput.size(), 2);\n        assertTrue(controllerOutput.get(0).getTitle().contains(\"Test\"));\n        assertTrue(controllerOutput.get(0).getUppercaseTitle().contains(\"TEST\"));\n        assertTrue(controllerOutput.get(0).getPostDate().matches(\"\\\\d{4}-[01]\\\\d-[0-3]\\\\d\"));\n    }","cleancode":"@test public void transformedendpointreturnspostswithcurrentdate() { transformedforumposts transformed = generatetransformedtestposts(); when(exampleapiservice.gettransformedposts()).thenreturn(transformed); transformedforumposts controlleroutput = exercisecontroller.transformed(); assertequals(controlleroutput.size(), 2); asserttrue(controlleroutput.get(0).gettitle().contains(\"test\")); asserttrue(controlleroutput.get(0).getuppercasetitle().contains(\"test\")); asserttrue(controlleroutput.get(0).getpostdate().matches(\"\\\\d{4}-[01]\\\\d-[0-3]\\\\d\")); }","repo":"JoseAlban\/etc","label":[0,0,0,1]}
{"id":33512,"original_code":"@Override\n    public void doServerTick(World world)\n    {\n        super.doServerTick(world);\n        Entity rider = entity.getControllingPassenger();\n        pokemob.setGeneralState(GeneralStates.CONTROLLED, rider != null);\n        if (rider == null) return;\n        Config config = PokecubeCore.instance.getConfig();\n        boolean move = false;\n        entity.rotationYaw = pokemob.getHeading();\n        boolean shouldControl = entity.onGround || pokemob.floats();\n        boolean verticalControl = false;\n        boolean waterSpeed = false;\n        boolean airSpeed = !entity.onGround;\n        boolean canFly = pokemob.canUseFly();\n        boolean canSurf = pokemob.canUseSurf();\n        boolean canDive = pokemob.canUseDive();\n        if (rider instanceof EntityPlayerMP)\n        {\n            EntityPlayer player = (EntityPlayer) rider;\n            IPermissionHandler handler = PermissionAPI.getPermissionHandler();\n            PlayerContext context = new PlayerContext(player);\n            PokedexEntry entry = pokemob.getPokedexEntry();\n            if (config.permsFly && canFly\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.FLYPOKEMOB, context))\n            {\n                canFly = false;\n            }\n            if (config.permsFlySpecific && canFly\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.FLYSPECIFIC.get(entry), context))\n            {\n                canFly = false;\n            }\n            if (config.permsSurf && canSurf\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.SURFPOKEMOB, context))\n            {\n                canSurf = false;\n            }\n            if (config.permsSurfSpecific && canSurf\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.SURFSPECIFIC.get(entry), context))\n            {\n                canSurf = false;\n            }\n            if (config.permsDive && canDive\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.DIVEPOKEMOB, context))\n            {\n                canDive = false;\n            }\n            if (config.permsDiveSpecific && canDive\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.DIVESPECIFIC.get(entry), context))\n            {\n                canDive = false;\n            }\n        }\n        if (canFly) for (int i = 0; i < PokecubeMod.core.getConfig().flyDimBlacklist.length; i++)\n            if (PokecubeMod.core.getConfig().flyDimBlacklist[i] == world.provider.getDimension())\n            {\n                canFly = false;\n                break;\n            }\n        if (canFly) shouldControl = verticalControl = PokecubeMod.core.getConfig().flyEnabled || shouldControl;\n        if ((canSurf || canDive) && (waterSpeed = entity.isInWater()))\n            shouldControl = verticalControl = PokecubeMod.core.getConfig().surfEnabled || shouldControl;\n        if (waterSpeed) airSpeed = false;\n        Entity controller = rider;\n        if (pokemob.getPokedexEntry().shouldDive)\n        {\n            PotionEffect vision = new PotionEffect(Potion.getPotionFromResourceLocation(\"night_vision\"), 300, 1, true,\n                    false);\n            ItemStack stack = new ItemStack(Blocks.BARRIER);\n            vision.setCurativeItems(Lists.newArrayList(stack));\n            for (Entity e : entity.getRecursivePassengers())\n            {\n                if (e instanceof EntityLivingBase)\n                {\n                    if (entity.isInWater())\n                    {\n                        ((EntityLivingBase) e).addPotionEffect(vision);\n                        ((EntityLivingBase) e).setAir(300);\n                    }\n                    else((EntityLivingBase) e).curePotionEffects(stack);\n                }\n            }\n        }\n        float speedFactor = (float) (1 + Math.sqrt(pokemob.getPokedexEntry().getStatVIT()) \/ (10F));\n        float moveSpeed = (float) (0.25f * throttle * speedFactor);\n        if (forwardInputDown)\n        {\n            move = true;\n            float f = moveSpeed \/ 2;\n            if (airSpeed) f *= config.flySpeedFactor;\n            else if (waterSpeed) f *= config.surfSpeedFactor;\n            else f *= config.groundSpeedFactor;\n            if (shouldControl)\n            {\n                if (!entity.onGround) f *= 2;\n                entity.motionX += MathHelper.sin(-entity.rotationYaw * 0.017453292F) * f;\n                entity.motionZ += MathHelper.cos(entity.rotationYaw * 0.017453292F) * f;\n            }\n            else if (entity.isInLava() || entity.isInWater())\n            {\n                f *= 0.1;\n                entity.motionX += MathHelper.sin(-entity.rotationYaw * 0.017453292F) * f;\n                entity.motionZ += MathHelper.cos(entity.rotationYaw * 0.017453292F) * f;\n            }\n        }\n        if (backInputDown)\n        {\n            move = true;\n            float f = -moveSpeed \/ 4;\n            if (shouldControl)\n            {\n                if (airSpeed) f *= config.flySpeedFactor;\n                else if (waterSpeed) f *= config.surfSpeedFactor;\n                else f *= config.groundSpeedFactor;\n                entity.motionX += MathHelper.sin(-entity.rotationYaw * 0.017453292F) * f;\n                entity.motionZ += MathHelper.cos(entity.rotationYaw * 0.017453292F) * f;\n            }\n        }\n        if (upInputDown)\n        {\n            if (entity.onGround)\n            {\n                entity.getJumpHelper().setJumping();\n            }\n            else if (verticalControl)\n            {\n                entity.motionY += 0.1 * throttle;\n            }\n            else if (entity.isInLava() || entity.isInWater())\n            {\n                entity.motionY += 0.05 * throttle;\n            }\n        }\n        if (downInputDown)\n        {\n            if (verticalControl && !entity.onGround)\n            {\n                entity.motionY -= 0.1 * throttle;\n            }\n        }\n        else if (!verticalControl && !entity.onGround)\n        {\n            entity.motionY -= 0.1;\n        }\n        if (!followOwnerLook)\n        {\/\/ TODO some way to make this change based on how long button is held?\n            if (leftInputDown)\n            {\n                pokemob.setHeading(pokemob.getHeading() - 5);\n            }\n            if (rightInputDown)\n            {\n                pokemob.setHeading(pokemob.getHeading() + 5);\n            }\n        }\n        else if (!entity.getPassengers().isEmpty())\n        {\n            pokemob.setHeading(controller.rotationYaw);\n            float f = moveSpeed \/ 2;\n            if (leftInputDown)\n            {\n                move = true;\n                if (shouldControl)\n                {\n                    if (!entity.onGround) f *= 2;\n                    if (airSpeed) f *= config.flySpeedFactor;\n                    else if (waterSpeed) f *= config.surfSpeedFactor;\n                    else f *= config.groundSpeedFactor;\n                    entity.motionX += MathHelper.cos(-entity.rotationYaw * 0.017453292F) * f;\n                    entity.motionZ += MathHelper.sin(entity.rotationYaw * 0.017453292F) * f;\n                }\n                else if (entity.isInLava() || entity.isInWater())\n                {\n                    f *= 0.1;\n                    entity.motionX += MathHelper.cos(-entity.rotationYaw * 0.017453292F) * f;\n                    entity.motionZ += MathHelper.sin(entity.rotationYaw * 0.017453292F) * f;\n                }\n            }\n            if (rightInputDown)\n            {\n                move = true;\n                if (shouldControl)\n                {\n                    if (!entity.onGround) f *= 2;\n                    if (airSpeed) f *= config.flySpeedFactor;\n                    else if (waterSpeed) f *= config.surfSpeedFactor;\n                    else f *= config.groundSpeedFactor;\n                    entity.motionX -= MathHelper.cos(-entity.rotationYaw * 0.017453292F) * f;\n                    entity.motionZ -= MathHelper.sin(entity.rotationYaw * 0.017453292F) * f;\n                }\n                else if (entity.isInLava() || entity.isInWater())\n                {\n                    f *= 0.1;\n                    entity.motionX -= MathHelper.cos(-entity.rotationYaw * 0.017453292F) * f;\n                    entity.motionZ -= MathHelper.sin(entity.rotationYaw * 0.017453292F) * f;\n                }\n            }\n        }\n        if (!move)\n        {\n            entity.motionX *= 0.5;\n            entity.motionZ *= 0.5;\n        }\n        \/\/ Sync the rotations.\n        entity.setRenderYawOffset(pokemob.getHeading());\n        entity.setRotationYawHead(pokemob.getHeading());\n    }","code_wo_comment":"@Override\n    public void doServerTick(World world)\n    {\n        super.doServerTick(world);\n        Entity rider = entity.getControllingPassenger();\n        pokemob.setGeneralState(GeneralStates.CONTROLLED, rider != null);\n        if (rider == null) return;\n        Config config = PokecubeCore.instance.getConfig();\n        boolean move = false;\n        entity.rotationYaw = pokemob.getHeading();\n        boolean shouldControl = entity.onGround || pokemob.floats();\n        boolean verticalControl = false;\n        boolean waterSpeed = false;\n        boolean airSpeed = !entity.onGround;\n        boolean canFly = pokemob.canUseFly();\n        boolean canSurf = pokemob.canUseSurf();\n        boolean canDive = pokemob.canUseDive();\n        if (rider instanceof EntityPlayerMP)\n        {\n            EntityPlayer player = (EntityPlayer) rider;\n            IPermissionHandler handler = PermissionAPI.getPermissionHandler();\n            PlayerContext context = new PlayerContext(player);\n            PokedexEntry entry = pokemob.getPokedexEntry();\n            if (config.permsFly && canFly\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.FLYPOKEMOB, context))\n            {\n                canFly = false;\n            }\n            if (config.permsFlySpecific && canFly\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.FLYSPECIFIC.get(entry), context))\n            {\n                canFly = false;\n            }\n            if (config.permsSurf && canSurf\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.SURFPOKEMOB, context))\n            {\n                canSurf = false;\n            }\n            if (config.permsSurfSpecific && canSurf\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.SURFSPECIFIC.get(entry), context))\n            {\n                canSurf = false;\n            }\n            if (config.permsDive && canDive\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.DIVEPOKEMOB, context))\n            {\n                canDive = false;\n            }\n            if (config.permsDiveSpecific && canDive\n                    && !handler.hasPermission(player.getGameProfile(), Permissions.DIVESPECIFIC.get(entry), context))\n            {\n                canDive = false;\n            }\n        }\n        if (canFly) for (int i = 0; i < PokecubeMod.core.getConfig().flyDimBlacklist.length; i++)\n            if (PokecubeMod.core.getConfig().flyDimBlacklist[i] == world.provider.getDimension())\n            {\n                canFly = false;\n                break;\n            }\n        if (canFly) shouldControl = verticalControl = PokecubeMod.core.getConfig().flyEnabled || shouldControl;\n        if ((canSurf || canDive) && (waterSpeed = entity.isInWater()))\n            shouldControl = verticalControl = PokecubeMod.core.getConfig().surfEnabled || shouldControl;\n        if (waterSpeed) airSpeed = false;\n        Entity controller = rider;\n        if (pokemob.getPokedexEntry().shouldDive)\n        {\n            PotionEffect vision = new PotionEffect(Potion.getPotionFromResourceLocation(\"night_vision\"), 300, 1, true,\n                    false);\n            ItemStack stack = new ItemStack(Blocks.BARRIER);\n            vision.setCurativeItems(Lists.newArrayList(stack));\n            for (Entity e : entity.getRecursivePassengers())\n            {\n                if (e instanceof EntityLivingBase)\n                {\n                    if (entity.isInWater())\n                    {\n                        ((EntityLivingBase) e).addPotionEffect(vision);\n                        ((EntityLivingBase) e).setAir(300);\n                    }\n                    else((EntityLivingBase) e).curePotionEffects(stack);\n                }\n            }\n        }\n        float speedFactor = (float) (1 + Math.sqrt(pokemob.getPokedexEntry().getStatVIT()) \/ (10F));\n        float moveSpeed = (float) (0.25f * throttle * speedFactor);\n        if (forwardInputDown)\n        {\n            move = true;\n            float f = moveSpeed \/ 2;\n            if (airSpeed) f *= config.flySpeedFactor;\n            else if (waterSpeed) f *= config.surfSpeedFactor;\n            else f *= config.groundSpeedFactor;\n            if (shouldControl)\n            {\n                if (!entity.onGround) f *= 2;\n                entity.motionX += MathHelper.sin(-entity.rotationYaw * 0.017453292F) * f;\n                entity.motionZ += MathHelper.cos(entity.rotationYaw * 0.017453292F) * f;\n            }\n            else if (entity.isInLava() || entity.isInWater())\n            {\n                f *= 0.1;\n                entity.motionX += MathHelper.sin(-entity.rotationYaw * 0.017453292F) * f;\n                entity.motionZ += MathHelper.cos(entity.rotationYaw * 0.017453292F) * f;\n            }\n        }\n        if (backInputDown)\n        {\n            move = true;\n            float f = -moveSpeed \/ 4;\n            if (shouldControl)\n            {\n                if (airSpeed) f *= config.flySpeedFactor;\n                else if (waterSpeed) f *= config.surfSpeedFactor;\n                else f *= config.groundSpeedFactor;\n                entity.motionX += MathHelper.sin(-entity.rotationYaw * 0.017453292F) * f;\n                entity.motionZ += MathHelper.cos(entity.rotationYaw * 0.017453292F) * f;\n            }\n        }\n        if (upInputDown)\n        {\n            if (entity.onGround)\n            {\n                entity.getJumpHelper().setJumping();\n            }\n            else if (verticalControl)\n            {\n                entity.motionY += 0.1 * throttle;\n            }\n            else if (entity.isInLava() || entity.isInWater())\n            {\n                entity.motionY += 0.05 * throttle;\n            }\n        }\n        if (downInputDown)\n        {\n            if (verticalControl && !entity.onGround)\n            {\n                entity.motionY -= 0.1 * throttle;\n            }\n        }\n        else if (!verticalControl && !entity.onGround)\n        {\n            entity.motionY -= 0.1;\n        }\n        if (!followOwnerLook)\n        \n            if (leftInputDown)\n            {\n                pokemob.setHeading(pokemob.getHeading() - 5);\n            }\n            if (rightInputDown)\n            {\n                pokemob.setHeading(pokemob.getHeading() + 5);\n            }\n        }\n        else if (!entity.getPassengers().isEmpty())\n        {\n            pokemob.setHeading(controller.rotationYaw);\n            float f = moveSpeed \/ 2;\n            if (leftInputDown)\n            {\n                move = true;\n                if (shouldControl)\n                {\n                    if (!entity.onGround) f *= 2;\n                    if (airSpeed) f *= config.flySpeedFactor;\n                    else if (waterSpeed) f *= config.surfSpeedFactor;\n                    else f *= config.groundSpeedFactor;\n                    entity.motionX += MathHelper.cos(-entity.rotationYaw * 0.017453292F) * f;\n                    entity.motionZ += MathHelper.sin(entity.rotationYaw * 0.017453292F) * f;\n                }\n                else if (entity.isInLava() || entity.isInWater())\n                {\n                    f *= 0.1;\n                    entity.motionX += MathHelper.cos(-entity.rotationYaw * 0.017453292F) * f;\n                    entity.motionZ += MathHelper.sin(entity.rotationYaw * 0.017453292F) * f;\n                }\n            }\n            if (rightInputDown)\n            {\n                move = true;\n                if (shouldControl)\n                {\n                    if (!entity.onGround) f *= 2;\n                    if (airSpeed) f *= config.flySpeedFactor;\n                    else if (waterSpeed) f *= config.surfSpeedFactor;\n                    else f *= config.groundSpeedFactor;\n                    entity.motionX -= MathHelper.cos(-entity.rotationYaw * 0.017453292F) * f;\n                    entity.motionZ -= MathHelper.sin(entity.rotationYaw * 0.017453292F) * f;\n                }\n                else if (entity.isInLava() || entity.isInWater())\n                {\n                    f *= 0.1;\n                    entity.motionX -= MathHelper.cos(-entity.rotationYaw * 0.017453292F) * f;\n                    entity.motionZ -= MathHelper.sin(entity.rotationYaw * 0.017453292F) * f;\n                }\n            }\n        }\n        if (!move)\n        {\n            entity.motionX *= 0.5;\n            entity.motionZ *= 0.5;\n        }\n       \n        entity.setRenderYawOffset(pokemob.getHeading());\n        entity.setRotationYawHead(pokemob.getHeading());\n    }","cleancode":"@override public void doservertick(world world) { super.doservertick(world); entity rider = entity.getcontrollingpassenger(); pokemob.setgeneralstate(generalstates.controlled, rider != null); if (rider == null) return; config config = pokecubecore.instance.getconfig(); boolean move = false; entity.rotationyaw = pokemob.getheading(); boolean shouldcontrol = entity.onground || pokemob.floats(); boolean verticalcontrol = false; boolean waterspeed = false; boolean airspeed = !entity.onground; boolean canfly = pokemob.canusefly(); boolean cansurf = pokemob.canusesurf(); boolean candive = pokemob.canusedive(); if (rider instanceof entityplayermp) { entityplayer player = (entityplayer) rider; ipermissionhandler handler = permissionapi.getpermissionhandler(); playercontext context = new playercontext(player); pokedexentry entry = pokemob.getpokedexentry(); if (config.permsfly && canfly && !handler.haspermission(player.getgameprofile(), permissions.flypokemob, context)) { canfly = false; } if (config.permsflyspecific && canfly && !handler.haspermission(player.getgameprofile(), permissions.flyspecific.get(entry), context)) { canfly = false; } if (config.permssurf && cansurf && !handler.haspermission(player.getgameprofile(), permissions.surfpokemob, context)) { cansurf = false; } if (config.permssurfspecific && cansurf && !handler.haspermission(player.getgameprofile(), permissions.surfspecific.get(entry), context)) { cansurf = false; } if (config.permsdive && candive && !handler.haspermission(player.getgameprofile(), permissions.divepokemob, context)) { candive = false; } if (config.permsdivespecific && candive && !handler.haspermission(player.getgameprofile(), permissions.divespecific.get(entry), context)) { candive = false; } } if (canfly) for (int i = 0; i < pokecubemod.core.getconfig().flydimblacklist.length; i++) if (pokecubemod.core.getconfig().flydimblacklist[i] == world.provider.getdimension()) { canfly = false; break; } if (canfly) shouldcontrol = verticalcontrol = pokecubemod.core.getconfig().flyenabled || shouldcontrol; if ((cansurf || candive) && (waterspeed = entity.isinwater())) shouldcontrol = verticalcontrol = pokecubemod.core.getconfig().surfenabled || shouldcontrol; if (waterspeed) airspeed = false; entity controller = rider; if (pokemob.getpokedexentry().shoulddive) { potioneffect vision = new potioneffect(potion.getpotionfromresourcelocation(\"night_vision\"), 300, 1, true, false); itemstack stack = new itemstack(blocks.barrier); vision.setcurativeitems(lists.newarraylist(stack)); for (entity e : entity.getrecursivepassengers()) { if (e instanceof entitylivingbase) { if (entity.isinwater()) { ((entitylivingbase) e).addpotioneffect(vision); ((entitylivingbase) e).setair(300); } else((entitylivingbase) e).curepotioneffects(stack); } } } float speedfactor = (float) (1 + math.sqrt(pokemob.getpokedexentry().getstatvit()) \/ (10f)); float movespeed = (float) (0.25f * throttle * speedfactor); if (forwardinputdown) { move = true; float f = movespeed \/ 2; if (airspeed) f *= config.flyspeedfactor; else if (waterspeed) f *= config.surfspeedfactor; else f *= config.groundspeedfactor; if (shouldcontrol) { if (!entity.onground) f *= 2; entity.motionx += mathhelper.sin(-entity.rotationyaw * 0.017453292f) * f; entity.motionz += mathhelper.cos(entity.rotationyaw * 0.017453292f) * f; } else if (entity.isinlava() || entity.isinwater()) { f *= 0.1; entity.motionx += mathhelper.sin(-entity.rotationyaw * 0.017453292f) * f; entity.motionz += mathhelper.cos(entity.rotationyaw * 0.017453292f) * f; } } if (backinputdown) { move = true; float f = -movespeed \/ 4; if (shouldcontrol) { if (airspeed) f *= config.flyspeedfactor; else if (waterspeed) f *= config.surfspeedfactor; else f *= config.groundspeedfactor; entity.motionx += mathhelper.sin(-entity.rotationyaw * 0.017453292f) * f; entity.motionz += mathhelper.cos(entity.rotationyaw * 0.017453292f) * f; } } if (upinputdown) { if (entity.onground) { entity.getjumphelper().setjumping(); } else if (verticalcontrol) { entity.motiony += 0.1 * throttle; } else if (entity.isinlava() || entity.isinwater()) { entity.motiony += 0.05 * throttle; } } if (downinputdown) { if (verticalcontrol && !entity.onground) { entity.motiony -= 0.1 * throttle; } } else if (!verticalcontrol && !entity.onground) { entity.motiony -= 0.1; } if (!followownerlook) if (leftinputdown) { pokemob.setheading(pokemob.getheading() - 5); } if (rightinputdown) { pokemob.setheading(pokemob.getheading() + 5); } } else if (!entity.getpassengers().isempty()) { pokemob.setheading(controller.rotationyaw); float f = movespeed \/ 2; if (leftinputdown) { move = true; if (shouldcontrol) { if (!entity.onground) f *= 2; if (airspeed) f *= config.flyspeedfactor; else if (waterspeed) f *= config.surfspeedfactor; else f *= config.groundspeedfactor; entity.motionx += mathhelper.cos(-entity.rotationyaw * 0.017453292f) * f; entity.motionz += mathhelper.sin(entity.rotationyaw * 0.017453292f) * f; } else if (entity.isinlava() || entity.isinwater()) { f *= 0.1; entity.motionx += mathhelper.cos(-entity.rotationyaw * 0.017453292f) * f; entity.motionz += mathhelper.sin(entity.rotationyaw * 0.017453292f) * f; } } if (rightinputdown) { move = true; if (shouldcontrol) { if (!entity.onground) f *= 2; if (airspeed) f *= config.flyspeedfactor; else if (waterspeed) f *= config.surfspeedfactor; else f *= config.groundspeedfactor; entity.motionx -= mathhelper.cos(-entity.rotationyaw * 0.017453292f) * f; entity.motionz -= mathhelper.sin(entity.rotationyaw * 0.017453292f) * f; } else if (entity.isinlava() || entity.isinwater()) { f *= 0.1; entity.motionx -= mathhelper.cos(-entity.rotationyaw * 0.017453292f) * f; entity.motionz -= mathhelper.sin(entity.rotationyaw * 0.017453292f) * f; } } } if (!move) { entity.motionx *= 0.5; entity.motionz *= 0.5; } entity.setrenderyawoffset(pokemob.getheading()); entity.setrotationyawhead(pokemob.getheading()); }","repo":"Pokecube-Development\/Pokecube-Core","label":[1,0,0,0]}
{"id":17267,"original_code":"public void split (FeatureSelection fs)\n\t\t{\n\t\t\tif (ilist == null)\n\t\t\t\tthrow new IllegalStateException (\"Frozen.  Cannot split.\");\n\t\t\tInstanceList ilist0 = new InstanceList (ilist.getPipe());\n\t\t\tInstanceList ilist1 = new InstanceList (ilist.getPipe());\n\t\t\tfor (int i = 0; i < ilist.size(); i++) {\n\t\t\t\tInstance instance = ilist.getInstance(i);\n\t\t\t\tFeatureVector fv = (FeatureVector) instance.getData ();\n\t\t\t\t\/\/ xxx What test should this be?  What to do with negative values?\n\t\t\t\t\t\/\/ Whatever is decided here should also go in InfoGain.calcInfoGains()\n\t\t\t\tif (fv.value (featureIndex) != 0) {\n\t\t\t\t\t\/\/System.out.println (\"list1 add \"+instance.getUri()+\" weight=\"+ilist.getInstanceWeight(i));\n\t\t\t\t\tilist1.add (instance, ilist.getInstanceWeight(i));\n\t\t\t\t} else {\n\t\t\t\t\t\/\/System.out.println (\"list0 add \"+instance.getUri()+\" weight=\"+ilist.getInstanceWeight(i));\n\t\t\t\t\tilist0.add (instance, ilist.getInstanceWeight(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tlogger.info(\"child0=\"+ilist0.size()+\" child1=\"+ilist1.size());\n\t\t\tchild0 = new Node (ilist0, this, fs);\n\t\t\tchild1 = new Node (ilist1, this, fs);\n\t\t}","code_wo_comment":"public void split (FeatureSelection fs)\n\t\t{\n\t\t\tif (ilist == null)\n\t\t\t\tthrow new IllegalStateException (\"Frozen.  Cannot split.\");\n\t\t\tInstanceList ilist0 = new InstanceList (ilist.getPipe());\n\t\t\tInstanceList ilist1 = new InstanceList (ilist.getPipe());\n\t\t\tfor (int i = 0; i < ilist.size(); i++) {\n\t\t\t\tInstance instance = ilist.getInstance(i);\n\t\t\t\tFeatureVector fv = (FeatureVector) instance.getData ();\n\t\t\t\n\t\t\t\t\n\t\t\t\tif (fv.value (featureIndex) != 0) {\n\t\t\t\t\n\t\t\t\t\tilist1.add (instance, ilist.getInstanceWeight(i));\n\t\t\t\t} else {\n\t\t\t\t\n\t\t\t\t\tilist0.add (instance, ilist.getInstanceWeight(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tlogger.info(\"child0=\"+ilist0.size()+\" child1=\"+ilist1.size());\n\t\t\tchild0 = new Node (ilist0, this, fs);\n\t\t\tchild1 = new Node (ilist1, this, fs);\n\t\t}","cleancode":"public void split (featureselection fs) { if (ilist == null) throw new illegalstateexception (\"frozen. cannot split.\"); instancelist ilist0 = new instancelist (ilist.getpipe()); instancelist ilist1 = new instancelist (ilist.getpipe()); for (int i = 0; i < ilist.size(); i++) { instance instance = ilist.getinstance(i); featurevector fv = (featurevector) instance.getdata (); if (fv.value (featureindex) != 0) { ilist1.add (instance, ilist.getinstanceweight(i)); } else { ilist0.add (instance, ilist.getinstanceweight(i)); } } logger.info(\"child0=\"+ilist0.size()+\" child1=\"+ilist1.size()); child0 = new node (ilist0, this, fs); child1 = new node (ilist1, this, fs); }","repo":"JULIELab\/jcore-dependencies","label":[0,0,0,1]}
{"id":25541,"original_code":"Uri findNext() {\n        \/\/ TODO: Unify with searchSubtitles()\n        if (mPrefs.scopeUri != null || isTvBox) {\n            DocumentFile video = null;\n            File videoRaw = null;\n            if (!isTvBox && mPrefs.scopeUri != null) {\n                if (\"com.android.externalstorage.documents\".equals(mPrefs.mediaUri.getHost())) {\n                    \/\/ Fast search based on path in uri\n                    video = SubtitleUtils.findUriInScope(this, mPrefs.scopeUri, mPrefs.mediaUri);\n                } else {\n                    \/\/ Slow search based on matching metadata, no path in uri\n                    \/\/ Provider \"com.android.providers.media.documents\" when using \"Videos\" tab in file picker\n                    DocumentFile fileScope = DocumentFile.fromTreeUri(this, mPrefs.scopeUri);\n                    DocumentFile fileMedia = DocumentFile.fromSingleUri(this, mPrefs.mediaUri);\n                    video = SubtitleUtils.findDocInScope(fileScope, fileMedia);\n                }\n            } else if (isTvBox) {\n                videoRaw = new File(mPrefs.mediaUri.getSchemeSpecificPart());\n                video = DocumentFile.fromFile(videoRaw);\n            }\n            if (video != null) {\n                DocumentFile next;\n                if (!isTvBox) {\n                    next = SubtitleUtils.findNext(video);\n                } else {\n                    File parentRaw = videoRaw.getParentFile();\n                    DocumentFile dir = DocumentFile.fromFile(parentRaw);\n                    next = SubtitleUtils.findNext(video, dir);\n                }\n                if (next != null) {\n                    return next.getUri();\n                }\n            }\n        }\n        return null;\n    }","code_wo_comment":"Uri findNext() {\n       \n        if (mPrefs.scopeUri != null || isTvBox) {\n            DocumentFile video = null;\n            File videoRaw = null;\n            if (!isTvBox && mPrefs.scopeUri != null) {\n                if (\"com.android.externalstorage.documents\".equals(mPrefs.mediaUri.getHost())) {\n                   \n                    video = SubtitleUtils.findUriInScope(this, mPrefs.scopeUri, mPrefs.mediaUri);\n                } else {\n                   \n                   \n                    DocumentFile fileScope = DocumentFile.fromTreeUri(this, mPrefs.scopeUri);\n                    DocumentFile fileMedia = DocumentFile.fromSingleUri(this, mPrefs.mediaUri);\n                    video = SubtitleUtils.findDocInScope(fileScope, fileMedia);\n                }\n            } else if (isTvBox) {\n                videoRaw = new File(mPrefs.mediaUri.getSchemeSpecificPart());\n                video = DocumentFile.fromFile(videoRaw);\n            }\n            if (video != null) {\n                DocumentFile next;\n                if (!isTvBox) {\n                    next = SubtitleUtils.findNext(video);\n                } else {\n                    File parentRaw = videoRaw.getParentFile();\n                    DocumentFile dir = DocumentFile.fromFile(parentRaw);\n                    next = SubtitleUtils.findNext(video, dir);\n                }\n                if (next != null) {\n                    return next.getUri();\n                }\n            }\n        }\n        return null;\n    }","cleancode":"uri findnext() { if (mprefs.scopeuri != null || istvbox) { documentfile video = null; file videoraw = null; if (!istvbox && mprefs.scopeuri != null) { if (\"com.android.externalstorage.documents\".equals(mprefs.mediauri.gethost())) { video = subtitleutils.finduriinscope(this, mprefs.scopeuri, mprefs.mediauri); } else { documentfile filescope = documentfile.fromtreeuri(this, mprefs.scopeuri); documentfile filemedia = documentfile.fromsingleuri(this, mprefs.mediauri); video = subtitleutils.finddocinscope(filescope, filemedia); } } else if (istvbox) { videoraw = new file(mprefs.mediauri.getschemespecificpart()); video = documentfile.fromfile(videoraw); } if (video != null) { documentfile next; if (!istvbox) { next = subtitleutils.findnext(video); } else { file parentraw = videoraw.getparentfile(); documentfile dir = documentfile.fromfile(parentraw); next = subtitleutils.findnext(video, dir); } if (next != null) { return next.geturi(); } } } return null; }","repo":"Radfanyemen\/Player","label":[0,1,0,0]}
{"id":17459,"original_code":"private void mOSActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_mOSActionPerformed\n        \/\/ TODO add your handling code here:\n      \/\/ new ViewOrdemServico().setVisible(true);\n    }","code_wo_comment":"private void mOSActionPerformed(java.awt.event.ActionEvent evt) {       \n     \n    }","cleancode":"private void mosactionperformed(java.awt.event.actionevent evt) { }","repo":"LeandroDosSantosPereira\/sistemaBarbearia","label":[0,1,0,0]}
{"id":9278,"original_code":"@SubscribeEvent(priority = EventPriority.NORMAL)\n\tpublic void onRenderOverlay(RenderGameOverlayEvent.Post event) {\n        \/*\n        if (event.getType() != RenderGameOverlayEvent.ElementType.CROSSHAIRS) {\n            return;\n        }\n        FIXME: still needed? if so, search for ported way\n         *\/\n\t\tItemStack activeStack = mc.player.getUseItem();\n\t\tif (activeStack.getItem() instanceof ModularCrossbowItem) {\n\t\t\tModularCrossbowItem item = (ModularCrossbowItem) activeStack.getItem();\n\t\t\tgui.setProgress(item.getProgress(activeStack, mc.player), 0);\n\t\t} else {\n\t\t\tgui.setProgress(0, 0);\n\t\t}\n\t\tgui.draw();\n\t}","code_wo_comment":"@SubscribeEvent(priority = EventPriority.NORMAL)\n\tpublic void onRenderOverlay(RenderGameOverlayEvent.Post event) {\n       \n\t\tItemStack activeStack = mc.player.getUseItem();\n\t\tif (activeStack.getItem() instanceof ModularCrossbowItem) {\n\t\t\tModularCrossbowItem item = (ModularCrossbowItem) activeStack.getItem();\n\t\t\tgui.setProgress(item.getProgress(activeStack, mc.player), 0);\n\t\t} else {\n\t\t\tgui.setProgress(0, 0);\n\t\t}\n\t\tgui.draw();\n\t}","cleancode":"@subscribeevent(priority = eventpriority.normal) public void onrenderoverlay(rendergameoverlayevent.post event) { itemstack activestack = mc.player.getuseitem(); if (activestack.getitem() instanceof modularcrossbowitem) { modularcrossbowitem item = (modularcrossbowitem) activestack.getitem(); gui.setprogress(item.getprogress(activestack, mc.player), 0); } else { gui.setprogress(0, 0); } gui.draw(); }","repo":"LordGrimmauld\/tetra","label":[1,0,0,0]}
{"id":33945,"original_code":"public static boolean isAlphabetic(String s) {\n        if (isEmpty(s)) return defaultEmptyOK;\n        \/\/ Search through string's characters one by one\n        \/\/ until we find a non-alphabetic character.\n        \/\/ When we do, return false; if we don't, return true.\n        for (int i = 0; i < s.length(); i++) {\n            \/\/ Check that current character is letter.\n            char c = s.charAt(i);\n            if (!isLetter(c))\n                return false;\n        }\n        \/\/ All characters are letters.\n        return true;\n    }","code_wo_comment":"public static boolean isAlphabetic(String s) {\n        if (isEmpty(s)) return defaultEmptyOK;\n       \n       \n       \n        for (int i = 0; i < s.length(); i++) {\n           \n            char c = s.charAt(i);\n            if (!isLetter(c))\n                return false;\n        }\n       \n        return true;\n    }","cleancode":"public static boolean isalphabetic(string s) { if (isempty(s)) return defaultemptyok; for (int i = 0; i < s.length(); i++) { char c = s.charat(i); if (!isletter(c)) return false; } return true; }","repo":"Mark110\/e-commerce","label":[1,0,0,0]}
{"id":17649,"original_code":"private void rollupParameters(TLParamGroup sourceParamGroup, TLParamGroup targetParamGroup,\n        RollupReferenceHandler referenceHandler, ModelElementCloner cloner) {\n        for (TLParameter sourceParam : sourceParamGroup.getParameters()) {\n            TLMemberField<?> sourceFieldRef = sourceParam.getFieldRef();\n            if (sourceFieldRef != null) {\n                TLParameter targetParam = targetParamGroup.getParameter( sourceFieldRef.getName() );\n                if (targetParam == null) {\n                    targetParam = cloner.clone( sourceParam ); \/\/ TODO: After cloning, targetParam.fieldRef is null\n                    targetParamGroup.addParameter( targetParam );\n                    referenceHandler.captureRollupReferences( targetParam );\n                }\n                if (targetParam.getDocumentation() == null) {\n                    targetParam.setDocumentation( cloner.clone( sourceParam.getDocumentation() ) );\n                }\n            }\n        }\n    }","code_wo_comment":"private void rollupParameters(TLParamGroup sourceParamGroup, TLParamGroup targetParamGroup,\n        RollupReferenceHandler referenceHandler, ModelElementCloner cloner) {\n        for (TLParameter sourceParam : sourceParamGroup.getParameters()) {\n            TLMemberField<?> sourceFieldRef = sourceParam.getFieldRef();\n            if (sourceFieldRef != null) {\n                TLParameter targetParam = targetParamGroup.getParameter( sourceFieldRef.getName() );\n                if (targetParam == null) {\n                    targetParam = cloner.clone( sourceParam );\n                    targetParamGroup.addParameter( targetParam );\n                    referenceHandler.captureRollupReferences( targetParam );\n                }\n                if (targetParam.getDocumentation() == null) {\n                    targetParam.setDocumentation( cloner.clone( sourceParam.getDocumentation() ) );\n                }\n            }\n        }\n    }","cleancode":"private void rollupparameters(tlparamgroup sourceparamgroup, tlparamgroup targetparamgroup, rollupreferencehandler referencehandler, modelelementcloner cloner) { for (tlparameter sourceparam : sourceparamgroup.getparameters()) { tlmemberfield<?> sourcefieldref = sourceparam.getfieldref(); if (sourcefieldref != null) { tlparameter targetparam = targetparamgroup.getparameter( sourcefieldref.getname() ); if (targetparam == null) { targetparam = cloner.clone( sourceparam ); targetparamgroup.addparameter( targetparam ); referencehandler.capturerollupreferences( targetparam ); } if (targetparam.getdocumentation() == null) { targetparam.setdocumentation( cloner.clone( sourceparam.getdocumentation() ) ); } } } }","repo":"OpenTravel\/OTM-DE-Compiler","label":[0,1,0,0]}
{"id":9475,"original_code":"private static List<TestConfiguration> getAdditionalConfigurations(Activity activity) {\n        List<TestConfiguration> additionalConfigurations = new ArrayList<>();\n        if (Constants.USE_GMS_CONFIGURATION) {\n            additionalConfigurations.add(new GmsPermissionConfiguration(activity));\n        }\n        \/\/ TODO: Any custom configurations that are intended to be run as part of this test should\n        \/\/ be added here.\n        return additionalConfigurations;\n    }","code_wo_comment":"private static List<TestConfiguration> getAdditionalConfigurations(Activity activity) {\n        List<TestConfiguration> additionalConfigurations = new ArrayList<>();\n        if (Constants.USE_GMS_CONFIGURATION) {\n            additionalConfigurations.add(new GmsPermissionConfiguration(activity));\n        }\n       \n       \n        return additionalConfigurations;\n    }","cleancode":"private static list<testconfiguration> getadditionalconfigurations(activity activity) { list<testconfiguration> additionalconfigurations = new arraylist<>(); if (constants.use_gms_configuration) { additionalconfigurations.add(new gmspermissionconfiguration(activity)); } return additionalconfigurations; }","repo":"LaudateCorpus1\/security-certification-resources","label":[1,0,0,0]}
{"id":9644,"original_code":"@Override\n  public void simpleRender(RenderManager rm) {\n    \/\/TODO: add render code\n  }","code_wo_comment":"@Override\n  public void simpleRender(RenderManager rm) {\n   \n  }","cleancode":"@override public void simplerender(rendermanager rm) { }","repo":"MeFisto94\/test-bot-1","label":[0,1,0,0]}
{"id":9670,"original_code":"public int applyLayers(int[] data) {\n        checkNotNull(data);\n        BlockVector3 minY = region.getMinimumPoint();\n        int originX = minY.getBlockX();\n        int originZ = minY.getBlockZ();\n        int maxY = region.getMaximumPoint().getBlockY();\n        BlockState fillerAir = BlockTypes.AIR.getDefaultState();\n        int blocksChanged = 0;\n        BlockStateHolder<BlockState> tmpBlock = BlockTypes.AIR.getDefaultState();\n        int maxY4 = maxY << 4;\n        int index = 0;\n        \/\/ Apply heightmap\n        for (int z = 0; z < height; ++z) {\n            int zr = z + originZ;\n            for (int x = 0; x < width; ++x) {\n                if (this.invalid != null && this.invalid[index]) {\n                    continue;\n                }\n                int curHeight = this.data[index];\n                \/\/Clamp newHeight within the selection area\n                int newHeight = Math.min(maxY4, data[index++]);\n                int curBlock = (curHeight) >> 4;\n                int newBlock = (newHeight + 15) >> 4;\n                \/\/ Offset x,z to be 'real' coordinates\n                int xr = x + originX;\n                \/\/ Depending on growing or shrinking we need to start at the bottom or top\n                if (newHeight > curHeight) {\n                    \/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\n                    BlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n                    \/\/ Skip water\/lava\n                    if (existing.getBlockType().getMaterial().isMovementBlocker()) {\n                        \/\/ Grow -- start from 1 below top replacing airblocks\n                        for (int setY = newBlock - 1, getY = curBlock; setY >= curBlock; --setY, getY--) {\n                            BlockStateHolder<BlockState> get = session.getBlock(xr, getY, zr);\n                            if (get != BlockTypes.AIR.getDefaultState()) {\n                                tmpBlock = get;\n                            }\n                            session.setBlock(xr, setY, zr, tmpBlock);\n                            ++blocksChanged;\n                        }\n                        int setData = newHeight & 15;\n                        if (setData != 0) {\n                            existing = PropertyGroup.LEVEL.set(existing, setData - 1);\n                            session.setBlock(xr, newBlock, zr, existing);\n                            ++blocksChanged;\n                        } else {\n                            existing = PropertyGroup.LEVEL.set(existing, 15);\n                            session.setBlock(xr, newBlock, zr, existing);\n                            ++blocksChanged;\n                        }\n                    }\n                } else if (curHeight > newHeight) {\n                    \/\/ Fill rest with air\n                    for (int y = newBlock + 1; y <= ((curHeight + 15) >> 4); ++y) {\n                        session.setBlock(xr, y, zr, fillerAir);\n                        ++blocksChanged;\n                    }\n                    \/\/ Set the top block of the column to be the same type\n                    \/\/ (this could otherwise go wrong with rounding)\n                    int setData = newHeight & 15;\n                    BlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n                    if (setData != 0) {\n                        existing = PropertyGroup.LEVEL.set(existing, setData - 1);\n                        session.setBlock(xr, newBlock, zr, existing);\n                    } else {\n                        existing = PropertyGroup.LEVEL.set(existing, 15);\n                        session.setBlock(xr, newBlock, zr, existing);\n                    }\n                    ++blocksChanged;\n                }\n            }\n        }\n        return blocksChanged;\n    }","code_wo_comment":"public int applyLayers(int[] data) {\n        checkNotNull(data);\n        BlockVector3 minY = region.getMinimumPoint();\n        int originX = minY.getBlockX();\n        int originZ = minY.getBlockZ();\n        int maxY = region.getMaximumPoint().getBlockY();\n        BlockState fillerAir = BlockTypes.AIR.getDefaultState();\n        int blocksChanged = 0;\n        BlockStateHolder<BlockState> tmpBlock = BlockTypes.AIR.getDefaultState();\n        int maxY4 = maxY << 4;\n        int index = 0;\n       \n        for (int z = 0; z < height; ++z) {\n            int zr = z + originZ;\n            for (int x = 0; x < width; ++x) {\n                if (this.invalid != null && this.invalid[index]) {\n                    continue;\n                }\n                int curHeight = this.data[index];\n               \n                int newHeight = Math.min(maxY4, data[index++]);\n                int curBlock = (curHeight) >> 4;\n                int newBlock = (newHeight + 15) >> 4;\n               \n                int xr = x + originX;\n               \n                if (newHeight > curHeight) {\n                   \n                    BlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n                   \n                    if (existing.getBlockType().getMaterial().isMovementBlocker()) {\n                       \n                        for (int setY = newBlock - 1, getY = curBlock; setY >= curBlock; --setY, getY--) {\n                            BlockStateHolder<BlockState> get = session.getBlock(xr, getY, zr);\n                            if (get != BlockTypes.AIR.getDefaultState()) {\n                                tmpBlock = get;\n                            }\n                            session.setBlock(xr, setY, zr, tmpBlock);\n                            ++blocksChanged;\n                        }\n                        int setData = newHeight & 15;\n                        if (setData != 0) {\n                            existing = PropertyGroup.LEVEL.set(existing, setData - 1);\n                            session.setBlock(xr, newBlock, zr, existing);\n                            ++blocksChanged;\n                        } else {\n                            existing = PropertyGroup.LEVEL.set(existing, 15);\n                            session.setBlock(xr, newBlock, zr, existing);\n                            ++blocksChanged;\n                        }\n                    }\n                } else if (curHeight > newHeight) {\n                   \n                    for (int y = newBlock + 1; y <= ((curHeight + 15) >> 4); ++y) {\n                        session.setBlock(xr, y, zr, fillerAir);\n                        ++blocksChanged;\n                    }\n                   \n                   \n                    int setData = newHeight & 15;\n                    BlockStateHolder<BlockState> existing = session.getBlock(xr, curBlock, zr);\n                    if (setData != 0) {\n                        existing = PropertyGroup.LEVEL.set(existing, setData - 1);\n                        session.setBlock(xr, newBlock, zr, existing);\n                    } else {\n                        existing = PropertyGroup.LEVEL.set(existing, 15);\n                        session.setBlock(xr, newBlock, zr, existing);\n                    }\n                    ++blocksChanged;\n                }\n            }\n        }\n        return blocksChanged;\n    }","cleancode":"public int applylayers(int[] data) { checknotnull(data); blockvector3 miny = region.getminimumpoint(); int originx = miny.getblockx(); int originz = miny.getblockz(); int maxy = region.getmaximumpoint().getblocky(); blockstate fillerair = blocktypes.air.getdefaultstate(); int blockschanged = 0; blockstateholder<blockstate> tmpblock = blocktypes.air.getdefaultstate(); int maxy4 = maxy << 4; int index = 0; for (int z = 0; z < height; ++z) { int zr = z + originz; for (int x = 0; x < width; ++x) { if (this.invalid != null && this.invalid[index]) { continue; } int curheight = this.data[index]; int newheight = math.min(maxy4, data[index++]); int curblock = (curheight) >> 4; int newblock = (newheight + 15) >> 4; int xr = x + originx; if (newheight > curheight) { blockstateholder<blockstate> existing = session.getblock(xr, curblock, zr); if (existing.getblocktype().getmaterial().ismovementblocker()) { for (int sety = newblock - 1, gety = curblock; sety >= curblock; --sety, gety--) { blockstateholder<blockstate> get = session.getblock(xr, gety, zr); if (get != blocktypes.air.getdefaultstate()) { tmpblock = get; } session.setblock(xr, sety, zr, tmpblock); ++blockschanged; } int setdata = newheight & 15; if (setdata != 0) { existing = propertygroup.level.set(existing, setdata - 1); session.setblock(xr, newblock, zr, existing); ++blockschanged; } else { existing = propertygroup.level.set(existing, 15); session.setblock(xr, newblock, zr, existing); ++blockschanged; } } } else if (curheight > newheight) { for (int y = newblock + 1; y <= ((curheight + 15) >> 4); ++y) { session.setblock(xr, y, zr, fillerair); ++blockschanged; } int setdata = newheight & 15; blockstateholder<blockstate> existing = session.getblock(xr, curblock, zr); if (setdata != 0) { existing = propertygroup.level.set(existing, setdata - 1); session.setblock(xr, newblock, zr, existing); } else { existing = propertygroup.level.set(existing, 15); session.setblock(xr, newblock, zr, existing); } ++blockschanged; } } } return blockschanged; }","repo":"IronApollo\/FastAsyncWorldEdit","label":[0,1,0,0]}
{"id":9671,"original_code":"public int apply(int[] data) throws MaxChangedBlocksException {\n        checkNotNull(data);\n        BlockVector3 minY = region.getMinimumPoint();\n        int originX = minY.getBlockX();\n        int originY = minY.getBlockY();\n        int originZ = minY.getBlockZ();\n        int maxY = region.getMaximumPoint().getBlockY();\n        BlockState fillerAir = BlockTypes.AIR.getDefaultState();\n        int blocksChanged = 0;\n        BlockState tmpBlock = BlockTypes.AIR.getDefaultState();\n        \/\/ Apply heightmap\n        int index = 0;\n        for (int z = 0; z < height; ++z) {\n            int zr = z + originZ;\n            for (int x = 0; x < width; ++x, index++) {\n                if (this.invalid != null && this.invalid[index]) {\n                    continue;\n                }\n                int curHeight = this.data[index];\n                \/\/ Clamp newHeight within the selection area\n                int newHeight = Math.min(maxY, data[index]);\n                \/\/ Offset x,z to be 'real' coordinates\n                int xr = x + originX;\n                \/\/ Depending on growing or shrinking we need to start at the bottom or top\n                if (newHeight > curHeight) {\n                    \/\/ Set the top block of the column to be the same type (this might go wrong with rounding)\n                    BlockState existing = session.getBlock(xr, curHeight, zr);\n                    \/\/ Skip water\/lava\n                    if (existing.getBlockType().getMaterial().isMovementBlocker()) {\n                        int y0 = newHeight - 1;\n                        for (int setY = y0, getY = curHeight - 1; setY >= curHeight; setY--, getY--) {\n                            BlockState get;\n                            if (getY >= 0 && getY < 256) {\n                                get = session.getBlock(xr, getY, zr);\n                            } else {\n                                get = BlockTypes.AIR.getDefaultState();\n                            }\n                            if (get != BlockTypes.AIR.getDefaultState()) {\n                                tmpBlock = get;\n                            }\n                            session.setBlock(xr, setY, zr, tmpBlock);\n                            ++blocksChanged;\n                        }\n                        session.setBlock(xr, newHeight, zr, existing);\n                        ++blocksChanged;\n                    }\n                } else if (curHeight > newHeight) {\n                    \/\/ Set the top block of the column to be the same type\n                    \/\/ (this could otherwise go wrong with rounding)\n                    session.setBlock(xr, newHeight, zr, session.getBlock(xr, curHeight, zr));\n                    ++blocksChanged;\n                    \/\/ Fill rest with air\n                    for (int y = newHeight + 1; y <= curHeight; ++y) {\n                        session.setBlock(xr, y, zr, fillerAir);\n                        ++blocksChanged;\n                    }\n                }\n            }\n        }\n        \/\/ Drop trees to the floor -- TODO\n        return blocksChanged;\n    }","code_wo_comment":"public int apply(int[] data) throws MaxChangedBlocksException {\n        checkNotNull(data);\n        BlockVector3 minY = region.getMinimumPoint();\n        int originX = minY.getBlockX();\n        int originY = minY.getBlockY();\n        int originZ = minY.getBlockZ();\n        int maxY = region.getMaximumPoint().getBlockY();\n        BlockState fillerAir = BlockTypes.AIR.getDefaultState();\n        int blocksChanged = 0;\n        BlockState tmpBlock = BlockTypes.AIR.getDefaultState();\n       \n        int index = 0;\n        for (int z = 0; z < height; ++z) {\n            int zr = z + originZ;\n            for (int x = 0; x < width; ++x, index++) {\n                if (this.invalid != null && this.invalid[index]) {\n                    continue;\n                }\n                int curHeight = this.data[index];\n               \n                int newHeight = Math.min(maxY, data[index]);\n               \n                int xr = x + originX;\n               \n                if (newHeight > curHeight) {\n                   \n                    BlockState existing = session.getBlock(xr, curHeight, zr);\n                   \n                    if (existing.getBlockType().getMaterial().isMovementBlocker()) {\n                        int y0 = newHeight - 1;\n                        for (int setY = y0, getY = curHeight - 1; setY >= curHeight; setY--, getY--) {\n                            BlockState get;\n                            if (getY >= 0 && getY < 256) {\n                                get = session.getBlock(xr, getY, zr);\n                            } else {\n                                get = BlockTypes.AIR.getDefaultState();\n                            }\n                            if (get != BlockTypes.AIR.getDefaultState()) {\n                                tmpBlock = get;\n                            }\n                            session.setBlock(xr, setY, zr, tmpBlock);\n                            ++blocksChanged;\n                        }\n                        session.setBlock(xr, newHeight, zr, existing);\n                        ++blocksChanged;\n                    }\n                } else if (curHeight > newHeight) {\n                   \n                   \n                    session.setBlock(xr, newHeight, zr, session.getBlock(xr, curHeight, zr));\n                    ++blocksChanged;\n                   \n                    for (int y = newHeight + 1; y <= curHeight; ++y) {\n                        session.setBlock(xr, y, zr, fillerAir);\n                        ++blocksChanged;\n                    }\n                }\n            }\n        }\n       \n        return blocksChanged;\n    }","cleancode":"public int apply(int[] data) throws maxchangedblocksexception { checknotnull(data); blockvector3 miny = region.getminimumpoint(); int originx = miny.getblockx(); int originy = miny.getblocky(); int originz = miny.getblockz(); int maxy = region.getmaximumpoint().getblocky(); blockstate fillerair = blocktypes.air.getdefaultstate(); int blockschanged = 0; blockstate tmpblock = blocktypes.air.getdefaultstate(); int index = 0; for (int z = 0; z < height; ++z) { int zr = z + originz; for (int x = 0; x < width; ++x, index++) { if (this.invalid != null && this.invalid[index]) { continue; } int curheight = this.data[index]; int newheight = math.min(maxy, data[index]); int xr = x + originx; if (newheight > curheight) { blockstate existing = session.getblock(xr, curheight, zr); if (existing.getblocktype().getmaterial().ismovementblocker()) { int y0 = newheight - 1; for (int sety = y0, gety = curheight - 1; sety >= curheight; sety--, gety--) { blockstate get; if (gety >= 0 && gety < 256) { get = session.getblock(xr, gety, zr); } else { get = blocktypes.air.getdefaultstate(); } if (get != blocktypes.air.getdefaultstate()) { tmpblock = get; } session.setblock(xr, sety, zr, tmpblock); ++blockschanged; } session.setblock(xr, newheight, zr, existing); ++blockschanged; } } else if (curheight > newheight) { session.setblock(xr, newheight, zr, session.getblock(xr, curheight, zr)); ++blockschanged; for (int y = newheight + 1; y <= curheight; ++y) { session.setblock(xr, y, zr, fillerair); ++blockschanged; } } } } return blockschanged; }","repo":"IronApollo\/FastAsyncWorldEdit","label":[0,1,0,0]}
{"id":1494,"original_code":"private void initialization(int minXSize, int maxXSize) {\n        \/\/ TODO: current implementation is less elegant. code refactoring may be needed.\n        dfaConfig = new DFAConfig(); \/\/ allocates a new config every time.\n        Random r = new Random();\n        dfaConfig.stateSize = r.nextInt((maxXSize - minXSize) + 1) + minXSize;\n        dfaConfig.faultyStateSize = Math.max(dfaConfig.stateSize \/ 10, 4);\n        LOGGER.debug(\"Generated overall state size and faulty state size: {}, {}\",\n                dfaConfig.stateSize, dfaConfig.faultyStateSize);\n        dfaConfig.states = new int[dfaConfig.stateSize];\n        for (int i = 0; i < dfaConfig.stateSize; i++) {\n            dfaConfig.states[i] = i;\n        }\n        \/\/ alphabet size: range[6 ~ 16] or [10, 20]\n        int base = dfaConfig.stateSize > 20 ? 10 : 6;\n        int alphabetSize = r.nextInt(11) + base;\n        dfaConfig.alphabet = new char[alphabetSize];\n        LOGGER.debug(\"Chosen alphabet size is {}\", alphabetSize);\n        \/\/ randomly fill the alphabet\n        int alphabetSpaceLen = dfaConfig.alphabetSpace.length();\n        boolean[] tempFlags = new boolean[alphabetSpaceLen];\n        int tempIndex;\n        for (int i = 0; i < dfaConfig.alphabet.length; i++) {\n            tempIndex = r.nextInt(alphabetSpaceLen);\n            while (tempFlags[tempIndex]) {\n                tempIndex = r.nextInt(alphabetSpaceLen);\n            }\n            tempFlags[tempIndex] = true;\n            dfaConfig.alphabet[i] = dfaConfig.alphabetSpace.charAt(tempIndex);\n        }\n        \/\/ faulty event size (make sure it less than a half of alphabet size)\n        int faultEventSize = Math.max(dfaConfig.faultyStateSize \/ 2, 2);\n        faultEventSize = faultEventSize >= 5 ? 4 : faultEventSize;\n        if (alphabetSize > 15 && (dfaConfig.faultyStateSize \/ faultEventSize) > 3) {\n            faultEventSize = faultEventSize + r.nextInt(2) + 1;\n        }\n        dfaConfig.faultyEvents = new int[faultEventSize];\n        LOGGER.debug(\"Chosen faulty event size: {}\", faultEventSize);\n        boolean[] chosenFaultMarks = new boolean[alphabetSize];\n        int choose;\n        for (int i = 0; i < faultEventSize; i++) {\n            choose = r.nextInt(alphabetSize);\n            while (chosenFaultMarks[choose])\n                choose = r.nextInt(alphabetSize);\n            chosenFaultMarks[choose] = true;\n            dfaConfig.faultyEvents[i] = choose;\n        }\n        LOGGER.debug(\"Generated alphabet set: {}\", Arrays.toString(dfaConfig.alphabet));\n        LOGGER.debug(\"Faulty events (index): {}\", Arrays.toString(dfaConfig.faultyEvents));\n        Set<Integer> faultyEventIndexSet = new HashSet<>();\n        for (int fi : dfaConfig.faultyEvents)\n            faultyEventIndexSet.add(fi);\n        int ui = 0;\n        int oi = 0;\n        dfaConfig.observableEvents = new char[alphabetSize - faultEventSize];\n        dfaConfig.unobservableEvents = new char[faultEventSize];\n        for (int i = 0; i < alphabetSize; i++) {\n            if (faultyEventIndexSet.contains(i))\n                dfaConfig.unobservableEvents[ui++] = dfaConfig.alphabet[i];\n            else\n                dfaConfig.observableEvents[oi++] = dfaConfig.alphabet[i];\n        }\n        LOGGER.debug(\"selected observable events : {}\", Arrays.toString(dfaConfig.observableEvents));\n        LOGGER.debug(\"selected unobservable events : {}\", Arrays.toString(dfaConfig.unobservableEvents));\n    }","code_wo_comment":"private void initialization(int minXSize, int maxXSize) {\n       \n        dfaConfig = new DFAConfig();\n        Random r = new Random();\n        dfaConfig.stateSize = r.nextInt((maxXSize - minXSize) + 1) + minXSize;\n        dfaConfig.faultyStateSize = Math.max(dfaConfig.stateSize \/ 10, 4);\n        LOGGER.debug(\"Generated overall state size and faulty state size: {}, {}\",\n                dfaConfig.stateSize, dfaConfig.faultyStateSize);\n        dfaConfig.states = new int[dfaConfig.stateSize];\n        for (int i = 0; i < dfaConfig.stateSize; i++) {\n            dfaConfig.states[i] = i;\n        }\n       \n        int base = dfaConfig.stateSize > 20 ? 10 : 6;\n        int alphabetSize = r.nextInt(11) + base;\n        dfaConfig.alphabet = new char[alphabetSize];\n        LOGGER.debug(\"Chosen alphabet size is {}\", alphabetSize);\n       \n        int alphabetSpaceLen = dfaConfig.alphabetSpace.length();\n        boolean[] tempFlags = new boolean[alphabetSpaceLen];\n        int tempIndex;\n        for (int i = 0; i < dfaConfig.alphabet.length; i++) {\n            tempIndex = r.nextInt(alphabetSpaceLen);\n            while (tempFlags[tempIndex]) {\n                tempIndex = r.nextInt(alphabetSpaceLen);\n            }\n            tempFlags[tempIndex] = true;\n            dfaConfig.alphabet[i] = dfaConfig.alphabetSpace.charAt(tempIndex);\n        }\n       \n        int faultEventSize = Math.max(dfaConfig.faultyStateSize \/ 2, 2);\n        faultEventSize = faultEventSize >= 5 ? 4 : faultEventSize;\n        if (alphabetSize > 15 && (dfaConfig.faultyStateSize \/ faultEventSize) > 3) {\n            faultEventSize = faultEventSize + r.nextInt(2) + 1;\n        }\n        dfaConfig.faultyEvents = new int[faultEventSize];\n        LOGGER.debug(\"Chosen faulty event size: {}\", faultEventSize);\n        boolean[] chosenFaultMarks = new boolean[alphabetSize];\n        int choose;\n        for (int i = 0; i < faultEventSize; i++) {\n            choose = r.nextInt(alphabetSize);\n            while (chosenFaultMarks[choose])\n                choose = r.nextInt(alphabetSize);\n            chosenFaultMarks[choose] = true;\n            dfaConfig.faultyEvents[i] = choose;\n        }\n        LOGGER.debug(\"Generated alphabet set: {}\", Arrays.toString(dfaConfig.alphabet));\n        LOGGER.debug(\"Faulty events (index): {}\", Arrays.toString(dfaConfig.faultyEvents));\n        Set<Integer> faultyEventIndexSet = new HashSet<>();\n        for (int fi : dfaConfig.faultyEvents)\n            faultyEventIndexSet.add(fi);\n        int ui = 0;\n        int oi = 0;\n        dfaConfig.observableEvents = new char[alphabetSize - faultEventSize];\n        dfaConfig.unobservableEvents = new char[faultEventSize];\n        for (int i = 0; i < alphabetSize; i++) {\n            if (faultyEventIndexSet.contains(i))\n                dfaConfig.unobservableEvents[ui++] = dfaConfig.alphabet[i];\n            else\n                dfaConfig.observableEvents[oi++] = dfaConfig.alphabet[i];\n        }\n        LOGGER.debug(\"selected observable events : {}\", Arrays.toString(dfaConfig.observableEvents));\n        LOGGER.debug(\"selected unobservable events : {}\", Arrays.toString(dfaConfig.unobservableEvents));\n    }","cleancode":"private void initialization(int minxsize, int maxxsize) { dfaconfig = new dfaconfig(); random r = new random(); dfaconfig.statesize = r.nextint((maxxsize - minxsize) + 1) + minxsize; dfaconfig.faultystatesize = math.max(dfaconfig.statesize \/ 10, 4); logger.debug(\"generated overall state size and faulty state size: {}, {}\", dfaconfig.statesize, dfaconfig.faultystatesize); dfaconfig.states = new int[dfaconfig.statesize]; for (int i = 0; i < dfaconfig.statesize; i++) { dfaconfig.states[i] = i; } int base = dfaconfig.statesize > 20 ? 10 : 6; int alphabetsize = r.nextint(11) + base; dfaconfig.alphabet = new char[alphabetsize]; logger.debug(\"chosen alphabet size is {}\", alphabetsize); int alphabetspacelen = dfaconfig.alphabetspace.length(); boolean[] tempflags = new boolean[alphabetspacelen]; int tempindex; for (int i = 0; i < dfaconfig.alphabet.length; i++) { tempindex = r.nextint(alphabetspacelen); while (tempflags[tempindex]) { tempindex = r.nextint(alphabetspacelen); } tempflags[tempindex] = true; dfaconfig.alphabet[i] = dfaconfig.alphabetspace.charat(tempindex); } int faulteventsize = math.max(dfaconfig.faultystatesize \/ 2, 2); faulteventsize = faulteventsize >= 5 ? 4 : faulteventsize; if (alphabetsize > 15 && (dfaconfig.faultystatesize \/ faulteventsize) > 3) { faulteventsize = faulteventsize + r.nextint(2) + 1; } dfaconfig.faultyevents = new int[faulteventsize]; logger.debug(\"chosen faulty event size: {}\", faulteventsize); boolean[] chosenfaultmarks = new boolean[alphabetsize]; int choose; for (int i = 0; i < faulteventsize; i++) { choose = r.nextint(alphabetsize); while (chosenfaultmarks[choose]) choose = r.nextint(alphabetsize); chosenfaultmarks[choose] = true; dfaconfig.faultyevents[i] = choose; } logger.debug(\"generated alphabet set: {}\", arrays.tostring(dfaconfig.alphabet)); logger.debug(\"faulty events (index): {}\", arrays.tostring(dfaconfig.faultyevents)); set<integer> faultyeventindexset = new hashset<>(); for (int fi : dfaconfig.faultyevents) faultyeventindexset.add(fi); int ui = 0; int oi = 0; dfaconfig.observableevents = new char[alphabetsize - faulteventsize]; dfaconfig.unobservableevents = new char[faulteventsize]; for (int i = 0; i < alphabetsize; i++) { if (faultyeventindexset.contains(i)) dfaconfig.unobservableevents[ui++] = dfaconfig.alphabet[i]; else dfaconfig.observableevents[oi++] = dfaconfig.alphabet[i]; } logger.debug(\"selected observable events : {}\", arrays.tostring(dfaconfig.observableevents)); logger.debug(\"selected unobservable events : {}\", arrays.tostring(dfaconfig.unobservableevents)); }","repo":"OES2018\/randomly-generation-of-diagnosable-dfa","label":[1,0,0,0]}
{"id":34283,"original_code":"@Override\n    public BiomeProvider load(AnnotatedType t, Object c, ConfigLoader loader) throws LoadException {\n        return loader.loadType(BiomePipelineProvider.class, c); \/\/ TODO: actually implement this lol\n    }","code_wo_comment":"@Override\n    public BiomeProvider load(AnnotatedType t, Object c, ConfigLoader loader) throws LoadException {\n        return loader.loadType(BiomePipelineProvider.class, c);\n    }","cleancode":"@override public biomeprovider load(annotatedtype t, object c, configloader loader) throws loadexception { return loader.loadtype(biomepipelineprovider.class, c); }","repo":"PolyhedralDev\/Terra-biome-provider-pipeline","label":[0,1,0,0]}
{"id":34349,"original_code":"public List<List<String>> rows() {\n    try {\n      List<List<String>> results = new ArrayList<>();\n      for (BaseWork baseWork : topSortedWork) {\n        String vertexName = baseWork.getName();\n        VertexProgress progress = progressCountsMap.get(vertexName);\n        if (progress != null) {\n          \/\/ Map 1 .......... container  SUCCEEDED      7          7        0        0       0       0\n          \/\/ TODO: can we pass custom things thru the progress?\n          results.add(\n            Arrays.asList(\n              getNameWithProgress(vertexName, progress.succeededTaskCount, progress.totalTaskCount),\n              getMode(baseWork),\n              progress.vertexStatus(vertexStatusMap.get(vertexName)),\n              progress.total(),\n              progress.completed(),\n              progress.running(),\n              progress.pending(),\n              progress.failed(),\n              progress.killed()\n            )\n          );\n        }\n      }\n      return results;\n    } catch (Exception e) {\n      console.printInfo(\n          \"Getting  Progress Bar table rows failed: \" + e.getMessage() + \" stack trace: \" + Arrays\n              .toString(e.getStackTrace())\n      );\n    }\n    return Collections.emptyList();\n  }","code_wo_comment":"public List<List<String>> rows() {\n    try {\n      List<List<String>> results = new ArrayList<>();\n      for (BaseWork baseWork : topSortedWork) {\n        String vertexName = baseWork.getName();\n        VertexProgress progress = progressCountsMap.get(vertexName);\n        if (progress != null) {\n         \n         \n          results.add(\n            Arrays.asList(\n              getNameWithProgress(vertexName, progress.succeededTaskCount, progress.totalTaskCount),\n              getMode(baseWork),\n              progress.vertexStatus(vertexStatusMap.get(vertexName)),\n              progress.total(),\n              progress.completed(),\n              progress.running(),\n              progress.pending(),\n              progress.failed(),\n              progress.killed()\n            )\n          );\n        }\n      }\n      return results;\n    } catch (Exception e) {\n      console.printInfo(\n          \"Getting  Progress Bar table rows failed: \" + e.getMessage() + \" stack trace: \" + Arrays\n              .toString(e.getStackTrace())\n      );\n    }\n    return Collections.emptyList();\n  }","cleancode":"public list<list<string>> rows() { try { list<list<string>> results = new arraylist<>(); for (basework basework : topsortedwork) { string vertexname = basework.getname(); vertexprogress progress = progresscountsmap.get(vertexname); if (progress != null) { results.add( arrays.aslist( getnamewithprogress(vertexname, progress.succeededtaskcount, progress.totaltaskcount), getmode(basework), progress.vertexstatus(vertexstatusmap.get(vertexname)), progress.total(), progress.completed(), progress.running(), progress.pending(), progress.failed(), progress.killed() ) ); } } return results; } catch (exception e) { console.printinfo( \"getting progress bar table rows failed: \" + e.getmessage() + \" stack trace: \" + arrays .tostring(e.getstacktrace()) ); } return collections.emptylist(); }","repo":"JSA-Insubria\/hive","label":[1,0,0,0]}
{"id":9779,"original_code":"Statement compileSQLProcedureStatementOrNull(Routine routine,\n            StatementCompound context) {\n        Statement cs    = null;\n        HsqlName  label = null;\n        RangeVariable[] rangeVariables = context == null\n                                         ? routine.getParameterRangeVariables()\n                                         : context.getRangeVariables();\n        if (!routine.isTrigger() && isSimpleName() && !isReservedKey()) {\n            label = readNewSchemaObjectName(SchemaObject.LABEL, false);\n            \/\/ todo - improved error message\n            if (token.tokenType != Tokens.COLON) {\n                throw unexpectedToken(label.getNameString());\n            }\n            readThis(Tokens.COLON);\n        }\n        compileContext.reset();\n        HsqlName oldSchema = session.getCurrentSchemaHsqlName();\n        session.setCurrentSchemaHsqlName(routine.getSchemaName());\n        try {\n            switch (token.tokenType) {\n                \/\/ data\n                case Tokens.OPEN : {\n                    if (routine.dataImpact == Routine.CONTAINS_SQL) {\n                        throw Error.error(ErrorCode.X_42602,\n                                          routine.getDataImpactString());\n                    }\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileOpenCursorStatement(context);\n                    break;\n                }\n                case Tokens.SELECT : {\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileSelectSingleRowStatement(rangeVariables);\n                    break;\n                }\n                \/\/ data change\n                case Tokens.INSERT :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileInsertStatement(rangeVariables);\n                    break;\n                case Tokens.UPDATE :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileUpdateStatement(rangeVariables);\n                    break;\n                case Tokens.DELETE :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileDeleteStatement(rangeVariables);\n                    break;\n                case Tokens.TRUNCATE :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileTruncateStatement();\n                    break;\n                case Tokens.MERGE :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileMergeStatement(rangeVariables);\n                    break;\n                case Tokens.SET :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    if (routine.isTrigger()) {\n                        if (routine.triggerOperation\n                                == StatementTypes.DELETE_WHERE) {\n                            cs = compileSetStatement(rangeVariables);\n                            break;\n                        }\n                        if (routine.triggerType != TriggerDef.BEFORE) {\n                            cs = compileSetStatement(rangeVariables);\n                            break;\n                        }\n                        int position = super.getPosition();\n                        try {\n                            cs = compileTriggerSetStatement(\n                                routine.triggerTable, rangeVariables);\n                        } catch (HsqlException e) {\n                            rewind(position);\n                            cs = compileSetStatement(rangeVariables);\n                        }\n                    } else {\n                        cs = compileSetStatement(rangeVariables);\n                    }\n                    break;\n                case Tokens.GET :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = this.compileGetStatement(rangeVariables);\n                    break;\n                \/\/ control\n                case Tokens.CALL : {\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileCallStatement(rangeVariables, true);\n                    Routine proc = ((StatementProcedure) cs).procedure;\n                    if (proc != null) {\n                        switch (routine.dataImpact) {\n                            case Routine.CONTAINS_SQL : {\n                                if (proc.dataImpact == Routine.READS_SQL\n                                        || proc.dataImpact\n                                           == Routine.MODIFIES_SQL) {\n                                    throw Error.error(\n                                        ErrorCode.X_42602,\n                                        routine.getDataImpactString());\n                                }\n                                break;\n                            }\n                            case Routine.READS_SQL : {\n                                if (proc.dataImpact == Routine.MODIFIES_SQL) {\n                                    throw Error.error(\n                                        ErrorCode.X_42602,\n                                        routine.getDataImpactString());\n                                }\n                                break;\n                            }\n                        }\n                    }\n                    break;\n                }\n                case Tokens.RETURN : {\n                    if (routine.isTrigger() || label != null) {\n                        throw unexpectedToken();\n                    }\n                    read();\n                    cs = compileReturnValue(routine, context);\n                    break;\n                }\n                case Tokens.BEGIN : {\n                    cs = compileCompoundStatement(routine, context, label);\n                    break;\n                }\n                case Tokens.WHILE : {\n                    if (routine.isTrigger()) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileWhile(routine, context, label);\n                    break;\n                }\n                case Tokens.REPEAT : {\n                    cs = compileRepeat(routine, context, label);\n                    break;\n                }\n                case Tokens.LOOP : {\n                    cs = compileLoop(routine, context, label);\n                    break;\n                }\n                case Tokens.FOR : {\n                    cs = compileFor(routine, context, label);\n                    break;\n                }\n                case Tokens.ITERATE : {\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileIterate();\n                    break;\n                }\n                case Tokens.LEAVE : {\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileLeave(routine, context);\n                    break;\n                }\n                case Tokens.IF : {\n                    cs = compileIf(routine, context);\n                    break;\n                }\n                case Tokens.CASE : {\n                    cs = compileCase(routine, context);\n                    break;\n                }\n                case Tokens.SIGNAL : {\n                    cs = compileSignal(routine, context, label);\n                    break;\n                }\n                case Tokens.RESIGNAL : {\n                    cs = compileResignal(routine, context, label);\n                    break;\n                }\n                default :\n                    return null;\n            }\n            cs.setRoot(routine);\n            cs.setParent(context);\n            return cs;\n        } finally {\n            session.setCurrentSchemaHsqlName(oldSchema);\n        }\n    }","code_wo_comment":"Statement compileSQLProcedureStatementOrNull(Routine routine,\n            StatementCompound context) {\n        Statement cs    = null;\n        HsqlName  label = null;\n        RangeVariable[] rangeVariables = context == null\n                                         ? routine.getParameterRangeVariables()\n                                         : context.getRangeVariables();\n        if (!routine.isTrigger() && isSimpleName() && !isReservedKey()) {\n            label = readNewSchemaObjectName(SchemaObject.LABEL, false);\n           \n            if (token.tokenType != Tokens.COLON) {\n                throw unexpectedToken(label.getNameString());\n            }\n            readThis(Tokens.COLON);\n        }\n        compileContext.reset();\n        HsqlName oldSchema = session.getCurrentSchemaHsqlName();\n        session.setCurrentSchemaHsqlName(routine.getSchemaName());\n        try {\n            switch (token.tokenType) {\n               \n                case Tokens.OPEN : {\n                    if (routine.dataImpact == Routine.CONTAINS_SQL) {\n                        throw Error.error(ErrorCode.X_42602,\n                                          routine.getDataImpactString());\n                    }\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileOpenCursorStatement(context);\n                    break;\n                }\n                case Tokens.SELECT : {\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileSelectSingleRowStatement(rangeVariables);\n                    break;\n                }\n               \n                case Tokens.INSERT :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileInsertStatement(rangeVariables);\n                    break;\n                case Tokens.UPDATE :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileUpdateStatement(rangeVariables);\n                    break;\n                case Tokens.DELETE :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileDeleteStatement(rangeVariables);\n                    break;\n                case Tokens.TRUNCATE :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileTruncateStatement();\n                    break;\n                case Tokens.MERGE :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileMergeStatement(rangeVariables);\n                    break;\n                case Tokens.SET :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    if (routine.isTrigger()) {\n                        if (routine.triggerOperation\n                                == StatementTypes.DELETE_WHERE) {\n                            cs = compileSetStatement(rangeVariables);\n                            break;\n                        }\n                        if (routine.triggerType != TriggerDef.BEFORE) {\n                            cs = compileSetStatement(rangeVariables);\n                            break;\n                        }\n                        int position = super.getPosition();\n                        try {\n                            cs = compileTriggerSetStatement(\n                                routine.triggerTable, rangeVariables);\n                        } catch (HsqlException e) {\n                            rewind(position);\n                            cs = compileSetStatement(rangeVariables);\n                        }\n                    } else {\n                        cs = compileSetStatement(rangeVariables);\n                    }\n                    break;\n                case Tokens.GET :\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = this.compileGetStatement(rangeVariables);\n                    break;\n               \n                case Tokens.CALL : {\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileCallStatement(rangeVariables, true);\n                    Routine proc = ((StatementProcedure) cs).procedure;\n                    if (proc != null) {\n                        switch (routine.dataImpact) {\n                            case Routine.CONTAINS_SQL : {\n                                if (proc.dataImpact == Routine.READS_SQL\n                                        || proc.dataImpact\n                                           == Routine.MODIFIES_SQL) {\n                                    throw Error.error(\n                                        ErrorCode.X_42602,\n                                        routine.getDataImpactString());\n                                }\n                                break;\n                            }\n                            case Routine.READS_SQL : {\n                                if (proc.dataImpact == Routine.MODIFIES_SQL) {\n                                    throw Error.error(\n                                        ErrorCode.X_42602,\n                                        routine.getDataImpactString());\n                                }\n                                break;\n                            }\n                        }\n                    }\n                    break;\n                }\n                case Tokens.RETURN : {\n                    if (routine.isTrigger() || label != null) {\n                        throw unexpectedToken();\n                    }\n                    read();\n                    cs = compileReturnValue(routine, context);\n                    break;\n                }\n                case Tokens.BEGIN : {\n                    cs = compileCompoundStatement(routine, context, label);\n                    break;\n                }\n                case Tokens.WHILE : {\n                    if (routine.isTrigger()) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileWhile(routine, context, label);\n                    break;\n                }\n                case Tokens.REPEAT : {\n                    cs = compileRepeat(routine, context, label);\n                    break;\n                }\n                case Tokens.LOOP : {\n                    cs = compileLoop(routine, context, label);\n                    break;\n                }\n                case Tokens.FOR : {\n                    cs = compileFor(routine, context, label);\n                    break;\n                }\n                case Tokens.ITERATE : {\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileIterate();\n                    break;\n                }\n                case Tokens.LEAVE : {\n                    if (label != null) {\n                        throw unexpectedToken();\n                    }\n                    cs = compileLeave(routine, context);\n                    break;\n                }\n                case Tokens.IF : {\n                    cs = compileIf(routine, context);\n                    break;\n                }\n                case Tokens.CASE : {\n                    cs = compileCase(routine, context);\n                    break;\n                }\n                case Tokens.SIGNAL : {\n                    cs = compileSignal(routine, context, label);\n                    break;\n                }\n                case Tokens.RESIGNAL : {\n                    cs = compileResignal(routine, context, label);\n                    break;\n                }\n                default :\n                    return null;\n            }\n            cs.setRoot(routine);\n            cs.setParent(context);\n            return cs;\n        } finally {\n            session.setCurrentSchemaHsqlName(oldSchema);\n        }\n    }","cleancode":"statement compilesqlprocedurestatementornull(routine routine, statementcompound context) { statement cs = null; hsqlname label = null; rangevariable[] rangevariables = context == null ? routine.getparameterrangevariables() : context.getrangevariables(); if (!routine.istrigger() && issimplename() && !isreservedkey()) { label = readnewschemaobjectname(schemaobject.label, false); if (token.tokentype != tokens.colon) { throw unexpectedtoken(label.getnamestring()); } readthis(tokens.colon); } compilecontext.reset(); hsqlname oldschema = session.getcurrentschemahsqlname(); session.setcurrentschemahsqlname(routine.getschemaname()); try { switch (token.tokentype) { case tokens.open : { if (routine.dataimpact == routine.contains_sql) { throw error.error(errorcode.x_42602, routine.getdataimpactstring()); } if (label != null) { throw unexpectedtoken(); } cs = compileopencursorstatement(context); break; } case tokens.select : { if (label != null) { throw unexpectedtoken(); } cs = compileselectsinglerowstatement(rangevariables); break; } case tokens.insert : if (label != null) { throw unexpectedtoken(); } cs = compileinsertstatement(rangevariables); break; case tokens.update : if (label != null) { throw unexpectedtoken(); } cs = compileupdatestatement(rangevariables); break; case tokens.delete : if (label != null) { throw unexpectedtoken(); } cs = compiledeletestatement(rangevariables); break; case tokens.truncate : if (label != null) { throw unexpectedtoken(); } cs = compiletruncatestatement(); break; case tokens.merge : if (label != null) { throw unexpectedtoken(); } cs = compilemergestatement(rangevariables); break; case tokens.set : if (label != null) { throw unexpectedtoken(); } if (routine.istrigger()) { if (routine.triggeroperation == statementtypes.delete_where) { cs = compilesetstatement(rangevariables); break; } if (routine.triggertype != triggerdef.before) { cs = compilesetstatement(rangevariables); break; } int position = super.getposition(); try { cs = compiletriggersetstatement( routine.triggertable, rangevariables); } catch (hsqlexception e) { rewind(position); cs = compilesetstatement(rangevariables); } } else { cs = compilesetstatement(rangevariables); } break; case tokens.get : if (label != null) { throw unexpectedtoken(); } cs = this.compilegetstatement(rangevariables); break; case tokens.call : { if (label != null) { throw unexpectedtoken(); } cs = compilecallstatement(rangevariables, true); routine proc = ((statementprocedure) cs).procedure; if (proc != null) { switch (routine.dataimpact) { case routine.contains_sql : { if (proc.dataimpact == routine.reads_sql || proc.dataimpact == routine.modifies_sql) { throw error.error( errorcode.x_42602, routine.getdataimpactstring()); } break; } case routine.reads_sql : { if (proc.dataimpact == routine.modifies_sql) { throw error.error( errorcode.x_42602, routine.getdataimpactstring()); } break; } } } break; } case tokens.return : { if (routine.istrigger() || label != null) { throw unexpectedtoken(); } read(); cs = compilereturnvalue(routine, context); break; } case tokens.begin : { cs = compilecompoundstatement(routine, context, label); break; } case tokens.while : { if (routine.istrigger()) { throw unexpectedtoken(); } cs = compilewhile(routine, context, label); break; } case tokens.repeat : { cs = compilerepeat(routine, context, label); break; } case tokens.loop : { cs = compileloop(routine, context, label); break; } case tokens.for : { cs = compilefor(routine, context, label); break; } case tokens.iterate : { if (label != null) { throw unexpectedtoken(); } cs = compileiterate(); break; } case tokens.leave : { if (label != null) { throw unexpectedtoken(); } cs = compileleave(routine, context); break; } case tokens.if : { cs = compileif(routine, context); break; } case tokens.case : { cs = compilecase(routine, context); break; } case tokens.signal : { cs = compilesignal(routine, context, label); break; } case tokens.resignal : { cs = compileresignal(routine, context, label); break; } default : return null; } cs.setroot(routine); cs.setparent(context); return cs; } finally { session.setcurrentschemahsqlname(oldschema); } }","repo":"RabadanLab\/Pegasus","label":[0,1,0,0]}
{"id":34400,"original_code":"public int pcToLine(int pc) {\n        \/*\n         * Line number entries don't have to appear in any particular\n         * order, so we have to do a linear search. TODO: If\n         * this turns out to be a bottleneck, consider sorting the\n         * list prior to use.\n         *\/\n        int sz = size();\n        int bestPc = -1;\n        int bestLine = -1;\n        for (int i = 0; i < sz; i++) {\n            Item one = get(i);\n            int onePc = one.getStartPc();\n            if ((onePc <= pc) && (onePc > bestPc)) {\n                bestPc = onePc;\n                bestLine = one.getLineNumber();\n                if (bestPc == pc) {\n                    \/\/ We can't do better than this\n                    break;\n                }\n            }\n        }\n        return bestLine;\n    }","code_wo_comment":"public int pcToLine(int pc) {\n       \n        int sz = size();\n        int bestPc = -1;\n        int bestLine = -1;\n        for (int i = 0; i < sz; i++) {\n            Item one = get(i);\n            int onePc = one.getStartPc();\n            if ((onePc <= pc) && (onePc > bestPc)) {\n                bestPc = onePc;\n                bestLine = one.getLineNumber();\n                if (bestPc == pc) {\n                   \n                    break;\n                }\n            }\n        }\n        return bestLine;\n    }","cleancode":"public int pctoline(int pc) { int sz = size(); int bestpc = -1; int bestline = -1; for (int i = 0; i < sz; i++) { item one = get(i); int onepc = one.getstartpc(); if ((onepc <= pc) && (onepc > bestpc)) { bestpc = onepc; bestline = one.getlinenumber(); if (bestpc == pc) { break; } } } return bestline; }","repo":"MaTriXy\/atlas","label":[1,0,0,0]}
{"id":9846,"original_code":"public void free()\n  {\n    currState = NO_STATE;\n    if (Sage.DBG) System.out.println(\"Closing down mplayer\");\n    if (uiMgr != null)\n      uiMgr.putFloat(\"mplayer\/last_volume\", currVolume);\n    timeGuessMillis = 0;\n    guessTimestamp = 0;\n    currVolume = 1.0f;\n    if (mpStdin != null && isMPlayerRunning())\n    {\n      \/\/ Be sure to clear the active file bit in case MPlayer is waiting for more data\n      \/\/ Be sure we don't close the stdin connection before we send the quit message, but don't\n      \/\/ hang waiting for the quit to be processed\n      \/\/\t\t\tinactiveFile();\n      \/\/\t\t\tstop();\n      Thread t = new Thread(\"PlayerSendCmd\")\n      {\n        public void run()\n        {\n          if (Sage.DBG) System.out.println(\"Waiting for the cmd queue to clear...\");\n          synchronized (sendCmdQueue)\n          {\n            while (!sendCmdQueue.isEmpty())\n            {\n              try\n              {\n                sendCmdQueue.wait(50);\n              }\n              catch (InterruptedException e){}\n              continue;\n            }\n          }\n          if (Sage.DBG) System.out.println(\"Sending mplayer command: quit\");\n          if (!fileDeactivated)\n          {\n            fileDeactivated = true;\n            synchronized (mpStdin)\n            {\n              mpStdin.println(\"inactive_file\");\n            }\n          }\n          if (currState == PLAY_STATE && !eos)\n          {\n            synchronized (mpStdin)\n            {\n              mpStdin.println(\"pause\");\n            }\n            currState = STOPPED_STATE;\n          }\n          else\n            currState = STOPPED_STATE;\n          synchronized (mpStdin)\n          {\n            mpStdin.println(\"quit\");\n          }\n          mpStdin.close();\n          mpStdin = null;\n          if (mpStdout != null)\n          {\n            try { mpStdout.close(); } catch (java.io.IOException e) {}\n            mpStdout = null;\n          }\n          if (mpStderr != null)\n          {\n            try { mpStderr.close(); } catch (java.io.IOException e) {}\n            mpStderr = null;\n          }\n        }\n      };\n      t.setPriority(Thread.currentThread().getPriority());\n      t.setDaemon(true);\n      t.start();\n    }\n    if (mpProc != null)\n    {\n      long startWait = Sage.eventTime();\n      \/\/ FIXME: temp crutch, in testing on Mac OS X mplayer either terminates immediately or hangs, there is no in-between...\n      long killDelay = (Sage.MAC_OS_X ? 2000 : 15000);\n      while (true)\n      {\n        try\n        {\n          int exitValue = mpProc.exitValue();\n          if (Sage.DBG) System.out.println(\"MPlayer process exit code:\" + exitValue);\n          break;\n        }\n        catch (IllegalThreadStateException e)\n        {\n          if (Sage.DBG) System.out.println(\"MPlayer process has not exited yet...\");\n          try{Thread.sleep(100);}catch(Exception e1){}\n          if (Sage.eventTime() - startWait > killDelay)\n          {\n            if (Sage.DBG) System.out.println(\"Forcibly killing MPlayer process!\");\n            mpProc.destroy();\n            break;\n          }\n        }\n      }\n      mpProc = null;\n    }\n    if (launchedAsyncRenderThread)\n      ((DirectX9SageRenderer)uiMgr.getRootPanel().getRenderEngine()).asyncVideoRender(null);\n    if (releaseServerAccessVobSubBase != null)\n    {\n      NetworkClient.getSN().requestMediaServerAccess(new java.io.File(releaseServerAccessVobSubBase + \".idx\"), false);\n      NetworkClient.getSN().requestMediaServerAccess(new java.io.File(releaseServerAccessVobSubBase + \".sub\"), false);\n      releaseServerAccessVobSubBase = null;\n    }\n  }","code_wo_comment":"public void free()\n  {\n    currState = NO_STATE;\n    if (Sage.DBG) System.out.println(\"Closing down mplayer\");\n    if (uiMgr != null)\n      uiMgr.putFloat(\"mplayer\/last_volume\", currVolume);\n    timeGuessMillis = 0;\n    guessTimestamp = 0;\n    currVolume = 1.0f;\n    if (mpStdin != null && isMPlayerRunning())\n    {\n     \n     \n     \n     \n     \n      Thread t = new Thread(\"PlayerSendCmd\")\n      {\n        public void run()\n        {\n          if (Sage.DBG) System.out.println(\"Waiting for the cmd queue to clear...\");\n          synchronized (sendCmdQueue)\n          {\n            while (!sendCmdQueue.isEmpty())\n            {\n              try\n              {\n                sendCmdQueue.wait(50);\n              }\n              catch (InterruptedException e){}\n              continue;\n            }\n          }\n          if (Sage.DBG) System.out.println(\"Sending mplayer command: quit\");\n          if (!fileDeactivated)\n          {\n            fileDeactivated = true;\n            synchronized (mpStdin)\n            {\n              mpStdin.println(\"inactive_file\");\n            }\n          }\n          if (currState == PLAY_STATE && !eos)\n          {\n            synchronized (mpStdin)\n            {\n              mpStdin.println(\"pause\");\n            }\n            currState = STOPPED_STATE;\n          }\n          else\n            currState = STOPPED_STATE;\n          synchronized (mpStdin)\n          {\n            mpStdin.println(\"quit\");\n          }\n          mpStdin.close();\n          mpStdin = null;\n          if (mpStdout != null)\n          {\n            try { mpStdout.close(); } catch (java.io.IOException e) {}\n            mpStdout = null;\n          }\n          if (mpStderr != null)\n          {\n            try { mpStderr.close(); } catch (java.io.IOException e) {}\n            mpStderr = null;\n          }\n        }\n      };\n      t.setPriority(Thread.currentThread().getPriority());\n      t.setDaemon(true);\n      t.start();\n    }\n    if (mpProc != null)\n    {\n      long startWait = Sage.eventTime();\n     \n      long killDelay = (Sage.MAC_OS_X ? 2000 : 15000);\n      while (true)\n      {\n        try\n        {\n          int exitValue = mpProc.exitValue();\n          if (Sage.DBG) System.out.println(\"MPlayer process exit code:\" + exitValue);\n          break;\n        }\n        catch (IllegalThreadStateException e)\n        {\n          if (Sage.DBG) System.out.println(\"MPlayer process has not exited yet...\");\n          try{Thread.sleep(100);}catch(Exception e1){}\n          if (Sage.eventTime() - startWait > killDelay)\n          {\n            if (Sage.DBG) System.out.println(\"Forcibly killing MPlayer process!\");\n            mpProc.destroy();\n            break;\n          }\n        }\n      }\n      mpProc = null;\n    }\n    if (launchedAsyncRenderThread)\n      ((DirectX9SageRenderer)uiMgr.getRootPanel().getRenderEngine()).asyncVideoRender(null);\n    if (releaseServerAccessVobSubBase != null)\n    {\n      NetworkClient.getSN().requestMediaServerAccess(new java.io.File(releaseServerAccessVobSubBase + \".idx\"), false);\n      NetworkClient.getSN().requestMediaServerAccess(new java.io.File(releaseServerAccessVobSubBase + \".sub\"), false);\n      releaseServerAccessVobSubBase = null;\n    }\n  }","cleancode":"public void free() { currstate = no_state; if (sage.dbg) system.out.println(\"closing down mplayer\"); if (uimgr != null) uimgr.putfloat(\"mplayer\/last_volume\", currvolume); timeguessmillis = 0; guesstimestamp = 0; currvolume = 1.0f; if (mpstdin != null && ismplayerrunning()) { thread t = new thread(\"playersendcmd\") { public void run() { if (sage.dbg) system.out.println(\"waiting for the cmd queue to clear...\"); synchronized (sendcmdqueue) { while (!sendcmdqueue.isempty()) { try { sendcmdqueue.wait(50); } catch (interruptedexception e){} continue; } } if (sage.dbg) system.out.println(\"sending mplayer command: quit\"); if (!filedeactivated) { filedeactivated = true; synchronized (mpstdin) { mpstdin.println(\"inactive_file\"); } } if (currstate == play_state && !eos) { synchronized (mpstdin) { mpstdin.println(\"pause\"); } currstate = stopped_state; } else currstate = stopped_state; synchronized (mpstdin) { mpstdin.println(\"quit\"); } mpstdin.close(); mpstdin = null; if (mpstdout != null) { try { mpstdout.close(); } catch (java.io.ioexception e) {} mpstdout = null; } if (mpstderr != null) { try { mpstderr.close(); } catch (java.io.ioexception e) {} mpstderr = null; } } }; t.setpriority(thread.currentthread().getpriority()); t.setdaemon(true); t.start(); } if (mpproc != null) { long startwait = sage.eventtime(); long killdelay = (sage.mac_os_x ? 2000 : 15000); while (true) { try { int exitvalue = mpproc.exitvalue(); if (sage.dbg) system.out.println(\"mplayer process exit code:\" + exitvalue); break; } catch (illegalthreadstateexception e) { if (sage.dbg) system.out.println(\"mplayer process has not exited yet...\"); try{thread.sleep(100);}catch(exception e1){} if (sage.eventtime() - startwait > killdelay) { if (sage.dbg) system.out.println(\"forcibly killing mplayer process!\"); mpproc.destroy(); break; } } } mpproc = null; } if (launchedasyncrenderthread) ((directx9sagerenderer)uimgr.getrootpanel().getrenderengine()).asyncvideorender(null); if (releaseserveraccessvobsubbase != null) { networkclient.getsn().requestmediaserveraccess(new java.io.file(releaseserveraccessvobsubbase + \".idx\"), false); networkclient.getsn().requestmediaserveraccess(new java.io.file(releaseserveraccessvobsubbase + \".sub\"), false); releaseserveraccessvobsubbase = null; } }","repo":"Narflex\/sagetv","label":[0,0,1,0]}
{"id":26236,"original_code":"@Test\n    public void testNullValueDisallowed() throws Exception {\n        {\n            String str = \"{ \\\"id\\\": 123, \\\"petId\\\": 345, \\\"quantity\\\": 100, \\\"status\\\": \\\"placed\\\" }\";\n            org.openapitools.client.model.Order o = json.getContext(null).readValue(str, org.openapitools.client.model.Order.class);\n            assertEquals(100L, (long)o.getQuantity());\n            assertEquals(org.openapitools.client.model.Order.StatusEnum.PLACED, o.getStatus());\n        }\n        {\n            String str = \"{ \\\"id\\\": 123, \\\"petId\\\": 345, \\\"quantity\\\": null }\";\n            org.openapitools.client.model.Order o = json.getContext(null).readValue(str, org.openapitools.client.model.Order.class);\n            \/\/ TODO: the null value is not allowed per OAS document.\n            \/\/ The deserialization should fail.\n            assertNull(o.getQuantity());\n        }\n    }","code_wo_comment":"@Test\n    public void testNullValueDisallowed() throws Exception {\n        {\n            String str = \"{ \\\"id\\\": 123, \\\"petId\\\": 345, \\\"quantity\\\": 100, \\\"status\\\": \\\"placed\\\" }\";\n            org.openapitools.client.model.Order o = json.getContext(null).readValue(str, org.openapitools.client.model.Order.class);\n            assertEquals(100L, (long)o.getQuantity());\n            assertEquals(org.openapitools.client.model.Order.StatusEnum.PLACED, o.getStatus());\n        }\n        {\n            String str = \"{ \\\"id\\\": 123, \\\"petId\\\": 345, \\\"quantity\\\": null }\";\n            org.openapitools.client.model.Order o = json.getContext(null).readValue(str, org.openapitools.client.model.Order.class);\n           \n           \n            assertNull(o.getQuantity());\n        }\n    }","cleancode":"@test public void testnullvaluedisallowed() throws exception { { string str = \"{ \\\"id\\\": 123, \\\"petid\\\": 345, \\\"quantity\\\": 100, \\\"status\\\": \\\"placed\\\" }\"; org.openapitools.client.model.order o = json.getcontext(null).readvalue(str, org.openapitools.client.model.order.class); assertequals(100l, (long)o.getquantity()); assertequals(org.openapitools.client.model.order.statusenum.placed, o.getstatus()); } { string str = \"{ \\\"id\\\": 123, \\\"petid\\\": 345, \\\"quantity\\\": null }\"; org.openapitools.client.model.order o = json.getcontext(null).readvalue(str, org.openapitools.client.model.order.class); assertnull(o.getquantity()); } }","repo":"IonBazan\/openapi-generator","label":[0,0,1,0]}
{"id":9930,"original_code":"public static String getUserDocumentsPath() {\n        if (m_documents == null) {\n            \/\/TODO: Should I look at the OneDrive entry first?\n            \/\/      The OneDrive key from the web is different from mine.\n            m_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\", \"Personal\");\n            if (m_documents == null) {\n                m_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\User Shell Folders\", \"Personal\");\n                if (m_documents == null) {\n                    Server.logger().log(Level.SEVERE, \"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\n                    System.out.println(\"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\n                    \/\/if we cannot get this, we have to exit because we don't know where to store our data.\n                    System.exit(1);\n                }\n            }\n            if (m_documents.contains(\"%USERPROFILE%\")) {\n                m_documents = m_documents.replace(\"%USERPROFILE%\", System.getenv(\"USERPROFILE\"));\n            }\n        }\n        return m_documents;\n    }","code_wo_comment":"public static String getUserDocumentsPath() {\n        if (m_documents == null) {\n           \n           \n            m_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\", \"Personal\");\n            if (m_documents == null) {\n                m_documents = Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\User Shell Folders\", \"Personal\");\n                if (m_documents == null) {\n                    Server.logger().log(Level.SEVERE, \"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\n                    System.out.println(\"Advapi32Util.registryGetStringValue(HKEY_CURRENT_USER, \\\"Software\\\\\\\\Microsoft\\\\\\\\Windows\\\\\\\\CurrentVersion\\\\\\\\Explorer\\\\\\\\User Shell Folders\\\", \\\"Personal\\\") returned NULL\");\n                   \n                    System.exit(1);\n                }\n            }\n            if (m_documents.contains(\"%USERPROFILE%\")) {\n                m_documents = m_documents.replace(\"%USERPROFILE%\", System.getenv(\"USERPROFILE\"));\n            }\n        }\n        return m_documents;\n    }","cleancode":"public static string getuserdocumentspath() { if (m_documents == null) { m_documents = advapi32util.registrygetstringvalue(hkey_current_user, \"software\\\\microsoft\\\\windows\\\\currentversion\\\\explorer\\\\shell folders\", \"personal\"); if (m_documents == null) { m_documents = advapi32util.registrygetstringvalue(hkey_current_user, \"software\\\\microsoft\\\\windows\\\\currentversion\\\\explorer\\\\user shell folders\", \"personal\"); if (m_documents == null) { server.logger().log(level.severe, \"advapi32util.registrygetstringvalue(hkey_current_user, \\\"software\\\\\\\\microsoft\\\\\\\\windows\\\\\\\\currentversion\\\\\\\\explorer\\\\\\\\user shell folders\\\", \\\"personal\\\") returned null\"); system.out.println(\"advapi32util.registrygetstringvalue(hkey_current_user, \\\"software\\\\\\\\microsoft\\\\\\\\windows\\\\\\\\currentversion\\\\\\\\explorer\\\\\\\\user shell folders\\\", \\\"personal\\\") returned null\"); system.exit(1); } } if (m_documents.contains(\"%userprofile%\")) { m_documents = m_documents.replace(\"%userprofile%\", system.getenv(\"userprofile\")); } } return m_documents; }","repo":"SIMRacingApps\/SIMRacingAppsServer","label":[1,0,0,0]}
{"id":34529,"original_code":"public void testWrongName() {\n        try {\n            construct(\"--- !!org.yaml.snakeyaml.constructor.TestBean\\nwrongName: No one\\nage: 24\\nborn: 1982-05-03\\n\");\n            fail(\"IntrospectionException expected.\");\n        } catch (Exception e) {\n            \/\/ TODO improve the error message - the pointer should be at the\n            \/\/ property name, not value\n            assertEquals(\n                    \"Cannot create property=wrongName for JavaBean=#<org.jvyaml.TestBean name=\\\"null\\\" age=0 born=\\\"null\\\">\\n\" +\n                            \" in 'string', line 1, column 5:\\n\" +\n                            \"    --- !!org.yaml.snakeyaml.constructor ... \\n\" +\n                            \"        ^\\n\" +\n                            \"Unable to find property 'wrongName' on class: org.yaml.snakeyaml.constructor.TestBean\\n\" +\n                            \" in 'string', line 2, column 12:\\n\" +\n                            \"    wrongName: No one\\n\" +\n                            \"               ^\\n\",\n                    e.getMessage());\n        }\n    }","code_wo_comment":"public void testWrongName() {\n        try {\n            construct(\"--- !!org.yaml.snakeyaml.constructor.TestBean\\nwrongName: No one\\nage: 24\\nborn: 1982-05-03\\n\");\n            fail(\"IntrospectionException expected.\");\n        } catch (Exception e) {\n           \n           \n            assertEquals(\n                    \"Cannot create property=wrongName for JavaBean=#<org.jvyaml.TestBean name=\\\"null\\\" age=0 born=\\\"null\\\">\\n\" +\n                            \" in 'string', line 1, column 5:\\n\" +\n                            \"    --- !!org.yaml.snakeyaml.constructor ... \\n\" +\n                            \"        ^\\n\" +\n                            \"Unable to find property 'wrongName' on class: org.yaml.snakeyaml.constructor.TestBean\\n\" +\n                            \" in 'string', line 2, column 12:\\n\" +\n                            \"    wrongName: No one\\n\" +\n                            \"               ^\\n\",\n                    e.getMessage());\n        }\n    }","cleancode":"public void testwrongname() { try { construct(\"--- !!org.yaml.snakeyaml.constructor.testbean\\nwrongname: no one\\nage: 24\\nborn: 1982-05-03\\n\"); fail(\"introspectionexception expected.\"); } catch (exception e) { assertequals( \"cannot create property=wrongname for javabean=#<org.jvyaml.testbean name=\\\"null\\\" age=0 born=\\\"null\\\">\\n\" + \" in 'string', line 1, column 5:\\n\" + \" --- !!org.yaml.snakeyaml.constructor ... \\n\" + \" ^\\n\" + \"unable to find property 'wrongname' on class: org.yaml.snakeyaml.constructor.testbean\\n\" + \" in 'string', line 2, column 12:\\n\" + \" wrongname: no one\\n\" + \" ^\\n\", e.getmessage()); } }","repo":"PRECISE\/ROSLab","label":[1,0,0,0]}
{"id":1770,"original_code":"@Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Request request = (Request) o;\n            if (objectID != request.objectID) return false;\n            if (methodIdentifier != null ? !methodIdentifier.equals(request.methodIdentifier) : request.methodIdentifier != null)\n                return false;\n            \/\/ Probably incorrect - comparing Object[] arrays with Arrays.equals\n            return Arrays.equals(args, request.args);\n        }","code_wo_comment":"@Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Request request = (Request) o;\n            if (objectID != request.objectID) return false;\n            if (methodIdentifier != null ? !methodIdentifier.equals(request.methodIdentifier) : request.methodIdentifier != null)\n                return false;\n           \n            return Arrays.equals(args, request.args);\n        }","cleancode":"@override public boolean equals(object o) { if (this == o) return true; if (o == null || getclass() != o.getclass()) return false; request request = (request) o; if (objectid != request.objectid) return false; if (methodidentifier != null ? !methodidentifier.equals(request.methodidentifier) : request.methodidentifier != null) return false; return arrays.equals(args, request.args); }","repo":"MatzeS\/blackbird_java","label":[0,0,1,0]}
{"id":34690,"original_code":"@Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,\n                                        Authentication authentication) throws ServletException, IOException {\n        log.debug(\"Authentication success\");\n        \/\/ TODO: Optimize\n        Map<String, Object> result = new HashMap<>(1);\n        result.put(\"redirect\", sitProperties.redirect());\n        JSONWriter.write(response, HttpStatus.OK, Result.ok(result));\n    }","code_wo_comment":"@Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,\n                                        Authentication authentication) throws ServletException, IOException {\n        log.debug(\"Authentication success\");\n       \n        Map<String, Object> result = new HashMap<>(1);\n        result.put(\"redirect\", sitProperties.redirect());\n        JSONWriter.write(response, HttpStatus.OK, Result.ok(result));\n    }","cleancode":"@override public void onauthenticationsuccess(httpservletrequest request, httpservletresponse response, authentication authentication) throws servletexception, ioexception { log.debug(\"authentication success\"); map<string, object> result = new hashmap<>(1); result.put(\"redirect\", sitproperties.redirect()); jsonwriter.write(response, httpstatus.ok, result.ok(result)); }","repo":"O70\/spring-laboratory","label":[1,0,0,0]}
{"id":18316,"original_code":"private Set<String> findUris(Graph graph) {\n        Set<String> result = new HashSet<>();\n        for (Triple t : graph.iterate()) {\n            try {\n                String object = t.getObject().toString().replace(\"<\", \"\").replace(\">\", \"\");\n                \/\/ check for valid uri\n                new URL(object).toURI();\n                result.add(object);\n            } catch (MalformedURLException e) {\n                e.printStackTrace();\n            } catch (URISyntaxException e) {\n                e.printStackTrace();\n            }\n        }\n        return result;\n    }","code_wo_comment":"private Set<String> findUris(Graph graph) {\n        Set<String> result = new HashSet<>();\n        for (Triple t : graph.iterate()) {\n            try {\n                String object = t.getObject().toString().replace(\"<\", \"\").replace(\">\", \"\");\n               \n                new URL(object).toURI();\n                result.add(object);\n            } catch (MalformedURLException e) {\n                e.printStackTrace();\n            } catch (URISyntaxException e) {\n                e.printStackTrace();\n            }\n        }\n        return result;\n    }","cleancode":"private set<string> finduris(graph graph) { set<string> result = new hashset<>(); for (triple t : graph.iterate()) { try { string object = t.getobject().tostring().replace(\"<\", \"\").replace(\">\", \"\"); new url(object).touri(); result.add(object); } catch (malformedurlexception e) { e.printstacktrace(); } catch (urisyntaxexception e) { e.printstacktrace(); } } return result; }","repo":"Interactions-HSG\/wot-search","label":[1,0,0,0]}
{"id":10287,"original_code":"@Override\n    public PipelineData execute(ActionExpressionType expression, PipelineData input, ExecutionContext context, OperationResult globalResult) throws ScriptExecutionException {\n        boolean rebind = expressionHelper.getArgumentAsBoolean(expression.getParameter(), PARAM_REBIND_RESOURCES, input, context, false, PARAM_REBIND_RESOURCES, globalResult);\n        PipelineData output = PipelineData.createEmpty();\n        for (PipelineItem item: input.getData()) {\n            PrismValue value = item.getValue();\n            OperationResult result = operationsHelper.createActionResult(item, this, context, globalResult);\n            context.checkTaskStop();\n            if (value instanceof PrismObjectValue && ((PrismObjectValue) value).asObjectable() instanceof ConnectorHostType) {\n                PrismObject<ConnectorHostType> connectorHostTypePrismObject = ((PrismObjectValue) value).asPrismObject();\n                Set<ConnectorType> newConnectors;\n                long started = operationsHelper.recordStart(context, connectorHostTypePrismObject.asObjectable());\n                Throwable exception = null;\n                try {\n\t\t\t\t\tnewConnectors = modelService.discoverConnectors(connectorHostTypePrismObject.asObjectable(), context.getTask(), result);\n                    operationsHelper.recordEnd(context, connectorHostTypePrismObject.asObjectable(), started, null);\n                } catch (CommunicationException | SecurityViolationException | SchemaException | ConfigurationException | ObjectNotFoundException | RuntimeException e) {\n                    operationsHelper.recordEnd(context, connectorHostTypePrismObject.asObjectable(), started, e);\n\t\t\t\t\texception = processActionException(e, NAME, value, context);\n\t\t\t\t\tnewConnectors = Collections.emptySet();\n\t\t\t\t}\n                context.println((exception != null ? \"Attempted to discover \" : \"Discovered \" + newConnectors.size())\n\t\t\t\t\t\t+ \" new connector(s) from \" + connectorHostTypePrismObject + exceptionSuffix(exception));\n                for (ConnectorType connectorType : newConnectors) {\n                    output.addValue(connectorType.asPrismObject().getValue(), item.getResult());\n                }\n                try {\n\t\t\t\t\tif (rebind) {\n\t\t\t\t\t\trebindConnectors(newConnectors, context, result);\n\t\t\t\t\t}\n\t\t\t\t} catch (ScriptExecutionException e) {\n\t\t\t\t\t\/\/noinspection ThrowableNotThrown\n\t\t\t\t\tprocessActionException(e, NAME, value, context);\t\t\/\/ TODO better message\n\t\t\t\t}\n            } else {\n\t\t\t\t\/\/noinspection ThrowableNotThrown\n\t\t\t\tprocessActionException(new ScriptExecutionException(\"Input item is not a PrismObject<ConnectorHost>\"), NAME, value, context);\n            }\n            operationsHelper.trimAndCloneResult(result, globalResult, context);\n        }\n        return output;      \/\/ TODO configurable output (either connector hosts or discovered connectors)\n    }","code_wo_comment":"@Override\n    public PipelineData execute(ActionExpressionType expression, PipelineData input, ExecutionContext context, OperationResult globalResult) throws ScriptExecutionException {\n        boolean rebind = expressionHelper.getArgumentAsBoolean(expression.getParameter(), PARAM_REBIND_RESOURCES, input, context, false, PARAM_REBIND_RESOURCES, globalResult);\n        PipelineData output = PipelineData.createEmpty();\n        for (PipelineItem item: input.getData()) {\n            PrismValue value = item.getValue();\n            OperationResult result = operationsHelper.createActionResult(item, this, context, globalResult);\n            context.checkTaskStop();\n            if (value instanceof PrismObjectValue && ((PrismObjectValue) value).asObjectable() instanceof ConnectorHostType) {\n                PrismObject<ConnectorHostType> connectorHostTypePrismObject = ((PrismObjectValue) value).asPrismObject();\n                Set<ConnectorType> newConnectors;\n                long started = operationsHelper.recordStart(context, connectorHostTypePrismObject.asObjectable());\n                Throwable exception = null;\n                try {\n\t\t\t\t\tnewConnectors = modelService.discoverConnectors(connectorHostTypePrismObject.asObjectable(), context.getTask(), result);\n                    operationsHelper.recordEnd(context, connectorHostTypePrismObject.asObjectable(), started, null);\n                } catch (CommunicationException | SecurityViolationException | SchemaException | ConfigurationException | ObjectNotFoundException | RuntimeException e) {\n                    operationsHelper.recordEnd(context, connectorHostTypePrismObject.asObjectable(), started, e);\n\t\t\t\t\texception = processActionException(e, NAME, value, context);\n\t\t\t\t\tnewConnectors = Collections.emptySet();\n\t\t\t\t}\n                context.println((exception != null ? \"Attempted to discover \" : \"Discovered \" + newConnectors.size())\n\t\t\t\t\t\t+ \" new connector(s) from \" + connectorHostTypePrismObject + exceptionSuffix(exception));\n                for (ConnectorType connectorType : newConnectors) {\n                    output.addValue(connectorType.asPrismObject().getValue(), item.getResult());\n                }\n                try {\n\t\t\t\t\tif (rebind) {\n\t\t\t\t\t\trebindConnectors(newConnectors, context, result);\n\t\t\t\t\t}\n\t\t\t\t} catch (ScriptExecutionException e) {\n\t\t\t\t\n\t\t\t\t\tprocessActionException(e, NAME, value, context);\t\n\t\t\t\t}\n            } else {\n\t\t\t\n\t\t\t\tprocessActionException(new ScriptExecutionException(\"Input item is not a PrismObject<ConnectorHost>\"), NAME, value, context);\n            }\n            operationsHelper.trimAndCloneResult(result, globalResult, context);\n        }\n        return output;     \n    }","cleancode":"@override public pipelinedata execute(actionexpressiontype expression, pipelinedata input, executioncontext context, operationresult globalresult) throws scriptexecutionexception { boolean rebind = expressionhelper.getargumentasboolean(expression.getparameter(), param_rebind_resources, input, context, false, param_rebind_resources, globalresult); pipelinedata output = pipelinedata.createempty(); for (pipelineitem item: input.getdata()) { prismvalue value = item.getvalue(); operationresult result = operationshelper.createactionresult(item, this, context, globalresult); context.checktaskstop(); if (value instanceof prismobjectvalue && ((prismobjectvalue) value).asobjectable() instanceof connectorhosttype) { prismobject<connectorhosttype> connectorhosttypeprismobject = ((prismobjectvalue) value).asprismobject(); set<connectortype> newconnectors; long started = operationshelper.recordstart(context, connectorhosttypeprismobject.asobjectable()); throwable exception = null; try { newconnectors = modelservice.discoverconnectors(connectorhosttypeprismobject.asobjectable(), context.gettask(), result); operationshelper.recordend(context, connectorhosttypeprismobject.asobjectable(), started, null); } catch (communicationexception | securityviolationexception | schemaexception | configurationexception | objectnotfoundexception | runtimeexception e) { operationshelper.recordend(context, connectorhosttypeprismobject.asobjectable(), started, e); exception = processactionexception(e, name, value, context); newconnectors = collections.emptyset(); } context.println((exception != null ? \"attempted to discover \" : \"discovered \" + newconnectors.size()) + \" new connector(s) from \" + connectorhosttypeprismobject + exceptionsuffix(exception)); for (connectortype connectortype : newconnectors) { output.addvalue(connectortype.asprismobject().getvalue(), item.getresult()); } try { if (rebind) { rebindconnectors(newconnectors, context, result); } } catch (scriptexecutionexception e) { processactionexception(e, name, value, context); } } else { processactionexception(new scriptexecutionexception(\"input item is not a prismobject<connectorhost>\"), name, value, context); } operationshelper.trimandcloneresult(result, globalresult, context); } return output; }","repo":"Neovision-xin\/dev","label":[1,0,0,0]}
{"id":34916,"original_code":"private boolean analyzeLastLine(\n      PageAnalysis analysis, PageElementTag tag,\n      Collection<CheckErrorResult> errors) {\n    \/\/ TODO: Refactor\n    \/\/ Check type of tag\n    if (!HtmlTagType.CENTER.equals(tag.getType()) &&\n        !HtmlTagType.SMALL.equals(tag.getType())) {\n      return false;\n    }\n    \/\/ Check namespace\n    Integer namespace = analysis.getPage().getNamespace();\n    if ((namespace == null) || (namespace.intValue() == Namespace.TEMPLATE)) {\n      return false;\n    }\n    \/\/ Go to the end of the last line\n    String contents = analysis.getContents();\n    int index = contents.length();\n    while ((index > 0) && (contents.charAt(index - 1) == '\\n')) {\n      index--;\n    }\n    while ((index > 0) && (contents.charAt(index - 1) == ' ')) {\n      index--;\n    }\n    if (index == 0) {\n      return false;\n    }\n    \/\/ Check if there's a tag at the end of the last line\n    int lastIndex = index;\n    PageElementTag lastTag = null;\n    if (contents.charAt(index - 1) == '>') {\n      lastTag = analysis.isInTag(index - 1);\n      if (lastTag != null) {\n        index = lastTag.getBeginIndex();\n      }\n    }\n    \/\/ Check if the tag is in the last line\n    int tagEndIndex = tag.getEndIndex();\n    while ((index > tagEndIndex) && (contents.charAt(index - 1) != '\\n')) {\n      index--;\n      if (contents.charAt(index) == '>') {\n        if (analysis.isInTag(index - 1, tag.getType()) != null) {\n          return false;\n        }\n      }\n    }\n    if (index > tagEndIndex) {\n      return false;\n    }\n    \/\/ Check if there's an other opening tag before in the page\n    List<PageElementTag> tags = analysis.getTags(tag.getType());\n    boolean after = false;\n    boolean hasOtherTagBefore = false;\n    for (PageElementTag otherTag : tags) {\n      if (!after) {\n        if (otherTag == tag) {\n          after = true;\n        } else if (!otherTag.isComplete()) {\n          hasOtherTagBefore = true;\n        }\n      }\n    }\n    \/\/ Decide what to do\n    if (lastTag == tag) {\n      CheckErrorResult errorResult = createCheckErrorResult(analysis, tag.getBeginIndex(), tag.getEndIndex());\n      errorResult.addReplacement(\"\");\n      if (hasOtherTagBefore && (tag.getParametersCount() == 0)) {\n        errorResult.addReplacement(\n            TagBuilder.from(tag.getName(), TagFormat.CLOSE).toString());\n      }\n      errors.add(errorResult);\n      return true;\n    }\n    if (lastTag != null) {\n      CheckErrorResult errorResult = analyzeArea(\n          analysis, tag, lastTag.getBeginIndex(), tag.getEndIndex(),\n          !hasOtherTagBefore, ActionAlone.ALONE_NOTHING); \n      if (errorResult != null) {\n        errors.add(errorResult);\n        return true;\n      }\n    } else {\n      CheckErrorResult errorResult = analyzeArea(\n          analysis, tag, tag.getBeginIndex(), lastIndex,\n          !hasOtherTagBefore, ActionAlone.ALONE_NOTHING); \n      if (errorResult != null) {\n        errors.add(errorResult);\n        return true;\n      }\n    }\n    return false;\n  }","code_wo_comment":"private boolean analyzeLastLine(\n      PageAnalysis analysis, PageElementTag tag,\n      Collection<CheckErrorResult> errors) {\n   \n   \n    if (!HtmlTagType.CENTER.equals(tag.getType()) &&\n        !HtmlTagType.SMALL.equals(tag.getType())) {\n      return false;\n    }\n   \n    Integer namespace = analysis.getPage().getNamespace();\n    if ((namespace == null) || (namespace.intValue() == Namespace.TEMPLATE)) {\n      return false;\n    }\n   \n    String contents = analysis.getContents();\n    int index = contents.length();\n    while ((index > 0) && (contents.charAt(index - 1) == '\\n')) {\n      index--;\n    }\n    while ((index > 0) && (contents.charAt(index - 1) == ' ')) {\n      index--;\n    }\n    if (index == 0) {\n      return false;\n    }\n   \n    int lastIndex = index;\n    PageElementTag lastTag = null;\n    if (contents.charAt(index - 1) == '>') {\n      lastTag = analysis.isInTag(index - 1);\n      if (lastTag != null) {\n        index = lastTag.getBeginIndex();\n      }\n    }\n   \n    int tagEndIndex = tag.getEndIndex();\n    while ((index > tagEndIndex) && (contents.charAt(index - 1) != '\\n')) {\n      index--;\n      if (contents.charAt(index) == '>') {\n        if (analysis.isInTag(index - 1, tag.getType()) != null) {\n          return false;\n        }\n      }\n    }\n    if (index > tagEndIndex) {\n      return false;\n    }\n   \n    List<PageElementTag> tags = analysis.getTags(tag.getType());\n    boolean after = false;\n    boolean hasOtherTagBefore = false;\n    for (PageElementTag otherTag : tags) {\n      if (!after) {\n        if (otherTag == tag) {\n          after = true;\n        } else if (!otherTag.isComplete()) {\n          hasOtherTagBefore = true;\n        }\n      }\n    }\n   \n    if (lastTag == tag) {\n      CheckErrorResult errorResult = createCheckErrorResult(analysis, tag.getBeginIndex(), tag.getEndIndex());\n      errorResult.addReplacement(\"\");\n      if (hasOtherTagBefore && (tag.getParametersCount() == 0)) {\n        errorResult.addReplacement(\n            TagBuilder.from(tag.getName(), TagFormat.CLOSE).toString());\n      }\n      errors.add(errorResult);\n      return true;\n    }\n    if (lastTag != null) {\n      CheckErrorResult errorResult = analyzeArea(\n          analysis, tag, lastTag.getBeginIndex(), tag.getEndIndex(),\n          !hasOtherTagBefore, ActionAlone.ALONE_NOTHING); \n      if (errorResult != null) {\n        errors.add(errorResult);\n        return true;\n      }\n    } else {\n      CheckErrorResult errorResult = analyzeArea(\n          analysis, tag, tag.getBeginIndex(), lastIndex,\n          !hasOtherTagBefore, ActionAlone.ALONE_NOTHING); \n      if (errorResult != null) {\n        errors.add(errorResult);\n        return true;\n      }\n    }\n    return false;\n  }","cleancode":"private boolean analyzelastline( pageanalysis analysis, pageelementtag tag, collection<checkerrorresult> errors) { if (!htmltagtype.center.equals(tag.gettype()) && !htmltagtype.small.equals(tag.gettype())) { return false; } integer namespace = analysis.getpage().getnamespace(); if ((namespace == null) || (namespace.intvalue() == namespace.template)) { return false; } string contents = analysis.getcontents(); int index = contents.length(); while ((index > 0) && (contents.charat(index - 1) == '\\n')) { index--; } while ((index > 0) && (contents.charat(index - 1) == ' ')) { index--; } if (index == 0) { return false; } int lastindex = index; pageelementtag lasttag = null; if (contents.charat(index - 1) == '>') { lasttag = analysis.isintag(index - 1); if (lasttag != null) { index = lasttag.getbeginindex(); } } int tagendindex = tag.getendindex(); while ((index > tagendindex) && (contents.charat(index - 1) != '\\n')) { index--; if (contents.charat(index) == '>') { if (analysis.isintag(index - 1, tag.gettype()) != null) { return false; } } } if (index > tagendindex) { return false; } list<pageelementtag> tags = analysis.gettags(tag.gettype()); boolean after = false; boolean hasothertagbefore = false; for (pageelementtag othertag : tags) { if (!after) { if (othertag == tag) { after = true; } else if (!othertag.iscomplete()) { hasothertagbefore = true; } } } if (lasttag == tag) { checkerrorresult errorresult = createcheckerrorresult(analysis, tag.getbeginindex(), tag.getendindex()); errorresult.addreplacement(\"\"); if (hasothertagbefore && (tag.getparameterscount() == 0)) { errorresult.addreplacement( tagbuilder.from(tag.getname(), tagformat.close).tostring()); } errors.add(errorresult); return true; } if (lasttag != null) { checkerrorresult errorresult = analyzearea( analysis, tag, lasttag.getbeginindex(), tag.getendindex(), !hasothertagbefore, actionalone.alone_nothing); if (errorresult != null) { errors.add(errorresult); return true; } } else { checkerrorresult errorresult = analyzearea( analysis, tag, tag.getbeginindex(), lastindex, !hasothertagbefore, actionalone.alone_nothing); if (errorresult != null) { errors.add(errorresult); return true; } } return false; }","repo":"RogueScholar\/wpcleaner","label":[1,0,0,0]}
{"id":10562,"original_code":"@Override\n    public CFG createCFG() {\n        CFG cfg = new CFG(null);\n        BasicBlock start = new BasicBlock(\"PROGRAM-START\", BasicBlock.NOT_REDUCIBLE);\n        BasicBlock end = new BasicBlock(\"PROGRAM-END\", BasicBlock.REDUCIBLE_SINGLETON);\n        cfg.start = start;\n        cfg.end = end;\n        cfg.addVertex(start);\n        cfg.addVertex(end);\n        CFG firstCFG = body.get(0).createCFG();\n        cfg.addVertex(firstCFG.start);\n        cfg.addVertex(firstCFG.end);\n        cfg.addEdge(start, firstCFG.start);\n        BasicBlock prev = firstCFG.end;\n        \/\/ If there is only one node, then we would fall through the for loop, so\n        \/\/ we just copy over all nodes in the CFG here. TODO: Don't Copy Paste\n        if (body.size() == 1) {\n            firstCFG.vertexSet()\n                    .stream()\n                        .forEachOrdered(block ->\n                            firstCFG\n                                    .edgesOf(block)\n                                    .stream()\n                                    .forEachOrdered(edge -> {\n                                        BasicBlock src = firstCFG.getEdgeSource(edge);\n                                        BasicBlock tgt = firstCFG.getEdgeTarget(edge);\n                                        cfg.addVertex(src);\n                                        cfg.addVertex(tgt);\n                                        cfg.addEdge(src, tgt);\n                                    })\n                        );\n        }\n        for (ASTNode node : body.subList(1, body.size())) {\n            if (node instanceof IfConditionalASTNode) {\n                Logger.getAnonymousLogger().info(node.getClass().getName());\n            }\n            CFG stmtCFG = node.createCFG();\n            if (stmtCFG == null) { \n                continue;\n            }\n            cfg.addVertex(stmtCFG.start);\n            cfg.addVertex(stmtCFG.end);\n            cfg.addEdge(prev, stmtCFG.start);\n            Logger.getAnonymousLogger().info(stmtCFG.toString());\n            stmtCFG.vertexSet()\n                    .stream()\n                        .forEachOrdered(block ->\n                            stmtCFG\n                                    .edgesOf(block)\n                                    .stream()\n                                    .forEachOrdered(edge -> {\n                                        BasicBlock src = stmtCFG.getEdgeSource(edge);\n                                        BasicBlock tgt = stmtCFG.getEdgeTarget(edge);\n                                        if (node instanceof IfConditionalASTNode) {\n                                            Logger.getAnonymousLogger().info(\"Bridging Gap for: \" + src + \" and \" + tgt);\n                                        }\n                                        cfg.addVertex(src);\n                                        cfg.addVertex(tgt);\n                                        cfg.addEdge(src, tgt);\n                                    })\n                        );\n            prev = stmtCFG.end;\n        }\n        cfg.addEdge(prev, end);\n        removeTrivialNodes(cfg);\n        Logger.getAnonymousLogger().info(\"Reducing...\");\n        Set<BasicBlock> processed = new TreeSet<>();\n        reduceCFG(cfg, processed);\n\/\/        processed.clear();\n\/\/        reduceCFG(cfg, processed);\n        return cfg;                \n    }","code_wo_comment":"@Override\n    public CFG createCFG() {\n        CFG cfg = new CFG(null);\n        BasicBlock start = new BasicBlock(\"PROGRAM-START\", BasicBlock.NOT_REDUCIBLE);\n        BasicBlock end = new BasicBlock(\"PROGRAM-END\", BasicBlock.REDUCIBLE_SINGLETON);\n        cfg.start = start;\n        cfg.end = end;\n        cfg.addVertex(start);\n        cfg.addVertex(end);\n        CFG firstCFG = body.get(0).createCFG();\n        cfg.addVertex(firstCFG.start);\n        cfg.addVertex(firstCFG.end);\n        cfg.addEdge(start, firstCFG.start);\n        BasicBlock prev = firstCFG.end;\n       \n       \n        if (body.size() == 1) {\n            firstCFG.vertexSet()\n                    .stream()\n                        .forEachOrdered(block ->\n                            firstCFG\n                                    .edgesOf(block)\n                                    .stream()\n                                    .forEachOrdered(edge -> {\n                                        BasicBlock src = firstCFG.getEdgeSource(edge);\n                                        BasicBlock tgt = firstCFG.getEdgeTarget(edge);\n                                        cfg.addVertex(src);\n                                        cfg.addVertex(tgt);\n                                        cfg.addEdge(src, tgt);\n                                    })\n                        );\n        }\n        for (ASTNode node : body.subList(1, body.size())) {\n            if (node instanceof IfConditionalASTNode) {\n                Logger.getAnonymousLogger().info(node.getClass().getName());\n            }\n            CFG stmtCFG = node.createCFG();\n            if (stmtCFG == null) { \n                continue;\n            }\n            cfg.addVertex(stmtCFG.start);\n            cfg.addVertex(stmtCFG.end);\n            cfg.addEdge(prev, stmtCFG.start);\n            Logger.getAnonymousLogger().info(stmtCFG.toString());\n            stmtCFG.vertexSet()\n                    .stream()\n                        .forEachOrdered(block ->\n                            stmtCFG\n                                    .edgesOf(block)\n                                    .stream()\n                                    .forEachOrdered(edge -> {\n                                        BasicBlock src = stmtCFG.getEdgeSource(edge);\n                                        BasicBlock tgt = stmtCFG.getEdgeTarget(edge);\n                                        if (node instanceof IfConditionalASTNode) {\n                                            Logger.getAnonymousLogger().info(\"Bridging Gap for: \" + src + \" and \" + tgt);\n                                        }\n                                        cfg.addVertex(src);\n                                        cfg.addVertex(tgt);\n                                        cfg.addEdge(src, tgt);\n                                    })\n                        );\n            prev = stmtCFG.end;\n        }\n        cfg.addEdge(prev, end);\n        removeTrivialNodes(cfg);\n        Logger.getAnonymousLogger().info(\"Reducing...\");\n        Set<BasicBlock> processed = new TreeSet<>();\n        reduceCFG(cfg, processed);\n        return cfg;                \n    }","cleancode":"@override public cfg createcfg() { cfg cfg = new cfg(null); basicblock start = new basicblock(\"program-start\", basicblock.not_reducible); basicblock end = new basicblock(\"program-end\", basicblock.reducible_singleton); cfg.start = start; cfg.end = end; cfg.addvertex(start); cfg.addvertex(end); cfg firstcfg = body.get(0).createcfg(); cfg.addvertex(firstcfg.start); cfg.addvertex(firstcfg.end); cfg.addedge(start, firstcfg.start); basicblock prev = firstcfg.end; if (body.size() == 1) { firstcfg.vertexset() .stream() .foreachordered(block -> firstcfg .edgesof(block) .stream() .foreachordered(edge -> { basicblock src = firstcfg.getedgesource(edge); basicblock tgt = firstcfg.getedgetarget(edge); cfg.addvertex(src); cfg.addvertex(tgt); cfg.addedge(src, tgt); }) ); } for (astnode node : body.sublist(1, body.size())) { if (node instanceof ifconditionalastnode) { logger.getanonymouslogger().info(node.getclass().getname()); } cfg stmtcfg = node.createcfg(); if (stmtcfg == null) { continue; } cfg.addvertex(stmtcfg.start); cfg.addvertex(stmtcfg.end); cfg.addedge(prev, stmtcfg.start); logger.getanonymouslogger().info(stmtcfg.tostring()); stmtcfg.vertexset() .stream() .foreachordered(block -> stmtcfg .edgesof(block) .stream() .foreachordered(edge -> { basicblock src = stmtcfg.getedgesource(edge); basicblock tgt = stmtcfg.getedgetarget(edge); if (node instanceof ifconditionalastnode) { logger.getanonymouslogger().info(\"bridging gap for: \" + src + \" and \" + tgt); } cfg.addvertex(src); cfg.addvertex(tgt); cfg.addedge(src, tgt); }) ); prev = stmtcfg.end; } cfg.addedge(prev, end); removetrivialnodes(cfg); logger.getanonymouslogger().info(\"reducing...\"); set<basicblock> processed = new treeset<>(); reducecfg(cfg, processed); return cfg; }","repo":"LouisJenkinsCS\/DSL","label":[1,0,0,0]}
{"id":2478,"original_code":"public boolean isHeld(IControllerEvent event) {\n  return activationMap.containsKey(event);\n }","code_wo_comment":"public boolean isHeld(IControllerEvent event) {\n  return activationMap.containsKey(event);\n }","cleancode":"public boolean isheld(icontrollerevent event) { return activationmap.containskey(event); }","repo":"Matthewacon\/mh4-hackathon","label":[0,0,0,0]}
{"id":18874,"original_code":"public void setAir(final World world)\n    {\n        \/\/ TODO maybe see if there is a way to find the default \"air\" for this\n        \/\/ world\n        world.setBlockState(this.getPos(), Blocks.AIR.getDefaultState());\n    }","code_wo_comment":"public void setAir(final World world)\n    {\n       \n       \n        world.setBlockState(this.getPos(), Blocks.AIR.getDefaultState());\n    }","cleancode":"public void setair(final world world) { world.setblockstate(this.getpos(), blocks.air.getdefaultstate()); }","repo":"MetaltyrantMk2\/Pokecube-Issues-and-Wiki","label":[1,0,0,0]}
{"id":2498,"original_code":"@PluginMethod\n    public void writeFile(PluginCall call) {\n        String path = call.getString(\"path\");\n        String data = call.getString(\"data\");\n        Boolean recursive = call.getBoolean(\"recursive\", false);\n        if (path == null) {\n            Logger.error(getLogTag(), \"No path or filename retrieved from call\", null);\n            call.reject(\"NO_PATH\");\n            return;\n        }\n        if (data == null) {\n            Logger.error(getLogTag(), \"No data retrieved from call\", null);\n            call.reject(\"NO_DATA\");\n            return;\n        }\n        String directory = getDirectoryParameter(call);\n        if (directory != null) {\n            if (isPublicDirectory(directory) && !isStoragePermissionGranted()) {\n                requestAllPermissions(call, \"permissionCallback\");\n            } else {\n                \/\/ create directory because it might not exist\n                File androidDir = implementation.getDirectory(directory);\n                if (androidDir != null) {\n                    if (androidDir.exists() || androidDir.mkdirs()) {\n                        \/\/ path might include directories as well\n                        File fileObject = new File(androidDir, path);\n                        if (fileObject.getParentFile().exists() || (recursive && fileObject.getParentFile().mkdirs())) {\n                            saveFile(call, fileObject, data);\n                        } else {\n                            call.reject(\"Parent folder doesn't exist\");\n                        }\n                    } else {\n                        Logger.error(getLogTag(), \"Not able to create '\" + directory + \"'!\", null);\n                        call.reject(\"NOT_CREATED_DIR\");\n                    }\n                } else {\n                    Logger.error(getLogTag(), \"Directory ID '\" + directory + \"' is not supported by plugin\", null);\n                    call.reject(\"INVALID_DIR\");\n                }\n            }\n        } else {\n            \/\/ check file:\/\/ or no scheme uris\n            Uri u = Uri.parse(path);\n            if (u.getScheme() == null || u.getScheme().equals(\"file\")) {\n                File fileObject = new File(u.getPath());\n                \/\/ do not know where the file is being store so checking the permission to be secure\n                \/\/ TODO to prevent permission checking we need a property from the call\n                if (!isStoragePermissionGranted()) {\n                    requestAllPermissions(call, \"permissionCallback\");\n                } else {\n                    if (\n                        fileObject.getParentFile() == null ||\n                        fileObject.getParentFile().exists() ||\n                        (recursive && fileObject.getParentFile().mkdirs())\n                    ) {\n                        saveFile(call, fileObject, data);\n                    } else {\n                        call.reject(\"Parent folder doesn't exist\");\n                    }\n                }\n            } else {\n                call.reject(u.getScheme() + \" scheme not supported\");\n            }\n        }\n    }","code_wo_comment":"@PluginMethod\n    public void writeFile(PluginCall call) {\n        String path = call.getString(\"path\");\n        String data = call.getString(\"data\");\n        Boolean recursive = call.getBoolean(\"recursive\", false);\n        if (path == null) {\n            Logger.error(getLogTag(), \"No path or filename retrieved from call\", null);\n            call.reject(\"NO_PATH\");\n            return;\n        }\n        if (data == null) {\n            Logger.error(getLogTag(), \"No data retrieved from call\", null);\n            call.reject(\"NO_DATA\");\n            return;\n        }\n        String directory = getDirectoryParameter(call);\n        if (directory != null) {\n            if (isPublicDirectory(directory) && !isStoragePermissionGranted()) {\n                requestAllPermissions(call, \"permissionCallback\");\n            } else {\n               \n                File androidDir = implementation.getDirectory(directory);\n                if (androidDir != null) {\n                    if (androidDir.exists() || androidDir.mkdirs()) {\n                       \n                        File fileObject = new File(androidDir, path);\n                        if (fileObject.getParentFile().exists() || (recursive && fileObject.getParentFile().mkdirs())) {\n                            saveFile(call, fileObject, data);\n                        } else {\n                            call.reject(\"Parent folder doesn't exist\");\n                        }\n                    } else {\n                        Logger.error(getLogTag(), \"Not able to create '\" + directory + \"'!\", null);\n                        call.reject(\"NOT_CREATED_DIR\");\n                    }\n                } else {\n                    Logger.error(getLogTag(), \"Directory ID '\" + directory + \"' is not supported by plugin\", null);\n                    call.reject(\"INVALID_DIR\");\n                }\n            }\n        } else {\n           \n            Uri u = Uri.parse(path);\n            if (u.getScheme() == null || u.getScheme().equals(\"file\")) {\n                File fileObject = new File(u.getPath());\n               \n               \n                if (!isStoragePermissionGranted()) {\n                    requestAllPermissions(call, \"permissionCallback\");\n                } else {\n                    if (\n                        fileObject.getParentFile() == null ||\n                        fileObject.getParentFile().exists() ||\n                        (recursive && fileObject.getParentFile().mkdirs())\n                    ) {\n                        saveFile(call, fileObject, data);\n                    } else {\n                        call.reject(\"Parent folder doesn't exist\");\n                    }\n                }\n            } else {\n                call.reject(u.getScheme() + \" scheme not supported\");\n            }\n        }\n    }","cleancode":"@pluginmethod public void writefile(plugincall call) { string path = call.getstring(\"path\"); string data = call.getstring(\"data\"); boolean recursive = call.getboolean(\"recursive\", false); if (path == null) { logger.error(getlogtag(), \"no path or filename retrieved from call\", null); call.reject(\"no_path\"); return; } if (data == null) { logger.error(getlogtag(), \"no data retrieved from call\", null); call.reject(\"no_data\"); return; } string directory = getdirectoryparameter(call); if (directory != null) { if (ispublicdirectory(directory) && !isstoragepermissiongranted()) { requestallpermissions(call, \"permissioncallback\"); } else { file androiddir = implementation.getdirectory(directory); if (androiddir != null) { if (androiddir.exists() || androiddir.mkdirs()) { file fileobject = new file(androiddir, path); if (fileobject.getparentfile().exists() || (recursive && fileobject.getparentfile().mkdirs())) { savefile(call, fileobject, data); } else { call.reject(\"parent folder doesn't exist\"); } } else { logger.error(getlogtag(), \"not able to create '\" + directory + \"'!\", null); call.reject(\"not_created_dir\"); } } else { logger.error(getlogtag(), \"directory id '\" + directory + \"' is not supported by plugin\", null); call.reject(\"invalid_dir\"); } } } else { uri u = uri.parse(path); if (u.getscheme() == null || u.getscheme().equals(\"file\")) { file fileobject = new file(u.getpath()); if (!isstoragepermissiongranted()) { requestallpermissions(call, \"permissioncallback\"); } else { if ( fileobject.getparentfile() == null || fileobject.getparentfile().exists() || (recursive && fileobject.getparentfile().mkdirs()) ) { savefile(call, fileobject, data); } else { call.reject(\"parent folder doesn't exist\"); } } } else { call.reject(u.getscheme() + \" scheme not supported\"); } } }","repo":"RetoeGo\/Stuby","label":[1,0,0,0]}
{"id":2512,"original_code":"public MyPair<List<List<FpgaInternalMove>>,List<MyPair<FpgaInternalState,List<FpgaInternalMove>>>> getNextStates(FpgaInternalState state){\n\t\tif(this.theMachine.isTerminal(state.getCompactMachineState())) {\n\t\t\treturn null;\n\t\t}\n\t\t\/\/ Retrieve all legal moves\n\t\tList<List<CompactMove>> movesForAllRoles;\n\t\ttry {\n\t\t\tmovesForAllRoles = this.theMachine.getAllLegalMoves(state.getCompactMachineState());\n\t\t} catch (MoveDefinitionException e) {\n\t\t\tGamerLogger.logError(\"StateMachine\", \"[FakeFPGALibrary] Error when getting all legal moves!\");\n\t\t\tthrow new RuntimeException(\"StateMachine - [FakeFPGALibrary] Error when getting all legal moves!\");\n\t\t}\n\t\tList<List<FpgaInternalMove>> internalMovesForAllRoles = new ArrayList<List<FpgaInternalMove>>();\n\t\tfor(List<CompactMove> movesForOneRole : movesForAllRoles) {\n\t\t\tList<FpgaInternalMove> internalMovesForOneRole = new ArrayList<FpgaInternalMove>();\n\t\t\tfor(CompactMove move : movesForOneRole) {\n\t\t\t\tinternalMovesForOneRole.add(new FpgaInternalMove(move));\n\t\t\t}\n\t\t\tinternalMovesForAllRoles.add(internalMovesForOneRole);\n\t\t}\n\t\t\/\/ Retrieve all joint moves and next states\n\t\tList<List<CompactMove>> allJointMoves;\n\t\ttry {\n\t\t\tallJointMoves = this.theMachine.getLegalJointMoves(state.getCompactMachineState());\n\t\t} catch (MoveDefinitionException | StateMachineException e) {\n\t\t\tGamerLogger.logError(\"StateMachine\", \"[FakeFPGALibrary] Error when getting all legal joint moves!\");\n\t\t\tthrow new RuntimeException(\"StateMachine - [FakeFPGALibrary] Error when getting all legal joint moves!\");\n\t\t}\n\t\tList<MyPair<FpgaInternalState,List<FpgaInternalMove>>> internalJointMovesAndNextStates = new ArrayList<MyPair<FpgaInternalState,List<FpgaInternalMove>>>();\n\t\tCompactMachineState nextState;\n\t\tif(allJointMoves == null) {\n\t\t\tSystem.out.println(\"Null joint moves\");\n\t\t}\n\t\tfor(List<CompactMove> jointMove : allJointMoves) {\n\t\t\tnextState = this.theMachine.getCompactNextState(state.getCompactMachineState(), jointMove);\n\t\t\tList<FpgaInternalMove> internalJointMove = new ArrayList<FpgaInternalMove>();\n\t\t\tfor(CompactMove move : jointMove) {\n\t\t\t\tinternalJointMove.add(new FpgaInternalMove(move));\n\t\t\t}\n\t\t\tinternalJointMovesAndNextStates.add(new MyPair<FpgaInternalState,List<FpgaInternalMove>>(new FpgaInternalState(nextState), internalJointMove));\n\t\t}\n\t\treturn new MyPair<List<List<FpgaInternalMove>>,List<MyPair<FpgaInternalState,List<FpgaInternalMove>>>>(internalMovesForAllRoles, internalJointMovesAndNextStates);\n\t}","code_wo_comment":"public MyPair<List<List<FpgaInternalMove>>,List<MyPair<FpgaInternalState,List<FpgaInternalMove>>>> getNextStates(FpgaInternalState state){\n\t\tif(this.theMachine.isTerminal(state.getCompactMachineState())) {\n\t\t\treturn null;\n\t\t}\n\t\n\t\tList<List<CompactMove>> movesForAllRoles;\n\t\ttry {\n\t\t\tmovesForAllRoles = this.theMachine.getAllLegalMoves(state.getCompactMachineState());\n\t\t} catch (MoveDefinitionException e) {\n\t\t\tGamerLogger.logError(\"StateMachine\", \"[FakeFPGALibrary] Error when getting all legal moves!\");\n\t\t\tthrow new RuntimeException(\"StateMachine - [FakeFPGALibrary] Error when getting all legal moves!\");\n\t\t}\n\t\tList<List<FpgaInternalMove>> internalMovesForAllRoles = new ArrayList<List<FpgaInternalMove>>();\n\t\tfor(List<CompactMove> movesForOneRole : movesForAllRoles) {\n\t\t\tList<FpgaInternalMove> internalMovesForOneRole = new ArrayList<FpgaInternalMove>();\n\t\t\tfor(CompactMove move : movesForOneRole) {\n\t\t\t\tinternalMovesForOneRole.add(new FpgaInternalMove(move));\n\t\t\t}\n\t\t\tinternalMovesForAllRoles.add(internalMovesForOneRole);\n\t\t}\n\t\n\t\tList<List<CompactMove>> allJointMoves;\n\t\ttry {\n\t\t\tallJointMoves = this.theMachine.getLegalJointMoves(state.getCompactMachineState());\n\t\t} catch (MoveDefinitionException | StateMachineException e) {\n\t\t\tGamerLogger.logError(\"StateMachine\", \"[FakeFPGALibrary] Error when getting all legal joint moves!\");\n\t\t\tthrow new RuntimeException(\"StateMachine - [FakeFPGALibrary] Error when getting all legal joint moves!\");\n\t\t}\n\t\tList<MyPair<FpgaInternalState,List<FpgaInternalMove>>> internalJointMovesAndNextStates = new ArrayList<MyPair<FpgaInternalState,List<FpgaInternalMove>>>();\n\t\tCompactMachineState nextState;\n\t\tif(allJointMoves == null) {\n\t\t\tSystem.out.println(\"Null joint moves\");\n\t\t}\n\t\tfor(List<CompactMove> jointMove : allJointMoves) {\n\t\t\tnextState = this.theMachine.getCompactNextState(state.getCompactMachineState(), jointMove);\n\t\t\tList<FpgaInternalMove> internalJointMove = new ArrayList<FpgaInternalMove>();\n\t\t\tfor(CompactMove move : jointMove) {\n\t\t\t\tinternalJointMove.add(new FpgaInternalMove(move));\n\t\t\t}\n\t\t\tinternalJointMovesAndNextStates.add(new MyPair<FpgaInternalState,List<FpgaInternalMove>>(new FpgaInternalState(nextState), internalJointMove));\n\t\t}\n\t\treturn new MyPair<List<List<FpgaInternalMove>>,List<MyPair<FpgaInternalState,List<FpgaInternalMove>>>>(internalMovesForAllRoles, internalJointMovesAndNextStates);\n\t}","cleancode":"public mypair<list<list<fpgainternalmove>>,list<mypair<fpgainternalstate,list<fpgainternalmove>>>> getnextstates(fpgainternalstate state){ if(this.themachine.isterminal(state.getcompactmachinestate())) { return null; } list<list<compactmove>> movesforallroles; try { movesforallroles = this.themachine.getalllegalmoves(state.getcompactmachinestate()); } catch (movedefinitionexception e) { gamerlogger.logerror(\"statemachine\", \"[fakefpgalibrary] error when getting all legal moves!\"); throw new runtimeexception(\"statemachine - [fakefpgalibrary] error when getting all legal moves!\"); } list<list<fpgainternalmove>> internalmovesforallroles = new arraylist<list<fpgainternalmove>>(); for(list<compactmove> movesforonerole : movesforallroles) { list<fpgainternalmove> internalmovesforonerole = new arraylist<fpgainternalmove>(); for(compactmove move : movesforonerole) { internalmovesforonerole.add(new fpgainternalmove(move)); } internalmovesforallroles.add(internalmovesforonerole); } list<list<compactmove>> alljointmoves; try { alljointmoves = this.themachine.getlegaljointmoves(state.getcompactmachinestate()); } catch (movedefinitionexception | statemachineexception e) { gamerlogger.logerror(\"statemachine\", \"[fakefpgalibrary] error when getting all legal joint moves!\"); throw new runtimeexception(\"statemachine - [fakefpgalibrary] error when getting all legal joint moves!\"); } list<mypair<fpgainternalstate,list<fpgainternalmove>>> internaljointmovesandnextstates = new arraylist<mypair<fpgainternalstate,list<fpgainternalmove>>>(); compactmachinestate nextstate; if(alljointmoves == null) { system.out.println(\"null joint moves\"); } for(list<compactmove> jointmove : alljointmoves) { nextstate = this.themachine.getcompactnextstate(state.getcompactmachinestate(), jointmove); list<fpgainternalmove> internaljointmove = new arraylist<fpgainternalmove>(); for(compactmove move : jointmove) { internaljointmove.add(new fpgainternalmove(move)); } internaljointmovesandnextstates.add(new mypair<fpgainternalstate,list<fpgainternalmove>>(new fpgainternalstate(nextstate), internaljointmove)); } return new mypair<list<list<fpgainternalmove>>,list<mypair<fpgainternalstate,list<fpgainternalmove>>>>(internalmovesforallroles, internaljointmovesandnextstates); }","repo":"Lucsparidans\/GGP-Project","label":[1,0,0,0]}
{"id":10940,"original_code":"public void setWindow(SpectralWindow window) {\n        \/\/ Use the same window everywhere.\n        for (int i = 0; i < ffts.length; i++) {\n            ffts[i].setWindow(window); \/\/ TODO review, both sides or just one\n            iffts[i].setWindow(window);\n        }\n    }","code_wo_comment":"public void setWindow(SpectralWindow window) {\n       \n        for (int i = 0; i < ffts.length; i++) {\n            ffts[i].setWindow(window);\n            iffts[i].setWindow(window);\n        }\n    }","cleancode":"public void setwindow(spectralwindow window) { for (int i = 0; i < ffts.length; i++) { ffts[i].setwindow(window); iffts[i].setwindow(window); } }","repo":"RubbaBoy\/jsyn","label":[1,0,0,0]}
{"id":19154,"original_code":"public void registBroadcastReceiver(){\n        mRegistrationBroadcastReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                String action = intent.getAction();\n                if(action.equals(QuickstartPreferences.REGISTRATION_READY)){\n                }else if(action.equals(QuickstartPreferences.REGISTRATION_GENERATING)){\n                }else if(action.equals(QuickstartPreferences.REGISTRATION_COMPLETE)){\n                    Log.d(TAG, \"token is set in gcm_token\");\n                    gcm_token = intent.getStringExtra(\"token\");\n                    Log.d(TAG, \"gcm_token: \" + gcm_token);\n                    ConnectServer.getInstance().setAsncTask(new AsyncTask<String, Void, Boolean>() {\n                        @Override\n                        protected Boolean doInBackground(String... params) {\n                            URL obj = null;\n                            try {\n                                obj = new URL(\"http:\/\/165.194.104.22:5000\/gcm\");\n                                HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n                                \/\/implement below code if token is send to server\n                                con = ConnectServer.getInstance().setHeader(con);\n                                con.setDoOutput(true);\n                                String parameter = URLEncoder.encode(\"register_id\", \"UTF-8\") + \"=\" + URLEncoder.encode(gcm_token, \"UTF-8\");\n                                OutputStreamWriter wr = new OutputStreamWriter(con.getOutputStream());\n                                wr.write(parameter);\n                                wr.flush();\n                                BufferedReader rd = null;\n                                if (con.getResponseCode() == 200) {\n                                    Log.d(TAG,\"gcm_token is sent\");\n                                } else {\n                                    rd = new BufferedReader(new InputStreamReader(con.getErrorStream(), \"UTF-8\"));\n                                    Log.e(TAG,rd.readLine());\n                                }\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                            }\n                            return null;\n                        }\n                        @Override\n                        protected void onPostExecute(Boolean aBoolean) {\n                        }\n                    });\n                    ConnectServer.getInstance().execute();\n                }\n            }\n        };\n    }","code_wo_comment":"public void registBroadcastReceiver(){\n        mRegistrationBroadcastReceiver = new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                String action = intent.getAction();\n                if(action.equals(QuickstartPreferences.REGISTRATION_READY)){\n                }else if(action.equals(QuickstartPreferences.REGISTRATION_GENERATING)){\n                }else if(action.equals(QuickstartPreferences.REGISTRATION_COMPLETE)){\n                    Log.d(TAG, \"token is set in gcm_token\");\n                    gcm_token = intent.getStringExtra(\"token\");\n                    Log.d(TAG, \"gcm_token: \" + gcm_token);\n                    ConnectServer.getInstance().setAsncTask(new AsyncTask<String, Void, Boolean>() {\n                        @Override\n                        protected Boolean doInBackground(String... params) {\n                            URL obj = null;\n                            try {\n                                obj = new URL(\"http:\/\/165.194.104.22:5000\/gcm\");\n                                HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n                               \n                                con = ConnectServer.getInstance().setHeader(con);\n                                con.setDoOutput(true);\n                                String parameter = URLEncoder.encode(\"register_id\", \"UTF-8\") + \"=\" + URLEncoder.encode(gcm_token, \"UTF-8\");\n                                OutputStreamWriter wr = new OutputStreamWriter(con.getOutputStream());\n                                wr.write(parameter);\n                                wr.flush();\n                                BufferedReader rd = null;\n                                if (con.getResponseCode() == 200) {\n                                    Log.d(TAG,\"gcm_token is sent\");\n                                } else {\n                                    rd = new BufferedReader(new InputStreamReader(con.getErrorStream(), \"UTF-8\"));\n                                    Log.e(TAG,rd.readLine());\n                                }\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                            }\n                            return null;\n                        }\n                        @Override\n                        protected void onPostExecute(Boolean aBoolean) {\n                        }\n                    });\n                    ConnectServer.getInstance().execute();\n                }\n            }\n        };\n    }","cleancode":"public void registbroadcastreceiver(){ mregistrationbroadcastreceiver = new broadcastreceiver() { @override public void onreceive(context context, intent intent) { string action = intent.getaction(); if(action.equals(quickstartpreferences.registration_ready)){ }else if(action.equals(quickstartpreferences.registration_generating)){ }else if(action.equals(quickstartpreferences.registration_complete)){ log.d(tag, \"token is set in gcm_token\"); gcm_token = intent.getstringextra(\"token\"); log.d(tag, \"gcm_token: \" + gcm_token); connectserver.getinstance().setasnctask(new asynctask<string, void, boolean>() { @override protected boolean doinbackground(string... params) { url obj = null; try { obj = new url(\"http:\/\/165.194.104.22:5000\/gcm\"); httpurlconnection con = (httpurlconnection) obj.openconnection(); con = connectserver.getinstance().setheader(con); con.setdooutput(true); string parameter = urlencoder.encode(\"register_id\", \"utf-8\") + \"=\" + urlencoder.encode(gcm_token, \"utf-8\"); outputstreamwriter wr = new outputstreamwriter(con.getoutputstream()); wr.write(parameter); wr.flush(); bufferedreader rd = null; if (con.getresponsecode() == 200) { log.d(tag,\"gcm_token is sent\"); } else { rd = new bufferedreader(new inputstreamreader(con.geterrorstream(), \"utf-8\")); log.e(tag,rd.readline()); } } catch (ioexception e) { e.printstacktrace(); } return null; } @override protected void onpostexecute(boolean aboolean) { } }); connectserver.getinstance().execute(); } } }; }","repo":"KyoungjunPark\/SmartClass","label":[0,1,0,0]}
{"id":10985,"original_code":"static void addChildElement(\n            BasePropertyWriter p,\n            Map<String, BasePropertyWriter> childElements,\n            FlowElementsContainer process,\n            Collection<ElementParameters> simulationParameters,\n            List<ItemDefinition> itemDefinitions,\n            List<RootElement> rootElements) {\n        childElements.put(p.getElement().getId(), p);\n        if (p.getElement() instanceof FlowElement) {\n            \/\/ compatibility fix: boundary events should always occur at the bottom\n            \/\/ otherwise they will be drawn at an incorrect position on load\n            if (p instanceof BoundaryEventPropertyWriter) {\n                process.getFlowElements().add((FlowElement) p.getElement());\n            } else {\n                process.getFlowElements().add(0, (FlowElement) p.getElement());\n                p.getElement();\n            }\n        } else if (p.getElement() instanceof Artifact) {\n            if (process instanceof Process) {\n                ((Process) process).getArtifacts().add((Artifact) p.getElement());\n            } else if (process instanceof SubProcess) {\n                ((SubProcess) process).getArtifacts().add((Artifact) p.getElement());\n            }\n        }\n        if (p instanceof PropertyWriter) {\n            ElementParameters sp = ((PropertyWriter) p).getSimulationParameters();\n            if (sp != null) {\n                simulationParameters.add(sp);\n            }\n        }\n        itemDefinitions.addAll(p.getItemDefinitions());\n        rootElements.addAll(p.getRootElements());\n        rootElements.addAll(p.getInterfaces());\n    }","code_wo_comment":"static void addChildElement(\n            BasePropertyWriter p,\n            Map<String, BasePropertyWriter> childElements,\n            FlowElementsContainer process,\n            Collection<ElementParameters> simulationParameters,\n            List<ItemDefinition> itemDefinitions,\n            List<RootElement> rootElements) {\n        childElements.put(p.getElement().getId(), p);\n        if (p.getElement() instanceof FlowElement) {\n           \n           \n            if (p instanceof BoundaryEventPropertyWriter) {\n                process.getFlowElements().add((FlowElement) p.getElement());\n            } else {\n                process.getFlowElements().add(0, (FlowElement) p.getElement());\n                p.getElement();\n            }\n        } else if (p.getElement() instanceof Artifact) {\n            if (process instanceof Process) {\n                ((Process) process).getArtifacts().add((Artifact) p.getElement());\n            } else if (process instanceof SubProcess) {\n                ((SubProcess) process).getArtifacts().add((Artifact) p.getElement());\n            }\n        }\n        if (p instanceof PropertyWriter) {\n            ElementParameters sp = ((PropertyWriter) p).getSimulationParameters();\n            if (sp != null) {\n                simulationParameters.add(sp);\n            }\n        }\n        itemDefinitions.addAll(p.getItemDefinitions());\n        rootElements.addAll(p.getRootElements());\n        rootElements.addAll(p.getInterfaces());\n    }","cleancode":"static void addchildelement( basepropertywriter p, map<string, basepropertywriter> childelements, flowelementscontainer process, collection<elementparameters> simulationparameters, list<itemdefinition> itemdefinitions, list<rootelement> rootelements) { childelements.put(p.getelement().getid(), p); if (p.getelement() instanceof flowelement) { if (p instanceof boundaryeventpropertywriter) { process.getflowelements().add((flowelement) p.getelement()); } else { process.getflowelements().add(0, (flowelement) p.getelement()); p.getelement(); } } else if (p.getelement() instanceof artifact) { if (process instanceof process) { ((process) process).getartifacts().add((artifact) p.getelement()); } else if (process instanceof subprocess) { ((subprocess) process).getartifacts().add((artifact) p.getelement()); } } if (p instanceof propertywriter) { elementparameters sp = ((propertywriter) p).getsimulationparameters(); if (sp != null) { simulationparameters.add(sp); } } itemdefinitions.addall(p.getitemdefinitions()); rootelements.addall(p.getrootelements()); rootelements.addall(p.getinterfaces()); }","repo":"Prodaxis\/kie-wb-common","label":[0,0,1,0]}
{"id":19324,"original_code":"@Test\n    public void testGetWithTwoTags() {\n        int limit = THREAD_COUNT;        \/\/ TODO How to set this?\n        queryParameters.put(\"limit\", Arrays.asList(String.valueOf(limit)));\n        \/\/ TODO pick iteration and pod at random\n        queryParameters.put(\"tag\", Arrays.asList(\"iteration:1\", \"podname:\" + workerPodNames.get(0)));\n        logger.info(\"Query parameters: \" + queryParameters.size());\n        List<Datum> traces = simpleRestClient.getTraces(queryParameters, limit);\n        Instant testEndTime = Instant.now();\n        long duration = Duration.between(testStartTime, testEndTime).toMillis();\n        logger.info(\"Retrieval of \" + limit + \" spans in testGetWithTwoTags took \" + numberFormat.format(duration) + \" milliseconds\");\n        assertNotNull(traces);\n        assertEquals(limit, traces.size());\n        \/\/ TODO add more validation\n    }","code_wo_comment":"@Test\n    public void testGetWithTwoTags() {\n        int limit = THREAD_COUNT;       \n        queryParameters.put(\"limit\", Arrays.asList(String.valueOf(limit)));\n       \n        queryParameters.put(\"tag\", Arrays.asList(\"iteration:1\", \"podname:\" + workerPodNames.get(0)));\n        logger.info(\"Query parameters: \" + queryParameters.size());\n        List<Datum> traces = simpleRestClient.getTraces(queryParameters, limit);\n        Instant testEndTime = Instant.now();\n        long duration = Duration.between(testStartTime, testEndTime).toMillis();\n        logger.info(\"Retrieval of \" + limit + \" spans in testGetWithTwoTags took \" + numberFormat.format(duration) + \" milliseconds\");\n        assertNotNull(traces);\n        assertEquals(limit, traces.size());\n       \n    }","cleancode":"@test public void testgetwithtwotags() { int limit = thread_count; queryparameters.put(\"limit\", arrays.aslist(string.valueof(limit))); queryparameters.put(\"tag\", arrays.aslist(\"iteration:1\", \"podname:\" + workerpodnames.get(0))); logger.info(\"query parameters: \" + queryparameters.size()); list<datum> traces = simplerestclient.gettraces(queryparameters, limit); instant testendtime = instant.now(); long duration = duration.between(teststarttime, testendtime).tomillis(); logger.info(\"retrieval of \" + limit + \" spans in testgetwithtwotags took \" + numberformat.format(duration) + \" milliseconds\"); assertnotnull(traces); assertequals(limit, traces.size()); }","repo":"PikBot\/jaeger-performance","label":[1,1,0,0]}
{"id":19350,"original_code":"@Override\n  public List<InputSplit> getSplits(JobContext context) throws IOException {\n    final Configuration conf = context.getConfiguration();\n    final KijiURI inputTableURI = getInputTableURI(conf);\n    final Kiji kiji = Kiji.Factory.open(inputTableURI, conf);\n    final KijiTable table = kiji.openTable(inputTableURI.getTable());\n    final HTableInterface htable = HBaseKijiTable.downcast(table).openHTableConnection();\n    try {\n      final List<InputSplit> splits = Lists.newArrayList();\n      for (KijiRegion region : table.getRegions()) {\n        final byte[] startKey = region.getStartKey();\n        \/\/ TODO: a smart way to get which location is most relevant.\n        final String location =\n            region.getLocations().isEmpty() ? null : region.getLocations().iterator().next();\n        final TableSplit tableSplit = new TableSplit(\n            htable.getTableName(), startKey, region.getEndKey(), location);\n        splits.add(new KijiTableSplit(tableSplit, startKey));\n      }\n      return splits;\n    } finally {\n      htable.close();\n    }\n  }","code_wo_comment":"@Override\n  public List<InputSplit> getSplits(JobContext context) throws IOException {\n    final Configuration conf = context.getConfiguration();\n    final KijiURI inputTableURI = getInputTableURI(conf);\n    final Kiji kiji = Kiji.Factory.open(inputTableURI, conf);\n    final KijiTable table = kiji.openTable(inputTableURI.getTable());\n    final HTableInterface htable = HBaseKijiTable.downcast(table).openHTableConnection();\n    try {\n      final List<InputSplit> splits = Lists.newArrayList();\n      for (KijiRegion region : table.getRegions()) {\n        final byte[] startKey = region.getStartKey();\n       \n        final String location =\n            region.getLocations().isEmpty() ? null : region.getLocations().iterator().next();\n        final TableSplit tableSplit = new TableSplit(\n            htable.getTableName(), startKey, region.getEndKey(), location);\n        splits.add(new KijiTableSplit(tableSplit, startKey));\n      }\n      return splits;\n    } finally {\n      htable.close();\n    }\n  }","cleancode":"@override public list<inputsplit> getsplits(jobcontext context) throws ioexception { final configuration conf = context.getconfiguration(); final kijiuri inputtableuri = getinputtableuri(conf); final kiji kiji = kiji.factory.open(inputtableuri, conf); final kijitable table = kiji.opentable(inputtableuri.gettable()); final htableinterface htable = hbasekijitable.downcast(table).openhtableconnection(); try { final list<inputsplit> splits = lists.newarraylist(); for (kijiregion region : table.getregions()) { final byte[] startkey = region.getstartkey(); final string location = region.getlocations().isempty() ? null : region.getlocations().iterator().next(); final tablesplit tablesplit = new tablesplit( htable.gettablename(), startkey, region.getendkey(), location); splits.add(new kijitablesplit(tablesplit, startkey)); } return splits; } finally { htable.close(); } }","repo":"NeoGridBR\/kiji-schema","label":[1,0,0,0]}
{"id":11228,"original_code":"private void onHeartClicked(MenuItem item) {\n        ArrayList favoritesList = null;\n        String filename = \"favorites.json\";\n        FileInputStream inputStream = null;\n        try {\n            inputStream = openFileInput(filename);\n            String json = IOUtils.toString(inputStream, \"UTF-8\");\n            Gson gson = new Gson();\n            favoritesList = gson.fromJson(json, ArrayList.class);\n            inputStream.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        if(favoritesList == null) return;\n        SharedPreferences sharedPreferences = getSharedPreferences(\"pref\", Context.MODE_PRIVATE);\n        Boolean isFavorited = sharedPreferences.getBoolean(stopName + \"Favorited\", false);\n        if (!isFavorited) { \/\/favoriting\n            item.setIcon(R.drawable.ic_favorite_white_24dp);\n            item.getIcon().setColorFilter(ContextCompat.getColor(getApplicationContext(), R.color.colorAccent), PorterDuff.Mode.SRC_IN);\n            favoritesList.add(stopName); \/\/TODO make sure this doesn't break anything\n            isFavorited = true;\n        } else { \/\/unfavoriting\n            item.setIcon(R.drawable.ic_favorite_border_white_24dp);\n            item.getIcon().setColorFilter(Color.parseColor(\"#ffffff\"), PorterDuff.Mode.SRC_IN);\n            favoritesList.remove(stopName);\n            isFavorited = false;\n        }\n        SharedPreferences.Editor editor = sharedPreferences.edit();\n        editor.putBoolean(stopName + \"Favorited\", isFavorited);\n        editor.putString(stopName, stopId); \/\/Stores stop id value with stopName key\n        editor.apply();\n        gsonFileUtils.writeListToFile(favoritesList, this);\n    }","code_wo_comment":"private void onHeartClicked(MenuItem item) {\n        ArrayList favoritesList = null;\n        String filename = \"favorites.json\";\n        FileInputStream inputStream = null;\n        try {\n            inputStream = openFileInput(filename);\n            String json = IOUtils.toString(inputStream, \"UTF-8\");\n            Gson gson = new Gson();\n            favoritesList = gson.fromJson(json, ArrayList.class);\n            inputStream.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        if(favoritesList == null) return;\n        SharedPreferences sharedPreferences = getSharedPreferences(\"pref\", Context.MODE_PRIVATE);\n        Boolean isFavorited = sharedPreferences.getBoolean(stopName + \"Favorited\", false);\n        if (!isFavorited) {\n            item.setIcon(R.drawable.ic_favorite_white_24dp);\n            item.getIcon().setColorFilter(ContextCompat.getColor(getApplicationContext(), R.color.colorAccent), PorterDuff.Mode.SRC_IN);\n            favoritesList.add(stopName);\n            isFavorited = true;\n        } else {\n            item.setIcon(R.drawable.ic_favorite_border_white_24dp);\n            item.getIcon().setColorFilter(Color.parseColor(\"#ffffff\"), PorterDuff.Mode.SRC_IN);\n            favoritesList.remove(stopName);\n            isFavorited = false;\n        }\n        SharedPreferences.Editor editor = sharedPreferences.edit();\n        editor.putBoolean(stopName + \"Favorited\", isFavorited);\n        editor.putString(stopName, stopId);\n        editor.apply();\n        gsonFileUtils.writeListToFile(favoritesList, this);\n    }","cleancode":"private void onheartclicked(menuitem item) { arraylist favoriteslist = null; string filename = \"favorites.json\"; fileinputstream inputstream = null; try { inputstream = openfileinput(filename); string json = ioutils.tostring(inputstream, \"utf-8\"); gson gson = new gson(); favoriteslist = gson.fromjson(json, arraylist.class); inputstream.close(); } catch (ioexception e) { e.printstacktrace(); } if(favoriteslist == null) return; sharedpreferences sharedpreferences = getsharedpreferences(\"pref\", context.mode_private); boolean isfavorited = sharedpreferences.getboolean(stopname + \"favorited\", false); if (!isfavorited) { item.seticon(r.drawable.ic_favorite_white_24dp); item.geticon().setcolorfilter(contextcompat.getcolor(getapplicationcontext(), r.color.coloraccent), porterduff.mode.src_in); favoriteslist.add(stopname); isfavorited = true; } else { item.seticon(r.drawable.ic_favorite_border_white_24dp); item.geticon().setcolorfilter(color.parsecolor(\"#ffffff\"), porterduff.mode.src_in); favoriteslist.remove(stopname); isfavorited = false; } sharedpreferences.editor editor = sharedpreferences.edit(); editor.putboolean(stopname + \"favorited\", isfavorited); editor.putstring(stopname, stopid); editor.apply(); gsonfileutils.writelisttofile(favoriteslist, this); }","repo":"Newbhope\/cu-bus","label":[0,0,1,0]}
{"id":11229,"original_code":"private void getStopLocation(String stopId) {\n        final RequestQueue queue = Volley.newRequestQueue(this);\n        Uri stopUrlUri = Uri.parse(getStopUrl)\n                .buildUpon()\n                .appendQueryParameter(key_param, getResources().getString(R.string.api_key))\n                .appendQueryParameter(stop_param, stopId)\n                .build();\n        String stopUrl = stopUrlUri.toString();\n        JsonObjectRequest locationRequest = new JsonObjectRequest(Request.Method.GET, stopUrl, null, new Response.Listener<JSONObject>() {\n            @Override\n            public void onResponse(JSONObject response) {\n                try {\n                    stopLatlon = new double[2];\n                    JSONArray stopsArray = response.getJSONArray(\"stops\");\n                    JSONObject stop = stopsArray.getJSONObject(0);\n                    JSONArray pointsArray = stop.getJSONArray(\"stop_points\");\n                    JSONObject point = pointsArray.getJSONObject(0); \/\/TODO: determine which corner I should use\n                    stopLatlon[0] = point.getDouble(\"stop_lat\");\n                    stopLatlon[1] = point.getDouble(\"stop_lon\");\n                } catch (JSONException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, new Response.ErrorListener() {\n            @Override\n            public void onErrorResponse(VolleyError error) {\n            }\n        });\n        queue.add(locationRequest);\n    }","code_wo_comment":"private void getStopLocation(String stopId) {\n        final RequestQueue queue = Volley.newRequestQueue(this);\n        Uri stopUrlUri = Uri.parse(getStopUrl)\n                .buildUpon()\n                .appendQueryParameter(key_param, getResources().getString(R.string.api_key))\n                .appendQueryParameter(stop_param, stopId)\n                .build();\n        String stopUrl = stopUrlUri.toString();\n        JsonObjectRequest locationRequest = new JsonObjectRequest(Request.Method.GET, stopUrl, null, new Response.Listener<JSONObject>() {\n            @Override\n            public void onResponse(JSONObject response) {\n                try {\n                    stopLatlon = new double[2];\n                    JSONArray stopsArray = response.getJSONArray(\"stops\");\n                    JSONObject stop = stopsArray.getJSONObject(0);\n                    JSONArray pointsArray = stop.getJSONArray(\"stop_points\");\n                    JSONObject point = pointsArray.getJSONObject(0);\n                    stopLatlon[0] = point.getDouble(\"stop_lat\");\n                    stopLatlon[1] = point.getDouble(\"stop_lon\");\n                } catch (JSONException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, new Response.ErrorListener() {\n            @Override\n            public void onErrorResponse(VolleyError error) {\n            }\n        });\n        queue.add(locationRequest);\n    }","cleancode":"private void getstoplocation(string stopid) { final requestqueue queue = volley.newrequestqueue(this); uri stopurluri = uri.parse(getstopurl) .buildupon() .appendqueryparameter(key_param, getresources().getstring(r.string.api_key)) .appendqueryparameter(stop_param, stopid) .build(); string stopurl = stopurluri.tostring(); jsonobjectrequest locationrequest = new jsonobjectrequest(request.method.get, stopurl, null, new response.listener<jsonobject>() { @override public void onresponse(jsonobject response) { try { stoplatlon = new double[2]; jsonarray stopsarray = response.getjsonarray(\"stops\"); jsonobject stop = stopsarray.getjsonobject(0); jsonarray pointsarray = stop.getjsonarray(\"stop_points\"); jsonobject point = pointsarray.getjsonobject(0); stoplatlon[0] = point.getdouble(\"stop_lat\"); stoplatlon[1] = point.getdouble(\"stop_lon\"); } catch (jsonexception e) { e.printstacktrace(); } } }, new response.errorlistener() { @override public void onerrorresponse(volleyerror error) { } }); queue.add(locationrequest); }","repo":"Newbhope\/cu-bus","label":[1,0,0,0]}
{"id":11234,"original_code":"private void buildWeightList(\n      List<TDataNodeInfo> onlineDataNodes, List<TRegionReplicaSet> allocatedRegions) {\n    \/\/ TODO: The remaining disk capacity of DataNode can also be calculated into the weightList\n    int maximumRegionNum = 0;\n    Map<TDataNodeLocation, Integer> countMap = new HashMap<>();\n    for (TDataNodeInfo dataNodeInfo : onlineDataNodes) {\n      maxId = Math.max(maxId, dataNodeInfo.getLocation().getDataNodeId());\n      countMap.put(dataNodeInfo.getLocation(), 0);\n    }\n    for (TRegionReplicaSet regionReplicaSet : allocatedRegions) {\n      for (TDataNodeLocation dataNodeLocation : regionReplicaSet.getDataNodeLocations()) {\n        countMap.computeIfPresent(dataNodeLocation, (dataNode, count) -> (count + 1));\n        maximumRegionNum = Math.max(maximumRegionNum, countMap.get(dataNodeLocation));\n      }\n    }\n    weightList = new ArrayList<>();\n    for (Map.Entry<TDataNodeLocation, Integer> countEntry : countMap.entrySet()) {\n      int weight = maximumRegionNum - countEntry.getValue() + 1;\n      \/\/ Repeatedly add DataNode copies equal to the number of their weights\n      for (int repeat = 0; repeat < weight; repeat++) {\n        weightList.add(countEntry.getKey().deepCopy());\n      }\n    }\n  }","code_wo_comment":"private void buildWeightList(\n      List<TDataNodeInfo> onlineDataNodes, List<TRegionReplicaSet> allocatedRegions) {\n   \n    int maximumRegionNum = 0;\n    Map<TDataNodeLocation, Integer> countMap = new HashMap<>();\n    for (TDataNodeInfo dataNodeInfo : onlineDataNodes) {\n      maxId = Math.max(maxId, dataNodeInfo.getLocation().getDataNodeId());\n      countMap.put(dataNodeInfo.getLocation(), 0);\n    }\n    for (TRegionReplicaSet regionReplicaSet : allocatedRegions) {\n      for (TDataNodeLocation dataNodeLocation : regionReplicaSet.getDataNodeLocations()) {\n        countMap.computeIfPresent(dataNodeLocation, (dataNode, count) -> (count + 1));\n        maximumRegionNum = Math.max(maximumRegionNum, countMap.get(dataNodeLocation));\n      }\n    }\n    weightList = new ArrayList<>();\n    for (Map.Entry<TDataNodeLocation, Integer> countEntry : countMap.entrySet()) {\n      int weight = maximumRegionNum - countEntry.getValue() + 1;\n     \n      for (int repeat = 0; repeat < weight; repeat++) {\n        weightList.add(countEntry.getKey().deepCopy());\n      }\n    }\n  }","cleancode":"private void buildweightlist( list<tdatanodeinfo> onlinedatanodes, list<tregionreplicaset> allocatedregions) { int maximumregionnum = 0; map<tdatanodelocation, integer> countmap = new hashmap<>(); for (tdatanodeinfo datanodeinfo : onlinedatanodes) { maxid = math.max(maxid, datanodeinfo.getlocation().getdatanodeid()); countmap.put(datanodeinfo.getlocation(), 0); } for (tregionreplicaset regionreplicaset : allocatedregions) { for (tdatanodelocation datanodelocation : regionreplicaset.getdatanodelocations()) { countmap.computeifpresent(datanodelocation, (datanode, count) -> (count + 1)); maximumregionnum = math.max(maximumregionnum, countmap.get(datanodelocation)); } } weightlist = new arraylist<>(); for (map.entry<tdatanodelocation, integer> countentry : countmap.entryset()) { int weight = maximumregionnum - countentry.getvalue() + 1; for (int repeat = 0; repeat < weight; repeat++) { weightlist.add(countentry.getkey().deepcopy()); } } }","repo":"RYH61\/iotdb","label":[1,0,0,0]}
{"id":11434,"original_code":"public static Connection getConnectionDB() {\n\t\tFile dbDir = new File(CoreContext.DB_DATA_PATH);\n\t\tif (!dbDir.exists()) dbDir.mkdir();\n\t\tConnection connection = null;\n\t\ttry {\n\t\t\t\/\/ \u0435\u0441\u043b\u0438 \u0431\u0430\u0437\u044b \u043d\u0435\u0442, \u0442\u043e \u043e\u043d\u0430 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u0430 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438,\n\t\t\t\/\/ \u0438\u043d\u0430\u0447\u0435 \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0439 \u0431\u0430\u0437\u0435\n\t\t\tconnection = DriverManager.getConnection(\n\t\t\t\t\t\"jdbc:hsqldb:file:\" + dbDir.getPath() + File.separator\n\t\t\t\t\t\t\t+ CoreContext.DB_LIBRARY_FILE_NAME, \"SA\", \"\");\n\t\t} catch (SQLException e) {\n\t\t\t\/\/ TODO change to log\n\t\t\tSystem.err.println(\"ERROR: failed to create connection with db\");\n\t\t\te.printStackTrace();\n\t\t\t\/\/ TODO change System.exit(1)\n\t\t\tSystem.exit(1);\n\t\t}\n\t\t\/\/ TODO version db\n\/\/\t\tSQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(\n\/\/\t\t\t\tnew File(dbDir, CoreContext.DB_LIBRARY_FILE_NAME), null);\n\/\/\n\/\/\t\tif (db.getVersion() != version) {\n\/\/\t\t\tdb.beginTransaction();\n\/\/\t\t\ttry {\n\/\/\t\t\t\tint currVersion = db.getVersion();\n\/\/\t\t\t\tif (currVersion == 0) {\n\/\/\t\t\t\t\tonCreate(db);\n\/\/\t\t\t\t};\n\/\/\t\t\t\tonUpgrade(db, currVersion);\n\/\/\t\t\t\tdb.setVersion(version);\n\/\/\t\t\t\tdb.setTransactionSuccessful();\n\/\/\t\t\t} finally {\n\/\/\t\t\t\tdb.endTransaction();\n\/\/\t\t\t}\n\/\/\t\t}\n\t\treturn connection;\n\t}","code_wo_comment":"public static Connection getConnectionDB() {\n\t\tFile dbDir = new File(CoreContext.DB_DATA_PATH);\n\t\tif (!dbDir.exists()) dbDir.mkdir();\n\t\tConnection connection = null;\n\t\ttry {\n\t\t\n\t\t\t\t\t\"jdbc:hsqldb:file:\" + dbDir.getPath() + File.separator\n\t\t\t\t\t\t\t+ CoreContext.DB_LIBRARY_FILE_NAME, \"SA\", \"\");\n\t\t} catch (SQLException e) {\n\t\t\n\t\t\tSystem.err.println(\"ERROR: failed to create connection with db\");\n\t\t\te.printStackTrace();\n\t\t\n\t\t\tSystem.exit(1);\n\t\t}\n\t\n\t\treturn connection;\n\t}","cleancode":"public static connection getconnectiondb() { file dbdir = new file(corecontext.db_data_path); if (!dbdir.exists()) dbdir.mkdir(); connection connection = null; try { \"jdbc:hsqldb:file:\" + dbdir.getpath() + file.separator + corecontext.db_library_file_name, \"sa\", \"\"); } catch (sqlexception e) { system.err.println(\"error: failed to create connection with db\"); e.printstacktrace(); system.exit(1); } return connection; }","repo":"NikitaFeodonit\/bqtj","label":[1,1,0,0]}
{"id":3313,"original_code":"public void setOverrides(final LegacyOverridesMixin overrides) {\n        this.overrides = overrides;\n    }","code_wo_comment":"public void setOverrides(final LegacyOverridesMixin overrides) {\n        this.overrides = overrides;\n    }","cleancode":"public void setoverrides(final legacyoverridesmixin overrides) { this.overrides = overrides; }","repo":"KellyShao\/tessera","label":[0,0,0,1]}
{"id":19819,"original_code":"private float getFuelAbsorptionCoefficient() {\n\t\t\/\/ TODO: Lookup type of fuel and get data from there\n\t\treturn 0.5f;\n\t}","code_wo_comment":"private float getFuelAbsorptionCoefficient() {\n\t\n\t\treturn 0.5f;\n\t}","cleancode":"private float getfuelabsorptioncoefficient() { return 0.5f; }","repo":"RAFIWE\/BigReactors-1.7.10-Fixed","label":[0,1,0,0]}
{"id":3445,"original_code":"@Override\n    public void teleopPeriodic()\n    {\n        SmartDashboard.putString(\"Robot\/GamePhase\", \"TELEOP\");\n        double timestamp = Timer.getFPGATimestamp();\n        double throttle = mControlBoard.getThrottle();\n        double turn = mControlBoard.getTurn();\n        try\n        {\n            if (mSuperstructure.isDriverControlled())\n            {\n                DriveSignal command = ArcadeDriveHelper.arcadeDrive(mControlBoard.getThrottle(), mControlBoard.getTurn(),\n                    true \/* TODO: Decide squared inputs or not *\/).scale(mSuperstructure.isDrivingReversed() ? -1 : 1)\/*.scale(6)*\/;\n                mDrive.setOpenLoop(command);\n                \/\/ mDrive.setVelocity(command, new DriveSignal(\n                \/\/     command.scale(Constants.kDriveLeftKv).getLeft() + Math.copySign(Constants.kDriveLeftVIntercept, command.getLeft()),\n                \/\/     command.scale(Constants.kDriveLeftKv).getRight() + Math.copySign(Constants.kDriveLeftVIntercept, command.getRight())\n                \/\/ ));\n                if(mControlBoard.getEjectPanel())\n                    mPanelHandler.setWantedState(PanelHandler.WantedState.EJECT);\n                if(mControlBoard.getIntake())\n                    mCargoIntake.setWantedState(CargoIntake.WantedState.INTAKE);\n                if(mControlBoard.getTestButtonOne())\n                    mCargoIntake.setWantedState(CargoIntake.WantedState.HOLD);\n                if(mControlBoard.getEjectCargo())\n                    mCargoIntake.setWantedState(CargoIntake.WantedState.EJECT);\n                if(mControlBoard.getTestButtonTwo())\n                    mPanelHandler.checkSystem(\"variant\");\n                if (mControlBoard.getReverseDirection())\n                {\n                    mSuperstructure.reverseDrivingDirection();\n                }\n                else if (mControlBoard.getDriveToSelectedTarget())\n                {\n                    mSuperstructure.setWantedState(Superstructure.WantedState.ALIGN_AND_INTAKE_CARGO);\n                }\n                else if (mControlBoard.getClimb()) \n                {\n                    mSuperstructure.setWantedState(Superstructure.WantedState.CLIMB);\n                }\n                \/\/ TODO (for button person): add buttons for all superstructure wanted states\n            }\n            else if (mControlBoard.getReturnToDriverControl())\n            {\n                mSuperstructure.setWantedState(Superstructure.WantedState.DRIVER_CONTROL);\n            }\n        }\n        catch (Throwable t)\n        {\n            Logger.logThrowableCrash(t);\n            throw t;\n        }\n        outputToSmartDashboard();\n    }","code_wo_comment":"@Override\n    public void teleopPeriodic()\n    {\n        SmartDashboard.putString(\"Robot\/GamePhase\", \"TELEOP\");\n        double timestamp = Timer.getFPGATimestamp();\n        double throttle = mControlBoard.getThrottle();\n        double turn = mControlBoard.getTurn();\n        try\n        {\n            if (mSuperstructure.isDriverControlled())\n            {\n                DriveSignal command = ArcadeDriveHelper.arcadeDrive(mControlBoard.getThrottle(), mControlBoard.getTurn(),\n                    true).scale(mSuperstructure.isDrivingReversed() ? -1 : 1;\n                mDrive.setOpenLoop(command);\n               \n               \n               \n               \n                if(mControlBoard.getEjectPanel())\n                    mPanelHandler.setWantedState(PanelHandler.WantedState.EJECT);\n                if(mControlBoard.getIntake())\n                    mCargoIntake.setWantedState(CargoIntake.WantedState.INTAKE);\n                if(mControlBoard.getTestButtonOne())\n                    mCargoIntake.setWantedState(CargoIntake.WantedState.HOLD);\n                if(mControlBoard.getEjectCargo())\n                    mCargoIntake.setWantedState(CargoIntake.WantedState.EJECT);\n                if(mControlBoard.getTestButtonTwo())\n                    mPanelHandler.checkSystem(\"variant\");\n                if (mControlBoard.getReverseDirection())\n                {\n                    mSuperstructure.reverseDrivingDirection();\n                }\n                else if (mControlBoard.getDriveToSelectedTarget())\n                {\n                    mSuperstructure.setWantedState(Superstructure.WantedState.ALIGN_AND_INTAKE_CARGO);\n                }\n                else if (mControlBoard.getClimb()) \n                {\n                    mSuperstructure.setWantedState(Superstructure.WantedState.CLIMB);\n                }\n               \n            }\n            else if (mControlBoard.getReturnToDriverControl())\n            {\n                mSuperstructure.setWantedState(Superstructure.WantedState.DRIVER_CONTROL);\n            }\n        }\n        catch (Throwable t)\n        {\n            Logger.logThrowableCrash(t);\n            throw t;\n        }\n        outputToSmartDashboard();\n    }","cleancode":"@override public void teleopperiodic() { smartdashboard.putstring(\"robot\/gamephase\", \"teleop\"); double timestamp = timer.getfpgatimestamp(); double throttle = mcontrolboard.getthrottle(); double turn = mcontrolboard.getturn(); try { if (msuperstructure.isdrivercontrolled()) { drivesignal command = arcadedrivehelper.arcadedrive(mcontrolboard.getthrottle(), mcontrolboard.getturn(), true).scale(msuperstructure.isdrivingreversed() ? -1 : 1; mdrive.setopenloop(command); if(mcontrolboard.getejectpanel()) mpanelhandler.setwantedstate(panelhandler.wantedstate.eject); if(mcontrolboard.getintake()) mcargointake.setwantedstate(cargointake.wantedstate.intake); if(mcontrolboard.gettestbuttonone()) mcargointake.setwantedstate(cargointake.wantedstate.hold); if(mcontrolboard.getejectcargo()) mcargointake.setwantedstate(cargointake.wantedstate.eject); if(mcontrolboard.gettestbuttontwo()) mpanelhandler.checksystem(\"variant\"); if (mcontrolboard.getreversedirection()) { msuperstructure.reversedrivingdirection(); } else if (mcontrolboard.getdrivetoselectedtarget()) { msuperstructure.setwantedstate(superstructure.wantedstate.align_and_intake_cargo); } else if (mcontrolboard.getclimb()) { msuperstructure.setwantedstate(superstructure.wantedstate.climb); } } else if (mcontrolboard.getreturntodrivercontrol()) { msuperstructure.setwantedstate(superstructure.wantedstate.driver_control); } } catch (throwable t) { logger.logthrowablecrash(t); throw t; } outputtosmartdashboard(); }","repo":"MaximillianHays\/2019-DeepSpace","label":[0,1,0,0]}
{"id":3595,"original_code":"public ByteBuffer encode() throws IOException { \/\/ TODO: an implementation that can use more than one chunk\n\t\tByteArrayOutputStream bout = new ByteArrayOutputStream();\n\t\ttry (DataOutputStream os = new DataOutputStream(bout)) {\n\t\t\t\/* add the data for each entry *\/\n\t\t\tfor (ByteBuffer entry : entries) {\n\t\t\t\t\/* copy to temp buffer *\/\n\t\t\t\tbyte[] temp = new byte[entry.limit()];\n\t\t\t\tentry.position(0);\n\t\t\t\tentry.get(temp);\n\t\t\t\tentry.position(0);\n\t\t\t\t\/* copy to output stream *\/\n\t\t\t\tos.write(temp);\n\t\t\t}\n\t\t\t\/* write the chunk lengths *\/\n\t\t\tint prev = 0;\n\t\t\tfor (ByteBuffer entry : entries) {\n\t\t\t\t\/* \n\t\t\t\t * since each file is stored in the only chunk, just write the\n\t\t\t\t * delta-encoded file size\n\t\t\t\t *\/\n\t\t\t\tint chunkSize = entry.limit();\n\t\t\t\tos.writeInt(chunkSize - prev);\n\t\t\t\tprev = chunkSize;\n\t\t\t}\n\t\t\t\/* we only used one chunk due to a limitation of the implementation *\/\n\t\t\tbout.write(1);\n\t\t\t\/* wrap the bytes from the stream in a buffer *\/\n\t\t\tbyte[] bytes = bout.toByteArray();\n\t\t\treturn ByteBuffer.wrap(bytes);\n\t\t}\n\t}","code_wo_comment":"public ByteBuffer encode() throws IOException { \t\tByteArrayOutputStream bout = new ByteArrayOutputStream();\n\t\ttry (DataOutputStream os = new DataOutputStream(bout)) {\n\t\t\n\t\t\tfor (ByteBuffer entry : entries) {\n\t\t\t\n\t\t\t\tbyte[] temp = new byte[entry.limit()];\n\t\t\t\tentry.position(0);\n\t\t\t\tentry.get(temp);\n\t\t\t\tentry.position(0);\n\t\t\t\n\t\t\t\tos.write(temp);\n\t\t\t}\n\t\t\n\t\t\tint prev = 0;\n\t\t\tfor (ByteBuffer entry : entries) {\n\t\t\t\n\t\t\t\tint chunkSize = entry.limit();\n\t\t\t\tos.writeInt(chunkSize - prev);\n\t\t\t\tprev = chunkSize;\n\t\t\t}\n\t\t\n\t\t\tbout.write(1);\n\t\t\n\t\t\tbyte[] bytes = bout.toByteArray();\n\t\t\treturn ByteBuffer.wrap(bytes);\n\t\t}\n\t}","cleancode":"public bytebuffer encode() throws ioexception { bytearrayoutputstream bout = new bytearrayoutputstream(); try (dataoutputstream os = new dataoutputstream(bout)) { for (bytebuffer entry : entries) { byte[] temp = new byte[entry.limit()]; entry.position(0); entry.get(temp); entry.position(0); os.write(temp); } int prev = 0; for (bytebuffer entry : entries) { int chunksize = entry.limit(); os.writeint(chunksize - prev); prev = chunksize; } bout.write(1); byte[] bytes = bout.tobytearray(); return bytebuffer.wrap(bytes); } }","repo":"Lmctruck30\/mopar","label":[0,1,0,0]}
{"id":11794,"original_code":"public ClassInfo extendedFindClass(String className) {\n    \/\/ ClassDoc.findClass has this bug that we're working around here:\n    \/\/ If you have a class PackageManager with an inner class PackageInfo\n    \/\/ and you call it with \"PackageInfo\" it doesn't find it.\n    return searchInnerClasses(className.split(\"\\\\.\"), 0);\n  }","code_wo_comment":"public ClassInfo extendedFindClass(String className) {\n   \n   \n   \n    return searchInnerClasses(className.split(\"\\\\.\"), 0);\n  }","cleancode":"public classinfo extendedfindclass(string classname) { return searchinnerclasses(classname.split(\"\\\\.\"), 0); }","repo":"Keneral\/ae1","label":[0,0,1,0]}
{"id":12226,"original_code":"@Override\n    public void buildFunctionIfNecessary(FunctionConf functionConf) {\n        \/\/ Snapshot the directory before installing dependencies\n        List<Path> beforeSnapshot = getDirectorySnapshot(functionConf);\n        loggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Copying Greengrass SDK\");\n        copySdk(log, functionConf, resourceHelper, ioHelper);\n        if (hasDependencies(functionConf.getBuildDirectory())) {\n            loggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Installing Python dependencies\");\n            installDependencies(functionConf);\n        }\n        \/\/ Snapshot the directory after installing dependencies\n        List<Path> afterSnapshot = getDirectorySnapshot(functionConf);\n        List<Path> addedFiles = new ArrayList<>(afterSnapshot);\n        addedFiles.removeAll(beforeSnapshot);\n        loggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Packaging function for AWS Lambda\");\n        File tempFile = Try.of(() -> ioHelper.getTempFile(\"python-lambda-build\", \"zip\")).get();\n        \/\/ Get the directories, longest named directories first\n        List<Path> addedDirectories = addedFiles\n                .stream()\n                .filter(path -> path.toFile().isDirectory())\n                .sorted(Comparator.comparingInt(path -> path.toString().length()).reversed())\n                .collect(Collectors.toList());\n        \/\/ Get the possible Python directories (don't include *dist-info and bin)\n        \/\/ NOTE: This is an esoteric fix for Zope being broken which breaks Twisted - https:\/\/github.com\/kpdyer\/fteproxy\/issues\/66\n        List<Path> possibleBrokenPythonDirectories = addedDirectories\n                .stream()\n                .filter(path -> !path.toString().endsWith(DIST_INFO))\n                .filter(path -> !path.toString().endsWith(BIN))\n                .filter(path -> !path.resolve(INIT_PY).toFile().exists())\n                .collect(Collectors.toList());\n        \/\/ \"Touch\" the file to fix this issue\n        possibleBrokenPythonDirectories.stream()\n                .map(path -> path.resolve(INIT_PY).toFile())\n                .forEach(this::touchAndIgnoreExceptions);\n        ZipUtil.pack(functionConf.getBuildDirectory().toFile(), tempFile);\n        moveDeploymentPackage(functionConf, tempFile);\n    }","code_wo_comment":"@Override\n    public void buildFunctionIfNecessary(FunctionConf functionConf) {\n       \n        List<Path> beforeSnapshot = getDirectorySnapshot(functionConf);\n        loggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Copying Greengrass SDK\");\n        copySdk(log, functionConf, resourceHelper, ioHelper);\n        if (hasDependencies(functionConf.getBuildDirectory())) {\n            loggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Installing Python dependencies\");\n            installDependencies(functionConf);\n        }\n       \n        List<Path> afterSnapshot = getDirectorySnapshot(functionConf);\n        List<Path> addedFiles = new ArrayList<>(afterSnapshot);\n        addedFiles.removeAll(beforeSnapshot);\n        loggingHelper.logInfoWithName(log, functionConf.getFunctionName(), \"Packaging function for AWS Lambda\");\n        File tempFile = Try.of(() -> ioHelper.getTempFile(\"python-lambda-build\", \"zip\")).get();\n       \n        List<Path> addedDirectories = addedFiles\n                .stream()\n                .filter(path -> path.toFile().isDirectory())\n                .sorted(Comparator.comparingInt(path -> path.toString().length()).reversed())\n                .collect(Collectors.toList());\n       \n       \n        List<Path> possibleBrokenPythonDirectories = addedDirectories\n                .stream()\n                .filter(path -> !path.toString().endsWith(DIST_INFO))\n                .filter(path -> !path.toString().endsWith(BIN))\n                .filter(path -> !path.resolve(INIT_PY).toFile().exists())\n                .collect(Collectors.toList());\n       \n        possibleBrokenPythonDirectories.stream()\n                .map(path -> path.resolve(INIT_PY).toFile())\n                .forEach(this::touchAndIgnoreExceptions);\n        ZipUtil.pack(functionConf.getBuildDirectory().toFile(), tempFile);\n        moveDeploymentPackage(functionConf, tempFile);\n    }","cleancode":"@override public void buildfunctionifnecessary(functionconf functionconf) { list<path> beforesnapshot = getdirectorysnapshot(functionconf); logginghelper.loginfowithname(log, functionconf.getfunctionname(), \"copying greengrass sdk\"); copysdk(log, functionconf, resourcehelper, iohelper); if (hasdependencies(functionconf.getbuilddirectory())) { logginghelper.loginfowithname(log, functionconf.getfunctionname(), \"installing python dependencies\"); installdependencies(functionconf); } list<path> aftersnapshot = getdirectorysnapshot(functionconf); list<path> addedfiles = new arraylist<>(aftersnapshot); addedfiles.removeall(beforesnapshot); logginghelper.loginfowithname(log, functionconf.getfunctionname(), \"packaging function for aws lambda\"); file tempfile = try.of(() -> iohelper.gettempfile(\"python-lambda-build\", \"zip\")).get(); list<path> addeddirectories = addedfiles .stream() .filter(path -> path.tofile().isdirectory()) .sorted(comparator.comparingint(path -> path.tostring().length()).reversed()) .collect(collectors.tolist()); list<path> possiblebrokenpythondirectories = addeddirectories .stream() .filter(path -> !path.tostring().endswith(dist_info)) .filter(path -> !path.tostring().endswith(bin)) .filter(path -> !path.resolve(init_py).tofile().exists()) .collect(collectors.tolist()); possiblebrokenpythondirectories.stream() .map(path -> path.resolve(init_py).tofile()) .foreach(this::touchandignoreexceptions); ziputil.pack(functionconf.getbuilddirectory().tofile(), tempfile); movedeploymentpackage(functionconf, tempfile); }","repo":"QuinnCiccoretti\/aws-greengrass-provisioner","label":[0,0,0,0]}
{"id":20549,"original_code":"private static Reporter trade(String starting_date, final String ending_date, Portfolio portfolio, Reporter reporter, String order_file_name,boolean include_trading_fees,boolean pay_dividends) {\n        int final_time = 0; \/\/last day must also be included\n        Strategy strategy = new Strategy(portfolio, portfolio.getDatabase(),include_trading_fees);\n        Long starting_time = System.currentTimeMillis();\n        System.out.println(\"Trading simulation starts: \");\n        System.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n        \/\/0. Write dividend dates to dividend array\n        \/\/todo: implement array\n        List<String> dividend_dates = new ArrayList<>();\n        if (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);}\n        while (final_time == 0) {\n            \/\/TECHNICAL\n            if (starting_date.equals(ending_date)) {\n                final_time++;\n            }\n            \/\/Check if we have data about this day in the database? Maybe it's Christmas or maybe it's the weekend.\n            if (portfolio.getDatabase().contains_day(starting_date)) {\n                \/\/1. Dividend payments to other parties\n                portfolio.exercise_dividends(starting_date);\n                \/\/2. Do I have any rights or obligations (Options) \/ Obligations(Stocks)?\n                portfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n                \/\/3. Strategy((1.)unemployment rate, (2.) P\/E  (3) moving average (4) RSI)\n                strategy.setPortfolio(strategy.trade_all(starting_date));\n                \/\/4. Pay dividends to the owners\n                if (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n            }\n            \/\/TODO: remove the else part later\n            else{\n                portfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n                portfolio.exercise_dividends(starting_date);\n            }\n            \/\/ todo: remove\n           if(portfolio.get_cash_available(starting_date) < 0){System.out.println(portfolio.get_cash_available(starting_date));}\n            reporter.report(portfolio,starting_date);\n            starting_date = LocalDate.parse(starting_date).plusDays(1).toString();\n        }\n        portfolio.order_results_to_file(order_file_name,ending_date);\n        Long ending_time = System.currentTimeMillis();\n        System.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n        System.out.println(\"Trading simulation ended: \");\n        System.out.println(\"Simulation took \" + Math.round((ending_time - starting_time) * 0.001 * 1 \/ 60) + \" minutes to complete\");\n        return reporter;\n    }","code_wo_comment":"private static Reporter trade(String starting_date, final String ending_date, Portfolio portfolio, Reporter reporter, String order_file_name,boolean include_trading_fees,boolean pay_dividends) {\n        int final_time = 0;\n        Strategy strategy = new Strategy(portfolio, portfolio.getDatabase(),include_trading_fees);\n        Long starting_time = System.currentTimeMillis();\n        System.out.println(\"Trading simulation starts: \");\n        System.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n       \n       \n        List<String> dividend_dates = new ArrayList<>();\n        if (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);}\n        while (final_time == 0) {\n           \n            if (starting_date.equals(ending_date)) {\n                final_time++;\n            }\n           \n            if (portfolio.getDatabase().contains_day(starting_date)) {\n               \n                portfolio.exercise_dividends(starting_date);\n               \n                portfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n               \n                strategy.setPortfolio(strategy.trade_all(starting_date));\n               \n                if (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);}\n            }\n           \n            else{\n                portfolio.exercise_obligations(starting_date,strategy.isUse_trading_fees());\n                portfolio.exercise_dividends(starting_date);\n            }\n           \n           if(portfolio.get_cash_available(starting_date) < 0){System.out.println(portfolio.get_cash_available(starting_date));}\n            reporter.report(portfolio,starting_date);\n            starting_date = LocalDate.parse(starting_date).plusDays(1).toString();\n        }\n        portfolio.order_results_to_file(order_file_name,ending_date);\n        Long ending_time = System.currentTimeMillis();\n        System.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n        System.out.println(\"Trading simulation ended: \");\n        System.out.println(\"Simulation took \" + Math.round((ending_time - starting_time) * 0.001 * 1 \/ 60) + \" minutes to complete\");\n        return reporter;\n    }","cleancode":"private static reporter trade(string starting_date, final string ending_date, portfolio portfolio, reporter reporter, string order_file_name,boolean include_trading_fees,boolean pay_dividends) { int final_time = 0; strategy strategy = new strategy(portfolio, portfolio.getdatabase(),include_trading_fees); long starting_time = system.currenttimemillis(); system.out.println(\"trading simulation starts: \"); system.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\"); list<string> dividend_dates = new arraylist<>(); if (pay_dividends){dividend_dates = dividend_dates(starting_date,ending_date);} while (final_time == 0) { if (starting_date.equals(ending_date)) { final_time++; } if (portfolio.getdatabase().contains_day(starting_date)) { portfolio.exercise_dividends(starting_date); portfolio.exercise_obligations(starting_date,strategy.isuse_trading_fees()); strategy.setportfolio(strategy.trade_all(starting_date)); if (pay_dividends && dividend_dates.contains(starting_date)){portfolio.pay_dividends(starting_date);} } else{ portfolio.exercise_obligations(starting_date,strategy.isuse_trading_fees()); portfolio.exercise_dividends(starting_date); } if(portfolio.get_cash_available(starting_date) < 0){system.out.println(portfolio.get_cash_available(starting_date));} reporter.report(portfolio,starting_date); starting_date = localdate.parse(starting_date).plusdays(1).tostring(); } portfolio.order_results_to_file(order_file_name,ending_date); long ending_time = system.currenttimemillis(); system.out.println(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxx\"); system.out.println(\"trading simulation ended: \"); system.out.println(\"simulation took \" + math.round((ending_time - starting_time) * 0.001 * 1 \/ 60) + \" minutes to complete\"); return reporter; }","repo":"KGKallasmaa\/S_P500_trading_options","label":[1,1,0,0]}
{"id":12644,"original_code":"public void sendMessage(long chatId, Response response) {\n        var request = responseToSendMessageConverter.convert(response, chatId);\n        telegramBot.execute(request, new Callback<>() {\n            @Override\n            public void onResponse(SendMessage sendMessage, SendResponse sendResponse) {\n                \/\/ Do nothing\n            }\n            @Override\n            public void onFailure(SendMessage sendMessage, IOException e) {\n                log.warn(\"Error occurred when sending message {}, exception: {}\", request, e);\n            }\n        });\n    }","code_wo_comment":"public void sendMessage(long chatId, Response response) {\n        var request = responseToSendMessageConverter.convert(response, chatId);\n        telegramBot.execute(request, new Callback<>() {\n            @Override\n            public void onResponse(SendMessage sendMessage, SendResponse sendResponse) {\n               \n            }\n            @Override\n            public void onFailure(SendMessage sendMessage, IOException e) {\n                log.warn(\"Error occurred when sending message {}, exception: {}\", request, e);\n            }\n        });\n    }","cleancode":"public void sendmessage(long chatid, response response) { var request = responsetosendmessageconverter.convert(response, chatid); telegrambot.execute(request, new callback<>() { @override public void onresponse(sendmessage sendmessage, sendresponse sendresponse) { } @override public void onfailure(sendmessage sendmessage, ioexception e) { log.warn(\"error occurred when sending message {}, exception: {}\", request, e); } }); }","repo":"MisterRnobe\/sodexo-tg-bot","label":[1,0,0,0]}
{"id":12762,"original_code":"public static DatabindException from(SerializerProvider ctxt, String msg, Throwable problem) {\n        \/\/ 17-Aug-2015, tatu: As per [databind#903] this is bit problematic as\n        \/\/   SerializerProvider instance does not currently hold on to generator...\n        return new DatabindException(ctxt.getGenerator(), msg, problem);\n    }","code_wo_comment":"public static DatabindException from(SerializerProvider ctxt, String msg, Throwable problem) {\n       \n       \n        return new DatabindException(ctxt.getGenerator(), msg, problem);\n    }","cleancode":"public static databindexception from(serializerprovider ctxt, string msg, throwable problem) { return new databindexception(ctxt.getgenerator(), msg, problem); }","repo":"Migwel\/jackson-databind","label":[0,0,1,0]}
{"id":12861,"original_code":"private void parseMedia() {\n        assertTypeAndAdvance(PXStylesheetTokenType.MEDIA);\n        \/\/ TODO: support media types, NOT, and ONLY. Skipping for now\n        while (isType(PXStylesheetTokenType.IDENTIFIER)) {\n            advance();\n        }\n        \/\/ 'and' may appear here\n        advanceIfIsType(PXStylesheetTokenType.AND);\n        \/\/ parse optional expressions\n        if (isType(PXStylesheetTokenType.LPAREN)) {\n            parseMediaExpressions();\n        }\n        \/\/ parse body\n        if (isType(PXStylesheetTokenType.LCURLY)) {\n            try {\n                advance();\n                while (currentLexeme != null\n                        && currentLexeme.getType() != PXStylesheetTokenType.EOF\n                        && !isType(PXStylesheetTokenType.RCURLY)) {\n                    parseRuleSet();\n                }\n                advanceIfIsType(PXStylesheetTokenType.RCURLY,\n                        \"Expected @media body closing curly brace\");\n            } finally {\n                \/\/ reset active media query to none\n                currentStyleSheet.setActiveMediaQuery(null);\n            }\n        }\n    }","code_wo_comment":"private void parseMedia() {\n        assertTypeAndAdvance(PXStylesheetTokenType.MEDIA);\n       \n        while (isType(PXStylesheetTokenType.IDENTIFIER)) {\n            advance();\n        }\n       \n        advanceIfIsType(PXStylesheetTokenType.AND);\n       \n        if (isType(PXStylesheetTokenType.LPAREN)) {\n            parseMediaExpressions();\n        }\n       \n        if (isType(PXStylesheetTokenType.LCURLY)) {\n            try {\n                advance();\n                while (currentLexeme != null\n                        && currentLexeme.getType() != PXStylesheetTokenType.EOF\n                        && !isType(PXStylesheetTokenType.RCURLY)) {\n                    parseRuleSet();\n                }\n                advanceIfIsType(PXStylesheetTokenType.RCURLY,\n                        \"Expected @media body closing curly brace\");\n            } finally {\n               \n                currentStyleSheet.setActiveMediaQuery(null);\n            }\n        }\n    }","cleancode":"private void parsemedia() { asserttypeandadvance(pxstylesheettokentype.media); while (istype(pxstylesheettokentype.identifier)) { advance(); } advanceifistype(pxstylesheettokentype.and); if (istype(pxstylesheettokentype.lparen)) { parsemediaexpressions(); } if (istype(pxstylesheettokentype.lcurly)) { try { advance(); while (currentlexeme != null && currentlexeme.gettype() != pxstylesheettokentype.eof && !istype(pxstylesheettokentype.rcurly)) { parseruleset(); } advanceifistype(pxstylesheettokentype.rcurly, \"expected @media body closing curly brace\"); } finally { currentstylesheet.setactivemediaquery(null); } } }","repo":"Pixate\/pixate-freestyle-android","label":[1,0,0,0]}
{"id":21298,"original_code":"private void init() {\n    try { \n      \/\/ TODO: detect if already have a gradle setup\n      \/\/ TODO: later, use always same and symlink if possible to save time\n      setupBuildFiles();\n      Files.createDirectories(srcFolder);\n      Files.walkFileTree(projectHome.toPath(), new FileTransferProcessor()); \n    }\n    catch (Exception e) { throw new RuntimeException(e); }\n  }","code_wo_comment":"private void init() {\n    try { \n     \n     \n      setupBuildFiles();\n      Files.createDirectories(srcFolder);\n      Files.walkFileTree(projectHome.toPath(), new FileTransferProcessor()); \n    }\n    catch (Exception e) { throw new RuntimeException(e); }\n  }","cleancode":"private void init() { try { setupbuildfiles(); files.createdirectories(srcfolder); files.walkfiletree(projecthome.topath(), new filetransferprocessor()); } catch (exception e) { throw new runtimeexception(e); } }","repo":"K1UBC\/BlangModel","label":[1,0,0,0]}
{"id":30159,"original_code":"public <T> DynamicType.Builder<T> apply(DynamicType.Builder<T> builder) {\n\t\tTypeDescription description = builder.toTypeDescription();\n\t\tList<MethodDescription> methods = getMethodDescriptionList(description);\n\t\tenhanceCasesByDynamicDefinitions(methods);\n\t\tbuilder = enhanceCasesByOverrides(builder, description, methods);\n\t\tif(cases.isEmpty()) return builder;\n\t\tCase[] cases = this.cases.toArray(new Case[this.cases.size()]);\n\t\t\/\/Lets cache presence of methods per condition\n\t\tboolean[] hasMatchedMethods = new boolean[cases.length];\n\t\tboolean[] hasOpositeMatchedMethods = new boolean[cases.length];\n\t\tfor (int i=0; i<cases.length; i++) {\n\t\t\thasMatchedMethods[i] = hasMatch(methods, cases[i].getMatcher());\n\t\t\thasOpositeMatchedMethods[i] = hasMatch(methods, not(cases[i].getMatcher()));\n\t\t}\n\t\tBigInteger permutationsTotal = BigInteger.ONE.shiftLeft(cases.length).subtract(BigInteger.ONE);\n\t\tfor(BigInteger currentPermutation = BigInteger.ONE; \n\t\t\t\tcurrentPermutation.compareTo(permutationsTotal)<=0;\n\t\t\t\tcurrentPermutation = currentPermutation.add(BigInteger.ONE)) {\n\t\t\t\/\/Finding Base Implementation: mostly recently added implementation (not Advice)\n\t\t\tImplementation baseImplementation = null;\n\t\t\tfor(int i=cases.length-1; i>=0; i--) {\n\t\t\t\tif(currentPermutation.testBit(i)) {\n\t\t\t\t\tImplementation impl = cases[i].getImplementation();\n\t\t\t\t\tif(baseImplementation==null) baseImplementation=cases[i].getImplementation();\n\t\t\t\t\tif(!(impl instanceof Advice)) {\n\t\t\t\t\t\tbaseImplementation = impl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tElementMatcher.Junction<? super MethodDescription> matcher = any();\n\t\t\tImplementation implementation = baseImplementation;\n\t\t\tint i = cases.length-1;\n\t\t\tfor(; i>=0; i--) {\n\t\t\t\tCase c = cases[i];\n\t\t\t\tboolean caseIncluded = currentPermutation.testBit(i); \/\/ Included or excluded\n\t\t\t\tif(!caseIncluded) continue; \/\/Advice will not be included in any case: moving forward\n\t\t\t\tif(!(caseIncluded?hasMatchedMethods[i]:hasOpositeMatchedMethods[i])) break; \/\/No such methods at all\n\t\t\t\tmatcher = matcher.and(caseIncluded?c.getMatcher():not(c.getMatcher()));\n\t\t\t\tif(caseIncluded \n\t\t\t\t\t\t&& c.getImplementation() instanceof Advice\n\t\t\t\t\t\t&& c.getImplementation() != baseImplementation) {\n\t\t\t\t\timplementation = ((Advice)c.getImplementation()).wrap(implementation);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i<0)\n\t\t\t\tbuilder = builder.method(matcher).intercept(implementation);\n\t\t}\n\t\treturn builder;\n\t}","code_wo_comment":"public <T> DynamicType.Builder<T> apply(DynamicType.Builder<T> builder) {\n\t\tTypeDescription description = builder.toTypeDescription();\n\t\tList<MethodDescription> methods = getMethodDescriptionList(description);\n\t\tenhanceCasesByDynamicDefinitions(methods);\n\t\tbuilder = enhanceCasesByOverrides(builder, description, methods);\n\t\tif(cases.isEmpty()) return builder;\n\t\tCase[] cases = this.cases.toArray(new Case[this.cases.size()]);\n\t\n\t\tboolean[] hasMatchedMethods = new boolean[cases.length];\n\t\tboolean[] hasOpositeMatchedMethods = new boolean[cases.length];\n\t\tfor (int i=0; i<cases.length; i++) {\n\t\t\thasMatchedMethods[i] = hasMatch(methods, cases[i].getMatcher());\n\t\t\thasOpositeMatchedMethods[i] = hasMatch(methods, not(cases[i].getMatcher()));\n\t\t}\n\t\tBigInteger permutationsTotal = BigInteger.ONE.shiftLeft(cases.length).subtract(BigInteger.ONE);\n\t\tfor(BigInteger currentPermutation = BigInteger.ONE; \n\t\t\t\tcurrentPermutation.compareTo(permutationsTotal)<=0;\n\t\t\t\tcurrentPermutation = currentPermutation.add(BigInteger.ONE)) {\n\t\t\n\t\t\tImplementation baseImplementation = null;\n\t\t\tfor(int i=cases.length-1; i>=0; i--) {\n\t\t\t\tif(currentPermutation.testBit(i)) {\n\t\t\t\t\tImplementation impl = cases[i].getImplementation();\n\t\t\t\t\tif(baseImplementation==null) baseImplementation=cases[i].getImplementation();\n\t\t\t\t\tif(!(impl instanceof Advice)) {\n\t\t\t\t\t\tbaseImplementation = impl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tElementMatcher.Junction<? super MethodDescription> matcher = any();\n\t\t\tImplementation implementation = baseImplementation;\n\t\t\tint i = cases.length-1;\n\t\t\tfor(; i>=0; i--) {\n\t\t\t\tCase c = cases[i];\n\t\t\t\tboolean caseIncluded = currentPermutation.testBit(i);\n\t\t\t\tif(!caseIncluded) continue;\n\t\t\t\tif(!(caseIncluded?hasMatchedMethods[i]:hasOpositeMatchedMethods[i])) break;\n\t\t\t\tmatcher = matcher.and(caseIncluded?c.getMatcher():not(c.getMatcher()));\n\t\t\t\tif(caseIncluded \n\t\t\t\t\t\t&& c.getImplementation() instanceof Advice\n\t\t\t\t\t\t&& c.getImplementation() != baseImplementation) {\n\t\t\t\t\timplementation = ((Advice)c.getImplementation()).wrap(implementation);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i<0)\n\t\t\t\tbuilder = builder.method(matcher).intercept(implementation);\n\t\t}\n\t\treturn builder;\n\t}","cleancode":"public <t> dynamictype.builder<t> apply(dynamictype.builder<t> builder) { typedescription description = builder.totypedescription(); list<methoddescription> methods = getmethoddescriptionlist(description); enhancecasesbydynamicdefinitions(methods); builder = enhancecasesbyoverrides(builder, description, methods); if(cases.isempty()) return builder; case[] cases = this.cases.toarray(new case[this.cases.size()]); boolean[] hasmatchedmethods = new boolean[cases.length]; boolean[] hasopositematchedmethods = new boolean[cases.length]; for (int i=0; i<cases.length; i++) { hasmatchedmethods[i] = hasmatch(methods, cases[i].getmatcher()); hasopositematchedmethods[i] = hasmatch(methods, not(cases[i].getmatcher())); } biginteger permutationstotal = biginteger.one.shiftleft(cases.length).subtract(biginteger.one); for(biginteger currentpermutation = biginteger.one; currentpermutation.compareto(permutationstotal)<=0; currentpermutation = currentpermutation.add(biginteger.one)) { implementation baseimplementation = null; for(int i=cases.length-1; i>=0; i--) { if(currentpermutation.testbit(i)) { implementation impl = cases[i].getimplementation(); if(baseimplementation==null) baseimplementation=cases[i].getimplementation(); if(!(impl instanceof advice)) { baseimplementation = impl; break; } } } elementmatcher.junction<? super methoddescription> matcher = any(); implementation implementation = baseimplementation; int i = cases.length-1; for(; i>=0; i--) { case c = cases[i]; boolean caseincluded = currentpermutation.testbit(i); if(!caseincluded) continue; if(!(caseincluded?hasmatchedmethods[i]:hasopositematchedmethods[i])) break; matcher = matcher.and(caseincluded?c.getmatcher():not(c.getmatcher())); if(caseincluded && c.getimplementation() instanceof advice && c.getimplementation() != baseimplementation) { implementation = ((advice)c.getimplementation()).wrap(implementation); } } if(i<0) builder = builder.method(matcher).intercept(implementation); } return builder; }","repo":"OrienteerBAP\/Transponder","label":[0,1,0,0]}
{"id":30162,"original_code":"@Ignore\n    @Test\n    public void testDelete() throws Exception {\n        final Map<String, Object> headers = new HashMap<String, Object>();\n        \/\/ parameter type is String\n        headers.put(\"CamelGoogleDrive.fileId\", null);\n        \/\/ parameter type is String\n        headers.put(\"CamelGoogleDrive.parentId\", null);\n        final com.google.api.services.drive.Drive.Parents.Delete result = requestBodyAndHeaders(\"direct:\/\/DELETE\", null, headers);\n        assertNotNull(\"delete result\", result);\n        LOG.debug(\"delete: \" + result);\n    }","code_wo_comment":"@Ignore\n    @Test\n    public void testDelete() throws Exception {\n        final Map<String, Object> headers = new HashMap<String, Object>();\n       \n        headers.put(\"CamelGoogleDrive.fileId\", null);\n       \n        headers.put(\"CamelGoogleDrive.parentId\", null);\n        final com.google.api.services.drive.Drive.Parents.Delete result = requestBodyAndHeaders(\"direct:\/\/DELETE\", null, headers);\n        assertNotNull(\"delete result\", result);\n        LOG.debug(\"delete: \" + result);\n    }","cleancode":"@ignore @test public void testdelete() throws exception { final map<string, object> headers = new hashmap<string, object>(); headers.put(\"camelgoogledrive.fileid\", null); headers.put(\"camelgoogledrive.parentid\", null); final com.google.api.services.drive.drive.parents.delete result = requestbodyandheaders(\"direct:\/\/delete\", null, headers); assertnotnull(\"delete result\", result); log.debug(\"delete: \" + result); }","repo":"NelloCarotenuto\/Weakness-Detector-for-Java","label":[1,0,0,0]}
{"id":30229,"original_code":"@Test\n\tpublic void processMessage_shouldSetValue_CodedMatchingABooleanConceptForObsIfTheAnswerIs0Or1AndQuestionDatatypeIsCoded()\n\t        throws Exception {\n\t\tObsService os = Context.getObsService();\n\t\tString hl7string = \"MSH|^~\\\\&|FORMENTRY|AMRS.ELD|HL7LISTENER|AMRS.ELD|20080226102656||ORU^R01|JqnfhKKtouEz8kzTk6Zo|P|2.5|1||||||||16^AMRS.ELD.FORMID\\r\"\n\t\t        + \"PID|||7^^^^||Collet^Test^Chebaskwony||\\r\"\n\t\t        + \"PV1||O|1^Unknown Location||||1^Super User (1-8)|||||||||||||||||||||||||||||||||||||20080212|||||||V\\r\"\n\t\t        + \"ORC|RE||||||||20080226102537|1^Super User\\r\"\n\t\t        + \"OBR|1|||1238^MEDICAL RECORD OBSERVATIONS^99DCT\\r\"\n\t\t        + \"OBX|2|NM|21^CIVIL STATUS^99DCT||1|||||||||20080206\";\n\t\t\/\/ the expected question for the obs in the hl7 message has to be coded\n\t\tAssert.assertEquals(\"Coded\", Context.getConceptService().getConcept(21).getDatatype().getName());\n\t\tList<Obs> oldList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\n\t\tMessage hl7message = parser.parse(hl7string);\n\t\trouter.processMessage(hl7message);\n\t\t\/\/ hacky way to get the newly added obs and make tests on it\n\t\tList<Obs> newList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\n\t\tObs newObservation = null;\n\t\tfor (Obs newObs : newList) {\n\t\t\tif (!oldList.contains(newObs) && !newObs.isObsGrouping()) {\n\t\t\t\tnewObservation = newObs;\n\t\t\t}\n\t\t}\n\t\tAssert.assertEquals(Context.getConceptService().getTrueConcept(), newObservation.getValueCoded());\n\t}","code_wo_comment":"@Test\n\tpublic void processMessage_shouldSetValue_CodedMatchingABooleanConceptForObsIfTheAnswerIs0Or1AndQuestionDatatypeIsCoded()\n\t        throws Exception {\n\t\tObsService os = Context.getObsService();\n\t\tString hl7string = \"MSH|^~\\\\&|FORMENTRY|AMRS.ELD|HL7LISTENER|AMRS.ELD|20080226102656||ORU^R01|JqnfhKKtouEz8kzTk6Zo|P|2.5|1||||||||16^AMRS.ELD.FORMID\\r\"\n\t\t        + \"PID|||7^^^^||Collet^Test^Chebaskwony||\\r\"\n\t\t        + \"PV1||O|1^Unknown Location||||1^Super User (1-8)|||||||||||||||||||||||||||||||||||||20080212|||||||V\\r\"\n\t\t        + \"ORC|RE||||||||20080226102537|1^Super User\\r\"\n\t\t        + \"OBR|1|||1238^MEDICAL RECORD OBSERVATIONS^99DCT\\r\"\n\t\t        + \"OBX|2|NM|21^CIVIL STATUS^99DCT||1|||||||||20080206\";\n\t\n\t\tAssert.assertEquals(\"Coded\", Context.getConceptService().getConcept(21).getDatatype().getName());\n\t\tList<Obs> oldList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\n\t\tMessage hl7message = parser.parse(hl7string);\n\t\trouter.processMessage(hl7message);\n\t\n\t\tList<Obs> newList = os.getObservationsByPersonAndConcept(new Person(7), new Concept(21));\n\t\tObs newObservation = null;\n\t\tfor (Obs newObs : newList) {\n\t\t\tif (!oldList.contains(newObs) && !newObs.isObsGrouping()) {\n\t\t\t\tnewObservation = newObs;\n\t\t\t}\n\t\t}\n\t\tAssert.assertEquals(Context.getConceptService().getTrueConcept(), newObservation.getValueCoded());\n\t}","cleancode":"@test public void processmessage_shouldsetvalue_codedmatchingabooleanconceptforobsiftheansweris0or1andquestiondatatypeiscoded() throws exception { obsservice os = context.getobsservice(); string hl7string = \"msh|^~\\\\&|formentry|amrs.eld|hl7listener|amrs.eld|20080226102656||oru^r01|jqnfhkktouez8kztk6zo|p|2.5|1||||||||16^amrs.eld.formid\\r\" + \"pid|||7^^^^||collet^test^chebaskwony||\\r\" + \"pv1||o|1^unknown location||||1^super user (1-8)|||||||||||||||||||||||||||||||||||||20080212|||||||v\\r\" + \"orc|re||||||||20080226102537|1^super user\\r\" + \"obr|1|||1238^medical record observations^99dct\\r\" + \"obx|2|nm|21^civil status^99dct||1|||||||||20080206\"; assert.assertequals(\"coded\", context.getconceptservice().getconcept(21).getdatatype().getname()); list<obs> oldlist = os.getobservationsbypersonandconcept(new person(7), new concept(21)); message hl7message = parser.parse(hl7string); router.processmessage(hl7message); list<obs> newlist = os.getobservationsbypersonandconcept(new person(7), new concept(21)); obs newobservation = null; for (obs newobs : newlist) { if (!oldlist.contains(newobs) && !newobs.isobsgrouping()) { newobservation = newobs; } } assert.assertequals(context.getconceptservice().gettrueconcept(), newobservation.getvaluecoded()); }","repo":"RuiDTLima\/diffuzz","label":[1,0,0,0]}
{"id":22244,"original_code":"private static void processPendingMoveToTrash(final Context context, Store remoteStore,\n            Mailbox newMailbox, EmailContent.Message oldMessage,\n            final EmailContent.Message newMessage) throws MessagingException {\n        \/\/ 0. No remote move if the message is local-only\n        if (newMessage.mServerId == null || newMessage.mServerId.equals(\"\")\n                || newMessage.mServerId.startsWith(LOCAL_SERVERID_PREFIX)) {\n            return;\n        }\n        \/\/ 1. Escape early if we can't find the local mailbox\n        \/\/ TODO smaller projection here\n        Mailbox oldMailbox = getRemoteMailboxForMessage(context, oldMessage);\n        if (oldMailbox == null) {\n            \/\/ can't find old mailbox, it may have been deleted.  just return.\n            return;\n        }\n        \/\/ 2. We don't support delete-from-trash here\n        if (oldMailbox.mType == Mailbox.TYPE_TRASH) {\n            return;\n        }\n        \/\/ The rest of this method handles server-side deletion\n        \/\/ 4.  Find the remote mailbox (that we deleted from), and open it\n        Folder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);\n        if (!remoteFolder.exists()) {\n            return;\n        }\n        remoteFolder.open(OpenMode.READ_WRITE);\n        if (remoteFolder.getMode() != OpenMode.READ_WRITE) {\n            remoteFolder.close(false);\n            return;\n        }\n        \/\/ 5. Find the remote original message\n        Message remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);\n        if (remoteMessage == null) {\n            remoteFolder.close(false);\n            return;\n        }\n        \/\/ 6. Find the remote trash folder, and create it if not found\n        Folder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);\n        if (!remoteTrashFolder.exists()) {\n            \/*\n             * If the remote trash folder doesn't exist we try to create it.\n             *\/\n            remoteTrashFolder.create(FolderType.HOLDS_MESSAGES);\n        }\n        \/\/ 7. Try to copy the message into the remote trash folder\n        \/\/ Note, this entire section will be skipped for POP3 because there's no remote trash\n        if (remoteTrashFolder.exists()) {\n            \/*\n             * Because remoteTrashFolder may be new, we need to explicitly open it\n             *\/\n            remoteTrashFolder.open(OpenMode.READ_WRITE);\n            if (remoteTrashFolder.getMode() != OpenMode.READ_WRITE) {\n                remoteFolder.close(false);\n                remoteTrashFolder.close(false);\n                return;\n            }\n            remoteFolder.copyMessages(new Message[] { remoteMessage }, remoteTrashFolder,\n                    new Folder.MessageUpdateCallbacks() {\n                @Override\n                public void onMessageUidChange(Message message, String newUid) {\n                    \/\/ update the UID in the local trash folder, because some stores will\n                    \/\/ have to change it when copying to remoteTrashFolder\n                    ContentValues cv = new ContentValues();\n                    cv.put(MessageColumns.SERVER_ID, newUid);\n                    context.getContentResolver().update(newMessage.getUri(), cv, null, null);\n                }\n                \/**\n                 * This will be called if the deleted message doesn't exist and can't be\n                 * deleted (e.g. it was already deleted from the server.)  In this case,\n                 * attempt to delete the local copy as well.\n                 *\/\n                @Override\n                public void onMessageNotFound(Message message) {\n                    context.getContentResolver().delete(newMessage.getUri(), null, null);\n                }\n            });\n            remoteTrashFolder.close(false);\n        }\n        \/\/ 8. Delete the message from the remote source folder\n        remoteMessage.setFlag(Flag.DELETED, true);\n        remoteFolder.expunge();\n        remoteFolder.close(false);\n    }","code_wo_comment":"private static void processPendingMoveToTrash(final Context context, Store remoteStore,\n            Mailbox newMailbox, EmailContent.Message oldMessage,\n            final EmailContent.Message newMessage) throws MessagingException {\n       \n        if (newMessage.mServerId == null || newMessage.mServerId.equals(\"\")\n                || newMessage.mServerId.startsWith(LOCAL_SERVERID_PREFIX)) {\n            return;\n        }\n       \n       \n        Mailbox oldMailbox = getRemoteMailboxForMessage(context, oldMessage);\n        if (oldMailbox == null) {\n           \n            return;\n        }\n       \n        if (oldMailbox.mType == Mailbox.TYPE_TRASH) {\n            return;\n        }\n       \n       \n        Folder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);\n        if (!remoteFolder.exists()) {\n            return;\n        }\n        remoteFolder.open(OpenMode.READ_WRITE);\n        if (remoteFolder.getMode() != OpenMode.READ_WRITE) {\n            remoteFolder.close(false);\n            return;\n        }\n       \n        Message remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);\n        if (remoteMessage == null) {\n            remoteFolder.close(false);\n            return;\n        }\n       \n        Folder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);\n        if (!remoteTrashFolder.exists()) {\n           \n            remoteTrashFolder.create(FolderType.HOLDS_MESSAGES);\n        }\n       \n       \n        if (remoteTrashFolder.exists()) {\n           \n            remoteTrashFolder.open(OpenMode.READ_WRITE);\n            if (remoteTrashFolder.getMode() != OpenMode.READ_WRITE) {\n                remoteFolder.close(false);\n                remoteTrashFolder.close(false);\n                return;\n            }\n            remoteFolder.copyMessages(new Message[] { remoteMessage }, remoteTrashFolder,\n                    new Folder.MessageUpdateCallbacks() {\n                @Override\n                public void onMessageUidChange(Message message, String newUid) {\n                   \n                   \n                    ContentValues cv = new ContentValues();\n                    cv.put(MessageColumns.SERVER_ID, newUid);\n                    context.getContentResolver().update(newMessage.getUri(), cv, null, null);\n                }\n               \n                @Override\n                public void onMessageNotFound(Message message) {\n                    context.getContentResolver().delete(newMessage.getUri(), null, null);\n                }\n            });\n            remoteTrashFolder.close(false);\n        }\n       \n        remoteMessage.setFlag(Flag.DELETED, true);\n        remoteFolder.expunge();\n        remoteFolder.close(false);\n    }","cleancode":"private static void processpendingmovetotrash(final context context, store remotestore, mailbox newmailbox, emailcontent.message oldmessage, final emailcontent.message newmessage) throws messagingexception { if (newmessage.mserverid == null || newmessage.mserverid.equals(\"\") || newmessage.mserverid.startswith(local_serverid_prefix)) { return; } mailbox oldmailbox = getremotemailboxformessage(context, oldmessage); if (oldmailbox == null) { return; } if (oldmailbox.mtype == mailbox.type_trash) { return; } folder remotefolder = remotestore.getfolder(oldmailbox.mserverid); if (!remotefolder.exists()) { return; } remotefolder.open(openmode.read_write); if (remotefolder.getmode() != openmode.read_write) { remotefolder.close(false); return; } message remotemessage = remotefolder.getmessage(oldmessage.mserverid); if (remotemessage == null) { remotefolder.close(false); return; } folder remotetrashfolder = remotestore.getfolder(newmailbox.mserverid); if (!remotetrashfolder.exists()) { remotetrashfolder.create(foldertype.holds_messages); } if (remotetrashfolder.exists()) { remotetrashfolder.open(openmode.read_write); if (remotetrashfolder.getmode() != openmode.read_write) { remotefolder.close(false); remotetrashfolder.close(false); return; } remotefolder.copymessages(new message[] { remotemessage }, remotetrashfolder, new folder.messageupdatecallbacks() { @override public void onmessageuidchange(message message, string newuid) { contentvalues cv = new contentvalues(); cv.put(messagecolumns.server_id, newuid); context.getcontentresolver().update(newmessage.geturi(), cv, null, null); } @override public void onmessagenotfound(message message) { context.getcontentresolver().delete(newmessage.geturi(), null, null); } }); remotetrashfolder.close(false); } remotemessage.setflag(flag.deleted, true); remotefolder.expunge(); remotefolder.close(false); }","repo":"Keneral\/apackages","label":[1,0,0,0]}
{"id":14054,"original_code":"@Override\n  public void enableDebug() {\n    \/\/ Turn on Crunch runtime error catching.\n    \/\/TODO: allow configurable\n    getConfiguration().setBoolean(\"crunch.debug\", true);\n  }","code_wo_comment":"@Override\n  public void enableDebug() {\n   \n   \n    getConfiguration().setBoolean(\"crunch.debug\", true);\n  }","cleancode":"@override public void enabledebug() { getconfiguration().setboolean(\"crunch.debug\", true); }","repo":"KeerthiYanda91\/crunch","label":[1,0,0,0]}
{"id":14145,"original_code":"private Optional<DecodedJWT> authenticateRequest(HttpServletRequest req, HttpServletResponse resp) {\n        String authHeader = StringUtil.trimToEmpty(req.getHeader(\"Authorization\"));\n        String authBearerToken = authHeader.replaceFirst(\"^Bearer \", \"\");\n        if (authHeader.isEmpty()) {\n            LOG.warn(\"No Authorization header in request\");\n            resp.setStatus(HTTP_FORBIDDEN);\n            return Optional.empty();\n        }\n        if (authBearerToken.isEmpty()) {\n            LOG.warn(\"No Authorization Bearer token in request\");\n            resp.setStatus(HTTP_FORBIDDEN);\n            return Optional.empty();\n        }\n        DecodedJWT decodedJWT = JWT.decode(authBearerToken);\n        RSAKeyProvider keyProvider = new RSAKeyProvider() {\n            @Override\n            public RSAPublicKey getPublicKeyById(String keyId) {\n                Optional<JSONWebKey> key = jwtKeyProvider.getKey(keyId);\n                if (!key.isPresent()) {\n                    \/\/ TODO what do?\n                    resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                    return null;\n                }\n                try {\n                    \/\/ https:\/\/github.com\/auth0\/jwks-rsa-java\/blob\/master\/src\/main\/java\/com\/auth0\/jwk\/Jwk.java#L171\n                    KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n                    JSONWebKey jwk = key.get();\n                    BigInteger modulus = new BigInteger(1, Base64.getUrlDecoder().decode(jwk.n));\n                    BigInteger exponent = new BigInteger(1, Base64.getUrlDecoder().decode(jwk.e));\n                    return (RSAPublicKey) keyFactory.generatePublic(new RSAPublicKeySpec(modulus, exponent));\n\/\/                    String keyDataString = key.get().x509CertificateChain.get(0);\n\/\/                    byte[] keyData = Base64.getDecoder().decode(keyDataString.getBytes(StandardCharsets.UTF_8));\n\/\/                    return (RSAPublicKey) keyFactory.generatePublic(new X509EncodedKeySpec(keyData));\n                } catch (InvalidKeySpecException | NoSuchAlgorithmException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            @Override\n            public RSAPrivateKey getPrivateKey() {\n                return null;\n            }\n            @Override\n            public String getPrivateKeyId() {\n                return null;\n            }\n        };\n        Algorithm algorithm;\n        switch (decodedJWT.getAlgorithm()) {\n            case \"RS256\":\n                algorithm = Algorithm.RSA256(keyProvider);\n                break;\n            default:\n                resp.setStatus(HTTP_BAD_REQUEST);\n                LOG.error(\"Unknown algorithm {}\", decodedJWT.getAlgorithm());\n                return Optional.empty();\n        }\n        JWTVerifier jwtVerifier = JWT.require(algorithm)\n                .acceptLeeway(Duration.ofMinutes(5).getSeconds())\n                .withIssuer(\"https:\/\/api.botframework.com\")\n                \/\/ .withAudience(ap) TODO verify audience if the app id\n                .build();\n        jwtVerifier.verify(authBearerToken);\n        return Optional.of(decodedJWT);\n    }","code_wo_comment":"private Optional<DecodedJWT> authenticateRequest(HttpServletRequest req, HttpServletResponse resp) {\n        String authHeader = StringUtil.trimToEmpty(req.getHeader(\"Authorization\"));\n        String authBearerToken = authHeader.replaceFirst(\"^Bearer \", \"\");\n        if (authHeader.isEmpty()) {\n            LOG.warn(\"No Authorization header in request\");\n            resp.setStatus(HTTP_FORBIDDEN);\n            return Optional.empty();\n        }\n        if (authBearerToken.isEmpty()) {\n            LOG.warn(\"No Authorization Bearer token in request\");\n            resp.setStatus(HTTP_FORBIDDEN);\n            return Optional.empty();\n        }\n        DecodedJWT decodedJWT = JWT.decode(authBearerToken);\n        RSAKeyProvider keyProvider = new RSAKeyProvider() {\n            @Override\n            public RSAPublicKey getPublicKeyById(String keyId) {\n                Optional<JSONWebKey> key = jwtKeyProvider.getKey(keyId);\n                if (!key.isPresent()) {\n                   \n                    resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                    return null;\n                }\n                try {\n                   \n                    KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n                    JSONWebKey jwk = key.get();\n                    BigInteger modulus = new BigInteger(1, Base64.getUrlDecoder().decode(jwk.n));\n                    BigInteger exponent = new BigInteger(1, Base64.getUrlDecoder().decode(jwk.e));\n                    return (RSAPublicKey) keyFactory.generatePublic(new RSAPublicKeySpec(modulus, exponent));\n                } catch (InvalidKeySpecException | NoSuchAlgorithmException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            @Override\n            public RSAPrivateKey getPrivateKey() {\n                return null;\n            }\n            @Override\n            public String getPrivateKeyId() {\n                return null;\n            }\n        };\n        Algorithm algorithm;\n        switch (decodedJWT.getAlgorithm()) {\n            case \"RS256\":\n                algorithm = Algorithm.RSA256(keyProvider);\n                break;\n            default:\n                resp.setStatus(HTTP_BAD_REQUEST);\n                LOG.error(\"Unknown algorithm {}\", decodedJWT.getAlgorithm());\n                return Optional.empty();\n        }\n        JWTVerifier jwtVerifier = JWT.require(algorithm)\n                .acceptLeeway(Duration.ofMinutes(5).getSeconds())\n                .withIssuer(\"https:\/\/api.botframework.com\")\n               \n                .build();\n        jwtVerifier.verify(authBearerToken);\n        return Optional.of(decodedJWT);\n    }","cleancode":"private optional<decodedjwt> authenticaterequest(httpservletrequest req, httpservletresponse resp) { string authheader = stringutil.trimtoempty(req.getheader(\"authorization\")); string authbearertoken = authheader.replacefirst(\"^bearer \", \"\"); if (authheader.isempty()) { log.warn(\"no authorization header in request\"); resp.setstatus(http_forbidden); return optional.empty(); } if (authbearertoken.isempty()) { log.warn(\"no authorization bearer token in request\"); resp.setstatus(http_forbidden); return optional.empty(); } decodedjwt decodedjwt = jwt.decode(authbearertoken); rsakeyprovider keyprovider = new rsakeyprovider() { @override public rsapublickey getpublickeybyid(string keyid) { optional<jsonwebkey> key = jwtkeyprovider.getkey(keyid); if (!key.ispresent()) { resp.setstatus(httpservletresponse.sc_bad_request); return null; } try { keyfactory keyfactory = keyfactory.getinstance(\"rsa\"); jsonwebkey jwk = key.get(); biginteger modulus = new biginteger(1, base64.geturldecoder().decode(jwk.n)); biginteger exponent = new biginteger(1, base64.geturldecoder().decode(jwk.e)); return (rsapublickey) keyfactory.generatepublic(new rsapublickeyspec(modulus, exponent)); } catch (invalidkeyspecexception | nosuchalgorithmexception e) { throw new runtimeexception(e); } } @override public rsaprivatekey getprivatekey() { return null; } @override public string getprivatekeyid() { return null; } }; algorithm algorithm; switch (decodedjwt.getalgorithm()) { case \"rs256\": algorithm = algorithm.rsa256(keyprovider); break; default: resp.setstatus(http_bad_request); log.error(\"unknown algorithm {}\", decodedjwt.getalgorithm()); return optional.empty(); } jwtverifier jwtverifier = jwt.require(algorithm) .acceptleeway(duration.ofminutes(5).getseconds()) .withissuer(\"https:\/\/api.botframework.com\") .build(); jwtverifier.verify(authbearertoken); return optional.of(decodedjwt); }","repo":"Mustard\/chatterbox","label":[1,1,0,0]}
{"id":22340,"original_code":"public List<DccdSB> getSearchBeans()\n\t{\n\t\tList<DccdSB> searchBeans = new ArrayList<DccdSB>();\n\t\tif (!hasTridas())\n\t\t\treturn searchBeans; \/\/ just an empty list\n\t\t\/\/ get all the ObjectEntity's in the tree\n\t\tList<Entity> entities = getSubTreeAsList();\n\t\tfor (Entity entity : entities)\n\t\t{\n\t\t\t\/\/ only objects, exclude derived series\n\t\t\tif (entity instanceof ObjectEntity)\n\t\t\t{\n\t\t\t\t\/\/ create a bean\n\t\t\t\tDccdSB searchBean = new DccdObjectSB();\n\t\t\t\t\/\/ fill it\n\t\t\t\t\/\/ first with the project info, maybe this can be done more efficiently\n\t\t\t\t\/\/ because same conversions are done for every Object again\n\t\t\t\tsearchBean = fillSearchBean(searchBean);\n\t\t\t\t\/\/ then the object info\n\t\t\t\tsearchBean = entity.fillSearchBean(searchBean);\n\t\t\t\t\/\/ all the ObjectEntities subentities must fill this bean as well\n\t\t\t\t\/\/ but not Objects?\n\t\t\t\tList<Entity> subentities = entity.getSubTreeAsList();\n\t\t\t\tfor (Entity subentity : subentities)\n\t\t\t\t{\n\t\t\t\t\tsearchBean = subentity.fillSearchBean(searchBean);\n\t\t\t\t}\n\t\t\t\t\/\/ Note id should be the (system) identifier in the repository (sid)\n\t\t\t\t\/\/ just hoping that is is set correctly when read from the repository!!!\n\t\t\t\tsearchBean.setDatastreamId(entity.getId());\/\/ should be the repository id for this peace of info\n\t\t\t\t\/\/ add to the list\n\t\t\t\tsearchBeans.add(searchBean);\n\t\t\t}\n\t\t}\n\t\treturn searchBeans;\n\t}","code_wo_comment":"public List<DccdSB> getSearchBeans()\n\t{\n\t\tList<DccdSB> searchBeans = new ArrayList<DccdSB>();\n\t\tif (!hasTridas())\n\t\t\treturn searchBeans;\n\t\n\t\tList<Entity> entities = getSubTreeAsList();\n\t\tfor (Entity entity : entities)\n\t\t{\n\t\t\n\t\t\tif (entity instanceof ObjectEntity)\n\t\t\t{\n\t\t\t\n\t\t\t\tDccdSB searchBean = new DccdObjectSB();\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\tsearchBean = fillSearchBean(searchBean);\n\t\t\t\n\t\t\t\tsearchBean = entity.fillSearchBean(searchBean);\n\t\t\t\n\t\t\t\n\t\t\t\tList<Entity> subentities = entity.getSubTreeAsList();\n\t\t\t\tfor (Entity subentity : subentities)\n\t\t\t\t{\n\t\t\t\t\tsearchBean = subentity.fillSearchBean(searchBean);\n\t\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\tsearchBean.setDatastreamId(entity.getId())\n\t\t\t\n\t\t\t\tsearchBeans.add(searchBean);\n\t\t\t}\n\t\t}\n\t\treturn searchBeans;\n\t}","cleancode":"public list<dccdsb> getsearchbeans() { list<dccdsb> searchbeans = new arraylist<dccdsb>(); if (!hastridas()) return searchbeans; list<entity> entities = getsubtreeaslist(); for (entity entity : entities) { if (entity instanceof objectentity) { dccdsb searchbean = new dccdobjectsb(); searchbean = fillsearchbean(searchbean); searchbean = entity.fillsearchbean(searchbean); list<entity> subentities = entity.getsubtreeaslist(); for (entity subentity : subentities) { searchbean = subentity.fillsearchbean(searchbean); } searchbean.setdatastreamid(entity.getid()) searchbeans.add(searchbean); } } return searchbeans; }","repo":"PaulBoon\/dccd-lib","label":[1,0,0,0]}
{"id":22391,"original_code":"public Integer getLastmodifiedby() {\n    return this.lastmodifiedby;\n  }","code_wo_comment":"public Integer getLastmodifiedby() {\n    return this.lastmodifiedby;\n  }","cleancode":"public integer getlastmodifiedby() { return this.lastmodifiedby; }","repo":"PLOS\/named-entity.service","label":[0,0,1,0]}
{"id":22404,"original_code":"@Override\n    public Loader<Cursor> onCreateLoader(int id, Bundle args) {\n        \/\/TODO Need a fix to make sure the value is not null\n        String locationSetting = Utility.getPreferredLocation(getActivity());\n        \/\/Sort order: Ascending by date\n        String sortOrder = WeatherContract.WeatherEntry.COLUMN_DATE + \" ASC\";\n        \/\/Build the Uri needed for the query\n        Uri weatherForLocationUri = WeatherContract.WeatherEntry.buildWeatherLocationWithStartDate(locationSetting,\n                System.currentTimeMillis());\n        \/\/Create a cursor loader\n        CursorLoader cursorLoader = new CursorLoader(getActivity(),\n                weatherForLocationUri,\n                FORECAST_COLUMNS,\n                null,\n                null,\n                sortOrder);\n        return cursorLoader;\n    }","code_wo_comment":"@Override\n    public Loader<Cursor> onCreateLoader(int id, Bundle args) {\n       \n        String locationSetting = Utility.getPreferredLocation(getActivity());\n       \n        String sortOrder = WeatherContract.WeatherEntry.COLUMN_DATE + \" ASC\";\n       \n        Uri weatherForLocationUri = WeatherContract.WeatherEntry.buildWeatherLocationWithStartDate(locationSetting,\n                System.currentTimeMillis());\n       \n        CursorLoader cursorLoader = new CursorLoader(getActivity(),\n                weatherForLocationUri,\n                FORECAST_COLUMNS,\n                null,\n                null,\n                sortOrder);\n        return cursorLoader;\n    }","cleancode":"@override public loader<cursor> oncreateloader(int id, bundle args) { string locationsetting = utility.getpreferredlocation(getactivity()); string sortorder = weathercontract.weatherentry.column_date + \" asc\"; uri weatherforlocationuri = weathercontract.weatherentry.buildweatherlocationwithstartdate(locationsetting, system.currenttimemillis()); cursorloader cursorloader = new cursorloader(getactivity(), weatherforlocationuri, forecast_columns, null, null, sortorder); return cursorloader; }","repo":"SafwanAhmad\/Sunshine-Version-2","label":[0,0,1,0]}
{"id":22471,"original_code":"@Test\n\tpublic void inexistentItemTest() {\n\t\tString searchQuery = \"awobsafhtui5we5t57zuo77izufh\";\t\t\n\t\tSearchResultsPage searchQueryPage = startPage.getSearchComponent().searchFor(searchQuery);\n\t\tString searchQueryDisplayText = searchQueryPage.getItemSearchQuery();\n\t\tAssert.assertEquals(searchQueryDisplayText, searchQuery);\n\t\tint numResults = searchQueryPage.getResultCount();\n\t\tAssert.assertEquals(numResults, 0, \"Non-matching results were displayed.\");\n\t}","code_wo_comment":"@Test\n\tpublic void inexistentItemTest() {\n\t\tString searchQuery = \"awobsafhtui5we5t57zuo77izufh\";\t\t\n\t\tSearchResultsPage searchQueryPage = startPage.getSearchComponent().searchFor(searchQuery);\n\t\tString searchQueryDisplayText = searchQueryPage.getItemSearchQuery();\n\t\tAssert.assertEquals(searchQueryDisplayText, searchQuery);\n\t\tint numResults = searchQueryPage.getResultCount();\n\t\tAssert.assertEquals(numResults, 0, \"Non-matching results were displayed.\");\n\t}","cleancode":"@test public void inexistentitemtest() { string searchquery = \"awobsafhtui5we5t57zuo77izufh\"; searchresultspage searchquerypage = startpage.getsearchcomponent().searchfor(searchquery); string searchquerydisplaytext = searchquerypage.getitemsearchquery(); assert.assertequals(searchquerydisplaytext, searchquery); int numresults = searchquerypage.getresultcount(); assert.assertequals(numresults, 0, \"non-matching results were displayed.\"); }","repo":"MPDL\/imeji-gui-testing","label":[0,1,0,0]}
{"id":30799,"original_code":"public final Node createView(OpenedFile file, String path) {\n        Node node = createView0(file, path);\n        node.getProperties().put(\"editor\", this);\n        node.getProperties().put(\"file\", file); \/\/ probably a memory leak\n        node.getProperties().put(\"path\", path);\n        return node;\n    }","code_wo_comment":"public final Node createView(OpenedFile file, String path) {\n        Node node = createView0(file, path);\n        node.getProperties().put(\"editor\", this);\n        node.getProperties().put(\"file\", file);\n        node.getProperties().put(\"path\", path);\n        return node;\n    }","cleancode":"public final node createview(openedfile file, string path) { node node = createview0(file, path); node.getproperties().put(\"editor\", this); node.getproperties().put(\"file\", file); node.getproperties().put(\"path\", path); return node; }","repo":"MiniDigger\/standalone-app","label":[0,0,1,0]}
{"id":30822,"original_code":"public void checkBookmarks() throws IOException {\n        for (Bookmark bookmark : bookmarksService.getBookmarks()) {\n            bookmarksService.doCheck(bookmark);\n            JavaFxUtils.getController(BookmarksController.class).bookmarksTableView.refresh();\n        }\n        JavaFxUtils.getController(BookmarksController.class).tableView.setUserData(null);\n        JavaFxUtils.getController(BookmarksController.class).webView.setUserData(null);\n        \/\/TODO refresh current bookmark if not SAME\n        if (currentBookmark != null\/* && JavaFxUtils.currentBookmark.getStatus() == BookmarkStatus.CHANGED*\/) {\n            JavaFxUtils.getController(BookmarksController.class).refresh();\n        }\n    }","code_wo_comment":"public void checkBookmarks() throws IOException {\n        for (Bookmark bookmark : bookmarksService.getBookmarks()) {\n            bookmarksService.doCheck(bookmark);\n            JavaFxUtils.getController(BookmarksController.class).bookmarksTableView.refresh();\n        }\n        JavaFxUtils.getController(BookmarksController.class).tableView.setUserData(null);\n        JavaFxUtils.getController(BookmarksController.class).webView.setUserData(null);\n       \n        if (currentBookmark != nul) {\n            JavaFxUtils.getController(BookmarksController.class).refresh();\n        }\n    }","cleancode":"public void checkbookmarks() throws ioexception { for (bookmark bookmark : bookmarksservice.getbookmarks()) { bookmarksservice.docheck(bookmark); javafxutils.getcontroller(bookmarkscontroller.class).bookmarkstableview.refresh(); } javafxutils.getcontroller(bookmarkscontroller.class).tableview.setuserdata(null); javafxutils.getcontroller(bookmarkscontroller.class).webview.setuserdata(null); if (currentbookmark != nul) { javafxutils.getcontroller(bookmarkscontroller.class).refresh(); } }","repo":"LeonisX\/jSite-Watcher","label":[0,1,0,0]}
{"id":22752,"original_code":"public void remove( )\n\t{\n\t\t\/\/ TODO Add remove operation support.\n\t}","code_wo_comment":"public void remove( )\n\t{\n\t\n\t}","cleancode":"public void remove( ) { }","repo":"JamesCao2048\/BlizzardData","label":[0,1,0,0]}
{"id":30989,"original_code":"public String longestPalindrome(String s) {\n        \/\/ TODO\uff1awrite your code here\n        return \"\";\n    }","code_wo_comment":"public String longestPalindrome(String s) {\n              return \"\";\n    }","cleancode":"public string longestpalindrome(string s) { return \"\"; }","repo":"MessierObject111\/algorithms-playground","label":[0,1,0,0]}
{"id":30992,"original_code":"public File executeOptimization() throws IOException, InterruptedException {\n            final String path = workingFile.getCanonicalPath();\n            \/\/ FIXME Handle the ImageFileOptimizationException in one of the optimizations so it does not impact the other optimizations.\n            return executePngquant(executeOptipng(executePngout(executeAdvpng(executePngquant(executeOptipng(executePngout(executeAdvpng(workingFile, path), path), path), path), path), path), path), path);\n        }","code_wo_comment":"public File executeOptimization() throws IOException, InterruptedException {\n            final String path = workingFile.getCanonicalPath();\n           \n            return executePngquant(executeOptipng(executePngout(executeAdvpng(executePngquant(executeOptipng(executePngout(executeAdvpng(workingFile, path), path), path), path), path), path), path), path);\n        }","cleancode":"public file executeoptimization() throws ioexception, interruptedexception { final string path = workingfile.getcanonicalpath(); return executepngquant(executeoptipng(executepngout(executeadvpng(executepngquant(executeoptipng(executepngout(executeadvpng(workingfile, path), path), path), path), path), path), path), path); }","repo":"MatthewJuliusScott\/ImageOptimization","label":[1,0,0,0]}
{"id":23231,"original_code":"@Test\n  public void testValueOfJ() {\n    \/\/ workaround to register this test as covering some part of the testee.\n    \/\/ static variable access does not currently register as coverage . . .\n    HasMutableStaticInitializer.noticeMe();\n    assertEquals(101, HasMutableStaticInitializer.j);\n  }","code_wo_comment":"@Test\n  public void testValueOfJ() {\n   \n   \n    HasMutableStaticInitializer.noticeMe();\n    assertEquals(101, HasMutableStaticInitializer.j);\n  }","cleancode":"@test public void testvalueofj() { hasmutablestaticinitializer.noticeme(); assertequals(101, hasmutablestaticinitializer.j); }","repo":"Programming-Systems-Lab\/pitest","label":[0,1,0,0]}
{"id":31477,"original_code":"@Test\n  public void testLineOfCaller() {\n    assumeStackTraceDetailsAvailable();\n    DynamicConverter<ILoggingEvent> converter = new LineOfCallerConverter();\n    StringBuilder buf = new StringBuilder();\n    converter.write(buf, le);\n    \/\/ the number below should be the line number of the previous line\n    assertEquals(\"78\", buf.toString());\n    \/\/ TODO: Refactor this test so that it does not depend on the actual line numbers of this file\n  }","code_wo_comment":"@Test\n  public void testLineOfCaller() {\n    assumeStackTraceDetailsAvailable();\n    DynamicConverter<ILoggingEvent> converter = new LineOfCallerConverter();\n    StringBuilder buf = new StringBuilder();\n    converter.write(buf, le);\n   \n    assertEquals(\"78\", buf.toString());\n   \n  }","cleancode":"@test public void testlineofcaller() { assumestacktracedetailsavailable(); dynamicconverter<iloggingevent> converter = new lineofcallerconverter(); stringbuilder buf = new stringbuilder(); converter.write(buf, le); assertequals(\"78\", buf.tostring()); }","repo":"LinZong\/logback-android","label":[0,0,0,1]}
{"id":23314,"original_code":"@Override\n    public void runOpMode() throws InterruptedException {\n\/*\n        Initialize the setDrivePowers system variables.  The init() methods of our hardware class\n        does all the work:\n         *\/\n        FtcDashboard dashboard = FtcDashboard.getInstance();\n        Telemetry dashboardTelemetry = dashboard.getTelemetry();\n        robot.init(hardwareMap, this, true, false);\n        \/*\n        Init Delay Option Select:\n        *\/\n        \/\/ After init is pushed but before Start we can change the delay using dpad up\/down \/\/\n        delayTimer.reset();\n        \/\/ Runs a loop to change certain settings while we wait to start\n        while (!opModeIsActive()) {\n            if (this.isStopRequested()) {\n                \/\/ Leave the loop if STOP is pressed\n                return;\n            }\n            if (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {\n                \/\/ Increases the amount of time we wait\n                timeDelay += 1;\n                delayTimer.reset();\n            }\n            if (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n                \/\/ Decreases the amount of time we wait\n                if (timeDelay > 0) {\n                    \/\/ No such thing as negative time\n                    timeDelay -= 1;\n                }\n                delayTimer.reset();\n            }\n            if (((gamepad1.x) && delayTimer.seconds() > 0.8)) {\n                \/\/ Changes Alliance Sides\n                if (isRedAlliance) {\n                    isRedAlliance = false;\n                    robot.isRedAlliance = false;\n                } else {\n                    isRedAlliance = true;\n                    robot.isRedAlliance = true;\n                }\n                delayTimer.reset();\n            }\n            \/**\n             * LED code:\n             *\/\n            if (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.NONE) {\n                robot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_LAVA_PALETTE);\n            }\n            if (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.ONE) {\n                robot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_OCEAN_PALETTE);\n            }\n            if (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.FOUR) {\n                robot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_PARTY_PALETTE);\n            }\n            \/**\n             * Telemetry while waiting for PLAY:\n             *\/\n            telemetry.addData(\"Delay Timer: \", timeDelay);\n            if (isRedAlliance) {\n                telemetry.addData(\"Alliance: \", \"Red\");\n            } else {\n                telemetry.addData(\"Alliance: \", \"Blue\");\n            }\n            telemetry.addData(\"Num of Rings\", \"%s\",robot.eyes.getNumRings().toString());\n            dashboardTelemetry.addData(\"Num of Rings\", \"%s\",robot.eyes.getNumRings().toString());\n            dashboardTelemetry.addData(\"Analysis\", \"%d\", robot.eyes.pipeline.getAnalysis());\n            dashboardTelemetry.update();\n            telemetry.update();\n            \/**\n             * We don't need a \"waitForStart()\" since we've been running our own\n             * loop all this time so that we can make some changes.\n             *\/\n        }\n        CatHW_Vision.UltimateGoalPipeline.numRings numRings = robot.eyes.getNumRings();\n        \/**\n         * Runs after hit start:\n         * DO STUFF FOR the OPMODE!!!\n         *\/\n        \/**\n         * Init the IMU after play so that it is not offset after\n         * remaining idle for a minute or two...\n         *\/\n        robot.driveClassic.IMU_Init();\n        \/\/ Time Delay:\n        robot.robotWait(timeDelay);\n        robot.driveOdo.quickDrive(-4,48,0.5, 0,3.0);\n        for (int i = 0; i < 5; i++) {\n            robot.robotWait(5);\n            Log.d(\"catbot\", String.format(\"Translate  Time wait    current %.2f %.2f %.1f \",\n                    robot.driveOdo.updatesThread.positionUpdate.returnXInches(),\n                    robot.driveOdo.updatesThread.positionUpdate.returnYInches(),\n                    robot.driveOdo.updatesThread.positionUpdate.returnOrientation()\n                    ));\n            robot.driveOdo.quickDrive( -4,96,0.8, 0,5.0);\n            robot.driveOdo.quickDrive(-52,96,0.8, 0,5.0);\n            robot.driveOdo.quickDrive(-52,48,0.8, 0,5.0);\n            robot.driveOdo.quickDrive( -4,48,0.8, 0,5.0);\n        }\n        \/*\n        for (int i = 0; i <= 5; i++) {\n            robot.robotWait(5);\n            robot.driveOdo.quickDrive( -4,96,0.3, -90,3.0);\n            robot.driveOdo.quickDrive(-52,96,0.3, 0,3.0);\n            robot.driveOdo.quickDrive(-52,48,0.3, 90,3.0);\n            robot.driveOdo.quickDrive( -4,48,0.3, 0,3.0);\n        }\n*\/\n        robot.driveOdo.updatesThread.stop();\n    }","code_wo_comment":"@Override\n    public void runOpMode() throws InterruptedException {\n        FtcDashboard dashboard = FtcDashboard.getInstance();\n        Telemetry dashboardTelemetry = dashboard.getTelemetry();\n        robot.init(hardwareMap, this, true, false);\n       \n       \n        delayTimer.reset();\n       \n        while (!opModeIsActive()) {\n            if (this.isStopRequested()) {\n               \n                return;\n            }\n            if (gamepad1.dpad_up && (delayTimer.seconds() > 0.8)) {\n               \n                timeDelay += 1;\n                delayTimer.reset();\n            }\n            if (gamepad1.dpad_down && (delayTimer.seconds() > 0.8)) {\n               \n                if (timeDelay > 0) {\n                   \n                    timeDelay -= 1;\n                }\n                delayTimer.reset();\n            }\n            if (((gamepad1.x) && delayTimer.seconds() > 0.8)) {\n               \n                if (isRedAlliance) {\n                    isRedAlliance = false;\n                    robot.isRedAlliance = false;\n                } else {\n                    isRedAlliance = true;\n                    robot.isRedAlliance = true;\n                }\n                delayTimer.reset();\n            }\n           \n            if (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.NONE) {\n                robot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_LAVA_PALETTE);\n            }\n            if (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.ONE) {\n                robot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_OCEAN_PALETTE);\n            }\n            if (robot.eyes.getNumRings() == CatHW_Vision.UltimateGoalPipeline.numRings.FOUR) {\n                robot.lights.setDefaultColor(RevBlinkinLedDriver.BlinkinPattern.RAINBOW_PARTY_PALETTE);\n            }\n           \n            telemetry.addData(\"Delay Timer: \", timeDelay);\n            if (isRedAlliance) {\n                telemetry.addData(\"Alliance: \", \"Red\");\n            } else {\n                telemetry.addData(\"Alliance: \", \"Blue\");\n            }\n            telemetry.addData(\"Num of Rings\", \"%s\",robot.eyes.getNumRings().toString());\n            dashboardTelemetry.addData(\"Num of Rings\", \"%s\",robot.eyes.getNumRings().toString());\n            dashboardTelemetry.addData(\"Analysis\", \"%d\", robot.eyes.pipeline.getAnalysis());\n            dashboardTelemetry.update();\n            telemetry.update();\n           \n        }\n        CatHW_Vision.UltimateGoalPipeline.numRings numRings = robot.eyes.getNumRings();\n       \n       \n        robot.driveClassic.IMU_Init();\n       \n        robot.robotWait(timeDelay);\n        robot.driveOdo.quickDrive(-4,48,0.5, 0,3.0);\n        for (int i = 0; i < 5; i++) {\n            robot.robotWait(5);\n            Log.d(\"catbot\", String.format(\"Translate  Time wait    current %.2f %.2f %.1f \",\n                    robot.driveOdo.updatesThread.positionUpdate.returnXInches(),\n                    robot.driveOdo.updatesThread.positionUpdate.returnYInches(),\n                    robot.driveOdo.updatesThread.positionUpdate.returnOrientation()\n                    ));\n            robot.driveOdo.quickDrive( -4,96,0.8, 0,5.0);\n            robot.driveOdo.quickDrive(-52,96,0.8, 0,5.0);\n            robot.driveOdo.quickDrive(-52,48,0.8, 0,5.0);\n            robot.driveOdo.quickDrive( -4,48,0.8, 0,5.0);\n        }\n       \n        robot.driveOdo.updatesThread.stop();\n    }","cleancode":"@override public void runopmode() throws interruptedexception { ftcdashboard dashboard = ftcdashboard.getinstance(); telemetry dashboardtelemetry = dashboard.gettelemetry(); robot.init(hardwaremap, this, true, false); delaytimer.reset(); while (!opmodeisactive()) { if (this.isstoprequested()) { return; } if (gamepad1.dpad_up && (delaytimer.seconds() > 0.8)) { timedelay += 1; delaytimer.reset(); } if (gamepad1.dpad_down && (delaytimer.seconds() > 0.8)) { if (timedelay > 0) { timedelay -= 1; } delaytimer.reset(); } if (((gamepad1.x) && delaytimer.seconds() > 0.8)) { if (isredalliance) { isredalliance = false; robot.isredalliance = false; } else { isredalliance = true; robot.isredalliance = true; } delaytimer.reset(); } if (robot.eyes.getnumrings() == cathw_vision.ultimategoalpipeline.numrings.none) { robot.lights.setdefaultcolor(revblinkinleddriver.blinkinpattern.rainbow_lava_palette); } if (robot.eyes.getnumrings() == cathw_vision.ultimategoalpipeline.numrings.one) { robot.lights.setdefaultcolor(revblinkinleddriver.blinkinpattern.rainbow_ocean_palette); } if (robot.eyes.getnumrings() == cathw_vision.ultimategoalpipeline.numrings.four) { robot.lights.setdefaultcolor(revblinkinleddriver.blinkinpattern.rainbow_party_palette); } telemetry.adddata(\"delay timer: \", timedelay); if (isredalliance) { telemetry.adddata(\"alliance: \", \"red\"); } else { telemetry.adddata(\"alliance: \", \"blue\"); } telemetry.adddata(\"num of rings\", \"%s\",robot.eyes.getnumrings().tostring()); dashboardtelemetry.adddata(\"num of rings\", \"%s\",robot.eyes.getnumrings().tostring()); dashboardtelemetry.adddata(\"analysis\", \"%d\", robot.eyes.pipeline.getanalysis()); dashboardtelemetry.update(); telemetry.update(); } cathw_vision.ultimategoalpipeline.numrings numrings = robot.eyes.getnumrings(); robot.driveclassic.imu_init(); robot.robotwait(timedelay); robot.driveodo.quickdrive(-4,48,0.5, 0,3.0); for (int i = 0; i < 5; i++) { robot.robotwait(5); log.d(\"catbot\", string.format(\"translate time wait current %.2f %.2f %.1f \", robot.driveodo.updatesthread.positionupdate.returnxinches(), robot.driveodo.updatesthread.positionupdate.returnyinches(), robot.driveodo.updatesthread.positionupdate.returnorientation() )); robot.driveodo.quickdrive( -4,96,0.8, 0,5.0); robot.driveodo.quickdrive(-52,96,0.8, 0,5.0); robot.driveodo.quickdrive(-52,48,0.8, 0,5.0); robot.driveodo.quickdrive( -4,48,0.8, 0,5.0); } robot.driveodo.updatesthread.stop(); }","repo":"PanzerSchnitter\/UltimateGoal2020","label":[0,0,0,0]}
{"id":15126,"original_code":"private void clanList(L2PcInstance activeChar, int index)\n\t{\n\t\tif (index < 1)\n\t\t{\n\t\t\tindex = 1;\n\t\t}\n\t\t\/\/ header\n\t\tfinal StringBuilder html = StringUtil.startAppend(2000, \"<html><body><br><br><center><br1><br1><table border=0 cellspacing=0 cellpadding=0><tr><td FIXWIDTH=15>&nbsp;<\/td><td width=610 height=30 align=left><a action=\\\"bypass _bbsclan_clanlist\\\"> CLAN COMMUNITY <\/a><\/td><\/tr><\/table><table border=0 cellspacing=0 cellpadding=0 width=610 bgcolor=434343><tr><td height=10><\/td><\/tr><tr><td fixWIDTH=5><\/td><td fixWIDTH=600><a action=\\\"bypass _bbsclan_clanhome;\", String.valueOf((activeChar.getClan() != null) ? activeChar.getClan().getId() : 0), \"\\\">[GO TO MY CLAN]<\/a>&nbsp;&nbsp;<\/td><td fixWIDTH=5><\/td><\/tr><tr><td height=10><\/td><\/tr><\/table><br><table border=0 cellspacing=0 cellpadding=2 bgcolor=5A5A5A width=610><tr><td FIXWIDTH=5><\/td><td FIXWIDTH=200 align=center>CLAN NAME<\/td><td FIXWIDTH=200 align=center>CLAN LEADER<\/td><td FIXWIDTH=100 align=center>CLAN LEVEL<\/td><td FIXWIDTH=100 align=center>CLAN MEMBERS<\/td><td FIXWIDTH=5><\/td><\/tr><\/table><img src=\\\"L2UI.Squareblank\\\" width=\\\"1\\\" height=\\\"5\\\">\");\n\t\tint i = 0;\n\t\tfor (L2Clan cl : ClanTable.getInstance().getClans())\n\t\t{\n\t\t\tif (i > ((index + 1) * 7))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i++ >= ((index - 1) * 7))\n\t\t\t{\n\t\t\t\tStringUtil.append(html, \"<img src=\\\"L2UI.SquareBlank\\\" width=\\\"610\\\" height=\\\"3\\\"><table border=0 cellspacing=0 cellpadding=0 width=610><tr> <td FIXWIDTH=5><\/td><td FIXWIDTH=200 align=center><a action=\\\"bypass _bbsclan_clanhome;\", String.valueOf(cl.getId()), \"\\\">\", cl.getName(), \"<\/a><\/td><td FIXWIDTH=200 align=center>\", cl.getLeaderName(), \"<\/td><td FIXWIDTH=100 align=center>\", String.valueOf(cl.getLevel()), \"<\/td><td FIXWIDTH=100 align=center>\", String.valueOf(cl.getMembersCount()), \"<\/td><td FIXWIDTH=5><\/td><\/tr><tr><td height=5><\/td><\/tr><\/table><img src=\\\"L2UI.SquareBlank\\\" width=\\\"610\\\" height=\\\"3\\\"><img src=\\\"L2UI.SquareGray\\\" width=\\\"610\\\" height=\\\"1\\\">\");\n\t\t\t}\n\t\t}\n\t\thtml.append(\"<img src=\\\"L2UI.SquareBlank\\\" width=\\\"610\\\" height=\\\"2\\\"><table cellpadding=0 cellspacing=2 border=0><tr>\");\n\t\tif (index == 1)\n\t\t{\n\t\t\thtml.append(\"<td><button action=\\\"\\\" back=\\\"l2ui_ch3.prev1_down\\\" fore=\\\"l2ui_ch3.prev1\\\" width=16 height=16 ><\/td>\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStringUtil.append(html, \"<td><button action=\\\"_bbsclan_clanlist;\", String.valueOf(index - 1), \"\\\" back=\\\"l2ui_ch3.prev1_down\\\" fore=\\\"l2ui_ch3.prev1\\\" width=16 height=16 ><\/td>\");\n\t\t}\n\t\ti = 0;\n\t\tint nbp = ClanTable.getInstance().getClanCount() \/ 8;\n\t\tif ((nbp * 8) != ClanTable.getInstance().getClanCount())\n\t\t{\n\t\t\tnbp++;\n\t\t}\n\t\tfor (i = 1; i <= nbp; i++)\n\t\t{\n\t\t\tif (i == index)\n\t\t\t{\n\t\t\t\tStringUtil.append(html, \"<td> \", String.valueOf(i), \" <\/td>\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tStringUtil.append(html, \"<td><a action=\\\"bypass _bbsclan_clanlist;\", String.valueOf(i), \"\\\"> \", String.valueOf(i), \" <\/a><\/td>\");\n\t\t\t}\n\t\t}\n\t\tif (index == nbp)\n\t\t{\n\t\t\thtml.append(\"<td><button action=\\\"\\\" back=\\\"l2ui_ch3.next1_down\\\" fore=\\\"l2ui_ch3.next1\\\" width=16 height=16 ><\/td>\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStringUtil.append(html, \"<td><button action=\\\"bypass _bbsclan_clanlist;\", String.valueOf(index + 1), \"\\\" back=\\\"l2ui_ch3.next1_down\\\" fore=\\\"l2ui_ch3.next1\\\" width=16 height=16 ><\/td>\");\n\t\t}\n\t\thtml.append(\"<\/tr><\/table><table border=0 cellspacing=0 cellpadding=0><tr><td width=610><img src=\\\"sek.cbui141\\\" width=\\\"610\\\" height=\\\"1\\\"><\/td><\/tr><\/table><table border=0><tr><td><combobox width=65 var=keyword list=\\\"Name;Ruler\\\"><\/td><td><edit var = \\\"Search\\\" width=130 height=11 length=\\\"16\\\"><\/td>\" +\n\t\t\/\/ TODO: search (Write in BBS)\n\t\t\"<td><button value=\\\"&$420;\\\" action=\\\"Write 5 -1 0 Search keyword keyword\\\" back=\\\"l2ui_ch3.smallbutton2_down\\\" width=65 height=20 fore=\\\"l2ui_ch3.smallbutton2\\\"> <\/td> <\/tr><\/table><br><br><\/center><\/body><\/html>\");\n\t\tCommunityBoardHandler.separateAndSend(html.toString(), activeChar);\n\t}","code_wo_comment":"private void clanList(L2PcInstance activeChar, int index)\n\t{\n\t\tif (index < 1)\n\t\t{\n\t\t\tindex = 1;\n\t\t}\n\t\n\t\tfinal StringBuilder html = StringUtil.startAppend(2000, \"<html><body><br><br><center><br1><br1><table border=0 cellspacing=0 cellpadding=0><tr><td FIXWIDTH=15>&nbsp;<\/td><td width=610 height=30 align=left><a action=\\\"bypass _bbsclan_clanlist\\\"> CLAN COMMUNITY <\/a><\/td><\/tr><\/table><table border=0 cellspacing=0 cellpadding=0 width=610 bgcolor=434343><tr><td height=10><\/td><\/tr><tr><td fixWIDTH=5><\/td><td fixWIDTH=600><a action=\\\"bypass _bbsclan_clanhome;\", String.valueOf((activeChar.getClan() != null) ? activeChar.getClan().getId() : 0), \"\\\">[GO TO MY CLAN]<\/a>&nbsp;&nbsp;<\/td><td fixWIDTH=5><\/td><\/tr><tr><td height=10><\/td><\/tr><\/table><br><table border=0 cellspacing=0 cellpadding=2 bgcolor=5A5A5A width=610><tr><td FIXWIDTH=5><\/td><td FIXWIDTH=200 align=center>CLAN NAME<\/td><td FIXWIDTH=200 align=center>CLAN LEADER<\/td><td FIXWIDTH=100 align=center>CLAN LEVEL<\/td><td FIXWIDTH=100 align=center>CLAN MEMBERS<\/td><td FIXWIDTH=5><\/td><\/tr><\/table><img src=\\\"L2UI.Squareblank\\\" width=\\\"1\\\" height=\\\"5\\\">\");\n\t\tint i = 0;\n\t\tfor (L2Clan cl : ClanTable.getInstance().getClans())\n\t\t{\n\t\t\tif (i > ((index + 1) * 7))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i++ >= ((index - 1) * 7))\n\t\t\t{\n\t\t\t\tStringUtil.append(html, \"<img src=\\\"L2UI.SquareBlank\\\" width=\\\"610\\\" height=\\\"3\\\"><table border=0 cellspacing=0 cellpadding=0 width=610><tr> <td FIXWIDTH=5><\/td><td FIXWIDTH=200 align=center><a action=\\\"bypass _bbsclan_clanhome;\", String.valueOf(cl.getId()), \"\\\">\", cl.getName(), \"<\/a><\/td><td FIXWIDTH=200 align=center>\", cl.getLeaderName(), \"<\/td><td FIXWIDTH=100 align=center>\", String.valueOf(cl.getLevel()), \"<\/td><td FIXWIDTH=100 align=center>\", String.valueOf(cl.getMembersCount()), \"<\/td><td FIXWIDTH=5><\/td><\/tr><tr><td height=5><\/td><\/tr><\/table><img src=\\\"L2UI.SquareBlank\\\" width=\\\"610\\\" height=\\\"3\\\"><img src=\\\"L2UI.SquareGray\\\" width=\\\"610\\\" height=\\\"1\\\">\");\n\t\t\t}\n\t\t}\n\t\thtml.append(\"<img src=\\\"L2UI.SquareBlank\\\" width=\\\"610\\\" height=\\\"2\\\"><table cellpadding=0 cellspacing=2 border=0><tr>\");\n\t\tif (index == 1)\n\t\t{\n\t\t\thtml.append(\"<td><button action=\\\"\\\" back=\\\"l2ui_ch3.prev1_down\\\" fore=\\\"l2ui_ch3.prev1\\\" width=16 height=16 ><\/td>\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStringUtil.append(html, \"<td><button action=\\\"_bbsclan_clanlist;\", String.valueOf(index - 1), \"\\\" back=\\\"l2ui_ch3.prev1_down\\\" fore=\\\"l2ui_ch3.prev1\\\" width=16 height=16 ><\/td>\");\n\t\t}\n\t\ti = 0;\n\t\tint nbp = ClanTable.getInstance().getClanCount() \/ 8;\n\t\tif ((nbp * 8) != ClanTable.getInstance().getClanCount())\n\t\t{\n\t\t\tnbp++;\n\t\t}\n\t\tfor (i = 1; i <= nbp; i++)\n\t\t{\n\t\t\tif (i == index)\n\t\t\t{\n\t\t\t\tStringUtil.append(html, \"<td> \", String.valueOf(i), \" <\/td>\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tStringUtil.append(html, \"<td><a action=\\\"bypass _bbsclan_clanlist;\", String.valueOf(i), \"\\\"> \", String.valueOf(i), \" <\/a><\/td>\");\n\t\t\t}\n\t\t}\n\t\tif (index == nbp)\n\t\t{\n\t\t\thtml.append(\"<td><button action=\\\"\\\" back=\\\"l2ui_ch3.next1_down\\\" fore=\\\"l2ui_ch3.next1\\\" width=16 height=16 ><\/td>\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStringUtil.append(html, \"<td><button action=\\\"bypass _bbsclan_clanlist;\", String.valueOf(index + 1), \"\\\" back=\\\"l2ui_ch3.next1_down\\\" fore=\\\"l2ui_ch3.next1\\\" width=16 height=16 ><\/td>\");\n\t\t}\n\t\thtml.append(\"<\/tr><\/table><table border=0 cellspacing=0 cellpadding=0><tr><td width=610><img src=\\\"sek.cbui141\\\" width=\\\"610\\\" height=\\\"1\\\"><\/td><\/tr><\/table><table border=0><tr><td><combobox width=65 var=keyword list=\\\"Name;Ruler\\\"><\/td><td><edit var = \\\"Search\\\" width=130 height=11 length=\\\"16\\\"><\/td>\" +\n\t\n\t\t\"<td><button value=\\\"&$420;\\\" action=\\\"Write 5 -1 0 Search keyword keyword\\\" back=\\\"l2ui_ch3.smallbutton2_down\\\" width=65 height=20 fore=\\\"l2ui_ch3.smallbutton2\\\"> <\/td> <\/tr><\/table><br><br><\/center><\/body><\/html>\");\n\t\tCommunityBoardHandler.separateAndSend(html.toString(), activeChar);\n\t}","cleancode":"private void clanlist(l2pcinstance activechar, int index) { if (index < 1) { index = 1; } final stringbuilder html = stringutil.startappend(2000, \"<html><body><br><br><center><br1><br1><table border=0 cellspacing=0 cellpadding=0><tr><td fixwidth=15>&nbsp;<\/td><td width=610 height=30 align=left><a action=\\\"bypass _bbsclan_clanlist\\\"> clan community <\/a><\/td><\/tr><\/table><table border=0 cellspacing=0 cellpadding=0 width=610 bgcolor=434343><tr><td height=10><\/td><\/tr><tr><td fixwidth=5><\/td><td fixwidth=600><a action=\\\"bypass _bbsclan_clanhome;\", string.valueof((activechar.getclan() != null) ? activechar.getclan().getid() : 0), \"\\\">[go to my clan]<\/a>&nbsp;&nbsp;<\/td><td fixwidth=5><\/td><\/tr><tr><td height=10><\/td><\/tr><\/table><br><table border=0 cellspacing=0 cellpadding=2 bgcolor=5a5a5a width=610><tr><td fixwidth=5><\/td><td fixwidth=200 align=center>clan name<\/td><td fixwidth=200 align=center>clan leader<\/td><td fixwidth=100 align=center>clan level<\/td><td fixwidth=100 align=center>clan members<\/td><td fixwidth=5><\/td><\/tr><\/table><img src=\\\"l2ui.squareblank\\\" width=\\\"1\\\" height=\\\"5\\\">\"); int i = 0; for (l2clan cl : clantable.getinstance().getclans()) { if (i > ((index + 1) * 7)) { break; } if (i++ >= ((index - 1) * 7)) { stringutil.append(html, \"<img src=\\\"l2ui.squareblank\\\" width=\\\"610\\\" height=\\\"3\\\"><table border=0 cellspacing=0 cellpadding=0 width=610><tr> <td fixwidth=5><\/td><td fixwidth=200 align=center><a action=\\\"bypass _bbsclan_clanhome;\", string.valueof(cl.getid()), \"\\\">\", cl.getname(), \"<\/a><\/td><td fixwidth=200 align=center>\", cl.getleadername(), \"<\/td><td fixwidth=100 align=center>\", string.valueof(cl.getlevel()), \"<\/td><td fixwidth=100 align=center>\", string.valueof(cl.getmemberscount()), \"<\/td><td fixwidth=5><\/td><\/tr><tr><td height=5><\/td><\/tr><\/table><img src=\\\"l2ui.squareblank\\\" width=\\\"610\\\" height=\\\"3\\\"><img src=\\\"l2ui.squaregray\\\" width=\\\"610\\\" height=\\\"1\\\">\"); } } html.append(\"<img src=\\\"l2ui.squareblank\\\" width=\\\"610\\\" height=\\\"2\\\"><table cellpadding=0 cellspacing=2 border=0><tr>\"); if (index == 1) { html.append(\"<td><button action=\\\"\\\" back=\\\"l2ui_ch3.prev1_down\\\" fore=\\\"l2ui_ch3.prev1\\\" width=16 height=16 ><\/td>\"); } else { stringutil.append(html, \"<td><button action=\\\"_bbsclan_clanlist;\", string.valueof(index - 1), \"\\\" back=\\\"l2ui_ch3.prev1_down\\\" fore=\\\"l2ui_ch3.prev1\\\" width=16 height=16 ><\/td>\"); } i = 0; int nbp = clantable.getinstance().getclancount() \/ 8; if ((nbp * 8) != clantable.getinstance().getclancount()) { nbp++; } for (i = 1; i <= nbp; i++) { if (i == index) { stringutil.append(html, \"<td> \", string.valueof(i), \" <\/td>\"); } else { stringutil.append(html, \"<td><a action=\\\"bypass _bbsclan_clanlist;\", string.valueof(i), \"\\\"> \", string.valueof(i), \" <\/a><\/td>\"); } } if (index == nbp) { html.append(\"<td><button action=\\\"\\\" back=\\\"l2ui_ch3.next1_down\\\" fore=\\\"l2ui_ch3.next1\\\" width=16 height=16 ><\/td>\"); } else { stringutil.append(html, \"<td><button action=\\\"bypass _bbsclan_clanlist;\", string.valueof(index + 1), \"\\\" back=\\\"l2ui_ch3.next1_down\\\" fore=\\\"l2ui_ch3.next1\\\" width=16 height=16 ><\/td>\"); } html.append(\"<\/tr><\/table><table border=0 cellspacing=0 cellpadding=0><tr><td width=610><img src=\\\"sek.cbui141\\\" width=\\\"610\\\" height=\\\"1\\\"><\/td><\/tr><\/table><table border=0><tr><td><combobox width=65 var=keyword list=\\\"name;ruler\\\"><\/td><td><edit var = \\\"search\\\" width=130 height=11 length=\\\"16\\\"><\/td>\" + \"<td><button value=\\\"&$420;\\\" action=\\\"write 5 -1 0 search keyword keyword\\\" back=\\\"l2ui_ch3.smallbutton2_down\\\" width=65 height=20 fore=\\\"l2ui_ch3.smallbutton2\\\"> <\/td> <\/tr><\/table><br><br><\/center><\/body><\/html>\"); communityboardhandler.separateandsend(html.tostring(), activechar); }","repo":"RollingSoftware\/L2J_HighFive_Hardcore","label":[0,1,0,0]}
{"id":23375,"original_code":"public void sendErrorEmail(RequestCycle cycle, Exception ex, IRequestLogger logger) {\n        try {\n            String customer = Utils.getCustomer();\n            Url url = cycle.getRequest().getUrl();\n            Url clientUrl = cycle.getRequest().getClientUrl();\n            String exStr = ExceptionUtils.getStackTrace(ex);\n            String fullUrl = cycle.getUrlRenderer().renderFullUrl(url);\n            int currUserId = 0;\n            RequestData currRd = logger.getCurrentRequest();\n            String currSessId = Session.get().getId();\n            SessionData sd = null;\n            if(currSessId != null) {\n                SessionData[] sessions = logger.getLiveSessions();\n                for(SessionData s : sessions) {\n                    if(s.getSessionId().equals(currSessId)) {\n                        sd = s;\n                        break;\n                    }\n                }\n            }\n            String currReq = ((CustomRequestLogger)logger).createRequestData(currRd, sd);\n            StringBuilder currSessStr = new StringBuilder();\n            if(sd != null) {\n                currSessStr.append(\"id:\").append(sd.getSessionId()).append('\\n');\n                currSessStr.append(\"requestCount:\").append(sd.getNumberOfRequests()).append('\\n');\n                currSessStr.append(\"requestsTime:\").append(sd.getTotalTimeTaken()).append('\\n');\n                currSessStr.append(\"sessionSize:\").append(Bytes.bytes(sd.getSessionSize())).append('\\n');\n                currSessStr.append(\"sessionInfo:\").append(sd.getSessionInfo()).append('\\n');\n                currSessStr.append(\"startDate:\").append(sd.getStartDate()).append('\\n');\n                currSessStr.append(\"lastRequestTime:\").append(sd.getLastActive()).append('\\n');\n                currSessStr.append(\"numberOfRequests:\").append(sd.getNumberOfRequests()).append('\\n');\n                currSessStr.append(\"totalTimeTaken:\").append(sd.getTotalTimeTaken()).append(\"\\n\\n\\n\");\n            }\n            currSessStr.append(\"Requests: \\n\");\n            ((CustomRequestLogger)logger).getRequests(currSessStr);\n            String template = \"param1: %s \\n url: %s \\n client url: %s \\n user: %s \\n\\n \"\n                    + \"curr req: %s \\n\\n\\n curr session: %s \\n\\n\\n stack trace: %s\";\n            String body = String.format(template, customer, fullUrl, clientUrl.toString(), currUserId, currReq, currSessStr.toString(), exStr);\n            String subject = customer + \" error\";\n            \/\/TODO send email here\n        } catch (Exception e) {\n            \/\/ignore\n        }\n    }","code_wo_comment":"public void sendErrorEmail(RequestCycle cycle, Exception ex, IRequestLogger logger) {\n        try {\n            String customer = Utils.getCustomer();\n            Url url = cycle.getRequest().getUrl();\n            Url clientUrl = cycle.getRequest().getClientUrl();\n            String exStr = ExceptionUtils.getStackTrace(ex);\n            String fullUrl = cycle.getUrlRenderer().renderFullUrl(url);\n            int currUserId = 0;\n            RequestData currRd = logger.getCurrentRequest();\n            String currSessId = Session.get().getId();\n            SessionData sd = null;\n            if(currSessId != null) {\n                SessionData[] sessions = logger.getLiveSessions();\n                for(SessionData s : sessions) {\n                    if(s.getSessionId().equals(currSessId)) {\n                        sd = s;\n                        break;\n                    }\n                }\n            }\n            String currReq = ((CustomRequestLogger)logger).createRequestData(currRd, sd);\n            StringBuilder currSessStr = new StringBuilder();\n            if(sd != null) {\n                currSessStr.append(\"id:\").append(sd.getSessionId()).append('\\n');\n                currSessStr.append(\"requestCount:\").append(sd.getNumberOfRequests()).append('\\n');\n                currSessStr.append(\"requestsTime:\").append(sd.getTotalTimeTaken()).append('\\n');\n                currSessStr.append(\"sessionSize:\").append(Bytes.bytes(sd.getSessionSize())).append('\\n');\n                currSessStr.append(\"sessionInfo:\").append(sd.getSessionInfo()).append('\\n');\n                currSessStr.append(\"startDate:\").append(sd.getStartDate()).append('\\n');\n                currSessStr.append(\"lastRequestTime:\").append(sd.getLastActive()).append('\\n');\n                currSessStr.append(\"numberOfRequests:\").append(sd.getNumberOfRequests()).append('\\n');\n                currSessStr.append(\"totalTimeTaken:\").append(sd.getTotalTimeTaken()).append(\"\\n\\n\\n\");\n            }\n            currSessStr.append(\"Requests: \\n\");\n            ((CustomRequestLogger)logger).getRequests(currSessStr);\n            String template = \"param1: %s \\n url: %s \\n client url: %s \\n user: %s \\n\\n \"\n                    + \"curr req: %s \\n\\n\\n curr session: %s \\n\\n\\n stack trace: %s\";\n            String body = String.format(template, customer, fullUrl, clientUrl.toString(), currUserId, currReq, currSessStr.toString(), exStr);\n            String subject = customer + \" error\";\n           \n        } catch (Exception e) {\n           \n        }\n    }","cleancode":"public void senderroremail(requestcycle cycle, exception ex, irequestlogger logger) { try { string customer = utils.getcustomer(); url url = cycle.getrequest().geturl(); url clienturl = cycle.getrequest().getclienturl(); string exstr = exceptionutils.getstacktrace(ex); string fullurl = cycle.geturlrenderer().renderfullurl(url); int curruserid = 0; requestdata currrd = logger.getcurrentrequest(); string currsessid = session.get().getid(); sessiondata sd = null; if(currsessid != null) { sessiondata[] sessions = logger.getlivesessions(); for(sessiondata s : sessions) { if(s.getsessionid().equals(currsessid)) { sd = s; break; } } } string currreq = ((customrequestlogger)logger).createrequestdata(currrd, sd); stringbuilder currsessstr = new stringbuilder(); if(sd != null) { currsessstr.append(\"id:\").append(sd.getsessionid()).append('\\n'); currsessstr.append(\"requestcount:\").append(sd.getnumberofrequests()).append('\\n'); currsessstr.append(\"requeststime:\").append(sd.gettotaltimetaken()).append('\\n'); currsessstr.append(\"sessionsize:\").append(bytes.bytes(sd.getsessionsize())).append('\\n'); currsessstr.append(\"sessioninfo:\").append(sd.getsessioninfo()).append('\\n'); currsessstr.append(\"startdate:\").append(sd.getstartdate()).append('\\n'); currsessstr.append(\"lastrequesttime:\").append(sd.getlastactive()).append('\\n'); currsessstr.append(\"numberofrequests:\").append(sd.getnumberofrequests()).append('\\n'); currsessstr.append(\"totaltimetaken:\").append(sd.gettotaltimetaken()).append(\"\\n\\n\\n\"); } currsessstr.append(\"requests: \\n\"); ((customrequestlogger)logger).getrequests(currsessstr); string template = \"param1: %s \\n url: %s \\n client url: %s \\n user: %s \\n\\n \" + \"curr req: %s \\n\\n\\n curr session: %s \\n\\n\\n stack trace: %s\"; string body = string.format(template, customer, fullurl, clienturl.tostring(), curruserid, currreq, currsessstr.tostring(), exstr); string subject = customer + \" error\"; } catch (exception e) { } }","repo":"RomanSery\/codesnippets","label":[0,1,0,0]}
{"id":23575,"original_code":"public static void main(String[] args) {\n\t\t\/\/ TODO Auto-generated method stub\n\t\t\/\/Assuming stock of each sport is 2\n\t\tSports sp1=new IndoorSports();\n\t\tSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\n\t\tsp1=new Billiards(sp1);\n\t\tSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\n\t\tsp1=new Carrom(sp1);\n\t\tSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\n\t\tsp1=new Badminton(sp1);\n\t\tSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\n\t\tSports sp2=new OutdoorSports();\n\t\tSystem.out.println(\"\\nTotal Outdoor Sports Stock:\"+sp2.getCurrentStock());\n\t\tsp2=new Trekking(sp2);\n\t\tSystem.out.println(\"Total Outdoor Sports Stock:\"+sp2.getCurrentStock());\n\t\tsp2=new Cricket(sp2);\n\t\tSystem.out.println(\"Total Outdoor Sports Stock:\"+sp2.getCurrentStock());\n\t\tsp2=new HighJump(sp2);\n\t\tSystem.out.println(\"Total Outdoor Sports Stock:\"+sp2.getCurrentStock());\n\t\tsp2=new LongJump(sp2);\n\t\tSystem.out.println(\"Total Outdoor Sports Stock:\"+sp2.getCurrentStock());\n\t}","code_wo_comment":"public static void main(String[] args) {\n\t\n\t\n\t\tSports sp1=new IndoorSports();\n\t\tSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\n\t\tsp1=new Billiards(sp1);\n\t\tSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\n\t\tsp1=new Carrom(sp1);\n\t\tSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\n\t\tsp1=new Badminton(sp1);\n\t\tSystem.out.println(\"Total Indoor Sports Stock:\"+sp1.getCurrentStock());\n\t\tSports sp2=new OutdoorSports();\n\t\tSystem.out.println(\"\\nTotal Outdoor Sports Stock:\"+sp2.getCurrentStock());\n\t\tsp2=new Trekking(sp2);\n\t\tSystem.out.println(\"Total Outdoor Sports Stock:\"+sp2.getCurrentStock());\n\t\tsp2=new Cricket(sp2);\n\t\tSystem.out.println(\"Total Outdoor Sports Stock:\"+sp2.getCurrentStock());\n\t\tsp2=new HighJump(sp2);\n\t\tSystem.out.println(\"Total Outdoor Sports Stock:\"+sp2.getCurrentStock());\n\t\tsp2=new LongJump(sp2);\n\t\tSystem.out.println(\"Total Outdoor Sports Stock:\"+sp2.getCurrentStock());\n\t}","cleancode":"public static void main(string[] args) { sports sp1=new indoorsports(); system.out.println(\"total indoor sports stock:\"+sp1.getcurrentstock()); sp1=new billiards(sp1); system.out.println(\"total indoor sports stock:\"+sp1.getcurrentstock()); sp1=new carrom(sp1); system.out.println(\"total indoor sports stock:\"+sp1.getcurrentstock()); sp1=new badminton(sp1); system.out.println(\"total indoor sports stock:\"+sp1.getcurrentstock()); sports sp2=new outdoorsports(); system.out.println(\"\\ntotal outdoor sports stock:\"+sp2.getcurrentstock()); sp2=new trekking(sp2); system.out.println(\"total outdoor sports stock:\"+sp2.getcurrentstock()); sp2=new cricket(sp2); system.out.println(\"total outdoor sports stock:\"+sp2.getcurrentstock()); sp2=new highjump(sp2); system.out.println(\"total outdoor sports stock:\"+sp2.getcurrentstock()); sp2=new longjump(sp2); system.out.println(\"total outdoor sports stock:\"+sp2.getcurrentstock()); }","repo":"Saba-d-coder\/6thSemIse","label":[1,0,0,0]}
{"id":15413,"original_code":"public void put(String name, Scriptable start, Object value) {\n\t    try {\n\t\tObjectLocation variable = this.extractFieldVariable(name);\n\t\tif (value instanceof NativeArray) {\n\t\t    \/\/ FIXME this breaks referential equality, but maybe it's OK\n\t\t    variable.set(this.sequenceFromArray((NativeArray)value, start));\n\t\t    return;\n\t\t}\n\t\t\/\/System.err.println(\"variable \" + variable + \" new value \" + value + \" type \" + variable.getClass().getName());\n\t\tif (variable instanceof FloatLocation) { \/\/ FIXME FIXME super ad-hoc\n\t\t    value = Context.jsToJava(value, Float.class);\n\t\t} else if (value instanceof ObjectLocation) {\n\t\t    \/\/ here's a place where two locations could be bound to each other?\n\t\t    value = ((ObjectLocation)value).get();\n\t\t} else if (value instanceof Wrapper) {\n\t\t    \/\/ FIXME is there a better way???\n\t\t    value = ((Wrapper)value).unwrap();\n\t\t    if (value instanceof ObjectLocation) {\n\t\t\tvalue = ((ObjectLocation)value).get();\n\t\t    }\n\t\t}\n\t\tvariable.set(value); \n\t\treturn;\n\t    } catch (Exception e) { \n\t\te.printStackTrace(System.err);\n\t    }\n\t}","code_wo_comment":"public void put(String name, Scriptable start, Object value) {\n\t    try {\n\t\tObjectLocation variable = this.extractFieldVariable(name);\n\t\tif (value instanceof NativeArray) {\n\t\t   \n\t\t    variable.set(this.sequenceFromArray((NativeArray)value, start));\n\t\t    return;\n\t\t}\n\t\n\t\tif (variable instanceof FloatLocation) {\n\t\t    value = Context.jsToJava(value, Float.class);\n\t\t} else if (value instanceof ObjectLocation) {\n\t\t   \n\t\t    value = ((ObjectLocation)value).get();\n\t\t} else if (value instanceof Wrapper) {\n\t\t   \n\t\t    value = ((Wrapper)value).unwrap();\n\t\t    if (value instanceof ObjectLocation) {\n\t\t\tvalue = ((ObjectLocation)value).get();\n\t\t    }\n\t\t}\n\t\tvariable.set(value); \n\t\treturn;\n\t    } catch (Exception e) { \n\t\te.printStackTrace(System.err);\n\t    }\n\t}","cleancode":"public void put(string name, scriptable start, object value) { try { objectlocation variable = this.extractfieldvariable(name); if (value instanceof nativearray) { variable.set(this.sequencefromarray((nativearray)value, start)); return; } if (variable instanceof floatlocation) { value = context.jstojava(value, float.class); } else if (value instanceof objectlocation) { value = ((objectlocation)value).get(); } else if (value instanceof wrapper) { value = ((wrapper)value).unwrap(); if (value instanceof objectlocation) { value = ((objectlocation)value).get(); } } variable.set(value); return; } catch (exception e) { e.printstacktrace(system.err); } }","repo":"LivelyKernel\/sunlabs-kernel","label":[1,0,1,0]}
{"id":15430,"original_code":"private static Method getMethod() {\n\t\treturn method.get(0);\n\t}","code_wo_comment":"private static Method getMethod() {\n\t\treturn method.get(0);\n\t}","cleancode":"private static method getmethod() { return method.get(0); }","repo":"Modify24x7\/ApkStringDecryptor","label":[1,0,0,0]}
{"id":15621,"original_code":"private boolean initCipher() {\n        try {\n            \/\/Obtain a cipher instance and configure it with the properties required for fingerprint authentication\/\/\n            if(this.cipher == null) {\n                this.cipher = Cipher.getInstance(\n                        KeyProperties.KEY_ALGORITHM_AES + \"\/\"\n                                + KeyProperties.BLOCK_MODE_CBC + \"\/\"\n                                + KeyProperties.ENCRYPTION_PADDING_PKCS7);\n            }\n        } catch (NoSuchAlgorithmException |\n                NoSuchPaddingException e) {\n            e.printStackTrace();\n            return false;\n        }\n        try {\n            if(this.secretKey == null) {\n                this.secretKey = generateKey();\n            }\n            if(this.keyStore != null) {\n                if(!this.keystoreInitialized) {\n                    this.keyStore.load(null);\n                    this.keystoreInitialized = true;\n                }\n            }\n\/\/            key = (SecretKey) this.keyStore.getKey(keyName, null); todo needed?\n            if(this.cipher != null) {\n                if (!this.cipherInitialized) {\n                    this.cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);\n                    this.cipherInitialized = true;\n                }\n            }\n            \/\/Return true if the cipher has been initialized successfully\/\/\n            return true;\n        } catch (KeyPermanentlyInvalidatedException e) {\n            \/\/Return false if cipher initialization failed\/\/\n            return false;\n        } catch (CertificateException \/\/KeyStoreException\n                | IOException \/\/UnrecoverableKeyException\n                | NullPointerException\n                | NoSuchAlgorithmException | InvalidKeyException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }","code_wo_comment":"private boolean initCipher() {\n        try {\n           \n            if(this.cipher == null) {\n                this.cipher = Cipher.getInstance(\n                        KeyProperties.KEY_ALGORITHM_AES + \"\/\"\n                                + KeyProperties.BLOCK_MODE_CBC + \"\/\"\n                                + KeyProperties.ENCRYPTION_PADDING_PKCS7);\n            }\n        } catch (NoSuchAlgorithmException |\n                NoSuchPaddingException e) {\n            e.printStackTrace();\n            return false;\n        }\n        try {\n            if(this.secretKey == null) {\n                this.secretKey = generateKey();\n            }\n            if(this.keyStore != null) {\n                if(!this.keystoreInitialized) {\n                    this.keyStore.load(null);\n                    this.keystoreInitialized = true;\n                }\n            }\n            if(this.cipher != null) {\n                if (!this.cipherInitialized) {\n                    this.cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);\n                    this.cipherInitialized = true;\n                }\n            }\n           \n            return true;\n        } catch (KeyPermanentlyInvalidatedException e) {\n           \n            return false;\n        } catch (CertificateException\n                | IOException\n                | NullPointerException\n                | NoSuchAlgorithmException | InvalidKeyException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }","cleancode":"private boolean initcipher() { try { if(this.cipher == null) { this.cipher = cipher.getinstance( keyproperties.key_algorithm_aes + \"\/\" + keyproperties.block_mode_cbc + \"\/\" + keyproperties.encryption_padding_pkcs7); } } catch (nosuchalgorithmexception | nosuchpaddingexception e) { e.printstacktrace(); return false; } try { if(this.secretkey == null) { this.secretkey = generatekey(); } if(this.keystore != null) { if(!this.keystoreinitialized) { this.keystore.load(null); this.keystoreinitialized = true; } } if(this.cipher != null) { if (!this.cipherinitialized) { this.cipher.init(cipher.encrypt_mode, this.secretkey); this.cipherinitialized = true; } } return true; } catch (keypermanentlyinvalidatedexception e) { return false; } catch (certificateexception | ioexception | nullpointerexception | nosuchalgorithmexception | invalidkeyexception e) { e.printstacktrace(); return false; } }","repo":"PGMacDesign\/PGMacTips","label":[1,0,0,0]}
{"id":23837,"original_code":"private void writeRunnerProject() throws IOException, XmlException, ParseException {\n        \/\/ TODO revise whole method\n        \/\/ TODO now using a newer JAPA (suuports java 8), -> maybe ANTLR supports better\n        PathUtils.createDir(getRunnerProjectSettings().getBaseDir().toPath());\n        \/\/ copy snippets\n        PathUtils.copy(getSnippetProject().getSourceDir(),\n                getRunnerProjectSettings().getSnippetSourceDirectory().toPath());\n        \/\/ create INFO file\n        writeInfoFile();\n        \/\/ remove SETTE annotations and imports from file\n        Collection<File> filesWritten = Files\n                .walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n                .filter(Files::isRegularFile).map(Path::toFile).sorted()\n                .collect(Collectors.toList());\n        for (File file : filesWritten) {\n            \/\/ parse source with JavaParser\n            log.debug(\"Parsing with JavaParser: {}\", file);\n            CompilationUnit compilationUnit = JavaParser.parse(file);\n            log.debug(\"Parsed with JavaParser: {}\", file);\n            \/\/ extract type\n            List<TypeDeclaration> types = compilationUnit.getTypes();\n            if (types.size() != 1) {\n                \/\/ NOTE better exception type\n                throw new RuntimeException(\n                        \"Java source files containing more that one types are not supported\");\n            }\n            TypeDeclaration type = types.get(0);\n            \/\/ skip file if Java version is not supported by the tool (@SetteSnippetContainer)\n            \/\/ NOTE it can be also done with snippet containers... (and also done in CATG\n            \/\/ generator!)\n            List<AnnotationExpr> classAnnotations = type.getAnnotations();\n            JavaVersion reqJavaVer = getRequiredJavaVersion(classAnnotations);\n            if (reqJavaVer != null && !getTool().supportsJavaVersion(reqJavaVer)) {\n                System.err.println(\n                        \"Skipping file: \" + file + \" (required Java version: \" + reqJavaVer + \")\");\n                PathUtils.delete(file.toPath());\n            } else {\n                \/\/ remove SETTE annotations from the class\n                Predicate<AnnotationExpr> isSetteAnnotation = (a -> a.getName().getName()\n                        .startsWith(\"Sette\"));\n                classAnnotations.removeIf(isSetteAnnotation);\n                \/\/ remove SETTE annotations from the members\n                for (BodyDeclaration member : type.getMembers()) {\n                    member.getAnnotations().removeIf(isSetteAnnotation);\n                }\n                \/\/ TODO enhance\n                List<String> toRemovePrefixes = new ArrayList<>();\n                toRemovePrefixes.add(\"hu.bme.mit.sette.snippets.inputs\");\n                toRemovePrefixes.add(\"hu.bme.mit.sette.common\");\n                \/\/ remove SETTE imports\n                compilationUnit.getImports().removeIf(importDeclaration -> {\n                    String impDecl = importDeclaration.getName().toString();\n                    for (String prefix : toRemovePrefixes) {\n                        if (impDecl.startsWith(prefix)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                });\n                \/\/ save edited source code\n                String source = compilationUnit.toString();\n                if (type instanceof EnumDeclaration) {\n                    \/\/ FIXME remove after javaparser bug is fixed\n                    source = source.replaceFirst(type.getName() + \"\\\\s+implements\\\\s*\\\\{\",\n                            type.getName() + \" {\");\n                }\n                PathUtils.write(file.toPath(), source.getBytes());\n            }\n        }\n        \/\/ copy libraries\n        if (getSnippetProject().getLibDir().toFile().exists()) {\n            PathUtils.copy(getSnippetProject().getLibDir(),\n                    getRunnerProjectSettings().getSnippetLibraryDirectory().toPath());\n        }\n        \/\/ create project\n        this.eclipseProject.save(getRunnerProjectSettings().getBaseDir().toPath());\n    }","code_wo_comment":"private void writeRunnerProject() throws IOException, XmlException, ParseException {\n       \n       \n        PathUtils.createDir(getRunnerProjectSettings().getBaseDir().toPath());\n       \n        PathUtils.copy(getSnippetProject().getSourceDir(),\n                getRunnerProjectSettings().getSnippetSourceDirectory().toPath());\n       \n        writeInfoFile();\n       \n        Collection<File> filesWritten = Files\n                .walk(getRunnerProjectSettings().getSnippetSourceDirectory().toPath())\n                .filter(Files::isRegularFile).map(Path::toFile).sorted()\n                .collect(Collectors.toList());\n        for (File file : filesWritten) {\n           \n            log.debug(\"Parsing with JavaParser: {}\", file);\n            CompilationUnit compilationUnit = JavaParser.parse(file);\n            log.debug(\"Parsed with JavaParser: {}\", file);\n           \n            List<TypeDeclaration> types = compilationUnit.getTypes();\n            if (types.size() != 1) {\n               \n                throw new RuntimeException(\n                        \"Java source files containing more that one types are not supported\");\n            }\n            TypeDeclaration type = types.get(0);\n           \n           \n           \n            List<AnnotationExpr> classAnnotations = type.getAnnotations();\n            JavaVersion reqJavaVer = getRequiredJavaVersion(classAnnotations);\n            if (reqJavaVer != null && !getTool().supportsJavaVersion(reqJavaVer)) {\n                System.err.println(\n                        \"Skipping file: \" + file + \" (required Java version: \" + reqJavaVer + \")\");\n                PathUtils.delete(file.toPath());\n            } else {\n               \n                Predicate<AnnotationExpr> isSetteAnnotation = (a -> a.getName().getName()\n                        .startsWith(\"Sette\"));\n                classAnnotations.removeIf(isSetteAnnotation);\n               \n                for (BodyDeclaration member : type.getMembers()) {\n                    member.getAnnotations().removeIf(isSetteAnnotation);\n                }\n               \n                List<String> toRemovePrefixes = new ArrayList<>();\n                toRemovePrefixes.add(\"hu.bme.mit.sette.snippets.inputs\");\n                toRemovePrefixes.add(\"hu.bme.mit.sette.common\");\n               \n                compilationUnit.getImports().removeIf(importDeclaration -> {\n                    String impDecl = importDeclaration.getName().toString();\n                    for (String prefix : toRemovePrefixes) {\n                        if (impDecl.startsWith(prefix)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                });\n               \n                String source = compilationUnit.toString();\n                if (type instanceof EnumDeclaration) {\n                   \n                    source = source.replaceFirst(type.getName() + \"\\\\s+implements\\\\s*\\\\{\",\n                            type.getName() + \" {\");\n                }\n                PathUtils.write(file.toPath(), source.getBytes());\n            }\n        }\n       \n        if (getSnippetProject().getLibDir().toFile().exists()) {\n            PathUtils.copy(getSnippetProject().getLibDir(),\n                    getRunnerProjectSettings().getSnippetLibraryDirectory().toPath());\n        }\n       \n        this.eclipseProject.save(getRunnerProjectSettings().getBaseDir().toPath());\n    }","cleancode":"private void writerunnerproject() throws ioexception, xmlexception, parseexception { pathutils.createdir(getrunnerprojectsettings().getbasedir().topath()); pathutils.copy(getsnippetproject().getsourcedir(), getrunnerprojectsettings().getsnippetsourcedirectory().topath()); writeinfofile(); collection<file> fileswritten = files .walk(getrunnerprojectsettings().getsnippetsourcedirectory().topath()) .filter(files::isregularfile).map(path::tofile).sorted() .collect(collectors.tolist()); for (file file : fileswritten) { log.debug(\"parsing with javaparser: {}\", file); compilationunit compilationunit = javaparser.parse(file); log.debug(\"parsed with javaparser: {}\", file); list<typedeclaration> types = compilationunit.gettypes(); if (types.size() != 1) { throw new runtimeexception( \"java source files containing more that one types are not supported\"); } typedeclaration type = types.get(0); list<annotationexpr> classannotations = type.getannotations(); javaversion reqjavaver = getrequiredjavaversion(classannotations); if (reqjavaver != null && !gettool().supportsjavaversion(reqjavaver)) { system.err.println( \"skipping file: \" + file + \" (required java version: \" + reqjavaver + \")\"); pathutils.delete(file.topath()); } else { predicate<annotationexpr> issetteannotation = (a -> a.getname().getname() .startswith(\"sette\")); classannotations.removeif(issetteannotation); for (bodydeclaration member : type.getmembers()) { member.getannotations().removeif(issetteannotation); } list<string> toremoveprefixes = new arraylist<>(); toremoveprefixes.add(\"hu.bme.mit.sette.snippets.inputs\"); toremoveprefixes.add(\"hu.bme.mit.sette.common\"); compilationunit.getimports().removeif(importdeclaration -> { string impdecl = importdeclaration.getname().tostring(); for (string prefix : toremoveprefixes) { if (impdecl.startswith(prefix)) { return true; } } return false; }); string source = compilationunit.tostring(); if (type instanceof enumdeclaration) { source = source.replacefirst(type.getname() + \"\\\\s+implements\\\\s*\\\\{\", type.getname() + \" {\"); } pathutils.write(file.topath(), source.getbytes()); } } if (getsnippetproject().getlibdir().tofile().exists()) { pathutils.copy(getsnippetproject().getlibdir(), getrunnerprojectsettings().getsnippetlibrarydirectory().topath()); } this.eclipseproject.save(getrunnerprojectsettings().getbasedir().topath()); }","repo":"SETTE-Testing\/sette-tool","label":[1,0,1,0]}
{"id":15691,"original_code":"public boolean isSubjectEmpty() {\n        return TextUtils.getTrimmedLength(mSubject.getText()) == 0;\n    }","code_wo_comment":"public boolean isSubjectEmpty() {\n        return TextUtils.getTrimmedLength(mSubject.getText()) == 0;\n    }","cleancode":"public boolean issubjectempty() { return textutils.gettrimmedlength(msubject.gettext()) == 0; }","repo":"Keneral\/apackages","label":[1,0,0,0]}
{"id":23891,"original_code":"public void buildOutAssignment(StringBuilder sb, PLSQLargument outArg, PLSQLStoredProcedureCall call) {\n        String sql2PlName = call.getPl2SQLName(this);\n        if (sql2PlName == null) {\n            \/\/ TODO: Error.\n            throw new NullPointerException(\"no Pl2SQL conversion routine for \" + typeName);\n        }\n        String target = databaseTypeHelper.buildTarget(outArg);\n        sb.append(\"  :\");\n        sb.append(outArg.outIndex);\n        sb.append(\" := \");\n        sb.append(sql2PlName);\n        sb.append(\"(\");\n        sb.append(target);\n        sb.append(\");\");\n        sb.append(NL);\n    }","code_wo_comment":"public void buildOutAssignment(StringBuilder sb, PLSQLargument outArg, PLSQLStoredProcedureCall call) {\n        String sql2PlName = call.getPl2SQLName(this);\n        if (sql2PlName == null) {\n           \n            throw new NullPointerException(\"no Pl2SQL conversion routine for \" + typeName);\n        }\n        String target = databaseTypeHelper.buildTarget(outArg);\n        sb.append(\"  :\");\n        sb.append(outArg.outIndex);\n        sb.append(\" := \");\n        sb.append(sql2PlName);\n        sb.append(\"(\");\n        sb.append(target);\n        sb.append(\");\");\n        sb.append(NL);\n    }","cleancode":"public void buildoutassignment(stringbuilder sb, plsqlargument outarg, plsqlstoredprocedurecall call) { string sql2plname = call.getpl2sqlname(this); if (sql2plname == null) { throw new nullpointerexception(\"no pl2sql conversion routine for \" + typename); } string target = databasetypehelper.buildtarget(outarg); sb.append(\" :\"); sb.append(outarg.outindex); sb.append(\" := \"); sb.append(sql2plname); sb.append(\"(\"); sb.append(target); sb.append(\");\"); sb.append(nl); }","repo":"Pandrex247\/patched-src-eclipselink","label":[0,0,1,0]}
{"id":23901,"original_code":"private void guestSearchActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_guestSearchActionPerformed\n        \/\/ TODO add your handling code here:\n        \/\/Guestsearch guestsearch = new Guestsearch(jFrameInstance, email);\n        \/\/jFrameInstance.changePanelToSpecific(guestsearch);\n    }","code_wo_comment":"private void guestSearchActionPerformed(java.awt.event.ActionEvent evt) {       \n       \n       \n    }","cleancode":"private void guestsearchactionperformed(java.awt.event.actionevent evt) { }","repo":"Jed-g\/property-booking-system","label":[0,1,0,0]}
{"id":32148,"original_code":"@Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        \/\/ TODO: This test will actually mess with contacts on your phone.\n        \/\/ Ideally we would use a fake content provider to give us contact data...\n        FakeFactory.registerWithoutFakeContext(getTestContext());\n        \/\/ add test contacts.\n        addTestContact(\"John\", \"650-123-1233\", \"john@gmail.com\", false);\n        addTestContact(\"Joe\", \"(650)123-1233\", \"joe@gmail.com\", false);\n        addTestContact(\"Jim\", \"650 123 1233\", \"jim@gmail.com\", false);\n        addTestContact(\"Samantha\", \"650-123-1235\", \"samantha@gmail.com\", true);\n        addTestContact(\"Adrienne\", \"650-123-1236\", \"adrienne@gmail.com\", true);\n    }","code_wo_comment":"@Override\n    protected void setUp() throws Exception {\n        super.setUp();\n       \n       \n        FakeFactory.registerWithoutFakeContext(getTestContext());\n       \n        addTestContact(\"John\", \"650-123-1233\", \"john@gmail.com\", false);\n        addTestContact(\"Joe\", \"(650)123-1233\", \"joe@gmail.com\", false);\n        addTestContact(\"Jim\", \"650 123 1233\", \"jim@gmail.com\", false);\n        addTestContact(\"Samantha\", \"650-123-1235\", \"samantha@gmail.com\", true);\n        addTestContact(\"Adrienne\", \"650-123-1236\", \"adrienne@gmail.com\", true);\n    }","cleancode":"@override protected void setup() throws exception { super.setup(); fakefactory.registerwithoutfakecontext(gettestcontext()); addtestcontact(\"john\", \"650-123-1233\", \"john@gmail.com\", false); addtestcontact(\"joe\", \"(650)123-1233\", \"joe@gmail.com\", false); addtestcontact(\"jim\", \"650 123 1233\", \"jim@gmail.com\", false); addtestcontact(\"samantha\", \"650-123-1235\", \"samantha@gmail.com\", true); addtestcontact(\"adrienne\", \"650-123-1236\", \"adrienne@gmail.com\", true); }","repo":"Keneral\/apackages","label":[0,0,0,1]}
{"id":15785,"original_code":"@Override\n\tpublic ItemStack transferStackInSlot(EntityPlayer player, int slot) {\n\t\t\/\/ TODO: Try to come up with a generic way of implementing this\n\t\treturn null;\n\t}","code_wo_comment":"@Override\n\tpublic ItemStack transferStackInSlot(EntityPlayer player, int slot) {\n\t\n\t\treturn null;\n\t}","cleancode":"@override public itemstack transferstackinslot(entityplayer player, int slot) { return null; }","repo":"PC-Logix\/GregsLighting-Reloaded","label":[1,0,0,0]}
{"id":7631,"original_code":"public JSONArray getProjectRevisions(ProjectEndpoint endpoint) {\n\t\t\/\/TODO need to add paging somewhere (page, items) to handle long commit histories\n\t\tString json = restInterface.get(TeamworkCloudEndpoints.GET_PROJECT_REVISIONS.buildUrl(endpoint.getHost(),\n\t\t\t\tendpoint.getCollection(), endpoint.getProject(), \"true\"), endpoint.getToken(), String.class);\n\t\treturn new JSONArray(json);\n\t}","code_wo_comment":"public JSONArray getProjectRevisions(ProjectEndpoint endpoint) {\n\t\n\t\tString json = restInterface.get(TeamworkCloudEndpoints.GET_PROJECT_REVISIONS.buildUrl(endpoint.getHost(),\n\t\t\t\tendpoint.getCollection(), endpoint.getProject(), \"true\"), endpoint.getToken(), String.class);\n\t\treturn new JSONArray(json);\n\t}","cleancode":"public jsonarray getprojectrevisions(projectendpoint endpoint) { string json = restinterface.get(teamworkcloudendpoints.get_project_revisions.buildurl(endpoint.gethost(), endpoint.getcollection(), endpoint.getproject(), \"true\"), endpoint.gettoken(), string.class); return new jsonarray(json); }","repo":"Open-MBEE\/sync-service","label":[0,1,0,0]}
{"id":24107,"original_code":"public void ClearScreenTest(){\n        press(R.id.btn_1);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.binary_number_2);\n        press(R.id.btn_1);\n        press(R.id.btn_0);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_divide);\n        press(R.id.btn_all_clear);\n        checkResult(\"\");\n        checkBinary1(\"\");\n        checkBinary2(\"\");\n    }","code_wo_comment":"public void ClearScreenTest(){\n        press(R.id.btn_1);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.binary_number_2);\n        press(R.id.btn_1);\n        press(R.id.btn_0);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_divide);\n        press(R.id.btn_all_clear);\n        checkResult(\"\");\n        checkBinary1(\"\");\n        checkBinary2(\"\");\n    }","cleancode":"public void clearscreentest(){ press(r.id.btn_1); press(r.id.btn_0); press(r.id.btn_0); press(r.id.btn_0); press(r.id.btn_0); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_1); press(r.id.binary_number_2); press(r.id.btn_1); press(r.id.btn_0); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_divide); press(r.id.btn_all_clear); checkresult(\"\"); checkbinary1(\"\"); checkbinary2(\"\"); }","repo":"ModestosV\/Simple-Calculator","label":[0,0,0,1]}
{"id":24108,"original_code":"public void DeleteTest(){\n        press(R.id.btn_1);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_del);\n        checkBinary1(\"1000011111\");\n        press(R.id.binary_number_2);\n        press(R.id.btn_1);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_del);\n        checkBinary2(\"10\");\n    }","code_wo_comment":"public void DeleteTest(){\n        press(R.id.btn_1);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_1);\n        press(R.id.btn_del);\n        checkBinary1(\"1000011111\");\n        press(R.id.binary_number_2);\n        press(R.id.btn_1);\n        press(R.id.btn_0);\n        press(R.id.btn_0);\n        press(R.id.btn_del);\n        checkBinary2(\"10\");\n    }","cleancode":"public void deletetest(){ press(r.id.btn_1); press(r.id.btn_0); press(r.id.btn_0); press(r.id.btn_0); press(r.id.btn_0); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_1); press(r.id.btn_del); checkbinary1(\"1000011111\"); press(r.id.binary_number_2); press(r.id.btn_1); press(r.id.btn_0); press(r.id.btn_0); press(r.id.btn_del); checkbinary2(\"10\"); }","repo":"ModestosV\/Simple-Calculator","label":[0,0,0,1]}
{"id":15927,"original_code":"public int ExecuteGFXCommand(int cmd, int len, byte[] cmddata, int[] hasret)\n\t{\n\t\tlen -= 4; \/\/ for the 4 byte header\n\t    hasret[0] = 0; \/\/ Nothing to return by default\n\/\/\t\tSystem.out.println(\"GFXCMD=\" + cmd);\n\t\t\/\/ make sure the frame is still valid or we could crash on fullscreen mode switches\n\t\tif((cmd != GFXCMD_INIT) && (cmd != GFXCMD_DEINIT))\n\t\t{\n\t\t\tif((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\n\/\/\t\t\t\tSystem.out.println(\"GFXCMD while frame not displayable\");\n\t\t\t\t\/\/ spin until the frame is valid and displayable, if we don't we'll lose parts of the UI or crash\n\t\t\t\twhile((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tThread.sleep(10);\n\t\t\t\t\t} catch(InterruptedException ex) {}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c != null)\n\t\t{\n\t\t\tswitch(cmd)\n\t\t\t{\n\t\t\t\tcase GFXCMD_INIT:\n\t\t\t\tcase GFXCMD_DEINIT:\n\t\t\t\tcase GFXCMD_STARTFRAME:\n\t\t\t\tcase GFXCMD_FLIPBUFFER:\n\t\t\t\t\tc.setCursor(null);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GFXCMD_DRAWRECT:\n\t\t\t\tcase GFXCMD_FILLRECT:\n\t\t\t\tcase GFXCMD_CLEARRECT:\n\t\t\t\tcase GFXCMD_DRAWOVAL:\n\t\t\t\tcase GFXCMD_FILLOVAL:\n\t\t\t\tcase GFXCMD_DRAWROUNDRECT:\n\t\t\t\tcase GFXCMD_FILLROUNDRECT:\n\t\t\t\tcase GFXCMD_DRAWTEXT:\n\t\t\t\tcase GFXCMD_DRAWTEXTURED:\n\t\t\t\tcase GFXCMD_DRAWLINE:\n\t\t\t\tcase GFXCMD_LOADIMAGE:\n\t\t\t\tcase GFXCMD_LOADIMAGETARGETED:\n\t\t\t\tcase GFXCMD_UNLOADIMAGE:\n\t\t\t\tcase GFXCMD_LOADFONT:\n\t\t\t\tcase GFXCMD_UNLOADFONT:\n\t\t\t\tcase GFXCMD_SETTARGETSURFACE:\n\t\t\t\tcase GFXCMD_CREATESURFACE:\n\t\t\t\t\tbreak;\n\t\t\t\tcase GFXCMD_PREPIMAGE:\n\t\t\t\tcase GFXCMD_LOADIMAGELINE:\n\t\t\t\tcase GFXCMD_LOADIMAGECOMPRESSED:\n\t\t\t\tcase GFXCMD_XFMIMAGE:\n\t\t\t\tcase GFXCMD_LOADCACHEDIMAGE:\n\t\t\t\tcase GFXCMD_PREPIMAGETARGETED:\n\t\t\t\t\tif (!cursorHidden)\n\t\t\t\t\t\tc.setCursor(java.awt.Cursor.getPredefinedCursor(java.awt.Cursor.WAIT_CURSOR));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswitch(cmd)\n\t\t{\n\t\t\tcase GFXCMD_INIT:\n\t\t\t\thasret[0] = 1;\n\/\/\t\t\t\tSystem.out.println(\"INIT\");\n\t\t\t\t\/\/ start up native renderer\n\t\t\t\tinit0();\n\t\t\t\tint windowTitleStyle = 0;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\twindowTitleStyle = Integer.parseInt(MiniClient.myProperties.getProperty(\"window_title_style\", \"0\"));\n\t\t\t\t}\n\t\t\t\tcatch (NumberFormatException e){}\n\t\t\t\tif (!\"true\".equals(MiniClient.myProperties.getProperty(\"enable_custom_title_bar\", MiniClient.MAC_OS_X ? \"false\" : \"true\")))\n\t\t\t\t\twindowTitleStyle = 10; \/\/ platform default\n\t\t\t\tf = new MiniClientWindow(myConn.getWindowTitle(), windowTitleStyle);\n\t\t\t\tjava.awt.LayoutManager layer = new java.awt.LayoutManager()\n\t\t\t\t\t{\n\t\t\t\t\t\tpublic void addLayoutComponent(String name, java.awt.Component comp)\n\t\t\t\t\t\t{}\n\t\t\t\t\t\tpublic java.awt.Dimension minimumLayoutSize(java.awt.Container parent)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn preferredLayoutSize(parent);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic java.awt.Dimension preferredLayoutSize(java.awt.Container parent)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn parent.getPreferredSize();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void removeLayoutComponent(java.awt.Component comp)\n\t\t\t\t\t\t{}\n\t\t\t\t\t\tpublic void layoutContainer(java.awt.Container parent)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc.setBounds(parent.getInsets().left, parent.getInsets().top, parent.getWidth() - parent.getInsets().left - parent.getInsets().right,\n\t\t\t\t\t\t\t\tparent.getHeight() - parent.getInsets().top - parent.getInsets().bottom);\n\/\/System.out.println(\"LAYOUT frame bounds=\" + f.getBounds() + \" videoBounds=\" + videoBounds + \" parentBounds=\" + parent.getBounds());\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tf.getContentPane().setLayout(layer);\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tbgImage = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/Background.jpg\"));\n\t\t\t\t\tensureImageIsLoaded(bgImage);\n\t\t\t\t\tlogoImage = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/SageLogo256.png\"));\n\t\t\t\t\tensureImageIsLoaded(logoImage);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"ERROR:\" + e);\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tf.setFocusTraversalKeysEnabled(false);\n\t\t\t\t\/*\n\t\t\t\t\tif not connecting to localhost:\n\t\t\t\t\t\t- draw background to bounds (scaled)\n\t\t\t\t\t\t- draw logo to {{2% from left, 15% from top}{20% view width, 7% view height}}, no clipping, alpha = 0.85, adjust size to keep aspect ratio\n\t\t\t\t\t\t- load Arial 32 bold\n\t\t\t\t\t\t- draw the following text, double spaced using Arial 32 bold, white with black shadow (offset by (+2,+2))\n\t\t\t\t\t\t\t\"SageTV Placeshifter is connecting to\"\n\t\t\t\t\t\t\t\"the server: \"+myConn.getServerName()\n\t\t\t\t\t\t\t\"Please Wait...\"\n\t\t\t\t\t\ttext is centered in the view on the middle line, use font metrics to determine proper location\n\t\t\t\t\t\t g.setFont(pleaseWaitFont);\n\t\t\t\t\t\t g.setColor(java.awt.Color.black);\n\t\t\t\t\t\t y += 2;\n\t\t\t\t\t\t g.drawString(str1, 2 + (getWidth()\/2) - (fm.stringWidth(str1)\/2), y + fm.getAscent());\n\t\t\t\t\t\t y += fm.getHeight();\n\t\t\t\t\t\t g.drawString(str2, 2 + (getWidth()\/2) - (fm.stringWidth(str2)\/2), y + fm.getAscent());\n\t\t\t\t\t\t y += 2*fm.getHeight();\n\t\t\t\t\t\t g.drawString(str3, 2 + (getWidth()\/2) - (fm.stringWidth(str3)\/2), y + fm.getAscent());\n\t\t\t\t\t\t g.setColor(java.awt.Color.white);\n\t\t\t\t\t\t y = (getHeight() \/ 2) - fh\/2;\n\t\t\t\t\t\t g.drawString(str1, (getWidth()\/2) - (fm.stringWidth(str1)\/2), y + fm.getAscent());\n\t\t\t\t\t\t y += fm.getHeight();\n\t\t\t\t\t\t g.drawString(str2, (getWidth()\/2) - (fm.stringWidth(str2)\/2), y + fm.getAscent());\n\t\t\t\t\t\t y += 2*fm.getHeight();\n\t\t\t\t\t\t g.drawString(str3, (getWidth()\/2) - (fm.stringWidth(str3)\/2), y + fm.getAscent());\n\t\t\t\t *\/\n\t\t\t\tjava.awt.Dimension panelSize = f.getContentPane().getSize();\n\t\t\t\tc = new QuartzRendererView();\n\t\t\t\tc.setSize(panelSize);\n\t\t\t\tc.setFocusTraversalKeysEnabled(false);\n\t\t\t\tf.getContentPane().add(c);\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tjava.awt.Image frameIcon = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/tvicon.gif\"));\n\t\t\t\t\tensureImageIsLoaded(frameIcon);\n\t\t\t\t\tf.setIconImage(frameIcon);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"ERROR:\" + e);\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tf.addWindowListener(new java.awt.event.WindowAdapter()\n\t\t\t\t{\n\t\t\t\t\tpublic void windowClosing(java.awt.event.WindowEvent evt)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!f.isFullScreen() || System.getProperty(\"os.name\").toLowerCase().indexOf(\"windows\") != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMiniClient.myProperties.setProperty(\"main_window_width\", Integer.toString(f.getWidth()));\n\t\t\t\t\t\t\tMiniClient.myProperties.setProperty(\"main_window_height\", Integer.toString(f.getHeight()));\n\t\t\t\t\t\t\tMiniClient.myProperties.setProperty(\"main_window_x\", Integer.toString(f.getX()));\n\t\t\t\t\t\t\tMiniClient.myProperties.setProperty(\"main_window_y\", Integer.toString(f.getY()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmyConn.close();\n\/*\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (myConn.getMediaCmd().getPlaya() != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmyConn.getMediaCmd().getPlaya().stop();\n\t\t\t\t\t\t\t\tmyConn.getMediaCmd().getPlaya().free();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}catch (Exception e){}\n\t\t\t\t\t\tSystem.exit(0);*\/\n\t\t\t\t\t\tclose();\n\/\/\t\t\t\t\t\tf.dispose();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tc.addComponentListener(new java.awt.event.ComponentAdapter()\n\t\t\t\t{\n\t\t\t\t\tpublic void componentResized(java.awt.event.ComponentEvent evt)\n\t\t\t\t\t{\n\t\t\t\t\t\tmyConn.postResizeEvent(new java.awt.Dimension(c.getWidth(), c.getHeight()));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tf.addKeyListener(this);\n\t\t\t\tc.addKeyListener(this);\n\t\t\t\t\/\/f.addMouseListener(this);\n\t\t\t\tf.addMouseWheelListener(this);\n\t\t\t\tc.addMouseListener(this);\n\t\t\t\tif (ENABLE_MOUSE_MOTION_EVENTS)\n\t\t\t\t{\n\t\t\t\t\t\/\/f.addMouseMotionListener(this);\n\t\t\t\t\tc.addMouseMotionListener(this);\n\t\t\t\t}\n\t\t\t\tint frameX = 100;\n\t\t\t\tint frameY = 100;\n\t\t\t\tint frameW = 720;\n\t\t\t\tint frameH = 480;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tframeW = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_width\", \"720\"));\n\t\t\t\t\tframeH = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_height\", \"480\"));\n\t\t\t\t\tframeX = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_x\", \"100\"));\n\t\t\t\t\tframeY = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_y\", \"100\"));\n\t\t\t\t}\n\t\t\t\tcatch (NumberFormatException e){}\n\t\t\t\tjava.awt.Point newPos = new java.awt.Point(frameX, frameY);\n\t\t\t\tboolean foundScreen = sage.UIUtils.isPointOnAScreen(newPos);\n\t\t\t\tif (!foundScreen)\n\t\t\t\t{\n\t\t\t\t\tnewPos.x = 150;\n\t\t\t\t\tnewPos.y = 150;\n\t\t\t\t}\n\t\t\t\tf.setVisible(true);\n\t\t\t\tf.setSize(1,1);\n\t\t\t\tf.setSize(Math.max(frameW, 320), Math.max(frameH, 240));\n\t\t\t\tf.setLocation(newPos);\n\t\t\t\tif (MiniClient.fsStartup)\n\t\t\t\t\tf.setFullScreen(true);\n\t\t\t\tMiniClient.hideSplash();\n\/\/\t\t\t\tf.setVisible(true);\n\t\t\t\treturn 1;\n\t\t\tcase GFXCMD_DEINIT:\n\/\/\t\t\t\tSystem.out.println(\"DEINIT\");\n\t\t\t\tclose();\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWRECT:\n\t\t\t\tif(len==36)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height;\n\t\t\t\t\tint thickness, argbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\tthickness=readInt(16, cmddata);\n\t\t\t\t\targbTL=readInt(20, cmddata);\n\t\t\t\t\targbTR=readInt(24, cmddata);\n\t\t\t\t\targbBR=readInt(28, cmddata);\n\t\t\t\t\targbBL=readInt(32, cmddata);\n\/\/\t\t\t\t\tSystem.out.println(\"DRAWRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") thickness=\"+thickness+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\t\t\t\t\t\/\/ FIXME: no gradients on framed rects yet...\n\t\t\t\t\tdrawRect0(new java.awt.geom.Rectangle2D.Float(x, y, width, height), null,\n\t\t\t\t\t\t\t  0,\n\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), thickness,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWRECT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_FILLRECT:\n\t\t\t\t\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL\n\t\t\t\tif(len==32)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height;\n\t\t\t\t\tint argbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\targbTL=readInt(16, cmddata);\n\t\t\t\t\targbTR=readInt(20, cmddata);\n\t\t\t\t\targbBR=readInt(24, cmddata);\n\t\t\t\t\targbBL=readInt(28, cmddata);\n\/\/\t\t\t\t\tSystem.out.println(\"FILLRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\t\t\t\t\tjava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tif(gp != null) {\n\t\t\t\t\t\tdrawRect0(bounds, null,\n\t\t\t\t\t\t\t\t  0,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  gp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\n\t\t\t\t\t\t\t\t  gp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\t\t\t\t\t\t\t\t  \/\/(float)((argbTL>>24)&0xff)\/255.0f);\n\t\t\t\t\t\t\t\t  1.0f); \/\/ alpha already supplied\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdrawRect0(bounds, null,\n\t\t\t\t\t\t\t\t  0,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_FILLRECT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_CLEARRECT:\n\t\t\t\t\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL\n\t\t\t\tif(len==32)\n\t\t\t\t{\n\t\t\t\t\tint x, y, width, height,\n\t\t\t\t\t\targbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=readInt(0, cmddata);\n\t\t\t\t\ty=readInt(4, cmddata);\n\t\t\t\t\twidth=readInt(8, cmddata);\n\t\t\t\t\theight=readInt(12, cmddata);\n\t\t\t\t\targbTL=readInt(16, cmddata);\n\t\t\t\t\targbTR=readInt(20, cmddata);\n\t\t\t\t\targbBR=readInt(24, cmddata);\n\t\t\t\t\targbBL=readInt(28, cmddata);\n\/\/\t\t\t\t\tSystem.out.println(\"CLEARRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float destRect = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tclearRect0(destRect);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_CLEARRECT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWOVAL:\n\t\t\t\t\/\/ x, y, width, height, thickness, argbTL, argbTR, argbBR, argbBL,\n\t\t\t\t\/\/ clipX, clipY, clipW, clipH\n\t\t\t\tif(len==52)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height, clipX, clipY, clipW, clipH;\n\t\t\t\t\tint thickness, argbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\tthickness=readInt(16, cmddata);\n\t\t\t\t\targbTL=readInt(20, cmddata);\n\t\t\t\t\targbTR=readInt(24, cmddata);\n\t\t\t\t\targbBR=readInt(28, cmddata);\n\t\t\t\t\targbBL=readInt(32, cmddata);\n\t\t\t\t\tclipX=(float)readInt(36, cmddata);\n\t\t\t\t\tclipY=(float)readInt(40, cmddata);\n\t\t\t\t\tclipW=(float)readInt(44, cmddata);\n\t\t\t\t\tclipH=(float)readInt(48, cmddata);\n\/\/\t\t\t\t\tSystem.out.println(\"DRAWOVAL: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") thickness=\"+thickness+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\t\t\t\t\t\/\/ FIXME: no gradient for framed ovals\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\n\t\t\t\t\tdrawOval0(bounds, clipRect,\n\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), thickness,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWOVAL : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_FILLOVAL:\n\t\t\t\t\/\/ x, y, width, height, argbTL, argbTR, argbBR, argbBL,\n\t\t\t\t\/\/ clipX, clipY, clipW, clipH\n\t\t\t\tif(len==48)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height,\n\t\t\t\t\t\tclipX, clipY, clipW, clipH;\n\t\t\t\t\tint argbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\targbTL=readInt(16, cmddata);\n\t\t\t\t\targbTR=readInt(20, cmddata);\n\t\t\t\t\targbBR=readInt(24, cmddata);\n\t\t\t\t\targbBL=readInt(28, cmddata);\n\t\t\t\t\tclipX=(float)readInt(32, cmddata);\n\t\t\t\t\tclipY=(float)readInt(36, cmddata);\n\t\t\t\t\tclipW=(float)readInt(40, cmddata);\n\t\t\t\t\tclipH=(float)readInt(44, cmddata);\n\/\/\t\t\t\t\tSystem.out.println(\"FILLOVAL: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\t\t\t\t\tjava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\n\t\t\t\t\tif(gp != null) {\n\t\t\t\t\t\tdrawOval0(bounds, clipRect,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  gp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\n\t\t\t\t\t\t\t\t  gp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdrawOval0(bounds, clipRect,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_FILLOVAL : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWROUNDRECT:\n\t\t\t\t\/\/ x, y, width, height, thickness, arcRadius, argbTL, argbTR, argbBR, argbBL,\n\t\t\t\t\/\/ clipX, clipY, clipW, clipH\n\t\t\t\tif(len==56)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height,\n\t\t\t\t\t\tclipX, clipY, clipW, clipH;\n\t\t\t\t\tint thickness, arcRadius,\n\t\t\t\t\t\targbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\tthickness=readInt(16, cmddata);\n\t\t\t\t\tarcRadius=readInt(20, cmddata);\n\t\t\t\t\targbTL=readInt(24, cmddata);\n\t\t\t\t\targbTR=readInt(28, cmddata);\n\t\t\t\t\targbBR=readInt(32, cmddata);\n\t\t\t\t\targbBL=readInt(36, cmddata);\n\t\t\t\t\tclipX=(float)readInt(40, cmddata);\n\t\t\t\t\tclipY=(float)readInt(44, cmddata);\n\t\t\t\t\tclipW=(float)readInt(48, cmddata);\n\t\t\t\t\tclipH=(float)readInt(52, cmddata);\n\/\/\t\t\t\t\tSystem.out.println(\"DRAWROUNDRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") thickness=\"+thickness+\" arcRadius=\"+arcRadius+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\t\t\t\t\t\/\/ FIXME: no gradients on stroked shapes\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\n\t\t\t\t\tdrawRect0(bounds, clipRect,\n\t\t\t\t\t\t\t  arcRadius,\n\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), thickness,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWROUNDRECT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_FILLROUNDRECT:\n\t\t\t\t\/\/ x, y, width, height, arcRadius, argbTL, argbTR, argbBR, argbBL,\n\t\t\t\t\/\/ clipX, clipY, clipW, clipH\n\t\t\t\tif(len==52)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height,\n\t\t\t\t\t\tclipX, clipY, clipW, clipH;\n\t\t\t\t\tint arcRadius, argbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\tarcRadius=readInt(16, cmddata);\n\t\t\t\t\targbTL=readInt(20, cmddata);\n\t\t\t\t\targbTR=readInt(24, cmddata);\n\t\t\t\t\targbBR=readInt(28, cmddata);\n\t\t\t\t\targbBL=readInt(32, cmddata);\n\t\t\t\t\tclipX=(float)readInt(36, cmddata);\n\t\t\t\t\tclipY=(float)readInt(40, cmddata);\n\t\t\t\t\tclipW=(float)readInt(44, cmddata);\n\t\t\t\t\tclipH=(float)readInt(48, cmddata);\n\/\/\t\t\t\t\tSystem.out.println(\"FILLROUNDRECT: dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") arcRadius=\"+arcRadius+\" argbTL=\"+Integer.toHexString(argbTL)+\" argbTR=\"+Integer.toHexString(argbTR)+\" argbBL=\"+Integer.toHexString(argbBL)+\" argbBR=\"+Integer.toHexString(argbBR));\n\t\t\t\t\tjava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\n\t\t\t\t\tif(gp != null) {\n\t\t\t\t\t\tdrawRect0(bounds, clipRect,\n\t\t\t\t\t\t\t\t  arcRadius,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  gp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\n\t\t\t\t\t\t\t\t  gp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\t\t\t\t\t\t\t\t  \/\/(float)((argbTL>>24)&0xff)\/255.0f);\n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdrawRect0(bounds, clipRect,\n\t\t\t\t\t\t\t\t  arcRadius,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_FILLROUNDRECT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWTEXT:\n\t\t\t\t\/\/ x, y, len, text, handle, argb, clipX, clipY, clipW, clipH\n\t\t\t\tif(len>=36 && len>=(36+readInt(8, cmddata)*2))\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, clipX, clipY, clipW, clipH;\n\t\t\t\t\tint textlen, fontHandle, argb;\n\t\t\t\t\tStringBuffer text = new StringBuffer();\n\t\t\t\t\tint i;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\ttextlen=readInt(8, cmddata);\n\t\t\t\t\tfor(i=0;i<textlen;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttext.append((char)readShort(12+i*2, cmddata));\n\t\t\t\t\t}\n\t\t\t\t\tfontHandle=readInt(textlen*2+12, cmddata);\n\t\t\t\t\targb=readInt(textlen*2+16, cmddata);\n\t\t\t\t\tclipX=(float)readInt(textlen*2+20, cmddata);\n\t\t\t\t\tclipY=(float)readInt(textlen*2+24, cmddata);\n\t\t\t\t\tclipW=(float)readInt(textlen*2+28, cmddata);\n\t\t\t\t\tclipH=(float)readInt(textlen*2+32, cmddata);\n\t\t\t\t\t\/\/ TODO: check if this is needed\n\/\/\t\t\t\t\tif (System.getProperty(\"java.version\").startsWith(\"1.4\"))\n\/\/\t\t\t\t\t\tclipW = clipW * 5 \/ 4;\n\/\/\t\t\t\t\tSystem.out.println(\"DRAWTEXT: dest=(\"+x+\",\"+y+\") clip=(\"+clipX+\",\"+clipY+\" \"+clipW+\"x\"+clipH+\") fontHandle=\"+fontHandle+\" argb=\"+Integer.toHexString(argb)+\" text=\"+text.toString());\n\t\t\t\t\tMcFont fontPtr = (McFont)fontMap.get(new Integer(fontHandle));\n\t\t\t\t\tif(fontPtr != null) {\n\t\t\t\t\t\t\/\/ use AWT string bounds or we'll clip on occasion\n\t\t\t\t\t\tString theString = text.toString();\n\/\/\t\t\t\t\t\tjava.awt.Dimension textSize = fontPtr.getStringSize(theString);\n\t\t\t\t\t\tfloat[] positions = fontPtr.getGlyphPositions(theString);\n\/\/\t\t\t\t\t\tSystem.out.println(\"drawText: \\\"\"+theString+\"\\\"  loc=(\"+x+\",\"+y+\") num positions=\"+positions.length);\n\t\t\t\t\t\tdrawTextWithPositions0(theString, fontPtr.nativeFont,\n\t\t\t\t\t\t\tx, y, positions, new java.awt.geom.Rectangle2D.Float(clipX,clipY,clipW,clipH),\n\t\t\t\t\t\t\tnew java.awt.Color(argb, true));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWTEXTURED:\n\t\t\t\t\/\/ x, y, width, height, handle, srcx, srcy, srcwidth, srcheight, blend\n\t\t\t\tif(len==40)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height,\n\t\t\t\t\t\tsrcx, srcy, srcwidth, srcheight;\n\t\t\t\t\tint handle, blend; \/\/ blend is a color, use alpha component for blending\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\thandle=readInt(16, cmddata);\t\t\t\/\/ either an image handle or layer handle (if not in imageMap)\n\t\t\t\t\tsrcx=(float)readInt(20, cmddata);\n\t\t\t\t\tsrcy=(float)readInt(24, cmddata);\n\t\t\t\t\tsrcwidth=(float)readInt(28, cmddata);\n\t\t\t\t\tsrcheight=(float)readInt(32, cmddata);\n\t\t\t\t\tblend=readInt(36, cmddata);\n\t\t\t\t\t\/*\n\t\t\t\t\t\tif height < 0\n\t\t\t\t\t\t\tdisable blending\n\t\t\t\t\t\tif width < 0 (font mode, composite with background and blend with given color)\n\t\t\t\t\t\t\tblend with full RGBA color\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tblend with alpha only\n\t\t\t\t\t *\/\n\/\/\t\t\t\t\tSystem.out.println(\"DRAWTEXTURED: handle=\"+handle+\" dest=(\"+x+\",\"+y+\" \"+width+\"x\"+height+\") src=(\"+srcx+\",\"+srcy+\" \"+srcwidth+\"x\"+srcheight+\") blend=\"+Integer.toHexString(blend));\n\t\t\t\t\tboolean doBlend = true;\n\t\t\t\t\tif(height < 0) {\n\t\t\t\t\t\tdoBlend = false;\n\t\t\t\t\t\theight *= -1;\n\t\t\t\t\t}\n\t\t\t\t\tif(width < 0) {\n\t\t\t\t\t\twidth *= -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(doBlend)\n\t\t\t\t\t\t\tblend |= 0x00ffffff; \/\/ only use alpha\n\t\t\t\t\t}\n\t\t\t\t\tLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float destRect = new java.awt.geom.Rectangle2D.Float(x,y,width,height);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float srcRect = new java.awt.geom.Rectangle2D.Float(srcx,srcy,srcwidth,srcheight);\n\t\t\t\t\tif(imagePtr != null) {\n\t\t\t\t\t\tmyConn.registerImageAccess(handle);\n\/\/\t\t\t\t\t\tSystem.out.println(\"              (drawing image) imagePtr=\"+imagePtr);\n\t\t\t\t\t\tdrawImage1(imagePtr.longValue(),\n\t\t\t\t\t\t\t\t   destRect, srcRect,\n\t\t\t\t\t\t\t\t   (doBlend) ? new java.awt.Color(blend, true) : null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\timagePtr = (Long)layerMap.get(new Integer(handle));\n\t\t\t\t\t\tif(imagePtr != null) {\n\t\t\t\t\t\t\tmyConn.registerImageAccess(handle);\n\/\/\t\t\t\t\t\t\tSystem.out.println(\"              (compositing surface) layerPtr=\"+Long.toHexString(imagePtr.longValue())+\" currentLayer=\"+currentLayer);\n\t\t\t\t\t\t\tfloat alpha = (doBlend ? (float)(((blend >> 24)&0xff))\/255.0f : 1.0f);\n\t\t\t\t\t\t\tcomposite0(imagePtr.longValue(), currentLayer, srcRect, destRect, alpha, doBlend);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR invalid handle passed for texture rendering of: \" + handle);\n\t\t\t\t\t\t\tabortRenderCycle = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXTURED : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWLINE:\n\t\t\t\t\/\/ x1, y1, x2, y2, argb1, argb2\n\t\t\t\tif(len==24)\n\t\t\t\t{\n\t\t\t\t\tfloat x1, y1, x2, y2;\n\t\t\t\t\tint argb1, argb2;\n\t\t\t\t\tx1=readInt(0, cmddata);\n\t\t\t\t\ty1=readInt(4, cmddata);\n\t\t\t\t\tx2=readInt(8, cmddata);\n\t\t\t\t\ty2=readInt(12, cmddata);\n\t\t\t\t\targb1=readInt(16, cmddata);\n\t\t\t\t\targb2=readInt(20, cmddata);\n\/\/\t\t\t\t\tSystem.out.println(\"DRAWLINE: start=(\"+x1+\",\"+y1+\") end=(\"+x2+\",\"+y2+\") argb1=\"+Integer.toHexString(argb1)+\" argb2=\"+Integer.toHexString(argb2));\n\t\t\t\t\tdrawLine0(x1, y1, x2, y2, 1, new java.awt.Color(argb1, true));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWLINE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADIMAGE:\n\t\t\t\t\/\/ width, height\n\t\t\t\tif(len>=8)\n\t\t\t\t{\n\t\t\t\t\tint width, height;\n\t\t\t\t\tint imghandle = 0;\n\t\t\t\t\twidth=readInt(0, cmddata);\n\t\t\t\t\theight=readInt(4, cmddata);\n\/\/\t\t\t\t\tSystem.out.println(\"LOADIMAGE: size=(\"+width+\"x\"+height+\")\");\n\t\t\t\t\tif (width * height * 4 + imageCacheSize > imageCacheLimit)\n\t\t\t\t\t{\n\t\t\t\t\t\timghandle = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t\/\/ creating a new image from bitmap data being sent over myConn, create a new empty image\n\t\t\t\t\t\tlong imagePtr = createNewImage0(width, height);\n\t\t\t\t\t\timghandle = handleCount++;\n\/\/\t\t\t\t\t\tSystem.out.println(\"           imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\n\t\t\t\t\t\timageMap.put(new Integer(imghandle), new Long(imagePtr));\t\/\/ actual value is filled in later when it's prepared\n\t\t\t\t\t\timageCacheSize += width * height * 4;\n\t\t\t\t\t}\n\t\t\t\t\thasret[0]=1;\n\t\t\t\t\treturn imghandle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADIMAGETARGETED:\n\t\t\t\t\/\/ handle, width, height \/\/ Not used unless we do uncompressed images\n\t\t\t\tif(len>=12)\n\t\t\t\t{\n\t\t\t\t\tint width, height;\n\t\t\t\t\tint imghandle = readInt(0, cmddata);\n\t\t\t\t\twidth=readInt(4, cmddata);\n\t\t\t\t\theight=readInt(8, cmddata);\n\t\t\t\t\twhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n\t\t\t\t\t{\n\t\t\t\t\t\t\/\/ Keep freeing the oldest image until we have enough memory to do this\n\t\t\t\t\t\tint oldestImage = myConn.getOldestImage();\n\t\t\t\t\t\tif (oldestImage != 0)\n\t\t\t\t\t\t{\nSystem.out.println(\"Freeing image to make room in cache\");\n\t\t\t\t\t\t\tunloadImage(oldestImage);\n\t\t\t\t\t\t\tmyConn.postImageUnload(oldestImage);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlong imagePtr = createNewImage0(width, height);\n\/\/\t\t\t\t\t\tSystem.out.println(\"           imghandle=\"+imghandle+\" imagePtr=\"+imagePtr);\n\t\t\t\t\timageMap.put(new Integer(imghandle), new Long(imagePtr));\t\/\/ actual value is filled in later when it's prepared\n\t\t\t\t\timageCacheSize += width * height * 4;\n\t\t\t\t\tmyConn.registerImageAccess(imghandle);\n\t\t\t\t\thasret[0]=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGETARGETED : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_CREATESURFACE:\n\t\t\t\t\/\/ width, height\n\t\t\t\tif(len>=8)\n\t\t\t\t{\n\t\t\t\t\tint width, height;\n\t\t\t\t\tint handle = handleCount++;;\n\t\t\t\t\twidth=readInt(0, cmddata);\n\t\t\t\t\theight=readInt(4, cmddata);\n\t\t\t\t\t\/\/ width\/height is managed here\n\t\t\t\t\tlong layerPtr = createLayer0(c.getSize());\n\t\t\t\t\tlayerMap.put(new Integer(handle), new Long(layerPtr));\n\/\/\t\t\t\t\tSystem.out.println(\"CREATESURFACE: (\"+width+\",\"+height+\") handle=\"+handle+\" layerPtr=\"+layerPtr);\n\t\t\t\t\thasret[0]=1;\n\t\t\t\t\treturn handle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_CREATESURFACE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_PREPIMAGE:\n\t\t\t\t\/\/ width, height\n\t\t\t\tif(len>=8)\n\t\t\t\t{\n\t\t\t\t\tint width, height;\n\t\t\t\t\t\/\/int imghandle = handleCount++;;\n\t\t\t\t\twidth=readInt(0, cmddata);\n\t\t\t\t\theight=readInt(4, cmddata);\n\t\t\t\t\tint imghandle = 1;\n\/\/\t\t\t\t\tSystem.out.println(\"PREPIMAGE: size=(\"+width+\"x\"+height+\")\");\n\t\t\t\t\tif (width * height * 4 + imageCacheSize > imageCacheLimit)\n\t\t\t\t\t\timghandle = 0;\n\t\t\t\t\telse if (len >= 12)\n\t\t\t\t\t{\n\t\t\t\t\t\t\/\/ We've got enough room for it and there's a cache ID, check if we've got it cached locally\n\t\t\t\t\t\tint strlen = readInt(8, cmddata);\n\t\t\t\t\t\tif (strlen > 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString rezName = new String(cmddata, 16, strlen - 1);\n\/\/\t\t\t\t\t\t\tSystem.out.println(\"           rezName=\"+rezName);\n\t\t\t\t\t\t\tlastImageResourceID = rezName;\n\t\t\t\t\t\t\t\/\/ We use this hashcode to match it up on the loadCompressedImage call so we know we're caching the right thing\n\t\t\t\t\t\t\tlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\n\t\t\t\t\t\t\tjava.io.File cachedFile = myConn.getCachedImageFile(rezName);\n\t\t\t\t\t\t\tif (cachedFile != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\/\/ We've got it locally in our cache! Read it from there.\n\t\t\t\t\t\t\t\tlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\n\t\t\t\t\t\t\t\tif(imagePtr != 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tjava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\n\t\t\t\t\t\t\t\t\tif(imgSize != null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\/\/ valid image in cache, use it\n\t\t\t\t\t\t\t\t\t\t\timghandle = handleCount++;\n\/\/\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"           loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\n\t\t\t\t\t\t\t\t\t\t\timageMap.put(new Integer(imghandle), new Long(imagePtr));\n\t\t\t\t\t\t\t\t\t\t\timageCacheSize += getImageSize0(imagePtr);\n\t\t\t\t\t\t\t\t\t\t\thasret[0] = 1;\n\t\t\t\t\t\t\t\t\t\t\treturn -1 * imghandle;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\tfreeNativeImage0(imagePtr);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tfreeNativeImage0(imagePtr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\/\/imghandle=STBGFX.GFX_loadImage(width, height);\n\t\t\t\t\thasret[0]=1;\n\t\t\t\t\treturn imghandle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_PREPIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_PREPIMAGETARGETED:\n\t\t\t\t\/\/ handle, width, height, [rezID]\n\t\t\t\tif(len>=12)\n\t\t\t\t{\n\t\t\t\t\tint imghandle, width, height;\n\t\t\t\t\timghandle = readInt(0, cmddata);\n\t\t\t\t\twidth=readInt(4, cmddata);\n\t\t\t\t\theight=readInt(8, cmddata);\n\t\t\t\t\tint strlen = readInt(12, cmddata);\n\t\t\t\t\twhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n\t\t\t\t\t{\n\t\t\t\t\t\t\/\/ Keep freeing the oldest image until we have enough memory to do this\n\t\t\t\t\t\tint oldestImage = myConn.getOldestImage();\n\t\t\t\t\t\tif (oldestImage != 0)\n\t\t\t\t\t\t{\nSystem.out.println(\"Freeing image to make room in cache\");\n\t\t\t\t\t\t\tunloadImage(oldestImage);\n\t\t\t\t\t\t\tmyConn.postImageUnload(oldestImage);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (len >= 16)\n\t\t\t\t\t{\n\t\t\t\t\t\t\/\/ We will not have this cached locally...but setup our vars to track it\n\t\t\t\t\t\tString rezName = new String(cmddata, 20, strlen - 1);\n\t\t\t\t\t\tlastImageResourceID = rezName;\n\t\t\t\t\t\tlastImageResourceIDHandle = imghandle;\nSystem.out.println(\"Prepped targeted image with handle \" + imghandle + \" resource=\" + rezName);\n\t\t\t\t\t}\n\t\t\t\t\tmyConn.registerImageAccess(imghandle);\n\t\t\t\t\thasret[0]=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_PREPIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADCACHEDIMAGE:\n\t\t\t\t\/\/ width, height\n\t\t\t\tif(len>=18)\n\t\t\t\t{\n\t\t\t\t\tint width, height, imghandle;\n\t\t\t\t\timghandle = readInt(0, cmddata);\n\t\t\t\t\twidth = readInt(4, cmddata);\n\t\t\t\t\theight = readInt(8, cmddata);\n\t\t\t\t\tint strlen = readInt(12, cmddata);\n\t\t\t\t\tString rezName = new String(cmddata, 20, strlen - 1);\nSystem.out.println(\"imghandle=\" + imghandle + \" width=\" + width + \" height=\" + height + \" strlen=\" + strlen + \" rezName=\" + rezName);\n\t\t\t\t\twhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n\t\t\t\t\t{\n\t\t\t\t\t\t\/\/ Keep freeing the oldest image until we have enough memory to do this\n\t\t\t\t\t\tint oldestImage = myConn.getOldestImage();\n\t\t\t\t\t\tif (oldestImage != 0)\n\t\t\t\t\t\t{\nSystem.out.println(\"Freeing image to make room in cache\");\n\t\t\t\t\t\t\tunloadImage(oldestImage);\n\t\t\t\t\t\t\tmyConn.postImageUnload(oldestImage);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmyConn.registerImageAccess(imghandle);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(\"Loading resource from cache: \" + rezName);\n\t\t\t\t\t\tjava.io.File cachedFile = myConn.getCachedImageFile(rezName);\n\t\t\t\t\t\tif (cachedFile != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\/\/ We've got it locally in our cache! Read it from there.\n\t\t\t\t\t\t\tSystem.out.println(\"Image found in cache!\");\n\t\t\t\t\t\t\t\/\/ We've got it locally in our cache! Read it from there.\n\t\t\t\t\t\t\tlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\n\t\t\t\t\t\t\tif(imagePtr != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tjava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\n\t\t\t\t\t\t\t\tif(imgSize != null && imgSize.getWidth() == width && imgSize.getHeight() == height)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\/\/ valid image in cache, use it\n\/\/\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"           loaded from cache, imagePtr=\"+imagePtr+\" handle=\"+imghandle);\n\t\t\t\t\t\t\t\t\timageMap.put(new Integer(imghandle), new Long(imagePtr));\n\t\t\t\t\t\t\t\t\timageCacheSize += getImageSize0(imagePtr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (imgSize != null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\/\/ It doesn't match the cache\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"CACHE ID verification failed for rezName=\" + rezName + \" target=\" + width + \"x\" + height + \" actual=\" + imgSize.getWidth() + \"x\" + imgSize.getHeight());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"CACHE Load failed for rezName=\" + rezName);\n\t\t\t\t\t\t\t\t\tcachedFile.delete();\n\t\t\t\t\t\t\t\t\tfreeNativeImage0(imagePtr);\n\t\t\t\t\t\t\t\t\t\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\n\t\t\t\t\t\t\t\t\tmyConn.postImageUnload(imghandle);\n\t\t\t\t\t\t\t\t\tmyConn.postOfflineCacheChange(false, rezName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcachedFile.delete();\n\t\t\t\t\t\t\t\t\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\n\t\t\t\t\t\t\t\tmyConn.postImageUnload(imghandle);\n\t\t\t\t\t\t\t\tmyConn.postOfflineCacheChange(false, rezName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR Image not found in cache that should be there! rezName=\" + rezName);\n\t\t\t\t\t\t\t\/\/ This load failed but the server thought it would succeed, so we need to inform it that the image is no longer loaded.\n\t\t\t\t\t\t\tmyConn.postImageUnload(imghandle);\n\t\t\t\t\t\t\tmyConn.postOfflineCacheChange(false, rezName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (java.io.IOException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(\"ERROR loading compressed image: \" + e);\n\t\t\t\t\t}\n\t\t\t\t\thasret[0]=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_PREPIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_UNLOADIMAGE:\n\t\t\t\t\/\/ handle\n\t\t\t\tif(len==4)\n\t\t\t\t{\n\t\t\t\t\tint handle;\n\t\t\t\t\thandle=readInt(0, cmddata);\n\t\t\t\t\tunloadImage(handle);\n\t\t\t\t\tmyConn.clearImageAccess(handle);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_UNLOADIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_SETTARGETSURFACE:\n\t\t\t\t\/\/ handle\n\t\t\t\tif(len==4)\n\t\t\t\t{\n\t\t\t\t\tint handle;\n\t\t\t\t\thandle=readInt(0, cmddata);\n\t\t\t\t\t\/\/STBGFX.GFX_unloadImage(handle);\n\t\t\t\t\tLong layerPtr = (Long)layerMap.get(new Integer(handle));\n\/\/\t\t\t\t\tSystem.out.println(\"SETTARGETSURFACE: handle=\"+handle+\" layerPtr=\"+ (layerPtr == null ? \"0\" : Long.toHexString(layerPtr.longValue())));\n\t\t\t\t\tcurrentLayer = (layerPtr != null) ? layerPtr.longValue() : 0;\n\t\t\t\t\tjava.awt.Rectangle clipRect = new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight());\n\t\t\t\t\tsetLayer0(currentLayer, c.getSize(), clipRect);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_SETTARGETSURFACE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADFONT:\n\t\t\t\t\/\/ namelen, name, style, size\n\t\t\t\tif(len>=12 && len>=(12+readInt(0, cmddata)))\n\t\t\t\t{\n\t\t\t\t\tint namelen, style, size;\n\t\t\t\t\tStringBuffer name = new StringBuffer();\n\t\t\t\t\tint i;\n\t\t\t\t\tint fonthandle = handleCount++;\n\t\t\t\t\tnamelen=readInt(0, cmddata);\n\t\t\t\t\tfor(i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n\t\t\t\t\t{\n\t\t\t\t\t\tname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n\t\t\t\t\t}\n\t\t\t\t\tstyle=readInt(namelen+4, cmddata);\n\t\t\t\t\tsize=readInt(namelen+8, cmddata);\n\/\/\t\t\t\t\tSystem.out.println(\"LOADFONT: handle=\"+fonthandle+\" name=\"+name.toString()+\" style=\"+Integer.toHexString(style)+\" size=\"+size);\n\t\t\t\t\tMcFont fontPtr = new McFont(name.toString(), style, size);\n\/\/\t\t\t\t\tlong fontPtr = loadFont0(name.toString(), style, size);\n\t\t\t\t\tif(fontPtr == null) {\n\t\t\t\t\t\t\/\/ FIXME: implement!\n\t\t\t\t\t\t\/\/ we don't have the font on this sytem (yet) see if it's cached and try to load it manually\n\/\/\t\t\t\t\t\tString cacheName = name.toString() + \"-\" + style;\n\/\/\t\t\t\t\t\tfontPtr = loadCachedFont0(cacheDir.getAbsolutePath(), name.toString() + \"-\" + myConn.getServerName(), style, size);\n\/\/\t\t\t\t\t\tif (fontPtr == 0) {\n\t\t\t\t\t\t\t\/\/ Return that we don't have this font so it'll load it into our cache\n\t\t\t\t\t\t\thasret[0] = 1;\n\t\t\t\t\t\t\treturn 0;\n\/\/\t\t\t\t\t\t}\n\t\t\t\t\t}\n\/\/\t\t\t\t\tSystem.out.println(\"          fontPtr=\" + fontPtr);\n\t\t\t\t\tfontMap.put(new Integer(fonthandle), fontPtr);\n\t\t\t\t\thasret[0] = 1;\n\t\t\t\t\treturn fonthandle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADFONT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_UNLOADFONT:\n\t\t\t\t\/\/ handle\n\t\t\t\tif(len==4)\n\t\t\t\t{\n\t\t\t\t\tint handle;\n\t\t\t\t\thandle=readInt(0, cmddata);\n\t\t\t\t\t\/\/STBGFX.GFX_unloadFont(handle);\n\t\t\t\t\tMcFont fontPtr = (McFont)fontMap.get(new Integer(handle));\n\/\/\t\t\t\t\tSystem.out.println(\"UNLOADFONT: handle=\"+handle+\" fontPtr=\"+fontPtr);\n\t\t\t\t\tif(fontPtr != null) fontPtr.unload();\n\t\t\t\t\tfontMap.remove(new Integer(handle));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_UNLOADFONT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADFONTSTREAM:\n\t\t\t    \/\/ namelen, name, len, data\n\t\t\t\tif (len>=8)\n\t\t\t\t{\n\t\t\t\t\tStringBuffer name = new StringBuffer();\n\t\t\t\t\tint namelen = readInt(0, cmddata);\n\t\t\t\t\tfor(int i=0;i<namelen-1;i++) \/\/ skip the terminating \\0 character\n\t\t\t\t\t{\n\t\t\t\t\t\tname.append((char) cmddata[8 + i]); \/\/ an extra 4 for the header\n\t\t\t\t\t}\n\t\t\t\t\tint datalen = readInt(4 + namelen, cmddata);\n\t\t\t\t\tif (len >= datalen + 8 + namelen)\n\t\t\t\t\t{\n\/\/\t\t\t\t\t\tSystem.out.println(\"Saving font \" + name.toString() + \" to cache\");\n\t\t\t\t\t\tmyConn.saveCacheData(name.toString() + \"-\" + myConn.getServerName(), cmddata, 12 + namelen, datalen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADFONTSTREAM : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_FLIPBUFFER:\n\/\/\t\t\t\tSystem.out.println(\"FLIPBUFFER\");\n\t\t\t\tif (abortRenderCycle)\n\t\t\t\t{\nSystem.out.println(\"ERROR in painting cycle, ABORT was set...send full repaint command\");\n\t\t\t\t\tmyConn.postRepaintEvent(0, 0, c.getWidth(), c.getHeight());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpresent0(c.nativeView, new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight()));\n\t\t\t\t}\n\t\t\t\thasret[0] = 1;\n\t\t\t\t\/\/STBGFX.GFX_flipBuffer();\n\t\t\t\tfirstFrameDone = true;\n\t\t\t\treturn 0;\n\t\t\tcase GFXCMD_STARTFRAME:\n\/\/\t\t\t\tSystem.out.println(\"STARTFRAME\");\n\t\t\t\t\/\/ prepare for a new frame to be rendered\n\t\t\t\tsetTargetView0(c.nativeView);\n\t\t\t\tsetLayer0(0, c.getSize(), null); \/\/ this makes sure the drawing surface gets resized properly\n\t\t\t\tabortRenderCycle = false;\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADIMAGELINE:\n\t\t\t\t\/\/ handle, line, len, data\n\t\t\t\tif(len>=12 && len>=(12+readInt(8, cmddata)))\n\t\t\t\t{\n\t\t\t\t\tint handle, line, len2;\n\t\t\t\t\t\/\/unsigned char *data=&cmddata[12];\n\t\t\t\t\thandle=readInt(0, cmddata);\n\t\t\t\t\tline=readInt(4, cmddata);\n\t\t\t\t\tlen2=readInt(8, cmddata);\n\t\t\t\t\t\/\/ the last number is the offset into the data array to start reading from\n\t\t\t\t\t\/\/STBGFX.GFX_loadImageLine(handle, line, len, data, 12);\n\t\t\t\t\t\/\/int dataPos = 12;\n\t\t\t\t\tLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\/\/\t\t\t\t\tSystem.out.println(\"LOADIMAGELINE: handle=\"+handle+\" imagePtr=\"+imagePtr+\" line=\"+line+\" len2=\"+len2);\n\t\t\t\t\tif(imagePtr != null)\n\t\t\t\t\t\tloadImageLine0(imagePtr.longValue(), line, cmddata, 16\/*12*\/, len2);\n\t\t\t\t\tmyConn.registerImageAccess(handle);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGELINE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADIMAGECOMPRESSED:\n\t\t\t\t\/\/ handle, line, len, data\n\t\t\t\tif(len>=8 && len>=(8+readInt(4, cmddata)))\n\t\t\t\t{\n\t\t\t\t\tint handle, len2;\n\t\t\t\t\thandle=readInt(0, cmddata);\n\t\t\t\t\tlen2=readInt(4, cmddata);\n\t\t\t\t\tif (lastImageResourceID != null && lastImageResourceIDHandle == handle)\n\t\t\t\t\t{\n\t\t\t\t\t\tmyConn.saveCacheData(lastImageResourceID, cmddata, 12, len2);\n\t\t\t\t\t\tmyConn.postOfflineCacheChange(true, lastImageResourceID);\n\t\t\t\t\t}\n\t\t\t\t\tif (!myConn.doesUseAdvancedImageCaching())\n\t\t\t\t\t{\n\t\t\t\t\t\thandle = handleCount++;\n\t\t\t\t\t\thasret[0] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\thasret[0] = 0;\n\t\t\t\t\tmyConn.registerImageAccess(handle);\n\t\t\t\t\tlong imagePtr = createImageFromBytes0(cmddata, 12, len2, null); \/\/ FIXME: grab extension if possible\n\/\/\t\t\t\t\tSystem.out.println(\"LOADIMAGECOMPRESSED: handle=\"+handle+\" imagePtr=\"+imagePtr+\" len2=\"+len2);\n\t\t\t\t\timageMap.put(new Integer(handle), new Long(imagePtr));\n\t\t\t\t\timageCacheSize += getImageSize0(imagePtr);\n\t\t\t\t\treturn handle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGECOMPRESSED : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_XFMIMAGE:\n\t\t\t\t\/\/ srcHandle, destHandle, destWidth, destHeight, maskCornerArc\n\t\t\t\tif (len >= 20)\n\t\t\t\t{\n\t\t\t\t\tint srcHandle, destHandle, destWidth, destHeight, maskCornerArc;\n\t\t\t\t\tsrcHandle = readInt(0, cmddata);\n\t\t\t\t\tdestHandle = readInt(4, cmddata);\t\t\/\/ seems to be unused\n\t\t\t\t\tdestWidth = readInt(8,  cmddata);\t\t\/\/ scaled size (ignore?)\n\t\t\t\t\tdestHeight = readInt(12, cmddata);\n\t\t\t\t\tmaskCornerArc = readInt(16, cmddata);\n\t\t\t\t\tint rvHandle = destHandle;\n\t\t\t\t\tif (!myConn.doesUseAdvancedImageCaching())\n\t\t\t\t\t{\n\t\t\t\t\t\trvHandle = handleCount++;\n\t\t\t\t\t\thasret[0] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\thasret[0] = 0;\n\t\t\t\t\t\/\/ we cheat and apply the transforms to a metaimage object without actually creating a new image (saves oodles of memory)\n\t\t\t\t\tLong srcImg = (Long)imageMap.get(new Integer(srcHandle));\n\/\/\t\t\t\t\tSystem.out.println(\"XFMIMAGE: srcHandle=\"+srcHandle+\" srcImg=\"+srcImg+\" destHandle=\"+destHandle+\" destWidth=\"+destWidth+\" destHeight=\"+destHeight+\" maskCornerArc=\"+maskCornerArc);\n\t\t\t\t\tif(srcImg != null) {\n\t\t\t\t\t\tlong newImage = transformImage0(srcImg.longValue(), destWidth, destHeight, maskCornerArc);\n\t\t\t\t\t\tif(newImage != 0) {\n\/\/\t\t\t\t\t\t\tSystem.out.println(\"          newImage=\"+newImage);\n\t\t\t\t\t\t\timageMap.put(new Integer(rvHandle), new Long(newImage));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn rvHandle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_XFMIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_SETVIDEOPROP:\n\t\t\t\tif (len >= 40)\n\t\t\t\t{\n\t\t\t\t\tjava.awt.Rectangle srcRect = new java.awt.Rectangle(readInt(4, cmddata), readInt(8, cmddata),\n\t\t\t\t\t\treadInt(12, cmddata), readInt(16, cmddata));\n\t\t\t\t\tjava.awt.Rectangle destRect = new java.awt.Rectangle(readInt(20, cmddata), readInt(24, cmddata),\n\t\t\t\t\t\treadInt(28, cmddata), readInt(32, cmddata));\n\t\t\t\t\tSystem.out.println(\"SETVIDEOPROP: srcRect=\"+srcRect+\" dstRect=\"+destRect);\n\t\t\t\t\tsetVideoBounds(srcRect, destRect);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_SETVIDEOPROP: \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}","code_wo_comment":"public int ExecuteGFXCommand(int cmd, int len, byte[] cmddata, int[] hasret)\n\t{\n\t\tlen -= 4;\n\t    hasret[0] = 0;\n\t\n\t\tif((cmd != GFXCMD_INIT) && (cmd != GFXCMD_DEINIT))\n\t\t{\n\t\t\tif((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\n\t\t\t\n\t\t\t\twhile((f != null) ? (!f.isDisplayable() || !f.isValid() || !f.isShowing()) : true) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tThread.sleep(10);\n\t\t\t\t\t} catch(InterruptedException ex) {}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c != null)\n\t\t{\n\t\t\tswitch(cmd)\n\t\t\t{\n\t\t\t\tcase GFXCMD_INIT:\n\t\t\t\tcase GFXCMD_DEINIT:\n\t\t\t\tcase GFXCMD_STARTFRAME:\n\t\t\t\tcase GFXCMD_FLIPBUFFER:\n\t\t\t\t\tc.setCursor(null);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GFXCMD_DRAWRECT:\n\t\t\t\tcase GFXCMD_FILLRECT:\n\t\t\t\tcase GFXCMD_CLEARRECT:\n\t\t\t\tcase GFXCMD_DRAWOVAL:\n\t\t\t\tcase GFXCMD_FILLOVAL:\n\t\t\t\tcase GFXCMD_DRAWROUNDRECT:\n\t\t\t\tcase GFXCMD_FILLROUNDRECT:\n\t\t\t\tcase GFXCMD_DRAWTEXT:\n\t\t\t\tcase GFXCMD_DRAWTEXTURED:\n\t\t\t\tcase GFXCMD_DRAWLINE:\n\t\t\t\tcase GFXCMD_LOADIMAGE:\n\t\t\t\tcase GFXCMD_LOADIMAGETARGETED:\n\t\t\t\tcase GFXCMD_UNLOADIMAGE:\n\t\t\t\tcase GFXCMD_LOADFONT:\n\t\t\t\tcase GFXCMD_UNLOADFONT:\n\t\t\t\tcase GFXCMD_SETTARGETSURFACE:\n\t\t\t\tcase GFXCMD_CREATESURFACE:\n\t\t\t\t\tbreak;\n\t\t\t\tcase GFXCMD_PREPIMAGE:\n\t\t\t\tcase GFXCMD_LOADIMAGELINE:\n\t\t\t\tcase GFXCMD_LOADIMAGECOMPRESSED:\n\t\t\t\tcase GFXCMD_XFMIMAGE:\n\t\t\t\tcase GFXCMD_LOADCACHEDIMAGE:\n\t\t\t\tcase GFXCMD_PREPIMAGETARGETED:\n\t\t\t\t\tif (!cursorHidden)\n\t\t\t\t\t\tc.setCursor(java.awt.Cursor.getPredefinedCursor(java.awt.Cursor.WAIT_CURSOR));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswitch(cmd)\n\t\t{\n\t\t\tcase GFXCMD_INIT:\n\t\t\t\thasret[0] = 1;\n\t\t\t\n\t\t\t\tinit0();\n\t\t\t\tint windowTitleStyle = 0;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\twindowTitleStyle = Integer.parseInt(MiniClient.myProperties.getProperty(\"window_title_style\", \"0\"));\n\t\t\t\t}\n\t\t\t\tcatch (NumberFormatException e){}\n\t\t\t\tif (!\"true\".equals(MiniClient.myProperties.getProperty(\"enable_custom_title_bar\", MiniClient.MAC_OS_X ? \"false\" : \"true\")))\n\t\t\t\t\twindowTitleStyle = 10;\n\t\t\t\tf = new MiniClientWindow(myConn.getWindowTitle(), windowTitleStyle);\n\t\t\t\tjava.awt.LayoutManager layer = new java.awt.LayoutManager()\n\t\t\t\t\t{\n\t\t\t\t\t\tpublic void addLayoutComponent(String name, java.awt.Component comp)\n\t\t\t\t\t\t{}\n\t\t\t\t\t\tpublic java.awt.Dimension minimumLayoutSize(java.awt.Container parent)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn preferredLayoutSize(parent);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic java.awt.Dimension preferredLayoutSize(java.awt.Container parent)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn parent.getPreferredSize();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void removeLayoutComponent(java.awt.Component comp)\n\t\t\t\t\t\t{}\n\t\t\t\t\t\tpublic void layoutContainer(java.awt.Container parent)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc.setBounds(parent.getInsets().left, parent.getInsets().top, parent.getWidth() - parent.getInsets().left - parent.getInsets().right,\n\t\t\t\t\t\t\t\tparent.getHeight() - parent.getInsets().top - parent.getInsets().bottom);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tf.getContentPane().setLayout(layer);\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tbgImage = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/Background.jpg\"));\n\t\t\t\t\tensureImageIsLoaded(bgImage);\n\t\t\t\t\tlogoImage = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/SageLogo256.png\"));\n\t\t\t\t\tensureImageIsLoaded(logoImage);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"ERROR:\" + e);\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tf.setFocusTraversalKeysEnabled(false);\n\t\t\t\n\t\t\t\tjava.awt.Dimension panelSize = f.getContentPane().getSize();\n\t\t\t\tc = new QuartzRendererView();\n\t\t\t\tc.setSize(panelSize);\n\t\t\t\tc.setFocusTraversalKeysEnabled(false);\n\t\t\t\tf.getContentPane().add(c);\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tjava.awt.Image frameIcon = java.awt.Toolkit.getDefaultToolkit().createImage(getClass().getClassLoader().getResource(\"images\/tvicon.gif\"));\n\t\t\t\t\tensureImageIsLoaded(frameIcon);\n\t\t\t\t\tf.setIconImage(frameIcon);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"ERROR:\" + e);\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tf.addWindowListener(new java.awt.event.WindowAdapter()\n\t\t\t\t{\n\t\t\t\t\tpublic void windowClosing(java.awt.event.WindowEvent evt)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!f.isFullScreen() || System.getProperty(\"os.name\").toLowerCase().indexOf(\"windows\") != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMiniClient.myProperties.setProperty(\"main_window_width\", Integer.toString(f.getWidth()));\n\t\t\t\t\t\t\tMiniClient.myProperties.setProperty(\"main_window_height\", Integer.toString(f.getHeight()));\n\t\t\t\t\t\t\tMiniClient.myProperties.setProperty(\"main_window_x\", Integer.toString(f.getX()));\n\t\t\t\t\t\t\tMiniClient.myProperties.setProperty(\"main_window_y\", Integer.toString(f.getY()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmyConn.close();\n\t\t\t\t\t\tclose();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tc.addComponentListener(new java.awt.event.ComponentAdapter()\n\t\t\t\t{\n\t\t\t\t\tpublic void componentResized(java.awt.event.ComponentEvent evt)\n\t\t\t\t\t{\n\t\t\t\t\t\tmyConn.postResizeEvent(new java.awt.Dimension(c.getWidth(), c.getHeight()));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tf.addKeyListener(this);\n\t\t\t\tc.addKeyListener(this);\n\t\t\t\n\t\t\t\tf.addMouseWheelListener(this);\n\t\t\t\tc.addMouseListener(this);\n\t\t\t\tif (ENABLE_MOUSE_MOTION_EVENTS)\n\t\t\t\t{\n\t\t\t\t\n\t\t\t\t\tc.addMouseMotionListener(this);\n\t\t\t\t}\n\t\t\t\tint frameX = 100;\n\t\t\t\tint frameY = 100;\n\t\t\t\tint frameW = 720;\n\t\t\t\tint frameH = 480;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tframeW = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_width\", \"720\"));\n\t\t\t\t\tframeH = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_height\", \"480\"));\n\t\t\t\t\tframeX = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_x\", \"100\"));\n\t\t\t\t\tframeY = Integer.parseInt(MiniClient.myProperties.getProperty(\"main_window_y\", \"100\"));\n\t\t\t\t}\n\t\t\t\tcatch (NumberFormatException e){}\n\t\t\t\tjava.awt.Point newPos = new java.awt.Point(frameX, frameY);\n\t\t\t\tboolean foundScreen = sage.UIUtils.isPointOnAScreen(newPos);\n\t\t\t\tif (!foundScreen)\n\t\t\t\t{\n\t\t\t\t\tnewPos.x = 150;\n\t\t\t\t\tnewPos.y = 150;\n\t\t\t\t}\n\t\t\t\tf.setVisible(true);\n\t\t\t\tf.setSize(1,1);\n\t\t\t\tf.setSize(Math.max(frameW, 320), Math.max(frameH, 240));\n\t\t\t\tf.setLocation(newPos);\n\t\t\t\tif (MiniClient.fsStartup)\n\t\t\t\t\tf.setFullScreen(true);\n\t\t\t\tMiniClient.hideSplash();\n\t\t\t\treturn 1;\n\t\t\tcase GFXCMD_DEINIT:\n\t\t\t\tclose();\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWRECT:\n\t\t\t\tif(len==36)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height;\n\t\t\t\t\tint thickness, argbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\tthickness=readInt(16, cmddata);\n\t\t\t\t\targbTL=readInt(20, cmddata);\n\t\t\t\t\targbTR=readInt(24, cmddata);\n\t\t\t\t\targbBR=readInt(28, cmddata);\n\t\t\t\t\targbBL=readInt(32, cmddata);\n\t\t\t\t\n\t\t\t\t\tdrawRect0(new java.awt.geom.Rectangle2D.Float(x, y, width, height), null,\n\t\t\t\t\t\t\t  0,\n\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), thickness,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWRECT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_FILLRECT:\n\t\t\t\n\t\t\t\tif(len==32)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height;\n\t\t\t\t\tint argbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\targbTL=readInt(16, cmddata);\n\t\t\t\t\targbTR=readInt(20, cmddata);\n\t\t\t\t\targbBR=readInt(24, cmddata);\n\t\t\t\t\targbBL=readInt(28, cmddata);\n\t\t\t\t\tjava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tif(gp != null) {\n\t\t\t\t\t\tdrawRect0(bounds, null,\n\t\t\t\t\t\t\t\t  0,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  gp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\n\t\t\t\t\t\t\t\t  gp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdrawRect0(bounds, null,\n\t\t\t\t\t\t\t\t  0,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_FILLRECT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_CLEARRECT:\n\t\t\t\n\t\t\t\tif(len==32)\n\t\t\t\t{\n\t\t\t\t\tint x, y, width, height,\n\t\t\t\t\t\targbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=readInt(0, cmddata);\n\t\t\t\t\ty=readInt(4, cmddata);\n\t\t\t\t\twidth=readInt(8, cmddata);\n\t\t\t\t\theight=readInt(12, cmddata);\n\t\t\t\t\targbTL=readInt(16, cmddata);\n\t\t\t\t\targbTR=readInt(20, cmddata);\n\t\t\t\t\targbBR=readInt(24, cmddata);\n\t\t\t\t\targbBL=readInt(28, cmddata);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float destRect = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tclearRect0(destRect);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_CLEARRECT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWOVAL:\n\t\t\t\n\t\t\t\n\t\t\t\tif(len==52)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height, clipX, clipY, clipW, clipH;\n\t\t\t\t\tint thickness, argbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\tthickness=readInt(16, cmddata);\n\t\t\t\t\targbTL=readInt(20, cmddata);\n\t\t\t\t\targbTR=readInt(24, cmddata);\n\t\t\t\t\targbBR=readInt(28, cmddata);\n\t\t\t\t\targbBL=readInt(32, cmddata);\n\t\t\t\t\tclipX=(float)readInt(36, cmddata);\n\t\t\t\t\tclipY=(float)readInt(40, cmddata);\n\t\t\t\t\tclipW=(float)readInt(44, cmddata);\n\t\t\t\t\tclipH=(float)readInt(48, cmddata);\n\t\t\t\t\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\n\t\t\t\t\tdrawOval0(bounds, clipRect,\n\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), thickness,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWOVAL : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_FILLOVAL:\n\t\t\t\n\t\t\t\n\t\t\t\tif(len==48)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height,\n\t\t\t\t\t\tclipX, clipY, clipW, clipH;\n\t\t\t\t\tint argbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\targbTL=readInt(16, cmddata);\n\t\t\t\t\targbTR=readInt(20, cmddata);\n\t\t\t\t\targbBR=readInt(24, cmddata);\n\t\t\t\t\targbBL=readInt(28, cmddata);\n\t\t\t\t\tclipX=(float)readInt(32, cmddata);\n\t\t\t\t\tclipY=(float)readInt(36, cmddata);\n\t\t\t\t\tclipW=(float)readInt(40, cmddata);\n\t\t\t\t\tclipH=(float)readInt(44, cmddata);\n\t\t\t\t\tjava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\n\t\t\t\t\tif(gp != null) {\n\t\t\t\t\t\tdrawOval0(bounds, clipRect,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  gp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\n\t\t\t\t\t\t\t\t  gp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdrawOval0(bounds, clipRect,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_FILLOVAL : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWROUNDRECT:\n\t\t\t\n\t\t\t\n\t\t\t\tif(len==56)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height,\n\t\t\t\t\t\tclipX, clipY, clipW, clipH;\n\t\t\t\t\tint thickness, arcRadius,\n\t\t\t\t\t\targbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\tthickness=readInt(16, cmddata);\n\t\t\t\t\tarcRadius=readInt(20, cmddata);\n\t\t\t\t\targbTL=readInt(24, cmddata);\n\t\t\t\t\targbTR=readInt(28, cmddata);\n\t\t\t\t\targbBR=readInt(32, cmddata);\n\t\t\t\t\targbBL=readInt(36, cmddata);\n\t\t\t\t\tclipX=(float)readInt(40, cmddata);\n\t\t\t\t\tclipY=(float)readInt(44, cmddata);\n\t\t\t\t\tclipW=(float)readInt(48, cmddata);\n\t\t\t\t\tclipH=(float)readInt(52, cmddata);\n\t\t\t\t\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\n\t\t\t\t\tdrawRect0(bounds, clipRect,\n\t\t\t\t\t\t\t  arcRadius,\n\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), thickness,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWROUNDRECT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_FILLROUNDRECT:\n\t\t\t\n\t\t\t\n\t\t\t\tif(len==52)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height,\n\t\t\t\t\t\tclipX, clipY, clipW, clipH;\n\t\t\t\t\tint arcRadius, argbTL, argbTR, argbBR, argbBL;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\tarcRadius=readInt(16, cmddata);\n\t\t\t\t\targbTL=readInt(20, cmddata);\n\t\t\t\t\targbTR=readInt(24, cmddata);\n\t\t\t\t\targbBR=readInt(28, cmddata);\n\t\t\t\t\targbBL=readInt(32, cmddata);\n\t\t\t\t\tclipX=(float)readInt(36, cmddata);\n\t\t\t\t\tclipY=(float)readInt(40, cmddata);\n\t\t\t\t\tclipW=(float)readInt(44, cmddata);\n\t\t\t\t\tclipH=(float)readInt(48, cmddata);\n\t\t\t\t\tjava.awt.GradientPaint gp = getGradient(x, y, width, height, argbTL, argbTR, argbBL, argbBR);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float bounds = new java.awt.geom.Rectangle2D.Float(x, y, width, height);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float clipRect = new java.awt.geom.Rectangle2D.Float(clipX, clipY, clipW, clipH);\n\t\t\t\t\tif(gp != null) {\n\t\t\t\t\t\tdrawRect0(bounds, clipRect,\n\t\t\t\t\t\t\t\t  arcRadius,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  gp.getColor1(), (float)gp.getPoint1().getX(), (float)gp.getPoint1().getY(),\n\t\t\t\t\t\t\t\t  gp.getColor2(), (float)gp.getPoint2().getX(), (float)gp.getPoint2().getY(),\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdrawRect0(bounds, clipRect,\n\t\t\t\t\t\t\t\t  arcRadius,\n\t\t\t\t\t\t\t\t  null, 0,\n\t\t\t\t\t\t\t\t  new java.awt.Color(argbTL, true), 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  null, 0.0f, 0.0f,\n\t\t\t\t\t\t\t\t  1.0f);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_FILLROUNDRECT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWTEXT:\n\t\t\t\n\t\t\t\tif(len>=36 && len>=(36+readInt(8, cmddata)*2))\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, clipX, clipY, clipW, clipH;\n\t\t\t\t\tint textlen, fontHandle, argb;\n\t\t\t\t\tStringBuffer text = new StringBuffer();\n\t\t\t\t\tint i;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\ttextlen=readInt(8, cmddata);\n\t\t\t\t\tfor(i=0;i<textlen;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttext.append((char)readShort(12+i*2, cmddata));\n\t\t\t\t\t}\n\t\t\t\t\tfontHandle=readInt(textlen*2+12, cmddata);\n\t\t\t\t\targb=readInt(textlen*2+16, cmddata);\n\t\t\t\t\tclipX=(float)readInt(textlen*2+20, cmddata);\n\t\t\t\t\tclipY=(float)readInt(textlen*2+24, cmddata);\n\t\t\t\t\tclipW=(float)readInt(textlen*2+28, cmddata);\n\t\t\t\t\tclipH=(float)readInt(textlen*2+32, cmddata);\n\t\t\t\t\n\t\t\t\t\tMcFont fontPtr = (McFont)fontMap.get(new Integer(fontHandle));\n\t\t\t\t\tif(fontPtr != null) {\n\t\t\t\t\t\n\t\t\t\t\t\tString theString = text.toString();\n\t\t\t\t\t\tfloat[] positions = fontPtr.getGlyphPositions(theString);\n\t\t\t\t\t\tdrawTextWithPositions0(theString, fontPtr.nativeFont,\n\t\t\t\t\t\t\tx, y, positions, new java.awt.geom.Rectangle2D.Float(clipX,clipY,clipW,clipH),\n\t\t\t\t\t\t\tnew java.awt.Color(argb, true));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWTEXTURED:\n\t\t\t\n\t\t\t\tif(len==40)\n\t\t\t\t{\n\t\t\t\t\tfloat x, y, width, height,\n\t\t\t\t\t\tsrcx, srcy, srcwidth, srcheight;\n\t\t\t\t\tint handle, blend;\n\t\t\t\t\tx=(float)readInt(0, cmddata);\n\t\t\t\t\ty=(float)readInt(4, cmddata);\n\t\t\t\t\twidth=(float)readInt(8, cmddata);\n\t\t\t\t\theight=(float)readInt(12, cmddata);\n\t\t\t\t\thandle=readInt(16, cmddata);\t\t\n\t\t\t\t\tsrcx=(float)readInt(20, cmddata);\n\t\t\t\t\tsrcy=(float)readInt(24, cmddata);\n\t\t\t\t\tsrcwidth=(float)readInt(28, cmddata);\n\t\t\t\t\tsrcheight=(float)readInt(32, cmddata);\n\t\t\t\t\tblend=readInt(36, cmddata);\n\t\t\t\t\n\t\t\t\t\tboolean doBlend = true;\n\t\t\t\t\tif(height < 0) {\n\t\t\t\t\t\tdoBlend = false;\n\t\t\t\t\t\theight *= -1;\n\t\t\t\t\t}\n\t\t\t\t\tif(width < 0) {\n\t\t\t\t\t\twidth *= -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(doBlend)\n\t\t\t\t\t\t\tblend |= 0x00ffffff;\n\t\t\t\t\t}\n\t\t\t\t\tLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float destRect = new java.awt.geom.Rectangle2D.Float(x,y,width,height);\n\t\t\t\t\tjava.awt.geom.Rectangle2D.Float srcRect = new java.awt.geom.Rectangle2D.Float(srcx,srcy,srcwidth,srcheight);\n\t\t\t\t\tif(imagePtr != null) {\n\t\t\t\t\t\tmyConn.registerImageAccess(handle);\n\t\t\t\t\t\tdrawImage1(imagePtr.longValue(),\n\t\t\t\t\t\t\t\t   destRect, srcRect,\n\t\t\t\t\t\t\t\t   (doBlend) ? new java.awt.Color(blend, true) : null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\timagePtr = (Long)layerMap.get(new Integer(handle));\n\t\t\t\t\t\tif(imagePtr != null) {\n\t\t\t\t\t\t\tmyConn.registerImageAccess(handle);\n\t\t\t\t\t\t\tfloat alpha = (doBlend ? (float)(((blend >> 24)&0xff))\/255.0f : 1.0f);\n\t\t\t\t\t\t\tcomposite0(imagePtr.longValue(), currentLayer, srcRect, destRect, alpha, doBlend);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR invalid handle passed for texture rendering of: \" + handle);\n\t\t\t\t\t\t\tabortRenderCycle = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWTEXTURED : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_DRAWLINE:\n\t\t\t\n\t\t\t\tif(len==24)\n\t\t\t\t{\n\t\t\t\t\tfloat x1, y1, x2, y2;\n\t\t\t\t\tint argb1, argb2;\n\t\t\t\t\tx1=readInt(0, cmddata);\n\t\t\t\t\ty1=readInt(4, cmddata);\n\t\t\t\t\tx2=readInt(8, cmddata);\n\t\t\t\t\ty2=readInt(12, cmddata);\n\t\t\t\t\targb1=readInt(16, cmddata);\n\t\t\t\t\targb2=readInt(20, cmddata);\n\t\t\t\t\tdrawLine0(x1, y1, x2, y2, 1, new java.awt.Color(argb1, true));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_DRAWLINE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADIMAGE:\n\t\t\t\n\t\t\t\tif(len>=8)\n\t\t\t\t{\n\t\t\t\t\tint width, height;\n\t\t\t\t\tint imghandle = 0;\n\t\t\t\t\twidth=readInt(0, cmddata);\n\t\t\t\t\theight=readInt(4, cmddata);\n\t\t\t\t\tif (width * height * 4 + imageCacheSize > imageCacheLimit)\n\t\t\t\t\t{\n\t\t\t\t\t\timghandle = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t\tlong imagePtr = createNewImage0(width, height);\n\t\t\t\t\t\timghandle = handleCount++;\n\t\t\t\t\t\timageMap.put(new Integer(imghandle), new Long(imagePtr));\n\t\t\t\t\t\timageCacheSize += width * height * 4;\n\t\t\t\t\t}\n\t\t\t\t\thasret[0]=1;\n\t\t\t\t\treturn imghandle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADIMAGETARGETED:\n\t\t\t\n\t\t\t\tif(len>=12)\n\t\t\t\t{\n\t\t\t\t\tint width, height;\n\t\t\t\t\tint imghandle = readInt(0, cmddata);\n\t\t\t\t\twidth=readInt(4, cmddata);\n\t\t\t\t\theight=readInt(8, cmddata);\n\t\t\t\t\twhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n\t\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t\tint oldestImage = myConn.getOldestImage();\n\t\t\t\t\t\tif (oldestImage != 0)\n\t\t\t\t\t\t{\nSystem.out.println(\"Freeing image to make room in cache\");\n\t\t\t\t\t\t\tunloadImage(oldestImage);\n\t\t\t\t\t\t\tmyConn.postImageUnload(oldestImage);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlong imagePtr = createNewImage0(width, height);\n\t\t\t\t\timageMap.put(new Integer(imghandle), new Long(imagePtr));\n\t\t\t\t\timageCacheSize += width * height * 4;\n\t\t\t\t\tmyConn.registerImageAccess(imghandle);\n\t\t\t\t\thasret[0]=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGETARGETED : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_CREATESURFACE:\n\t\t\t\n\t\t\t\tif(len>=8)\n\t\t\t\t{\n\t\t\t\t\tint width, height;\n\t\t\t\t\tint handle = handleCount++;;\n\t\t\t\t\twidth=readInt(0, cmddata);\n\t\t\t\t\theight=readInt(4, cmddata);\n\t\t\t\t\n\t\t\t\t\tlong layerPtr = createLayer0(c.getSize());\n\t\t\t\t\tlayerMap.put(new Integer(handle), new Long(layerPtr));\n\t\t\t\t\thasret[0]=1;\n\t\t\t\t\treturn handle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_CREATESURFACE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_PREPIMAGE:\n\t\t\t\n\t\t\t\tif(len>=8)\n\t\t\t\t{\n\t\t\t\t\tint width, height;\n\t\t\t\t\n\t\t\t\t\twidth=readInt(0, cmddata);\n\t\t\t\t\theight=readInt(4, cmddata);\n\t\t\t\t\tint imghandle = 1;\n\t\t\t\t\tif (width * height * 4 + imageCacheSize > imageCacheLimit)\n\t\t\t\t\t\timghandle = 0;\n\t\t\t\t\telse if (len >= 12)\n\t\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t\tint strlen = readInt(8, cmddata);\n\t\t\t\t\t\tif (strlen > 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString rezName = new String(cmddata, 16, strlen - 1);\n\t\t\t\t\t\t\tlastImageResourceID = rezName;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tlastImageResourceIDHandle = imghandle = Math.abs(lastImageResourceID.hashCode());\n\t\t\t\t\t\t\tjava.io.File cachedFile = myConn.getCachedImageFile(rezName);\n\t\t\t\t\t\t\tif (cachedFile != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\n\t\t\t\t\t\t\t\tif(imagePtr != 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tjava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\n\t\t\t\t\t\t\t\t\tif(imgSize != null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif(imgSize.getWidth() == width && imgSize.getHeight() == height)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\timghandle = handleCount++;\n\t\t\t\t\t\t\t\t\t\t\timageMap.put(new Integer(imghandle), new Long(imagePtr));\n\t\t\t\t\t\t\t\t\t\t\timageCacheSize += getImageSize0(imagePtr);\n\t\t\t\t\t\t\t\t\t\t\thasret[0] = 1;\n\t\t\t\t\t\t\t\t\t\t\treturn -1 * imghandle;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\tfreeNativeImage0(imagePtr);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tfreeNativeImage0(imagePtr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\thasret[0]=1;\n\t\t\t\t\treturn imghandle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_PREPIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_PREPIMAGETARGETED:\n\t\t\t\n\t\t\t\tif(len>=12)\n\t\t\t\t{\n\t\t\t\t\tint imghandle, width, height;\n\t\t\t\t\timghandle = readInt(0, cmddata);\n\t\t\t\t\twidth=readInt(4, cmddata);\n\t\t\t\t\theight=readInt(8, cmddata);\n\t\t\t\t\tint strlen = readInt(12, cmddata);\n\t\t\t\t\twhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n\t\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t\tint oldestImage = myConn.getOldestImage();\n\t\t\t\t\t\tif (oldestImage != 0)\n\t\t\t\t\t\t{\nSystem.out.println(\"Freeing image to make room in cache\");\n\t\t\t\t\t\t\tunloadImage(oldestImage);\n\t\t\t\t\t\t\tmyConn.postImageUnload(oldestImage);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (len >= 16)\n\t\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t\tString rezName = new String(cmddata, 20, strlen - 1);\n\t\t\t\t\t\tlastImageResourceID = rezName;\n\t\t\t\t\t\tlastImageResourceIDHandle = imghandle;\nSystem.out.println(\"Prepped targeted image with handle \" + imghandle + \" resource=\" + rezName);\n\t\t\t\t\t}\n\t\t\t\t\tmyConn.registerImageAccess(imghandle);\n\t\t\t\t\thasret[0]=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_PREPIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADCACHEDIMAGE:\n\t\t\t\n\t\t\t\tif(len>=18)\n\t\t\t\t{\n\t\t\t\t\tint width, height, imghandle;\n\t\t\t\t\timghandle = readInt(0, cmddata);\n\t\t\t\t\twidth = readInt(4, cmddata);\n\t\t\t\t\theight = readInt(8, cmddata);\n\t\t\t\t\tint strlen = readInt(12, cmddata);\n\t\t\t\t\tString rezName = new String(cmddata, 20, strlen - 1);\nSystem.out.println(\"imghandle=\" + imghandle + \" width=\" + width + \" height=\" + height + \" strlen=\" + strlen + \" rezName=\" + rezName);\n\t\t\t\t\twhile (width * height * 4 + imageCacheSize > imageCacheLimit)\n\t\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t\tint oldestImage = myConn.getOldestImage();\n\t\t\t\t\t\tif (oldestImage != 0)\n\t\t\t\t\t\t{\nSystem.out.println(\"Freeing image to make room in cache\");\n\t\t\t\t\t\t\tunloadImage(oldestImage);\n\t\t\t\t\t\t\tmyConn.postImageUnload(oldestImage);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR cannot free enough from the cache to support loading a new image!!!\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmyConn.registerImageAccess(imghandle);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(\"Loading resource from cache: \" + rezName);\n\t\t\t\t\t\tjava.io.File cachedFile = myConn.getCachedImageFile(rezName);\n\t\t\t\t\t\tif (cachedFile != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tSystem.out.println(\"Image found in cache!\");\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tlong imagePtr = createImageFromPath0(cachedFile.getAbsolutePath());\n\t\t\t\t\t\t\tif(imagePtr != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tjava.awt.Dimension imgSize = getImageDimensions0(imagePtr);\n\t\t\t\t\t\t\t\tif(imgSize != null && imgSize.getWidth() == width && imgSize.getHeight() == height)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\timageMap.put(new Integer(imghandle), new Long(imagePtr));\n\t\t\t\t\t\t\t\t\timageCacheSize += getImageSize0(imagePtr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (imgSize != null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"CACHE ID verification failed for rezName=\" + rezName + \" target=\" + width + \"x\" + height + \" actual=\" + imgSize.getWidth() + \"x\" + imgSize.getHeight());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"CACHE Load failed for rezName=\" + rezName);\n\t\t\t\t\t\t\t\t\tcachedFile.delete();\n\t\t\t\t\t\t\t\t\tfreeNativeImage0(imagePtr);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tmyConn.postImageUnload(imghandle);\n\t\t\t\t\t\t\t\t\tmyConn.postOfflineCacheChange(false, rezName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcachedFile.delete();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tmyConn.postImageUnload(imghandle);\n\t\t\t\t\t\t\t\tmyConn.postOfflineCacheChange(false, rezName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSystem.out.println(\"ERROR Image not found in cache that should be there! rezName=\" + rezName);\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tmyConn.postImageUnload(imghandle);\n\t\t\t\t\t\t\tmyConn.postOfflineCacheChange(false, rezName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (java.io.IOException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(\"ERROR loading compressed image: \" + e);\n\t\t\t\t\t}\n\t\t\t\t\thasret[0]=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_PREPIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_UNLOADIMAGE:\n\t\t\t\n\t\t\t\tif(len==4)\n\t\t\t\t{\n\t\t\t\t\tint handle;\n\t\t\t\t\thandle=readInt(0, cmddata);\n\t\t\t\t\tunloadImage(handle);\n\t\t\t\t\tmyConn.clearImageAccess(handle);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_UNLOADIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_SETTARGETSURFACE:\n\t\t\t\n\t\t\t\tif(len==4)\n\t\t\t\t{\n\t\t\t\t\tint handle;\n\t\t\t\t\thandle=readInt(0, cmddata);\n\t\t\t\t\n\t\t\t\t\tLong layerPtr = (Long)layerMap.get(new Integer(handle));\n\t\t\t\t\tcurrentLayer = (layerPtr != null) ? layerPtr.longValue() : 0;\n\t\t\t\t\tjava.awt.Rectangle clipRect = new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight());\n\t\t\t\t\tsetLayer0(currentLayer, c.getSize(), clipRect);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_SETTARGETSURFACE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADFONT:\n\t\t\t\n\t\t\t\tif(len>=12 && len>=(12+readInt(0, cmddata)))\n\t\t\t\t{\n\t\t\t\t\tint namelen, style, size;\n\t\t\t\t\tStringBuffer name = new StringBuffer();\n\t\t\t\t\tint i;\n\t\t\t\t\tint fonthandle = handleCount++;\n\t\t\t\t\tnamelen=readInt(0, cmddata);\n\t\t\t\t\tfor(i=0;i<namelen-1;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tname.append((char) cmddata[8 + i]);\n\t\t\t\t\t}\n\t\t\t\t\tstyle=readInt(namelen+4, cmddata);\n\t\t\t\t\tsize=readInt(namelen+8, cmddata);\n\t\t\t\t\tMcFont fontPtr = new McFont(name.toString(), style, size);\n\t\t\t\t\tif(fontPtr == null) {\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\thasret[0] = 1;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tfontMap.put(new Integer(fonthandle), fontPtr);\n\t\t\t\t\thasret[0] = 1;\n\t\t\t\t\treturn fonthandle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADFONT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_UNLOADFONT:\n\t\t\t\n\t\t\t\tif(len==4)\n\t\t\t\t{\n\t\t\t\t\tint handle;\n\t\t\t\t\thandle=readInt(0, cmddata);\n\t\t\t\t\n\t\t\t\t\tMcFont fontPtr = (McFont)fontMap.get(new Integer(handle));\n\t\t\t\t\tif(fontPtr != null) fontPtr.unload();\n\t\t\t\t\tfontMap.remove(new Integer(handle));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_UNLOADFONT : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADFONTSTREAM:\n\t\t\t   \n\t\t\t\tif (len>=8)\n\t\t\t\t{\n\t\t\t\t\tStringBuffer name = new StringBuffer();\n\t\t\t\t\tint namelen = readInt(0, cmddata);\n\t\t\t\t\tfor(int i=0;i<namelen-1;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tname.append((char) cmddata[8 + i]);\n\t\t\t\t\t}\n\t\t\t\t\tint datalen = readInt(4 + namelen, cmddata);\n\t\t\t\t\tif (len >= datalen + 8 + namelen)\n\t\t\t\t\t{\n\t\t\t\t\t\tmyConn.saveCacheData(name.toString() + \"-\" + myConn.getServerName(), cmddata, 12 + namelen, datalen);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADFONTSTREAM : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_FLIPBUFFER:\n\t\t\t\tif (abortRenderCycle)\n\t\t\t\t{\nSystem.out.println(\"ERROR in painting cycle, ABORT was set...send full repaint command\");\n\t\t\t\t\tmyConn.postRepaintEvent(0, 0, c.getWidth(), c.getHeight());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpresent0(c.nativeView, new java.awt.Rectangle(0, 0, c.getWidth(), c.getHeight()));\n\t\t\t\t}\n\t\t\t\thasret[0] = 1;\n\t\t\t\n\t\t\t\tfirstFrameDone = true;\n\t\t\t\treturn 0;\n\t\t\tcase GFXCMD_STARTFRAME:\n\t\t\t\n\t\t\t\tsetTargetView0(c.nativeView);\n\t\t\t\tsetLayer0(0, c.getSize(), null);\n\t\t\t\tabortRenderCycle = false;\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADIMAGELINE:\n\t\t\t\n\t\t\t\tif(len>=12 && len>=(12+readInt(8, cmddata)))\n\t\t\t\t{\n\t\t\t\t\tint handle, line, len2;\n\t\t\t\t\n\t\t\t\t\thandle=readInt(0, cmddata);\n\t\t\t\t\tline=readInt(4, cmddata);\n\t\t\t\t\tlen2=readInt(8, cmddata);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\tLong imagePtr = (Long)imageMap.get(new Integer(handle));\n\t\t\t\t\tif(imagePtr != null)\n\t\t\t\t\t\tloadImageLine0(imagePtr.longValue(), line, cmddata, 1, len2);\n\t\t\t\t\tmyConn.registerImageAccess(handle);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGELINE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_LOADIMAGECOMPRESSED:\n\t\t\t\n\t\t\t\tif(len>=8 && len>=(8+readInt(4, cmddata)))\n\t\t\t\t{\n\t\t\t\t\tint handle, len2;\n\t\t\t\t\thandle=readInt(0, cmddata);\n\t\t\t\t\tlen2=readInt(4, cmddata);\n\t\t\t\t\tif (lastImageResourceID != null && lastImageResourceIDHandle == handle)\n\t\t\t\t\t{\n\t\t\t\t\t\tmyConn.saveCacheData(lastImageResourceID, cmddata, 12, len2);\n\t\t\t\t\t\tmyConn.postOfflineCacheChange(true, lastImageResourceID);\n\t\t\t\t\t}\n\t\t\t\t\tif (!myConn.doesUseAdvancedImageCaching())\n\t\t\t\t\t{\n\t\t\t\t\t\thandle = handleCount++;\n\t\t\t\t\t\thasret[0] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\thasret[0] = 0;\n\t\t\t\t\tmyConn.registerImageAccess(handle);\n\t\t\t\t\tlong imagePtr = createImageFromBytes0(cmddata, 12, len2, null);\n\t\t\t\t\timageMap.put(new Integer(handle), new Long(imagePtr));\n\t\t\t\t\timageCacheSize += getImageSize0(imagePtr);\n\t\t\t\t\treturn handle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_LOADIMAGECOMPRESSED : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_XFMIMAGE:\n\t\t\t\n\t\t\t\tif (len >= 20)\n\t\t\t\t{\n\t\t\t\t\tint srcHandle, destHandle, destWidth, destHeight, maskCornerArc;\n\t\t\t\t\tsrcHandle = readInt(0, cmddata);\n\t\t\t\t\tdestHandle = readInt(4, cmddata);\t\n\t\t\t\t\tdestWidth = readInt(8,  cmddata);\t\n\t\t\t\t\tdestHeight = readInt(12, cmddata);\n\t\t\t\t\tmaskCornerArc = readInt(16, cmddata);\n\t\t\t\t\tint rvHandle = destHandle;\n\t\t\t\t\tif (!myConn.doesUseAdvancedImageCaching())\n\t\t\t\t\t{\n\t\t\t\t\t\trvHandle = handleCount++;\n\t\t\t\t\t\thasret[0] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\thasret[0] = 0;\n\t\t\t\t\n\t\t\t\t\tLong srcImg = (Long)imageMap.get(new Integer(srcHandle));\n\t\t\t\t\tif(srcImg != null) {\n\t\t\t\t\t\tlong newImage = transformImage0(srcImg.longValue(), destWidth, destHeight, maskCornerArc);\n\t\t\t\t\t\tif(newImage != 0) {\n\t\t\t\t\t\t\timageMap.put(new Integer(rvHandle), new Long(newImage));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn rvHandle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_XFMIMAGE : \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GFXCMD_SETVIDEOPROP:\n\t\t\t\tif (len >= 40)\n\t\t\t\t{\n\t\t\t\t\tjava.awt.Rectangle srcRect = new java.awt.Rectangle(readInt(4, cmddata), readInt(8, cmddata),\n\t\t\t\t\t\treadInt(12, cmddata), readInt(16, cmddata));\n\t\t\t\t\tjava.awt.Rectangle destRect = new java.awt.Rectangle(readInt(20, cmddata), readInt(24, cmddata),\n\t\t\t\t\t\treadInt(28, cmddata), readInt(32, cmddata));\n\t\t\t\t\tSystem.out.println(\"SETVIDEOPROP: srcRect=\"+srcRect+\" dstRect=\"+destRect);\n\t\t\t\t\tsetVideoBounds(srcRect, destRect);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"Invalid len for GFXCMD_SETVIDEOPROP: \" + len);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}","cleancode":"public int executegfxcommand(int cmd, int len, byte[] cmddata, int[] hasret) { len -= 4; hasret[0] = 0; if((cmd != gfxcmd_init) && (cmd != gfxcmd_deinit)) { if((f != null) ? (!f.isdisplayable() || !f.isvalid() || !f.isshowing()) : true) { while((f != null) ? (!f.isdisplayable() || !f.isvalid() || !f.isshowing()) : true) { try { thread.sleep(10); } catch(interruptedexception ex) {} } } } if (c != null) { switch(cmd) { case gfxcmd_init: case gfxcmd_deinit: case gfxcmd_startframe: case gfxcmd_flipbuffer: c.setcursor(null); break; case gfxcmd_drawrect: case gfxcmd_fillrect: case gfxcmd_clearrect: case gfxcmd_drawoval: case gfxcmd_filloval: case gfxcmd_drawroundrect: case gfxcmd_fillroundrect: case gfxcmd_drawtext: case gfxcmd_drawtextured: case gfxcmd_drawline: case gfxcmd_loadimage: case gfxcmd_loadimagetargeted: case gfxcmd_unloadimage: case gfxcmd_loadfont: case gfxcmd_unloadfont: case gfxcmd_settargetsurface: case gfxcmd_createsurface: break; case gfxcmd_prepimage: case gfxcmd_loadimageline: case gfxcmd_loadimagecompressed: case gfxcmd_xfmimage: case gfxcmd_loadcachedimage: case gfxcmd_prepimagetargeted: if (!cursorhidden) c.setcursor(java.awt.cursor.getpredefinedcursor(java.awt.cursor.wait_cursor)); break; } } switch(cmd) { case gfxcmd_init: hasret[0] = 1; init0(); int windowtitlestyle = 0; try { windowtitlestyle = integer.parseint(miniclient.myproperties.getproperty(\"window_title_style\", \"0\")); } catch (numberformatexception e){} if (!\"true\".equals(miniclient.myproperties.getproperty(\"enable_custom_title_bar\", miniclient.mac_os_x ? \"false\" : \"true\"))) windowtitlestyle = 10; f = new miniclientwindow(myconn.getwindowtitle(), windowtitlestyle); java.awt.layoutmanager layer = new java.awt.layoutmanager() { public void addlayoutcomponent(string name, java.awt.component comp) {} public java.awt.dimension minimumlayoutsize(java.awt.container parent) { return preferredlayoutsize(parent); } public java.awt.dimension preferredlayoutsize(java.awt.container parent) { return parent.getpreferredsize(); } public void removelayoutcomponent(java.awt.component comp) {} public void layoutcontainer(java.awt.container parent) { c.setbounds(parent.getinsets().left, parent.getinsets().top, parent.getwidth() - parent.getinsets().left - parent.getinsets().right, parent.getheight() - parent.getinsets().top - parent.getinsets().bottom); } }; f.getcontentpane().setlayout(layer); try { bgimage = java.awt.toolkit.getdefaulttoolkit().createimage(getclass().getclassloader().getresource(\"images\/background.jpg\")); ensureimageisloaded(bgimage); logoimage = java.awt.toolkit.getdefaulttoolkit().createimage(getclass().getclassloader().getresource(\"images\/sagelogo256.png\")); ensureimageisloaded(logoimage); } catch (exception e) { system.out.println(\"error:\" + e); e.printstacktrace(); } f.setfocustraversalkeysenabled(false); java.awt.dimension panelsize = f.getcontentpane().getsize(); c = new quartzrendererview(); c.setsize(panelsize); c.setfocustraversalkeysenabled(false); f.getcontentpane().add(c); try { java.awt.image frameicon = java.awt.toolkit.getdefaulttoolkit().createimage(getclass().getclassloader().getresource(\"images\/tvicon.gif\")); ensureimageisloaded(frameicon); f.seticonimage(frameicon); } catch (exception e) { system.out.println(\"error:\" + e); e.printstacktrace(); } f.addwindowlistener(new java.awt.event.windowadapter() { public void windowclosing(java.awt.event.windowevent evt) { if (!f.isfullscreen() || system.getproperty(\"os.name\").tolowercase().indexof(\"windows\") != -1) { miniclient.myproperties.setproperty(\"main_window_width\", integer.tostring(f.getwidth())); miniclient.myproperties.setproperty(\"main_window_height\", integer.tostring(f.getheight())); miniclient.myproperties.setproperty(\"main_window_x\", integer.tostring(f.getx())); miniclient.myproperties.setproperty(\"main_window_y\", integer.tostring(f.gety())); } myconn.close(); close(); } }); c.addcomponentlistener(new java.awt.event.componentadapter() { public void componentresized(java.awt.event.componentevent evt) { myconn.postresizeevent(new java.awt.dimension(c.getwidth(), c.getheight())); } }); f.addkeylistener(this); c.addkeylistener(this); f.addmousewheellistener(this); c.addmouselistener(this); if (enable_mouse_motion_events) { c.addmousemotionlistener(this); } int framex = 100; int framey = 100; int framew = 720; int frameh = 480; try { framew = integer.parseint(miniclient.myproperties.getproperty(\"main_window_width\", \"720\")); frameh = integer.parseint(miniclient.myproperties.getproperty(\"main_window_height\", \"480\")); framex = integer.parseint(miniclient.myproperties.getproperty(\"main_window_x\", \"100\")); framey = integer.parseint(miniclient.myproperties.getproperty(\"main_window_y\", \"100\")); } catch (numberformatexception e){} java.awt.point newpos = new java.awt.point(framex, framey); boolean foundscreen = sage.uiutils.ispointonascreen(newpos); if (!foundscreen) { newpos.x = 150; newpos.y = 150; } f.setvisible(true); f.setsize(1,1); f.setsize(math.max(framew, 320), math.max(frameh, 240)); f.setlocation(newpos); if (miniclient.fsstartup) f.setfullscreen(true); miniclient.hidesplash(); return 1; case gfxcmd_deinit: close(); break; case gfxcmd_drawrect: if(len==36) { float x, y, width, height; int thickness, argbtl, argbtr, argbbr, argbbl; x=(float)readint(0, cmddata); y=(float)readint(4, cmddata); width=(float)readint(8, cmddata); height=(float)readint(12, cmddata); thickness=readint(16, cmddata); argbtl=readint(20, cmddata); argbtr=readint(24, cmddata); argbbr=readint(28, cmddata); argbbl=readint(32, cmddata); drawrect0(new java.awt.geom.rectangle2d.float(x, y, width, height), null, 0, new java.awt.color(argbtl, true), thickness, null, 0.0f, 0.0f, null, 0.0f, 0.0f, 1.0f); } else { system.out.println(\"invalid len for gfxcmd_drawrect : \" + len); } break; case gfxcmd_fillrect: if(len==32) { float x, y, width, height; int argbtl, argbtr, argbbr, argbbl; x=(float)readint(0, cmddata); y=(float)readint(4, cmddata); width=(float)readint(8, cmddata); height=(float)readint(12, cmddata); argbtl=readint(16, cmddata); argbtr=readint(20, cmddata); argbbr=readint(24, cmddata); argbbl=readint(28, cmddata); java.awt.gradientpaint gp = getgradient(x, y, width, height, argbtl, argbtr, argbbl, argbbr); java.awt.geom.rectangle2d.float bounds = new java.awt.geom.rectangle2d.float(x, y, width, height); if(gp != null) { drawrect0(bounds, null, 0, null, 0, gp.getcolor1(), (float)gp.getpoint1().getx(), (float)gp.getpoint1().gety(), gp.getcolor2(), (float)gp.getpoint2().getx(), (float)gp.getpoint2().gety(), 1.0f); } else { drawrect0(bounds, null, 0, null, 0, new java.awt.color(argbtl, true), 0.0f, 0.0f, null, 0.0f, 0.0f, 1.0f); } } else { system.out.println(\"invalid len for gfxcmd_fillrect : \" + len); } break; case gfxcmd_clearrect: if(len==32) { int x, y, width, height, argbtl, argbtr, argbbr, argbbl; x=readint(0, cmddata); y=readint(4, cmddata); width=readint(8, cmddata); height=readint(12, cmddata); argbtl=readint(16, cmddata); argbtr=readint(20, cmddata); argbbr=readint(24, cmddata); argbbl=readint(28, cmddata); java.awt.geom.rectangle2d.float destrect = new java.awt.geom.rectangle2d.float(x, y, width, height); clearrect0(destrect); } else { system.out.println(\"invalid len for gfxcmd_clearrect : \" + len); } break; case gfxcmd_drawoval: if(len==52) { float x, y, width, height, clipx, clipy, clipw, cliph; int thickness, argbtl, argbtr, argbbr, argbbl; x=(float)readint(0, cmddata); y=(float)readint(4, cmddata); width=(float)readint(8, cmddata); height=(float)readint(12, cmddata); thickness=readint(16, cmddata); argbtl=readint(20, cmddata); argbtr=readint(24, cmddata); argbbr=readint(28, cmddata); argbbl=readint(32, cmddata); clipx=(float)readint(36, cmddata); clipy=(float)readint(40, cmddata); clipw=(float)readint(44, cmddata); cliph=(float)readint(48, cmddata); java.awt.geom.rectangle2d.float bounds = new java.awt.geom.rectangle2d.float(x, y, width, height); java.awt.geom.rectangle2d.float cliprect = new java.awt.geom.rectangle2d.float(clipx, clipy, clipw, cliph); drawoval0(bounds, cliprect, new java.awt.color(argbtl, true), thickness, null, 0.0f, 0.0f, null, 0.0f, 0.0f, 1.0f); } else { system.out.println(\"invalid len for gfxcmd_drawoval : \" + len); } break; case gfxcmd_filloval: if(len==48) { float x, y, width, height, clipx, clipy, clipw, cliph; int argbtl, argbtr, argbbr, argbbl; x=(float)readint(0, cmddata); y=(float)readint(4, cmddata); width=(float)readint(8, cmddata); height=(float)readint(12, cmddata); argbtl=readint(16, cmddata); argbtr=readint(20, cmddata); argbbr=readint(24, cmddata); argbbl=readint(28, cmddata); clipx=(float)readint(32, cmddata); clipy=(float)readint(36, cmddata); clipw=(float)readint(40, cmddata); cliph=(float)readint(44, cmddata); java.awt.gradientpaint gp = getgradient(x, y, width, height, argbtl, argbtr, argbbl, argbbr); java.awt.geom.rectangle2d.float bounds = new java.awt.geom.rectangle2d.float(x, y, width, height); java.awt.geom.rectangle2d.float cliprect = new java.awt.geom.rectangle2d.float(clipx, clipy, clipw, cliph); if(gp != null) { drawoval0(bounds, cliprect, null, 0, gp.getcolor1(), (float)gp.getpoint1().getx(), (float)gp.getpoint1().gety(), gp.getcolor2(), (float)gp.getpoint2().getx(), (float)gp.getpoint2().gety(), 1.0f); } else { drawoval0(bounds, cliprect, null, 0, new java.awt.color(argbtl, true), 0.0f, 0.0f, null, 0.0f, 0.0f, 1.0f); } } else { system.out.println(\"invalid len for gfxcmd_filloval : \" + len); } break; case gfxcmd_drawroundrect: if(len==56) { float x, y, width, height, clipx, clipy, clipw, cliph; int thickness, arcradius, argbtl, argbtr, argbbr, argbbl; x=(float)readint(0, cmddata); y=(float)readint(4, cmddata); width=(float)readint(8, cmddata); height=(float)readint(12, cmddata); thickness=readint(16, cmddata); arcradius=readint(20, cmddata); argbtl=readint(24, cmddata); argbtr=readint(28, cmddata); argbbr=readint(32, cmddata); argbbl=readint(36, cmddata); clipx=(float)readint(40, cmddata); clipy=(float)readint(44, cmddata); clipw=(float)readint(48, cmddata); cliph=(float)readint(52, cmddata); java.awt.geom.rectangle2d.float bounds = new java.awt.geom.rectangle2d.float(x, y, width, height); java.awt.geom.rectangle2d.float cliprect = new java.awt.geom.rectangle2d.float(clipx, clipy, clipw, cliph); drawrect0(bounds, cliprect, arcradius, new java.awt.color(argbtl, true), thickness, null, 0.0f, 0.0f, null, 0.0f, 0.0f, 1.0f); } else { system.out.println(\"invalid len for gfxcmd_drawroundrect : \" + len); } break; case gfxcmd_fillroundrect: if(len==52) { float x, y, width, height, clipx, clipy, clipw, cliph; int arcradius, argbtl, argbtr, argbbr, argbbl; x=(float)readint(0, cmddata); y=(float)readint(4, cmddata); width=(float)readint(8, cmddata); height=(float)readint(12, cmddata); arcradius=readint(16, cmddata); argbtl=readint(20, cmddata); argbtr=readint(24, cmddata); argbbr=readint(28, cmddata); argbbl=readint(32, cmddata); clipx=(float)readint(36, cmddata); clipy=(float)readint(40, cmddata); clipw=(float)readint(44, cmddata); cliph=(float)readint(48, cmddata); java.awt.gradientpaint gp = getgradient(x, y, width, height, argbtl, argbtr, argbbl, argbbr); java.awt.geom.rectangle2d.float bounds = new java.awt.geom.rectangle2d.float(x, y, width, height); java.awt.geom.rectangle2d.float cliprect = new java.awt.geom.rectangle2d.float(clipx, clipy, clipw, cliph); if(gp != null) { drawrect0(bounds, cliprect, arcradius, null, 0, gp.getcolor1(), (float)gp.getpoint1().getx(), (float)gp.getpoint1().gety(), gp.getcolor2(), (float)gp.getpoint2().getx(), (float)gp.getpoint2().gety(), 1.0f); } else { drawrect0(bounds, cliprect, arcradius, null, 0, new java.awt.color(argbtl, true), 0.0f, 0.0f, null, 0.0f, 0.0f, 1.0f); } } else { system.out.println(\"invalid len for gfxcmd_fillroundrect : \" + len); } break; case gfxcmd_drawtext: if(len>=36 && len>=(36+readint(8, cmddata)*2)) { float x, y, clipx, clipy, clipw, cliph; int textlen, fonthandle, argb; stringbuffer text = new stringbuffer(); int i; x=(float)readint(0, cmddata); y=(float)readint(4, cmddata); textlen=readint(8, cmddata); for(i=0;i<textlen;i++) { text.append((char)readshort(12+i*2, cmddata)); } fonthandle=readint(textlen*2+12, cmddata); argb=readint(textlen*2+16, cmddata); clipx=(float)readint(textlen*2+20, cmddata); clipy=(float)readint(textlen*2+24, cmddata); clipw=(float)readint(textlen*2+28, cmddata); cliph=(float)readint(textlen*2+32, cmddata); mcfont fontptr = (mcfont)fontmap.get(new integer(fonthandle)); if(fontptr != null) { string thestring = text.tostring(); float[] positions = fontptr.getglyphpositions(thestring); drawtextwithpositions0(thestring, fontptr.nativefont, x, y, positions, new java.awt.geom.rectangle2d.float(clipx,clipy,clipw,cliph), new java.awt.color(argb, true)); } } else { system.out.println(\"invalid len for gfxcmd_drawtext : \" + len); } break; case gfxcmd_drawtextured: if(len==40) { float x, y, width, height, srcx, srcy, srcwidth, srcheight; int handle, blend; x=(float)readint(0, cmddata); y=(float)readint(4, cmddata); width=(float)readint(8, cmddata); height=(float)readint(12, cmddata); handle=readint(16, cmddata); srcx=(float)readint(20, cmddata); srcy=(float)readint(24, cmddata); srcwidth=(float)readint(28, cmddata); srcheight=(float)readint(32, cmddata); blend=readint(36, cmddata); boolean doblend = true; if(height < 0) { doblend = false; height *= -1; } if(width < 0) { width *= -1; } else { if(doblend) blend |= 0x00ffffff; } long imageptr = (long)imagemap.get(new integer(handle)); java.awt.geom.rectangle2d.float destrect = new java.awt.geom.rectangle2d.float(x,y,width,height); java.awt.geom.rectangle2d.float srcrect = new java.awt.geom.rectangle2d.float(srcx,srcy,srcwidth,srcheight); if(imageptr != null) { myconn.registerimageaccess(handle); drawimage1(imageptr.longvalue(), destrect, srcrect, (doblend) ? new java.awt.color(blend, true) : null); } else { imageptr = (long)layermap.get(new integer(handle)); if(imageptr != null) { myconn.registerimageaccess(handle); float alpha = (doblend ? (float)(((blend >> 24)&0xff))\/255.0f : 1.0f); composite0(imageptr.longvalue(), currentlayer, srcrect, destrect, alpha, doblend); } else { system.out.println(\"error invalid handle passed for texture rendering of: \" + handle); abortrendercycle = true; } } } else { system.out.println(\"invalid len for gfxcmd_drawtextured : \" + len); } break; case gfxcmd_drawline: if(len==24) { float x1, y1, x2, y2; int argb1, argb2; x1=readint(0, cmddata); y1=readint(4, cmddata); x2=readint(8, cmddata); y2=readint(12, cmddata); argb1=readint(16, cmddata); argb2=readint(20, cmddata); drawline0(x1, y1, x2, y2, 1, new java.awt.color(argb1, true)); } else { system.out.println(\"invalid len for gfxcmd_drawline : \" + len); } break; case gfxcmd_loadimage: if(len>=8) { int width, height; int imghandle = 0; width=readint(0, cmddata); height=readint(4, cmddata); if (width * height * 4 + imagecachesize > imagecachelimit) { imghandle = 0; } else { long imageptr = createnewimage0(width, height); imghandle = handlecount++; imagemap.put(new integer(imghandle), new long(imageptr)); imagecachesize += width * height * 4; } hasret[0]=1; return imghandle; } else { system.out.println(\"invalid len for gfxcmd_loadimage : \" + len); } break; case gfxcmd_loadimagetargeted: if(len>=12) { int width, height; int imghandle = readint(0, cmddata); width=readint(4, cmddata); height=readint(8, cmddata); while (width * height * 4 + imagecachesize > imagecachelimit) { int oldestimage = myconn.getoldestimage(); if (oldestimage != 0) { system.out.println(\"freeing image to make room in cache\"); unloadimage(oldestimage); myconn.postimageunload(oldestimage); } else { system.out.println(\"error cannot free enough from the cache to support loading a new image!!!\"); break; } } long imageptr = createnewimage0(width, height); imagemap.put(new integer(imghandle), new long(imageptr)); imagecachesize += width * height * 4; myconn.registerimageaccess(imghandle); hasret[0]=0; } else { system.out.println(\"invalid len for gfxcmd_loadimagetargeted : \" + len); } break; case gfxcmd_createsurface: if(len>=8) { int width, height; int handle = handlecount++;; width=readint(0, cmddata); height=readint(4, cmddata); long layerptr = createlayer0(c.getsize()); layermap.put(new integer(handle), new long(layerptr)); hasret[0]=1; return handle; } else { system.out.println(\"invalid len for gfxcmd_createsurface : \" + len); } break; case gfxcmd_prepimage: if(len>=8) { int width, height; width=readint(0, cmddata); height=readint(4, cmddata); int imghandle = 1; if (width * height * 4 + imagecachesize > imagecachelimit) imghandle = 0; else if (len >= 12) { int strlen = readint(8, cmddata); if (strlen > 1) { string rezname = new string(cmddata, 16, strlen - 1); lastimageresourceid = rezname; lastimageresourceidhandle = imghandle = math.abs(lastimageresourceid.hashcode()); java.io.file cachedfile = myconn.getcachedimagefile(rezname); if (cachedfile != null) { long imageptr = createimagefrompath0(cachedfile.getabsolutepath()); if(imageptr != 0) { java.awt.dimension imgsize = getimagedimensions0(imageptr); if(imgsize != null) { if(imgsize.getwidth() == width && imgsize.getheight() == height) { imghandle = handlecount++; imagemap.put(new integer(imghandle), new long(imageptr)); imagecachesize += getimagesize0(imageptr); hasret[0] = 1; return -1 * imghandle; } else freenativeimage0(imageptr); } else freenativeimage0(imageptr); } } } } hasret[0]=1; return imghandle; } else { system.out.println(\"invalid len for gfxcmd_prepimage : \" + len); } break; case gfxcmd_prepimagetargeted: if(len>=12) { int imghandle, width, height; imghandle = readint(0, cmddata); width=readint(4, cmddata); height=readint(8, cmddata); int strlen = readint(12, cmddata); while (width * height * 4 + imagecachesize > imagecachelimit) { int oldestimage = myconn.getoldestimage(); if (oldestimage != 0) { system.out.println(\"freeing image to make room in cache\"); unloadimage(oldestimage); myconn.postimageunload(oldestimage); } else { system.out.println(\"error cannot free enough from the cache to support loading a new image!!!\"); break; } } if (len >= 16) { string rezname = new string(cmddata, 20, strlen - 1); lastimageresourceid = rezname; lastimageresourceidhandle = imghandle; system.out.println(\"prepped targeted image with handle \" + imghandle + \" resource=\" + rezname); } myconn.registerimageaccess(imghandle); hasret[0]=0; } else { system.out.println(\"invalid len for gfxcmd_prepimage : \" + len); } break; case gfxcmd_loadcachedimage: if(len>=18) { int width, height, imghandle; imghandle = readint(0, cmddata); width = readint(4, cmddata); height = readint(8, cmddata); int strlen = readint(12, cmddata); string rezname = new string(cmddata, 20, strlen - 1); system.out.println(\"imghandle=\" + imghandle + \" width=\" + width + \" height=\" + height + \" strlen=\" + strlen + \" rezname=\" + rezname); while (width * height * 4 + imagecachesize > imagecachelimit) { int oldestimage = myconn.getoldestimage(); if (oldestimage != 0) { system.out.println(\"freeing image to make room in cache\"); unloadimage(oldestimage); myconn.postimageunload(oldestimage); } else { system.out.println(\"error cannot free enough from the cache to support loading a new image!!!\"); break; } } myconn.registerimageaccess(imghandle); try { system.out.println(\"loading resource from cache: \" + rezname); java.io.file cachedfile = myconn.getcachedimagefile(rezname); if (cachedfile != null) { system.out.println(\"image found in cache!\"); long imageptr = createimagefrompath0(cachedfile.getabsolutepath()); if(imageptr != 0) { java.awt.dimension imgsize = getimagedimensions0(imageptr); if(imgsize != null && imgsize.getwidth() == width && imgsize.getheight() == height) { imagemap.put(new integer(imghandle), new long(imageptr)); imagecachesize += getimagesize0(imageptr); } else { if (imgsize != null) { system.out.println(\"cache id verification failed for rezname=\" + rezname + \" target=\" + width + \"x\" + height + \" actual=\" + imgsize.getwidth() + \"x\" + imgsize.getheight()); } else system.out.println(\"cache load failed for rezname=\" + rezname); cachedfile.delete(); freenativeimage0(imageptr); myconn.postimageunload(imghandle); myconn.postofflinecachechange(false, rezname); } } else { cachedfile.delete(); myconn.postimageunload(imghandle); myconn.postofflinecachechange(false, rezname); } } else { system.out.println(\"error image not found in cache that should be there! rezname=\" + rezname); myconn.postimageunload(imghandle); myconn.postofflinecachechange(false, rezname); } } catch (java.io.ioexception e) { system.out.println(\"error loading compressed image: \" + e); } hasret[0]=0; } else { system.out.println(\"invalid len for gfxcmd_prepimage : \" + len); } break; case gfxcmd_unloadimage: if(len==4) { int handle; handle=readint(0, cmddata); unloadimage(handle); myconn.clearimageaccess(handle); } else { system.out.println(\"invalid len for gfxcmd_unloadimage : \" + len); } break; case gfxcmd_settargetsurface: if(len==4) { int handle; handle=readint(0, cmddata); long layerptr = (long)layermap.get(new integer(handle)); currentlayer = (layerptr != null) ? layerptr.longvalue() : 0; java.awt.rectangle cliprect = new java.awt.rectangle(0, 0, c.getwidth(), c.getheight()); setlayer0(currentlayer, c.getsize(), cliprect); } else { system.out.println(\"invalid len for gfxcmd_settargetsurface : \" + len); } break; case gfxcmd_loadfont: if(len>=12 && len>=(12+readint(0, cmddata))) { int namelen, style, size; stringbuffer name = new stringbuffer(); int i; int fonthandle = handlecount++; namelen=readint(0, cmddata); for(i=0;i<namelen-1;i++) { name.append((char) cmddata[8 + i]); } style=readint(namelen+4, cmddata); size=readint(namelen+8, cmddata); mcfont fontptr = new mcfont(name.tostring(), style, size); if(fontptr == null) { hasret[0] = 1; return 0; } fontmap.put(new integer(fonthandle), fontptr); hasret[0] = 1; return fonthandle; } else { system.out.println(\"invalid len for gfxcmd_loadfont : \" + len); } break; case gfxcmd_unloadfont: if(len==4) { int handle; handle=readint(0, cmddata); mcfont fontptr = (mcfont)fontmap.get(new integer(handle)); if(fontptr != null) fontptr.unload(); fontmap.remove(new integer(handle)); } else { system.out.println(\"invalid len for gfxcmd_unloadfont : \" + len); } break; case gfxcmd_loadfontstream: if (len>=8) { stringbuffer name = new stringbuffer(); int namelen = readint(0, cmddata); for(int i=0;i<namelen-1;i++) { name.append((char) cmddata[8 + i]); } int datalen = readint(4 + namelen, cmddata); if (len >= datalen + 8 + namelen) { myconn.savecachedata(name.tostring() + \"-\" + myconn.getservername(), cmddata, 12 + namelen, datalen); } } else { system.out.println(\"invalid len for gfxcmd_loadfontstream : \" + len); } break; case gfxcmd_flipbuffer: if (abortrendercycle) { system.out.println(\"error in painting cycle, abort was set...send full repaint command\"); myconn.postrepaintevent(0, 0, c.getwidth(), c.getheight()); } else { present0(c.nativeview, new java.awt.rectangle(0, 0, c.getwidth(), c.getheight())); } hasret[0] = 1; firstframedone = true; return 0; case gfxcmd_startframe: settargetview0(c.nativeview); setlayer0(0, c.getsize(), null); abortrendercycle = false; break; case gfxcmd_loadimageline: if(len>=12 && len>=(12+readint(8, cmddata))) { int handle, line, len2; handle=readint(0, cmddata); line=readint(4, cmddata); len2=readint(8, cmddata); long imageptr = (long)imagemap.get(new integer(handle)); if(imageptr != null) loadimageline0(imageptr.longvalue(), line, cmddata, 1, len2); myconn.registerimageaccess(handle); } else { system.out.println(\"invalid len for gfxcmd_loadimageline : \" + len); } break; case gfxcmd_loadimagecompressed: if(len>=8 && len>=(8+readint(4, cmddata))) { int handle, len2; handle=readint(0, cmddata); len2=readint(4, cmddata); if (lastimageresourceid != null && lastimageresourceidhandle == handle) { myconn.savecachedata(lastimageresourceid, cmddata, 12, len2); myconn.postofflinecachechange(true, lastimageresourceid); } if (!myconn.doesuseadvancedimagecaching()) { handle = handlecount++; hasret[0] = 1; } else hasret[0] = 0; myconn.registerimageaccess(handle); long imageptr = createimagefrombytes0(cmddata, 12, len2, null); imagemap.put(new integer(handle), new long(imageptr)); imagecachesize += getimagesize0(imageptr); return handle; } else { system.out.println(\"invalid len for gfxcmd_loadimagecompressed : \" + len); } break; case gfxcmd_xfmimage: if (len >= 20) { int srchandle, desthandle, destwidth, destheight, maskcornerarc; srchandle = readint(0, cmddata); desthandle = readint(4, cmddata); destwidth = readint(8, cmddata); destheight = readint(12, cmddata); maskcornerarc = readint(16, cmddata); int rvhandle = desthandle; if (!myconn.doesuseadvancedimagecaching()) { rvhandle = handlecount++; hasret[0] = 1; } else hasret[0] = 0; long srcimg = (long)imagemap.get(new integer(srchandle)); if(srcimg != null) { long newimage = transformimage0(srcimg.longvalue(), destwidth, destheight, maskcornerarc); if(newimage != 0) { imagemap.put(new integer(rvhandle), new long(newimage)); } } return rvhandle; } else { system.out.println(\"invalid len for gfxcmd_xfmimage : \" + len); } break; case gfxcmd_setvideoprop: if (len >= 40) { java.awt.rectangle srcrect = new java.awt.rectangle(readint(4, cmddata), readint(8, cmddata), readint(12, cmddata), readint(16, cmddata)); java.awt.rectangle destrect = new java.awt.rectangle(readint(20, cmddata), readint(24, cmddata), readint(28, cmddata), readint(32, cmddata)); system.out.println(\"setvideoprop: srcrect=\"+srcrect+\" dstrect=\"+destrect); setvideobounds(srcrect, destrect); } else { system.out.println(\"invalid len for gfxcmd_setvideoprop: \" + len); } break; default: return -1; } return 0; }","repo":"Narflex\/sagetv","label":[1,0,1,0]}
{"id":7810,"original_code":"public boolean isOvertaking() {\n\t\tif (overtakeStage != OvertakeStage.NOT_OVERTAKING) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}","code_wo_comment":"public boolean isOvertaking() {\n\t\tif (overtakeStage != OvertakeStage.NOT_OVERTAKING) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}","cleancode":"public boolean isovertaking() { if (overtakestage != overtakestage.not_overtaking) { return true; } else { return false; } }","repo":"RobAlexander\/SCovSGen","label":[0,1,0,0]}
{"id":16039,"original_code":"public static List<String> generateParenthesis1(int n) {\n        Set<String>[] dp = new Set[n + 1];\n        Set<String> first = new HashSet<>();\n        first.add(\"\");\n        dp[0] = first;\n        for (int i = 1; i <= n; i++) {\n            Set<String> set = new HashSet<>();\n            for (String pre : dp[i - 1]) {\n                set.add(\"(\" + pre + \")\");\n            }\n            for (int m = 1; m < i; m++) {\n                for (String p1 : dp[m]) {\n                    for (String p2 : dp[i - m]) {\n                        set.add(p1 + p2);\n                        set.add(p2 + p1);\n                    }\n                }\n            }\n            dp[i] = set;\n        }\n        return new ArrayList<>(dp[n]);\n    }","code_wo_comment":"public static List<String> generateParenthesis1(int n) {\n        Set<String>[] dp = new Set[n + 1];\n        Set<String> first = new HashSet<>();\n        first.add(\"\");\n        dp[0] = first;\n        for (int i = 1; i <= n; i++) {\n            Set<String> set = new HashSet<>();\n            for (String pre : dp[i - 1]) {\n                set.add(\"(\" + pre + \")\");\n            }\n            for (int m = 1; m < i; m++) {\n                for (String p1 : dp[m]) {\n                    for (String p2 : dp[i - m]) {\n                        set.add(p1 + p2);\n                        set.add(p2 + p1);\n                    }\n                }\n            }\n            dp[i] = set;\n        }\n        return new ArrayList<>(dp[n]);\n    }","cleancode":"public static list<string> generateparenthesis1(int n) { set<string>[] dp = new set[n + 1]; set<string> first = new hashset<>(); first.add(\"\"); dp[0] = first; for (int i = 1; i <= n; i++) { set<string> set = new hashset<>(); for (string pre : dp[i - 1]) { set.add(\"(\" + pre + \")\"); } for (int m = 1; m < i; m++) { for (string p1 : dp[m]) { for (string p2 : dp[i - m]) { set.add(p1 + p2); set.add(p2 + p1); } } } dp[i] = set; } return new arraylist<>(dp[n]); }","repo":"Joybeanx\/leetcode","label":[1,0,0,0]}
